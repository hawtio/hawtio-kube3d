(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

},{}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var rootParent = {}

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  function Foo () {}
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    arr.constructor = Foo
    return arr.foo() === 42 && // typed array instances can be augmented
        arr.constructor === Foo && // constructor can be set
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (arg) {
  if (!(this instanceof Buffer)) {
    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.
    if (arguments.length > 1) return new Buffer(arg, arguments[1])
    return new Buffer(arg)
  }

  this.length = 0
  this.parent = undefined

  // Common case.
  if (typeof arg === 'number') {
    return fromNumber(this, arg)
  }

  // Slightly less common case.
  if (typeof arg === 'string') {
    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')
  }

  // Unusual.
  return fromObject(this, arg)
}

function fromNumber (that, length) {
  that = allocate(that, length < 0 ? 0 : checked(length) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < length; i++) {
      that[i] = 0
    }
  }
  return that
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'

  // Assumption: byteLength() return value is always < kMaxLength.
  var length = byteLength(string, encoding) | 0
  that = allocate(that, length)

  that.write(string, encoding)
  return that
}

function fromObject (that, object) {
  if (Buffer.isBuffer(object)) return fromBuffer(that, object)

  if (isArray(object)) return fromArray(that, object)

  if (object == null) {
    throw new TypeError('must start with number, buffer, array or string')
  }

  if (typeof ArrayBuffer !== 'undefined' && object.buffer instanceof ArrayBuffer) {
    return fromTypedArray(that, object)
  }

  if (object.length) return fromArrayLike(that, object)

  return fromJsonObject(that, object)
}

function fromBuffer (that, buffer) {
  var length = checked(buffer.length) | 0
  that = allocate(that, length)
  buffer.copy(that, 0, 0, length)
  return that
}

function fromArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Duplicate of fromArray() to keep fromArray() monomorphic.
function fromTypedArray (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  // Truncating the elements is probably not what people expect from typed
  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior
  // of the old Buffer constructor.
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayLike (that, array) {
  var length = checked(array.length) | 0
  that = allocate(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.
// Returns a zero-length buffer for inputs that don't conform to the spec.
function fromJsonObject (that, object) {
  var array
  var length = 0

  if (object.type === 'Buffer' && isArray(object.data)) {
    array = object.data
    length = checked(array.length) | 0
  }
  that = allocate(that, length)

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function allocate (that, length) {
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return an object instance of the Buffer class
    that.length = length
    that._isBuffer = true
  }

  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1
  if (fromPool) that.parent = rootParent

  return that
}

function checked (length) {
  // Note: cannot use `length < kMaxLength` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (subject, encoding) {
  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)

  var buf = new Buffer(subject, encoding)
  delete buf.parent
  return buf
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  var i = 0
  var len = Math.min(x, y)
  while (i < len) {
    if (a[i] !== b[i]) break

    ++i
  }

  if (i !== len) {
    x = a[i]
    y = b[i]
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; i++) {
      length += list[i].length
    }
  }

  var buf = new Buffer(length)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

function byteLength (string, encoding) {
  if (typeof string !== 'string') string = '' + string

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'binary':
      // Deprecated
      case 'raw':
      case 'raws':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

function slowToString (encoding, start, end) {
  var loweredCase = false

  start = start | 0
  end = end === undefined || end === Infinity ? this.length : end | 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return 0
  return Buffer.compare(this, b)
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset) {
  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff
  else if (byteOffset < -0x80000000) byteOffset = -0x80000000
  byteOffset >>= 0

  if (this.length === 0) return -1
  if (byteOffset >= this.length) return -1

  // Negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)

  if (typeof val === 'string') {
    if (val.length === 0) return -1 // special case: looking for empty string always fails
    return String.prototype.indexOf.call(this, val, byteOffset)
  }
  if (Buffer.isBuffer(val)) {
    return arrayIndexOf(this, val, byteOffset)
  }
  if (typeof val === 'number') {
    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {
      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)
    }
    return arrayIndexOf(this, [ val ], byteOffset)
  }

  function arrayIndexOf (arr, val, byteOffset) {
    var foundIndex = -1
    for (var i = 0; byteOffset + i < arr.length; i++) {
      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex
      } else {
        foundIndex = -1
      }
    }
    return -1
  }

  throw new TypeError('val must be string, number or Buffer')
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function get (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function set (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) throw new Error('Invalid hex string')
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    var swap = encoding
    encoding = offset
    offset = length | 0
    length = swap
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'binary':
        return binaryWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function binarySlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
  }

  if (newBuf.length) newBuf.parent = this.parent || this

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = value < 0 ? 1 : 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new RangeError('value is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('index out of range')
  if (offset < 0) throw new RangeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), targetStart)
  }

  return len
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function fill (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new RangeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')
  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function toArrayBuffer () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function _augment (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array set method before overwriting
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.indexOf = BP.indexOf
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUIntLE = BP.readUIntLE
  arr.readUIntBE = BP.readUIntBE
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readIntLE = BP.readIntLE
  arr.readIntBE = BP.readIntBE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUIntLE = BP.writeUIntLE
  arr.writeUIntBE = BP.writeUIntBE
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeIntLE = BP.writeIntLE
  arr.writeIntBE = BP.writeIntBE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z\-]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []
  var i = 0

  for (; i < length; i++) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (leadSurrogate) {
        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          leadSurrogate = codePoint
          continue
        } else {
          // valid surrogate pair
          codePoint = leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00 | 0x10000
          leadSurrogate = null
        }
      } else {
        // no lead yet

        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else {
          // valid lead
          leadSurrogate = codePoint
          continue
        }
      }
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
      leadSurrogate = null
    }

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x200000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":3,"ieee754":4,"is-array":5}],3:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],4:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],5:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],6:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],7:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],8:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],9:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":10}],10:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],11:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":12}],12:[function(require,module,exports){
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


module.exports = Duplex;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/



/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

},{"./_stream_readable":14,"./_stream_writable":16,"core-util-is":17,"inherits":7,"process-nextick-args":18}],13:[function(require,module,exports){
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":15,"core-util-is":17,"inherits":7}],14:[function(require,module,exports){
(function (process){
'use strict';

module.exports = Readable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/


/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/



/*<replacement>*/
var Stream;
(function (){try{
  Stream = require('st' + 'ream');
}catch(_){}finally{
  if (!Stream)
    Stream = require('events').EventEmitter;
}}())
/*</replacement>*/

var Buffer = require('buffer').Buffer;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/



/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options && typeof options.read === 'function')
    this._read = options.read;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (!state.objectMode && typeof chunk === 'string') {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

Readable.prototype.isPaused = function() {
  return this._readableState.flowing === false;
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else {
      return state.length;
    }
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (ret !== null)
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!(Buffer.isBuffer(chunk)) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      processNextTick(emitReadable_, stream);
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    processNextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }; }(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))

},{"./_stream_duplex":12,"_process":10,"buffer":2,"core-util-is":17,"events":6,"inherits":7,"isarray":8,"process-nextick-args":18,"string_decoder/":25,"util":1}],15:[function(require,module,exports){
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function')
      this._transform = options.transform;

    if (typeof options.flush === 'function')
      this._flush = options.flush;
  }

  this.once('prefinish', function() {
    if (typeof this._flush === 'function')
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":12,"core-util-is":17,"inherits":7}],16:[function(require,module,exports){
// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

module.exports = Writable;

/*<replacement>*/
var processNextTick = require('process-nextick-args');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/



/*<replacement>*/
var Stream;
(function (){try{
  Stream = require('st' + 'ream');
}catch(_){}finally{
  if (!Stream)
    Stream = require('events').EventEmitter;
}}())
/*</replacement>*/

var Buffer = require('buffer').Buffer;

util.inherits(Writable, Stream);

function nop() {}

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

WritableState.prototype.getBuffer = function writableStateGetBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function (){try {
Object.defineProperty(WritableState.prototype, 'buffer', {
  get: require('util-deprecate')(function() {
    return this.getBuffer();
  }, '_writableState.buffer is deprecated. Use ' +
      '_writableState.getBuffer() instead.')
});
}catch(_){}}());


function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function')
      this._write = options.write;

    if (typeof options.writev === 'function')
      this._writev = options.writev;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;

  if (!(Buffer.isBuffer(chunk)) &&
      typeof chunk !== 'string' &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = nop;

  if (state.ended)
    writeAfterEnd(this, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.bufferedRequest)
      clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string')
    encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64',
'ucs2', 'ucs-2','utf16le', 'utf-16le', 'raw']
.indexOf((encoding + '').toLowerCase()) > -1))
    throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;
  if (sync)
    processNextTick(cb, er);
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      processNextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var buffer = [];
    var cbs = [];
    while (entry) {
      cbs.push(entry.callback);
      buffer.push(entry);
      entry = entry.next;
    }

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    state.lastBufferedRequest = null;
    doWrite(stream, state, true, state.length, buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null)
      state.lastBufferedRequest = null;
  }
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined)
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(state) {
  return (state.ending &&
          state.length === 0 &&
          state.bufferedRequest === null &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else {
      prefinish(stream, state);
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      processNextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

},{"./_stream_duplex":12,"buffer":2,"core-util-is":17,"events":6,"inherits":7,"process-nextick-args":18,"util-deprecate":19}],17:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)

},{"buffer":2}],18:[function(require,module,exports){
(function (process){
'use strict';
module.exports = nextTick;

function nextTick(fn) {
  var args = new Array(arguments.length - 1);
  var i = 0;
  while (i < arguments.length) {
    args[i++] = arguments[i];
  }
  process.nextTick(function afterTick() {
    fn.apply(null, args);
  });
}

}).call(this,require('_process'))

},{"_process":10}],19:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  if (!global.localStorage) return false;
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],20:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":13}],21:[function(require,module,exports){
var Stream = (function (){
  try {
    return require('st' + 'ream'); // hack to fix a circular dependency issue when used with browserify
  } catch(_){}
}());
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream || exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":12,"./lib/_stream_passthrough.js":13,"./lib/_stream_readable.js":14,"./lib/_stream_transform.js":15,"./lib/_stream_writable.js":16}],22:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":15}],23:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":16}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":6,"inherits":7,"readable-stream/duplex.js":11,"readable-stream/passthrough.js":20,"readable-stream/readable.js":21,"readable-stream/transform.js":22,"readable-stream/writable.js":23}],25:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":2}],26:[function(require,module,exports){
var ever = require('ever')
var vkey = require('vkey')
var events = require('events')

var game

module.exports = function(gameInstance) {
  // cache the game instance
  game = gameInstance
  return function makeFly(physical, noKeyEvents) {
    return new Fly(physical, noKeyEvents)
  }
}

function Fly(physical, noKeyEvents) {
  this.flySpeed = 0.8
  this.physical = physical
  if (!noKeyEvents) this.bindKeyEvents()
}

Fly.prototype.bindKeyEvents = function(el) {
  if (!el) el = document.body
  var self = this
  var counter = 0
  var spaceUpAfterFirstDown = false
  var first = Date.now()
  ever(el)
    .on('keydown', onKeyDown)
    .on('keyup', onKeyUp)
  
  function onKeyDown(ev) {
    var key = vkey[ev.keyCode] || ev.char
    var binding = game.keybindings[key]
    if (binding !== "jump") return
    if (counter === 1) {
      if (Date.now() - first > 300) {
        spaceUpAfterFirstDown = false
        return first = Date.now()
      } else {
        if (!self.flying && spaceUpAfterFirstDown) {
          self.startFlying()
        }
      }
      spaceUpAfterFirstDown = false
      return counter = 0
    }
    if (counter === 0) {
      first = Date.now()
      counter += 1
    }
  }
  
  function onKeyUp(ev) {
    var key = vkey[ev.keyCode] || ev.char
    if (key === '<space>' && counter === 1) {
      spaceUpAfterFirstDown = true
    }
  }
}

Fly.prototype.startFlying = function() {
  var self = this
  this.flying = true
  var physical = this.physical
  physical.removeForce(game.gravity)
  physical.onGameTick = function(dt) {
    if (physical.atRestY() === -1) return self.stopFlying()
    physical.friction.x = self.flySpeed
    physical.friction.z = self.flySpeed
    var press = game.controls.state
    if (press['crouch']) return physical.velocity.y = -0.01
    if (press['jump']) return physical.velocity.y = 0.01
    physical.velocity.y = 0
  }
  game.on('tick', physical.onGameTick)
}

Fly.prototype.stopFlying = function() {
  this.flying = false
  var physical = this.physical
  physical.subjectTo(game.gravity)
  game.removeListener('tick', physical.onGameTick)
}
},{"events":6,"ever":27,"vkey":30}],27:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;

module.exports = function (elem) {
    return new Ever(elem);
};

function Ever (elem) {
    this.element = elem;
}

Ever.prototype = new EventEmitter;

Ever.prototype.on = function (name, cb, useCapture) {
    if (!this._events) this._events = {};
    if (!this._events[name]) this._events[name] = [];
    this._events[name].push(cb);
    this.element.addEventListener(name, cb, useCapture || false);

    return this;
};
Ever.prototype.addListener = Ever.prototype.on;

Ever.prototype.removeListener = function (type, listener, useCapture) {
    if (!this._events) this._events = {};
    this.element.removeEventListener(type, listener, useCapture || false);
    
    var xs = this.listeners(type);
    var ix = xs.indexOf(listener);
    if (ix >= 0) xs.splice(ix, 1);

    return this;
};

Ever.prototype.removeAllListeners = function (type) {
    var self = this;
    function removeAll (t) {
        var xs = self.listeners(t);
        for (var i = 0; i < xs.length; i++) {
            self.removeListener(t, xs[i]);
        }
    }
    
    if (type) {
        removeAll(type)
    }
    else if (self._events) {
        for (var key in self._events) {
            if (key) removeAll(key);
        }
    }
    return EventEmitter.prototype.removeAllListeners.apply(self, arguments);
}

var initSignatures = require('./init.json');

Ever.prototype.emit = function (name, ev) {
    if (typeof name === 'object') {
        ev = name;
        name = ev.type;
    }
    
    if (!isEvent(ev)) {
        var type = Ever.typeOf(name);
        
        var opts = ev || {};
        if (opts.type === undefined) opts.type = name;
        
        ev = document.createEvent(type + 's');
        var init = typeof ev['init' + type] === 'function'
            ? 'init' + type : 'initEvent'
        ;
        
        var sig = initSignatures[init];
        var used = {};
        var args = [];
        
        for (var i = 0; i < sig.length; i++) {
            var key = sig[i];
            args.push(opts[key]);
            used[key] = true;
        }
        ev[init].apply(ev, args);
        
        // attach remaining unused options to the object
        for (var key in opts) {
            if (!used[key]) ev[key] = opts[key];
        }
    }
    return this.element.dispatchEvent(ev);
};

function isEvent (ev) {
    var s = Object.prototype.toString.call(ev);
    return /\[object \S+Event\]/.test(s);
}

Ever.types = require('./types.json');
Ever.typeOf = (function () {
    var types = {};
    for (var key in Ever.types) {
        var ts = Ever.types[key];
        for (var i = 0; i < ts.length; i++) {
            types[ts[i]] = key;
        }
    }
    
    return function (name) {
        return types[name] || 'Event';
    };
})();;

},{"./init.json":28,"./types.json":29,"events":6}],28:[function(require,module,exports){
module.exports={
  "initEvent" : [
    "type",
    "canBubble", 
    "cancelable"
  ],
  "initUIEvent" : [
    "type",
    "canBubble", 
    "cancelable", 
    "view", 
    "detail"
  ],
  "initMouseEvent" : [
    "type",
    "canBubble", 
    "cancelable", 
    "view", 
    "detail", 
    "screenX", 
    "screenY", 
    "clientX", 
    "clientY", 
    "ctrlKey", 
    "altKey", 
    "shiftKey", 
    "metaKey", 
    "button",
    "relatedTarget"
  ],
  "initMutationEvent" : [
    "type",
    "canBubble", 
    "cancelable", 
    "relatedNode", 
    "prevValue", 
    "newValue", 
    "attrName", 
    "attrChange"
  ]
}

},{}],29:[function(require,module,exports){
module.exports={
  "MouseEvent" : [
    "click",
    "mousedown",
    "mouseup",
    "mouseover",
    "mousemove",
    "mouseout"
  ],
  "KeyBoardEvent" : [
    "keydown",
    "keyup",
    "keypress"
  ],
  "MutationEvent" : [
    "DOMSubtreeModified",
    "DOMNodeInserted",
    "DOMNodeRemoved",
    "DOMNodeRemovedFromDocument",
    "DOMNodeInsertedIntoDocument",
    "DOMAttrModified",
    "DOMCharacterDataModified"
  ],
  "HTMLEvent" : [
    "load",
    "unload",
    "abort",
    "error",
    "select",
    "change",
    "submit",
    "reset",
    "focus",
    "blur",
    "resize",
    "scroll"
  ],
  "UIEvent" : [
    "DOMFocusIn",
    "DOMFocusOut",
    "DOMActivate"
  ]
}

},{}],30:[function(require,module,exports){
var ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''
  , isOSX = /OS X/.test(ua)
  , isOpera = /Opera/.test(ua)
  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera

var i, output = module.exports = {
  0:  isOSX ? '<menu>' : '<UNK>'
, 1:  '<mouse 1>'
, 2:  '<mouse 2>'
, 3:  '<break>'
, 4:  '<mouse 3>'
, 5:  '<mouse 4>'
, 6:  '<mouse 5>'
, 8:  '<backspace>'
, 9:  '<tab>'
, 12: '<clear>'
, 13: '<enter>'
, 16: '<shift>'
, 17: '<control>'
, 18: '<alt>'
, 19: '<pause>'
, 20: '<caps-lock>'
, 21: '<ime-hangul>'
, 23: '<ime-junja>'
, 24: '<ime-final>'
, 25: '<ime-kanji>'
, 27: '<escape>'
, 28: '<ime-convert>'
, 29: '<ime-nonconvert>'
, 30: '<ime-accept>'
, 31: '<ime-mode-change>'
, 27: '<escape>'
, 32: '<space>'
, 33: '<page-up>'
, 34: '<page-down>'
, 35: '<end>'
, 36: '<home>'
, 37: '<left>'
, 38: '<up>'
, 39: '<right>'
, 40: '<down>'
, 41: '<select>'
, 42: '<print>'
, 43: '<execute>'
, 44: '<snapshot>'
, 45: '<insert>'
, 46: '<delete>'
, 47: '<help>'
, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.
, 92: '<meta>'  // meta-right
, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).
, 95: '<sleep>'
, 106: '<num-*>'
, 107: '<num-+>'
, 108: '<num-enter>'
, 109: '<num-->'
, 110: '<num-.>'
, 111: '<num-/>'
, 144: '<num-lock>'
, 145: '<scroll-lock>'
, 160: '<shift-left>'
, 161: '<shift-right>'
, 162: '<control-left>'
, 163: '<control-right>'
, 164: '<alt-left>'
, 165: '<alt-right>'
, 166: '<browser-back>'
, 167: '<browser-forward>'
, 168: '<browser-refresh>'
, 169: '<browser-stop>'
, 170: '<browser-search>'
, 171: '<browser-favorites>'
, 172: '<browser-home>'

  // ff/osx reports '<volume-mute>' for '-'
, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'
, 174: '<volume-down>'
, 175: '<volume-up>'
, 176: '<next-track>'
, 177: '<prev-track>'
, 178: '<stop>'
, 179: '<play-pause>'
, 180: '<launch-mail>'
, 181: '<launch-media-select>'
, 182: '<launch-app 1>'
, 183: '<launch-app 2>'
, 186: ';'
, 187: '='
, 188: ','
, 189: '-'
, 190: '.'
, 191: '/'
, 192: '`'
, 219: '['
, 220: '\\'
, 221: ']'
, 222: "'"
, 223: '<meta>'
, 224: '<meta>'       // firefox reports meta here.
, 226: '<alt-gr>'
, 229: '<ime-process>'
, 231: isOpera ? '`' : '<unicode>'
, 246: '<attention>'
, 247: '<crsel>'
, 248: '<exsel>'
, 249: '<erase-eof>'
, 250: '<play>'
, 251: '<zoom>'
, 252: '<no-name>'
, 253: '<pa-1>'
, 254: '<clear>'
}

for(i = 58; i < 65; ++i) {
  output[i] = String.fromCharCode(i)
}

// 0-9
for(i = 48; i < 58; ++i) {
  output[i] = (i - 48)+''
}

// A-Z
for(i = 65; i < 91; ++i) {
  output[i] = String.fromCharCode(i)
}

// num0-9
for(i = 96; i < 107; ++i) {
  output[i] = '<num-'+(i - 96)+'>'
}

// F1-F24
for(i = 112; i < 136; ++i) {
  output[i] = 'F'+(i-111)
}

},{}],31:[function(require,module,exports){
var createGame = require('voxel-engine')
var highlight = require('voxel-highlight')
var player = require('voxel-player')
var voxel = require('voxel')
var extend = require('extend')
var fly = require('voxel-fly')
var walk = require('voxel-walk')

module.exports = function(opts, setup) {
  setup = setup || defaultSetup
  var defaults = {
    generate: voxel.generator['Valley'],
    chunkDistance: 2,
    materials: ['#fff', '#000'],
    materialFlatColor: true,
    worldOrigin: [0, 0, 0],
    controls: { discreteFire: true }
  }
  opts = extend({}, defaults, opts || {})

  // setup the game and add some trees
  var game = createGame(opts)
  var container = opts.container || document.body
  window.game = game // for debugging
  game.appendTo(container)
  if (game.notCapable()) return game
  
  var createPlayer = player(game)

  // create the player from a minecraft skin file and tell the
  // game to use it as the main player
  var avatar = createPlayer(opts.playerSkin || 'player.png')
  avatar.possess()
  avatar.yaw.position.set(2, 14, 4)

  setup(game, avatar)
  
  return game
}

function defaultSetup(game, avatar) {
  
  var makeFly = fly(game)
  var target = game.controls.target()
  game.flyer = makeFly(target)
  
  // highlight blocks when you look at them, hold <Ctrl> for block placement
  var blockPosPlace, blockPosErase
  var hl = game.highlighter = highlight(game, { color: 0xff0000 })
  hl.on('highlight', function (voxelPos) { blockPosErase = voxelPos })
  hl.on('remove', function (voxelPos) { blockPosErase = null })
  hl.on('highlight-adjacent', function (voxelPos) { blockPosPlace = voxelPos })
  hl.on('remove-adjacent', function (voxelPos) { blockPosPlace = null })

  // toggle between first and third person modes
  window.addEventListener('keydown', function (ev) {
    if (ev.keyCode === 'R'.charCodeAt(0)) avatar.toggle()
  })

  // block interaction stuff, uses highlight data
  var currentMaterial = 1

  game.on('fire', function (target, state) {
    var position = blockPosPlace
    if (position) {
      game.createBlock(position, currentMaterial)
    }
    else {
      position = blockPosErase
      if (position) game.setBlock(position, 0)
    }
  })

  game.on('tick', function() {
    walk.render(target.playerSkin)
    var vx = Math.abs(target.velocity.x)
    var vz = Math.abs(target.velocity.z)
    if (vx > 0.001 || vz > 0.001) walk.stopWalking()
    else walk.startWalking()
  })

}

},{"extend":32,"voxel":80,"voxel-engine":33,"voxel-fly":68,"voxel-highlight":73,"voxel-player":76,"voxel-walk":78}],32:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;

function isPlainObject(obj) {
	if (!obj || toString.call(obj) !== '[object Object]' || obj.nodeType || obj.setInterval)
		return false;

	var has_own_constructor = hasOwnProperty.call(obj, 'constructor');
	var has_is_property_of_method = hasOwnProperty.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method)
		return false;

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for ( key in obj ) {}

	return key === undefined || hasOwn.call( obj, key );
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone,
	    target = arguments[0] || {},
	    i = 1,
	    length = arguments.length,
	    deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && typeof target !== "function") {
		target = {};
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( isPlainObject(copy) || (copyIsArray = Array.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray(src) ? src : [];

					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

},{}],33:[function(require,module,exports){
(function (process){
var voxel = require('voxel')
var voxelMesh = require('voxel-mesh')
var ray = require('voxel-raycast')
var texture = require('voxel-texture')
var control = require('voxel-control')
var voxelView = require('voxel-view')
var THREE = require('three')
var Stats = require('./lib/stats')
var Detector = require('./lib/detector')
var inherits = require('inherits')
var path = require('path')
var EventEmitter = require('events').EventEmitter
if (process.browser) var interact = require('interact')
var requestAnimationFrame = require('raf')
var collisions = require('collide-3d-tilemap')
var aabb = require('aabb-3d')
var glMatrix = require('gl-matrix')
var vector = glMatrix.vec3
var SpatialEventEmitter = require('spatial-events')
var regionChange = require('voxel-region-change')
var kb = require('kb-controls')
var physical = require('voxel-physical')
var pin = require('pin-it')
var tic = require('tic')()

module.exports = Game

function Game(opts) {
  if (!(this instanceof Game)) return new Game(opts)
  var self = this
  if (!opts) opts = {}
  if (process.browser && this.notCapable(opts)) return
  
  if (!('generateChunks' in opts)) opts.generateChunks = true
  this.generateChunks = opts.generateChunks
  this.setConfigurablePositions(opts)
  this.configureChunkLoading(opts)
  this.setDimensions(opts)
  this.THREE = THREE
  this.vector = vector
  this.glMatrix = glMatrix
  this.arrayType = opts.arrayType || Uint8Array
  this.cubeSize = 1 // backwards compat
  this.chunkSize = opts.chunkSize || 32
  
  // chunkDistance and removeDistance should not be set to the same thing
  // as it causes lag when you go back and forth on a chunk boundary
  this.chunkDistance = opts.chunkDistance || 2
  this.removeDistance = opts.removeDistance || this.chunkDistance + 1
  
  this.playerHeight = opts.playerHeight || 1.62
  this.meshType = opts.meshType || 'surfaceMesh'
  this.mesher = opts.mesher || voxel.meshers.culled
  this.materialType = opts.materialType || THREE.MeshLambertMaterial
  this.materialParams = opts.materialParams || {}
  this.items = []
  this.voxels = voxel(this)
  this.scene = new THREE.Scene()
  this.view = opts.view || new voxelView(THREE, { width: this.width, height: this.height })
  this.view.bindToScene(this.scene)
  this.camera = this.view.getCamera()
  if (!opts.lightsDisabled) this.addLights(this.scene)
  
  this.skyColor = opts.skyColor || 0xBFD1E5
  this.fogScale = opts.fogScale || 32
  if (!opts.fogDisabled) this.scene.fog = new THREE.Fog( this.skyColor, 0.00025, this.worldWidth() * this.fogScale )
  
  this.collideVoxels = collisions(
    this.getBlock.bind(this),
    1,
    [Infinity, Infinity, Infinity],
    [-Infinity, -Infinity, -Infinity]
  )
  
  this.timer = this.initializeTimer((opts.tickFPS || 16))
  this.paused = false

  this.spatial = new SpatialEventEmitter
  this.region = regionChange(this.spatial, aabb([0, 0, 0], [1, 1, 1]), this.chunkSize)
  this.voxelRegion = regionChange(this.spatial, 1)
  this.chunkRegion = regionChange(this.spatial, this.chunkSize)
  this.asyncChunkGeneration = false

  // contains chunks that has had an update this tick. Will be generated right before redrawing the frame
  this.chunksNeedsUpdate = {}
  // contains new chunks yet to be generated. Handled by game.loadPendingChunks
  this.pendingChunks = []

  this.materials = texture({
    game: this,
    texturePath: opts.texturePath || './textures/',
    materialType: opts.materialType || THREE.MeshLambertMaterial,
    materialParams: opts.materialParams || {},
    materialFlatColor: opts.materialFlatColor === true
  })

  this.materialNames = opts.materials || [['grass', 'dirt', 'grass_dirt'], 'brick', 'dirt']
  
  self.chunkRegion.on('change', function(newChunk) {
    self.removeFarChunks()
  })

  if (process.browser) this.materials.load(this.materialNames)

  if (this.generateChunks) this.handleChunkGeneration()

  // client side only after this point
  if (!process.browser) return
  
  this.paused = true
  this.initializeRendering(opts)
  
  for (var chunkIndex in this.voxels.chunks) this.showChunk(this.voxels.chunks[chunkIndex])

  setTimeout(function() {
    self.asyncChunkGeneration = 'asyncChunkGeneration' in opts ? opts.asyncChunkGeneration : true
  }, 2000)

  this.initializeControls(opts)
}

inherits(Game, EventEmitter)

// # External API

Game.prototype.voxelPosition = function(gamePosition) {
  var _ = Math.floor
  var p = gamePosition
  var v = []
  v[0] = _(p[0])
  v[1] = _(p[1])
  v[2] = _(p[2])
  return v
}

Game.prototype.cameraPosition = function() {
  return this.view.cameraPosition()
}

Game.prototype.cameraVector = function() {
  return this.view.cameraVector()
}

Game.prototype.makePhysical = function(target, envelope, blocksCreation) {
  var vel = this.terminalVelocity
  envelope = envelope || [2/3, 1.5, 2/3]
  var obj = physical(target, this.potentialCollisionSet(), envelope, {x: vel[0], y: vel[1], z: vel[2]})
  obj.blocksCreation = !!blocksCreation
  return obj
}

Game.prototype.addItem = function(item) {
  if (!item.tick) {
    var newItem = physical(
      item.mesh,
      this.potentialCollisionSet(),
      [item.size, item.size, item.size]
    )
    
    if (item.velocity) {
      newItem.velocity.copy(item.velocity)
      newItem.subjectTo(this.gravity)
    }
    
    newItem.repr = function() { return 'debris' }
    newItem.mesh = item.mesh
    newItem.blocksCreation = item.blocksCreation
    
    item = newItem
  }
  
  this.items.push(item)
  if (item.mesh) this.scene.add(item.mesh)
  return this.items[this.items.length - 1]
}

Game.prototype.removeItem = function(item) {
  var ix = this.items.indexOf(item)
  if (ix < 0) return
  this.items.splice(ix, 1)
  if (item.mesh) this.scene.remove(item.mesh)
}

// only intersects voxels, not items (for now)
Game.prototype.raycast = // backwards compat
Game.prototype.raycastVoxels = function(start, direction, maxDistance, epilson) {
  if (!start) return this.raycastVoxels(this.cameraPosition(), this.cameraVector(), 10)
  
  var hitNormal = [0, 0, 0]
  var hitPosition = [0, 0, 0]
  var cp = start || this.cameraPosition()
  var cv = direction || this.cameraVector()
  var hitBlock = ray(this, cp, cv, maxDistance || 10.0, hitPosition, hitNormal, epilson || this.epilson)
  if (hitBlock <= 0) return false
  var adjacentPosition = [0, 0, 0]
  var voxelPosition = this.voxelPosition(hitPosition)
  vector.add(adjacentPosition, voxelPosition, hitNormal)
  
  return {
    position: hitPosition,
    voxel: voxelPosition,
    direction: direction,
    value: hitBlock,
    normal: hitNormal,
    adjacent: adjacentPosition
  }
}

Game.prototype.canCreateBlock = function(pos) {
  pos = this.parseVectorArguments(arguments)
  var floored = pos.map(function(i) { return Math.floor(i) })
  var bbox = aabb(floored, [1, 1, 1])
  
  for (var i = 0, len = this.items.length; i < len; ++i) {
    var item = this.items[i]
    var itemInTheWay = item.blocksCreation && item.aabb && bbox.intersects(item.aabb())
    if (itemInTheWay) return false
  }

  return true
}

Game.prototype.createBlock = function(pos, val) {
  if (typeof val === 'string') val = this.materials.find(val)
  if (!this.canCreateBlock(pos)) return false
  this.setBlock(pos, val)
  return true
}

Game.prototype.setBlock = function(pos, val) {
  if (typeof val === 'string') val = this.materials.find(val)
  var old = this.voxels.voxelAtPosition(pos, val)
  var c = this.voxels.chunkAtPosition(pos)
  var chunk = this.voxels.chunks[c.join('|')]
  if (!chunk) return// todo - does self.emit('missingChunk', c.join('|')) make sense here?
  this.addChunkToNextUpdate(chunk)
  this.spatial.emit('change-block', pos, old, val)
  this.emit('setBlock', pos, val, old)
}

Game.prototype.getBlock = function(pos) {
  pos = this.parseVectorArguments(arguments)
  return this.voxels.voxelAtPosition(pos)
}

Game.prototype.blockPosition = function(pos) {
  pos = this.parseVectorArguments(arguments)
  var ox = Math.floor(pos[0])
  var oy = Math.floor(pos[1])
  var oz = Math.floor(pos[2])
  return [ox, oy, oz]
}

Game.prototype.blocks = function(low, high, iterator) {
  var l = low, h = high
  var d = [ h[0]-l[0], h[1]-l[1], h[2]-l[2] ]
  if (!iterator) var voxels = new this.arrayType(d[0]*d[1]*d[2])
  var i = 0
  for(var z=l[2]; z<h[2]; ++z)
  for(var y=l[1]; y<h[1]; ++y)
  for(var x=l[0]; x<h[0]; ++x, ++i) {
    if (iterator) iterator(x, y, z, i)
    else voxels[i] = this.voxels.voxelAtPosition([x, y, z])
  }
  if (!iterator) return {voxels: voxels, dims: d}
}

// backwards compat
Game.prototype.createAdjacent = function(hit, val) {
  this.createBlock(hit.adjacent, val)
}

Game.prototype.appendTo = function (element) {
  this.view.appendTo(element)
}

// # Defaults/options parsing

Game.prototype.gravity = [0, -0.0000036, 0]
Game.prototype.friction = 0.3
Game.prototype.epilson = 1e-8
Game.prototype.terminalVelocity = [0.9, 0.1, 0.9]

Game.prototype.defaultButtons = {
  'W': 'forward'
, 'A': 'left'
, 'S': 'backward'
, 'D': 'right'
, '<up>': 'forward'
, '<left>': 'left'
, '<down>': 'backward'
, '<right>': 'right'
, '<mouse 1>': 'fire'
, '<mouse 3>': 'firealt'
, '<space>': 'jump'
, '<shift>': 'crouch'
, '<control>': 'alt'
}

// used in methods that have identity function(pos) {}
Game.prototype.parseVectorArguments = function(args) {
  if (!args) return false
  if (args[0] instanceof Array) return args[0]
  return [args[0], args[1], args[2]]
}

Game.prototype.setConfigurablePositions = function(opts) {
  var sp = opts.startingPosition
  this.startingPosition = sp || [35, 1024, 35]
  var wo = opts.worldOrigin
  this.worldOrigin = wo || [0, 0, 0]
}

Game.prototype.setDimensions = function(opts) {
  if (opts.container) this.container = opts.container
  if (opts.container && opts.container.clientHeight) {
    this.height = opts.container.clientHeight
  } else {
    this.height = typeof window === "undefined" ? 1 : window.innerHeight
  }
  if (opts.container && opts.container.clientWidth) {
    this.width = opts.container.clientWidth
  } else {
    this.width = typeof window === "undefined" ? 1 : window.innerWidth
  }
}

Game.prototype.notCapable = function(opts) {
  var self = this
  if( !Detector().webgl ) {
    this.view = {
      appendTo: function(el) {
        el.appendChild(self.notCapableMessage())
      }
    }
    return true
  }
  return false
}

Game.prototype.notCapableMessage = function() {
  var wrapper = document.createElement('div')
  wrapper.className = "errorMessage"
  var a = document.createElement('a')
  a.title = "You need WebGL and Pointer Lock (Chrome 23/Firefox 14) to play this game. Click here for more information."
  a.innerHTML = a.title
  a.href = "http://get.webgl.org"
  wrapper.appendChild(a)
  return wrapper
}

Game.prototype.onWindowResize = function() {
  var width = window.innerWidth
  var height = window.innerHeight
  if (this.container) {
    width = this.container.clientWidth
    height = this.container.clientHeight
  }
  this.view.resizeWindow(width, height)
}

// # Physics/collision related methods

Game.prototype.control = function(target) {
  this.controlling = target
  return this.controls.target(target)
}

Game.prototype.potentialCollisionSet = function() {
  return [{ collide: this.collideTerrain.bind(this) }]
}

/**
 * Get the position of the player under control.
 * If there is no player under control, return
 * current position of the game's camera.
 *
 * @return {Array} an [x, y, z] tuple
 */

Game.prototype.playerPosition = function() {
  var target = this.controls.target()
  var position = target
    ? target.avatar.position
    : this.camera.localToWorld(this.camera.position.clone())
  return [position.x, position.y, position.z]
}

Game.prototype.playerAABB = function(position) {
  var pos = position || this.playerPosition()
  var lower = []
  var upper = [1/2, this.playerHeight, 1/2]
  var playerBottom = [1/4, this.playerHeight, 1/4]
  vector.subtract(lower, pos, playerBottom)
  var bbox = aabb(lower, upper)
  return bbox
}

Game.prototype.collideTerrain = function(other, bbox, vec, resting) {
  var self = this
  var axes = ['x', 'y', 'z']
  var vec3 = [vec.x, vec.y, vec.z]
  this.collideVoxels(bbox, vec3, function hit(axis, tile, coords, dir, edge) {
    if (!tile) return
    if (Math.abs(vec3[axis]) < Math.abs(edge)) return
    vec3[axis] = vec[axes[axis]] = edge
    other.acceleration[axes[axis]] = 0
    resting[axes[axis]] = dir
    other.friction[axes[(axis + 1) % 3]] = other.friction[axes[(axis + 2) % 3]] = axis === 1 ? self.friction  : 1
    return true
  })
}

// # Three.js specific methods

Game.prototype.addStats = function() {
  stats = new Stats()
  stats.domElement.style.position  = 'absolute'
  stats.domElement.style.bottom  = '0px'
  document.body.appendChild( stats.domElement )
}

Game.prototype.addLights = function(scene) {
  var ambientLight, directionalLight
  ambientLight = new THREE.AmbientLight(0xcccccc)
  scene.add(ambientLight)
  var light	= new THREE.DirectionalLight( 0xffffff , 1)
  light.position.set( 1, 1, 0.5 ).normalize()
  scene.add( light )
}

// # Chunk related methods

Game.prototype.configureChunkLoading = function(opts) {
  var self = this
  if (!opts.generateChunks) return
  if (!opts.generate) {
    this.generate = function(x,y,z) {
      return x*x+y*y+z*z <= 15*15 ? 1 : 0 // sphere world
    }
  } else {
    this.generate = opts.generate
  }
  if (opts.generateVoxelChunk) {
    this.generateVoxelChunk = opts.generateVoxelChunk
  } else {
    this.generateVoxelChunk = function(low, high) {
      return voxel.generate(low, high, self.generate, self)
    }
  }
}

Game.prototype.worldWidth = function() {
  return this.chunkSize * 2 * this.chunkDistance
}

Game.prototype.chunkToWorld = function(pos) {
  return [
    pos[0] * this.chunkSize,
    pos[1] * this.chunkSize,
    pos[2] * this.chunkSize
  ]
}

Game.prototype.removeFarChunks = function(playerPosition) {
  var self = this
  playerPosition = playerPosition || this.playerPosition()
  var nearbyChunks = this.voxels.nearbyChunks(playerPosition, this.removeDistance).map(function(chunkPos) {
    return chunkPos.join('|')
  })
  Object.keys(self.voxels.chunks).map(function(chunkIndex) {
    if (nearbyChunks.indexOf(chunkIndex) > -1) return
    var chunk = self.voxels.chunks[chunkIndex]
    var mesh = self.voxels.meshes[chunkIndex]
    var pendingIndex = self.pendingChunks.indexOf(chunkIndex)
    if (pendingIndex !== -1) self.pendingChunks.splice(pendingIndex, 1)
    if (!chunk) return
    var chunkPosition = chunk.position
    if (mesh) {
      self.scene.remove(mesh[self.meshType])
      mesh[self.meshType].geometry.dispose()
      delete mesh.data
      delete mesh.geometry
      delete mesh.meshed
      delete mesh.surfaceMesh
    }
    delete self.voxels.chunks[chunkIndex]
    self.emit('removeChunk', chunkPosition)
  })
  self.voxels.requestMissingChunks(playerPosition)
}

Game.prototype.addChunkToNextUpdate = function(chunk) {
  this.chunksNeedsUpdate[chunk.position.join('|')] = chunk
}

Game.prototype.updateDirtyChunks = function() {
  var self = this
  Object.keys(this.chunksNeedsUpdate).forEach(function showChunkAtIndex(chunkIndex) {
    var chunk = self.chunksNeedsUpdate[chunkIndex]
    self.emit('dirtyChunkUpdate', chunk)
    self.showChunk(chunk)
  })
  this.chunksNeedsUpdate = {}
}

Game.prototype.loadPendingChunks = function(count) {
  var pendingChunks = this.pendingChunks

  if (!this.asyncChunkGeneration) {
    count = pendingChunks.length
  } else {
    count = count || (pendingChunks.length * 0.1)
    count = Math.max(1, Math.min(count, pendingChunks.length))
  }

  for (var i = 0; i < count; i += 1) {
    var chunkPos = pendingChunks[i].split('|')
    var chunk = this.voxels.generateChunk(chunkPos[0]|0, chunkPos[1]|0, chunkPos[2]|0)

    if (process.browser) this.showChunk(chunk)
  }

  if (count) pendingChunks.splice(0, count)
}

Game.prototype.getChunkAtPosition = function(pos) {
  var chunkID = this.voxels.chunkAtPosition(pos).join('|')
  var chunk = this.voxels.chunks[chunkID]
  return chunk
}

Game.prototype.showChunk = function(chunk) {
  var chunkIndex = chunk.position.join('|')
  var bounds = this.voxels.getBounds.apply(this.voxels, chunk.position)
  var scale = new THREE.Vector3(1, 1, 1)
  var mesh = voxelMesh(chunk, this.mesher, scale, this.THREE)
  this.voxels.chunks[chunkIndex] = chunk
  if (this.voxels.meshes[chunkIndex]) this.scene.remove(this.voxels.meshes[chunkIndex][this.meshType])
  this.voxels.meshes[chunkIndex] = mesh
  if (process.browser) {
    if (this.meshType === 'wireMesh') mesh.createWireMesh()
    else mesh.createSurfaceMesh(this.materials.material)
    this.materials.paint(mesh)
  }
  mesh.setPosition(bounds[0][0], bounds[0][1], bounds[0][2])
  mesh.addToScene(this.scene)
  this.emit('renderChunk', chunk)
  return mesh
}

// # Debugging methods

Game.prototype.addMarker = function(position) {
  var geometry = new THREE.SphereGeometry( 0.1, 10, 10 )
  var material = new THREE.MeshPhongMaterial( { color: 0xffffff, shading: THREE.FlatShading } )
  var mesh = new THREE.Mesh( geometry, material )
  mesh.position.copy(position)
  this.scene.add(mesh)
}

Game.prototype.addAABBMarker = function(aabb, color) {
  var geometry = new THREE.CubeGeometry(aabb.width(), aabb.height(), aabb.depth())
  var material = new THREE.MeshBasicMaterial({ color: color || 0xffffff, wireframe: true, transparent: true, opacity: 0.5, side: THREE.DoubleSide })
  var mesh = new THREE.Mesh(geometry, material)
  mesh.position.set(aabb.x0() + aabb.width() / 2, aabb.y0() + aabb.height() / 2, aabb.z0() + aabb.depth() / 2)
  this.scene.add(mesh)
  return mesh
}

Game.prototype.addVoxelMarker = function(x, y, z, color) {
  var bbox = aabb([x, y, z], [1, 1, 1])
  return this.addAABBMarker(bbox, color)
}

Game.prototype.pin = pin

// # Misc internal methods

Game.prototype.onControlChange = function(gained, stream) {
  this.paused = false

  if (!gained && !this.optout) {
    this.buttons.disable()
    return
  }

  this.buttons.enable()
  stream.pipe(this.controls.createWriteRotationStream())
}

Game.prototype.onControlOptOut = function() {
  this.optout = true
}

Game.prototype.onFire = function(state) {
  this.emit('fire', this.controlling, state)
}

Game.prototype.setInterval = tic.interval.bind(tic)
Game.prototype.setTimeout = tic.timeout.bind(tic)

Game.prototype.tick = function(delta) {
  for(var i = 0, len = this.items.length; i < len; ++i) {
    this.items[i].tick(delta)
  }
  
  if (this.materials) this.materials.tick(delta)

  if (this.pendingChunks.length) this.loadPendingChunks()
  if (Object.keys(this.chunksNeedsUpdate).length > 0) this.updateDirtyChunks()
  
  tic.tick(delta)

  this.emit('tick', delta)
  
  if (!this.controls) return
  var playerPos = this.playerPosition()
  this.spatial.emit('position', playerPos, playerPos)
}

Game.prototype.render = function(delta) {
  this.view.render(this.scene)
}

Game.prototype.initializeTimer = function(rate) {
  var self = this
  var accum = 0
  var now = 0
  var last = null
  var dt = 0
  var wholeTick
  
  self.frameUpdated = true
  self.interval = setInterval(timer, 0)
  return self.interval
  
  function timer() {
    if (self.paused) {
      last = Date.now()
      accum = 0
      return
    }
    now = Date.now()
    dt = now - (last || now)
    last = now
    accum += dt
    if (accum < rate) return
    wholeTick = ((accum / rate)|0)
    if (wholeTick <= 0) return
    wholeTick *= rate
    
    self.tick(wholeTick)
    accum -= wholeTick
    
    self.frameUpdated = true
  }
}

Game.prototype.initializeRendering = function(opts) {
  var self = this

  if (!opts.statsDisabled) self.addStats()

  window.addEventListener('resize', self.onWindowResize.bind(self), false)

  requestAnimationFrame(window).on('data', function(dt) {
    self.emit('prerender', dt)
    self.render(dt)
    self.emit('postrender', dt)
  })
  if (typeof stats !== 'undefined') {
    self.on('postrender', function() {
      stats.update()
    })
  }
}

Game.prototype.initializeControls = function(opts) {
  // player control
  this.keybindings = opts.keybindings || this.defaultButtons
  this.buttons = kb(document.body, this.keybindings)
  this.buttons.disable()
  this.optout = false
  this.interact = interact(opts.interactElement || this.view.element, opts.interactMouseDrag)
  this.interact
      .on('attain', this.onControlChange.bind(this, true))
      .on('release', this.onControlChange.bind(this, false))
      .on('opt-out', this.onControlOptOut.bind(this))
  this.hookupControls(this.buttons, opts)
}

Game.prototype.hookupControls = function(buttons, opts) {
  opts = opts || {}
  opts.controls = opts.controls || {}
  opts.controls.onfire = this.onFire.bind(this)
  this.controls = control(buttons, opts.controls)
  this.items.push(this.controls)
  this.controlling = null
}

Game.prototype.handleChunkGeneration = function() {
  var self = this
  this.voxels.on('missingChunk', function(chunkPos) {
    self.pendingChunks.push(chunkPos.join('|'))
  })
  this.voxels.requestMissingChunks(this.worldOrigin)
  this.loadPendingChunks(this.pendingChunks.length)
}

// teardown methods
Game.prototype.destroy = function() {
  clearInterval(this.timer)
}

}).call(this,require('_process'))

},{"./lib/detector":34,"./lib/stats":35,"_process":10,"aabb-3d":36,"collide-3d-tilemap":37,"events":6,"gl-matrix":38,"inherits":39,"interact":40,"kb-controls":49,"path":9,"pin-it":54,"raf":55,"spatial-events":56,"three":58,"tic":59,"voxel":80,"voxel-control":60,"voxel-mesh":61,"voxel-physical":62,"voxel-raycast":63,"voxel-region-change":64,"voxel-texture":65,"voxel-view":67}],34:[function(require,module,exports){
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mr.doob / http://mrdoob.com/
 */

module.exports = function() {
  return {
  	canvas : !! window.CanvasRenderingContext2D,
  	webgl : ( function () { try { return !! window.WebGLRenderingContext && !! document.createElement( 'canvas' ).getContext( 'experimental-webgl' ); } catch( e ) { return false; } } )(),
  	workers : !! window.Worker,
  	fileapi : window.File && window.FileReader && window.FileList && window.Blob,

  	getWebGLErrorMessage : function () {

  		var domElement = document.createElement( 'div' );

  		domElement.style.fontFamily = 'monospace';
  		domElement.style.fontSize = '13px';
  		domElement.style.textAlign = 'center';
  		domElement.style.background = '#eee';
  		domElement.style.color = '#000';
  		domElement.style.padding = '1em';
  		domElement.style.width = '475px';
  		domElement.style.margin = '5em auto 0';

  		if ( ! this.webgl ) {

  			domElement.innerHTML = window.WebGLRenderingContext ? [
  				'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br />',
  				'Find out how to get it <a href="http://get.webgl.org/">here</a>.'
  			].join( '\n' ) : [
  				'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation">WebGL</a>.<br/>',
  				'Find out how to get it <a href="http://get.webgl.org/">here</a>.'
  			].join( '\n' );

  		}

  		return domElement;

  	},

  	addGetWebGLMessage : function ( parameters ) {

  		var parent, id, domElement;

  		parameters = parameters || {};

  		parent = parameters.parent !== undefined ? parameters.parent : document.body;
  		id = parameters.id !== undefined ? parameters.id : 'oldie';

  		domElement = Detector.getWebGLErrorMessage();
  		domElement.id = id;

  		parent.appendChild( domElement );

  	}

  };
}

},{}],35:[function(require,module,exports){
/**
 * @author mrdoob / http://mrdoob.com/
 */

var Stats = function () {

	var startTime = Date.now(), prevTime = startTime;
	var ms = 0, msMin = Infinity, msMax = 0;
	var fps = 0, fpsMin = Infinity, fpsMax = 0;
	var frames = 0, mode = 0;

	var container = document.createElement( 'div' );
	container.id = 'stats';
	container.addEventListener( 'mousedown', function ( event ) { event.preventDefault(); setMode( ++ mode % 2 ) }, false );
	container.style.cssText = 'width:80px;opacity:0.9;cursor:pointer';

	var fpsDiv = document.createElement( 'div' );
	fpsDiv.id = 'fps';
	fpsDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#002';
	container.appendChild( fpsDiv );

	var fpsText = document.createElement( 'div' );
	fpsText.id = 'fpsText';
	fpsText.style.cssText = 'color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
	fpsText.innerHTML = 'FPS';
	fpsDiv.appendChild( fpsText );

	var fpsGraph = document.createElement( 'div' );
	fpsGraph.id = 'fpsGraph';
	fpsGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0ff';
	fpsDiv.appendChild( fpsGraph );

	while ( fpsGraph.children.length < 74 ) {

		var bar = document.createElement( 'span' );
		bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#113';
		fpsGraph.appendChild( bar );

	}

	var msDiv = document.createElement( 'div' );
	msDiv.id = 'ms';
	msDiv.style.cssText = 'padding:0 0 3px 3px;text-align:left;background-color:#020;display:none';
	container.appendChild( msDiv );

	var msText = document.createElement( 'div' );
	msText.id = 'msText';
	msText.style.cssText = 'color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px';
	msText.innerHTML = 'MS';
	msDiv.appendChild( msText );

	var msGraph = document.createElement( 'div' );
	msGraph.id = 'msGraph';
	msGraph.style.cssText = 'position:relative;width:74px;height:30px;background-color:#0f0';
	msDiv.appendChild( msGraph );

	while ( msGraph.children.length < 74 ) {

		var bar = document.createElement( 'span' );
		bar.style.cssText = 'width:1px;height:30px;float:left;background-color:#131';
		msGraph.appendChild( bar );

	}

	var setMode = function ( value ) {

		mode = value;

		switch ( mode ) {

			case 0:
				fpsDiv.style.display = 'block';
				msDiv.style.display = 'none';
				break;
			case 1:
				fpsDiv.style.display = 'none';
				msDiv.style.display = 'block';
				break;
		}

	}

	var updateGraph = function ( dom, value ) {

		var child = dom.appendChild( dom.firstChild );
		child.style.height = value + 'px';

	}

	return {

		REVISION: 11,

		domElement: container,

		setMode: setMode,

		begin: function () {

			startTime = Date.now();

		},

		end: function () {

			var time = Date.now();

			ms = time - startTime;
			msMin = Math.min( msMin, ms );
			msMax = Math.max( msMax, ms );

			msText.textContent = ms + ' MS (' + msMin + '-' + msMax + ')';
			updateGraph( msGraph, Math.min( 30, 30 - ( ms / 200 ) * 30 ) );

			frames ++;

			if ( time > prevTime + 1000 ) {

				fps = Math.round( ( frames * 1000 ) / ( time - prevTime ) );
				fpsMin = Math.min( fpsMin, fps );
				fpsMax = Math.max( fpsMax, fps );

				fpsText.textContent = fps + ' FPS (' + fpsMin + '-' + fpsMax + ')';
				updateGraph( fpsGraph, Math.min( 30, 30 - ( fps / 100 ) * 30 ) );

				prevTime = time;
				frames = 0;

			}

			return time;

		},

		update: function () {

			startTime = this.end();

		}

	}

};

module.exports = Stats
},{}],36:[function(require,module,exports){
module.exports = AABB

var vec3 = require('gl-matrix').vec3

function AABB(pos, vec) {
  if(!(this instanceof AABB)) {
    return new AABB(pos, vec)
  }

  this.base = pos
  this.vec = vec

  this.mag = vec3.length(this.vec)

  this.max = vec3.create()
  vec3.add(this.max, this.base, this.vec)
}

var cons = AABB
  , proto = cons.prototype

proto.width = function() {
  return this.vec[0]
}

proto.height = function() {
  return this.vec[1]
}

proto.depth = function() {
  return this.vec[2]
}

proto.x0 = function() {
  return this.base[0]
}

proto.y0 = function() {
  return this.base[1]
}

proto.z0 = function() {
  return this.base[2]
}

proto.x1 = function() {
  return this.max[0]
}

proto.y1 = function() {
  return this.max[1]
}

proto.z1 = function() {
  return this.max[2]
}

proto.translate = function(by) {
  vec3.add(this.max, this.max, by)
  vec3.add(this.base, this.base, by)
  return this
}

proto.expand = function(aabb) {
  var max = vec3.create()
    , min = vec3.create()

  vec3.max(max, aabb.max, this.max)
  vec3.min(min, aabb.base, this.base)
  vec3.sub(max, max, min)

  return new AABB(min, max)
}

proto.intersects = function(aabb) {
  if(aabb.base[0] > this.max[0]) return false
  if(aabb.base[1] > this.max[1]) return false
  if(aabb.base[2] > this.max[2]) return false
  if(aabb.max[0] < this.base[0]) return false
  if(aabb.max[1] < this.base[1]) return false
  if(aabb.max[2] < this.base[2]) return false

  return true
}

proto.union = function(aabb) {
  if(!this.intersects(aabb)) return null

  var base_x = Math.max(aabb.base[0], this.base[0])
    , base_y = Math.max(aabb.base[1], this.base[1])
    , base_z = Math.max(aabb.base[2], this.base[2])
    , max_x = Math.min(aabb.max[0], this.max[0])
    , max_y = Math.min(aabb.max[1], this.max[1])
    , max_z = Math.min(aabb.max[2], this.max[2])

  return new AABB([base_x, base_y, base_z], [max_x - base_x, max_y - base_y, max_z - base_z])
}

},{"gl-matrix":38}],37:[function(require,module,exports){
module.exports = function(field, tilesize, dimensions, offset) {
  dimensions = dimensions || [ 
    Math.sqrt(field.length) >> 0
  , Math.sqrt(field.length) >> 0
  , Math.sqrt(field.length) >> 0
  ] 

  offset = offset || [
    0
  , 0
  , 0
  ]

  field = typeof field === 'function' ? field : function(x, y, z) {
    return this[x + y * dimensions[1] + (z * dimensions[1] * dimensions[2])]
  }.bind(field) 

  var coords

  coords = [0, 0, 0]

  return collide

  function collide(box, vec, oncollision) {
    if(vec[0] === 0 && vec[1] === 0 && vec[2] === 0) return

    // collide x, then y
    collideaxis(0)
    collideaxis(1)
    collideaxis(2)

    function collideaxis(i_axis) {
      var j_axis = (i_axis + 1) % 3
        , k_axis = (i_axis + 2) % 3 
        , posi = vec[i_axis] > 0
        , leading = box[posi ? 'max' : 'base'][i_axis] 
        , dir = posi ? 1 : -1
        , i_start = Math.floor(leading / tilesize)
        , i_end = (Math.floor((leading + vec[i_axis]) / tilesize)) + dir
        , j_start = Math.floor(box.base[j_axis] / tilesize)
        , j_end = Math.ceil(box.max[j_axis] / tilesize)
        , k_start = Math.floor(box.base[k_axis] / tilesize) 
        , k_end = Math.ceil(box.max[k_axis] / tilesize)
        , done = false
        , edge_vector
        , edge
        , tile

      // loop from the current tile coord to the dest tile coord
      //    -> loop on the opposite axis to get the other candidates
      //      -> if `oncollision` return `true` we've hit something and
      //         should break out of the loops entirely.
      //         NB: `oncollision` is where the client gets the chance
      //         to modify the `vec` in-flight.
      // once we're done translate the box to the vec results

      var step = 0
      for(var i = i_start; !done && i !== i_end; ++step, i += dir) {
        if(i < offset[i_axis] || i >= dimensions[i_axis]) continue
        for(var j = j_start; !done && j !== j_end; ++j) {
          if(j < offset[j_axis] || j >= dimensions[j_axis]) continue
          for(var k = k_start; k !== k_end; ++k) {
            if(k < offset[k_axis] || k >= dimensions[k_axis]) continue
            coords[i_axis] = i
            coords[j_axis] = j
            coords[k_axis] = k
            tile = field.apply(field, coords)

            if(tile === undefined) continue

            edge = dir > 0 ? i * tilesize : (i + 1) * tilesize
            edge_vector = edge - leading

            if(oncollision(i_axis, tile, coords, dir, edge_vector)) {
              done = true
              break
            }
          } 
        }
      }

      coords[0] = coords[1] = coords[2] = 0
      coords[i_axis] = vec[i_axis]
      box.translate(coords)
    }
  }  
}

},{}],38:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.0.0
 */

/* Copyright (c) 2012, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


(function() {
  "use strict";

  var shim = {};
  if (typeof(exports) === 'undefined') {
    if(typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
      shim.exports = {};
      define(function() {
        return shim.exports;
      });
    } else {
      // gl-matrix lives in a browser, define its namespaces in global
      shim.exports = window;
    }    
  }
  else {
    // gl-matrix lives in commonjs, define its namespaces in exports
    shim.exports = exports;
  }

  (function(exports) {
    /* Copyright (c) 2012, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */

var vec2 = {};

if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}
 
/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    return new Float32Array(2);
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new Float32Array(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new Float32Array(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.sub = vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.mul = vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.div = vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {vec2} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.dist = vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.sqrDist = vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Caclulates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.len = vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Caclulates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.sqrLen = vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Caclulates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = x * m[0] + y * m[1];
    out[1] = x * m[2] + y * m[3];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 */
vec2.forEach = (function() {
    var vec = new Float32Array(2);

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec2 = vec2;
}
;
/* Copyright (c) 2012, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */

var vec3 = {};

if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}
 
/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    return new Float32Array(3);
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new Float32Array(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new Float32Array(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.sub = vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.mul = vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.div = vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {vec3} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.dist = vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.sqrDist = vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Caclulates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.len = vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Caclulates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.sqrLen = vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Caclulates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 */
vec3.forEach = (function() {
    var vec = new Float32Array(3);

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec3 = vec3;
}
;
/* Copyright (c) 2012, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */

var vec4 = {};

if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    return new Float32Array(4);
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new Float32Array(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new Float32Array(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.sub = vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.mul = vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.div = vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {vec4} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.dist = vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.sqrDist = vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Caclulates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.len = vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Caclulates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.sqrLen = vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
        out[3] = a[3] * len;
    }
    return out;
};

/**
 * Caclulates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 */
vec4.forEach = (function() {
    var vec = new Float32Array(4);

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.vec4 = vec4;
}
;
/* Copyright (c) 2012, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 2x2 Matrix
 * @name mat2
 */

var mat2 = {};

var mat2Identity = new Float32Array([
    1, 0,
    0, 1
]);

if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    return new Float32Array(mat2Identity);
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new Float32Array(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Caclulates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.mul = mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a1 * b2;
    out[1] = a0 * b1 + a1 * b3;
    out[2] = a2 * b0 + a3 * b2;
    out[3] = a2 * b1 + a3 * b3;
    return out;
};

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {mat2} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a1 * s;
    out[1] = a0 * -s + a1 * c;
    out[2] = a2 *  c + a3 * s;
    out[3] = a2 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {mat2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v1;
    out[2] = a2 * v0;
    out[3] = a3 * v1;
    return out;
};

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.mat2 = mat2;
}
;
/* Copyright (c) 2012, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 3x3 Matrix
 * @name mat3
 */

var mat3 = {};

var mat3Identity = new Float32Array([
    1, 0, 0,
    0, 1, 0,
    0, 0, 1
]);

if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    return new Float32Array(mat3Identity);
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new Float32Array(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Caclulates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.mul = mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.mat3 = mat3;
}
;
/* Copyright (c) 2012, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class 4x4 Matrix
 * @name mat4
 */

var mat4 = {};

var mat4Identity = new Float32Array([
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1
]);

if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    return new Float32Array(mat4Identity);
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Caclulates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.mul = mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < GLMAT_EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&
        Math.abs(eyey - centery) < GLMAT_EPSILON &&
        Math.abs(eyez - centerz) < GLMAT_EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.mat4 = mat4;
}
;
/* Copyright (c) 2012, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation 
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE 
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */

/**
 * @class Quaternion
 * @name quat
 */

var quat = {};

var quatIdentity = new Float32Array([0, 0, 0, 1]);

if(!GLMAT_EPSILON) {
    var GLMAT_EPSILON = 0.000001;
}

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    return new Float32Array(quatIdentity);
};

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.mul = quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {quat} b amount to scale the vector by
 * @returns {quat} out
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle around the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle around the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle around the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Caclulates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = a[3];

    var cosHalfTheta = ax * bx + ay * by + az * bz + aw * bw,
        halfTheta,
        sinHalfTheta,
        ratioA,
        ratioB;

    if (Math.abs(cosHalfTheta) >= 1.0) {
        if (out !== a) {
            out[0] = ax;
            out[1] = ay;
            out[2] = az;
            out[3] = aw;
        }
        return out;
    }

    halfTheta = Math.acos(cosHalfTheta);
    sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    if (Math.abs(sinHalfTheta) < 0.001) {
        out[0] = (ax * 0.5 + bx * 0.5);
        out[1] = (ay * 0.5 + by * 0.5);
        out[2] = (az * 0.5 + bz * 0.5);
        out[3] = (aw * 0.5 + bw * 0.5);
        return out;
    }

    ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
    ratioB = Math.sin(t * halfTheta) / sinHalfTheta;

    out[0] = (ax * ratioA + bx * ratioB);
    out[1] = (ay * ratioA + by * ratioB);
    out[2] = (az * ratioA + bz * ratioB);
    out[3] = (aw * ratioA + bw * ratioB);

    return out;
};

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Caclulates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
quat.len = quat.length = vec4.length;

/**
 * Caclulates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
quat.sqrLen = quat.squaredLength = vec4.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 */
quat.normalize = vec4.normalize;

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

if(typeof(exports) !== 'undefined') {
    exports.quat = quat;
}
;










  })(shim.exports);
})();

},{}],39:[function(require,module,exports){
module.exports = inherits

function inherits (c, p, proto) {
  proto = proto || {}
  var e = {}
  ;[c.prototype, proto].forEach(function (s) {
    Object.getOwnPropertyNames(s).forEach(function (k) {
      e[k] = Object.getOwnPropertyDescriptor(s, k)
    })
  })
  c.prototype = Object.create(p.prototype, e)
  c.super = p
}

//function Child () {
//  Child.super.call(this)
//  console.error([this
//                ,this.constructor
//                ,this.constructor === Child
//                ,this.constructor.super === Parent
//                ,Object.getPrototypeOf(this) === Child.prototype
//                ,Object.getPrototypeOf(Object.getPrototypeOf(this))
//                 === Parent.prototype
//                ,this instanceof Child
//                ,this instanceof Parent])
//}
//function Parent () {}
//inherits(Child, Parent)
//new Child

},{}],40:[function(require,module,exports){
var lock = require('pointer-lock')
  , drag = require('drag-stream')
  , full = require('fullscreen')

var EE = require('events').EventEmitter
  , Stream = require('stream').Stream

module.exports = interact

function interact(el, skiplock) {
  var ee = new EE
    , internal

  if(!lock.available() || skiplock) {
    internal = usedrag(el)
  } else {
    internal = uselock(el, politelydeclined)
  }

  ee.release = function() { internal.release && internal.release() }
  ee.request = function() { internal.request && internal.request() }
  ee.destroy = function() { internal.destroy && internal.destroy() }
  ee.pointerAvailable = function() { return lock.available() }
  ee.fullscreenAvailable = function() { return full.available() }

  forward()

  return ee

  function politelydeclined() {
    ee.emit('opt-out')
    internal.destroy()
    internal = usedrag(el)
    forward()
  }

  function forward() {
    internal.on('attain', function(stream) {
      ee.emit('attain', stream)
    })

    internal.on('release', function() {
      ee.emit('release')
    })
  }
}

function uselock(el, declined) {
  var pointer = lock(el)
    , fs = full(el)

  pointer.on('needs-fullscreen', function() {
    fs.once('attain', function() {
      pointer.request()
    })
    fs.request()
  })

  pointer.on('error', declined)

  return pointer
}

function usedrag(el) {
  var ee = new EE
    , d = drag(el)
    , stream

  d.paused = true

  d.on('resume', function() {
    stream = new Stream
    stream.readable = true
    stream.initial = null
  })

  d.on('data', function(datum) {
    if(!stream) {
      stream = new Stream
      stream.readable = true
      stream.initial = null
    }

    if(!stream.initial) {
      stream.initial = {
        x: datum.dx
      , y: datum.dy
      , t: datum.dt
      }
      return ee.emit('attain', stream)
    }

    if(stream.paused) {
      ee.emit('release')
      stream.emit('end')
      stream.readable = false
      stream.emit('close')
      stream = null
    }

    stream.emit('data', datum)
  })

  return ee
}

},{"drag-stream":41,"events":6,"fullscreen":47,"pointer-lock":48,"stream":24}],41:[function(require,module,exports){
module.exports = dragstream

var Stream = require('stream')
  , read = require('domnode-dom').createReadStream
  , through = require('through')

function dragstream(el) {
  var body = el.ownerDocument.body
    , down = read(el, 'mousedown')
    , up = read(body, 'mouseup', false)
    , move = read(body, 'mousemove', false)
    , anchor = {x: 0, y: 0, t: 0}
    , drag = through(on_move)

  // default to "paused"
  drag.pause()

  down.on('data', on_down)
  up.on('data', on_up)

  return move.pipe(drag)

  // listeners:

  function on_move(ev) {
    if(drag.paused) return

    drag.emit('data', datum(
        ev.screenX - anchor.x
      , ev.screenY - anchor.y
      , +new Date
    ))

    anchor.x = ev.screenX
    anchor.y = ev.screenY
  }

  function on_down(ev) {
    anchor.x = ev.screenX
    anchor.y = ev.screenY
    anchor.t = +new Date
    drag.resume()
    drag.emit('data', datum(
        anchor.x
      , anchor.y
      , anchor.t
    ))
  }

  function on_up(ev) {
    drag.pause()
    drag.emit('data', datum(
        ev.screenX - anchor.x
      , ev.screenY - anchor.y
      , +new Date
    ))
  }

  function datum(dx, dy, when) {
    return {
      dx: dx
    , dy: dy
    , dt: when - anchor.t
    }
  }
}

},{"domnode-dom":42,"stream":24,"through":46}],42:[function(require,module,exports){
module.exports = require('./lib/index')

},{"./lib/index":43}],43:[function(require,module,exports){
var WriteStream = require('./writable')
  , ReadStream = require('./readable')
  , DOMStream = {}

DOMStream.WriteStream = WriteStream
DOMStream.ReadStream = ReadStream

DOMStream.createAppendStream = function(el, mimetype) {
  return new DOMStream.WriteStream(
      el
    , DOMStream.WriteStream.APPEND
    , mimetype
  )
}

DOMStream.createWriteStream = function(el, mimetype) {
  return new DOMStream.WriteStream(
      el
    , DOMStream.WriteStream.WRITE
    , mimetype
  )
}

DOMStream.createReadStream =
DOMStream.createEventStream = function(el, type, preventDefault) {
  preventDefault = preventDefault === undefined ? true : preventDefault

  return new DOMStream.ReadStream(
      el
    , type
    , preventDefault
  )
}

module.exports = DOMStream


},{"./readable":44,"./writable":45}],44:[function(require,module,exports){
module.exports = DOMStream

var Stream = require('stream').Stream

var listener = function(el, type, onmsg) {
  return el.addEventListener(type, onmsg, false)
}

if(typeof $ !== 'undefined')
  listener = function(el, type, onmsg) {
    return el = $(el)[type](onmsg)
  }

if(typeof document !== 'undefined' && !document.createElement('div').addEventListener)
  listener = function(el, type, onmsg) {
    return el.attachEvent('on'+type, onmsg)
  }

function DOMStream(el, eventType, shouldPreventDefault) {
  this.el = el
  this.eventType = eventType
  this.shouldPreventDefault = shouldPreventDefault

  var self = this

  if(el && this.eventType)
    listener(
        this.el
      , this.eventType
      , function() { return self.listen.apply(self, arguments) }
    )

  Stream.call(this)
}

var cons = DOMStream
  , proto = cons.prototype = Object.create(Stream.prototype)

proto.constructor = cons

proto.listen = function(ev) {
  if(this.shouldPreventDefault)
    ev.preventDefault ? ev.preventDefault() : (ev.returnValue = false)

  var collectData =
    this.eventType === 'submit' ||
    this.eventType === 'change' ||
    this.eventType === 'keydown' ||
    this.eventType === 'keyup' ||
    this.eventType === 'input'

  if(collectData) {
    if(this.el.tagName.toUpperCase() === 'FORM')
      return this.handleFormSubmit(ev)

    return this.emit('data', valueFromElement(this.el))
  }

  this.emit('data', ev)
}

proto.handleFormSubmit = function(ev) {
  var elements = []

  if(this.el.querySelectorAll) {
    elements = this.el.querySelectorAll('input,textarea,select')
  } else {
    var inputs = {'INPUT':true, 'TEXTAREA':true, 'SELECT':true}

    var recurse = function(el) {
      for(var i = 0, len = el.childNodes.length; i < len; ++i) {
        if(el.childNodes[i].tagName) {
          if(inputs[el.childNodes[i].tagName.toUpperCase()]) {
            elements.push(el)
          } else {
            recurse(el.childNodes[i])
          }
        }
      }
    }

    recurse(this.el)
  }

  var output = {}
    , attr
    , val

  for(var i = 0, len = elements.length; i < len; ++i) {
    attr = elements[i].getAttribute('name')
    val = valueFromElement(elements[i])

    if(val !== null) {
      output[attr] = val
    }
  }

  return this.emit('data', output)
}

function valueFromElement(el) {
  switch(el.getAttribute('type')) {
    case 'radio':
      return el.checked ? el.value : null
    case 'checkbox':
      return 'data', el.checked
  }
  return el.value
}

},{"stream":24}],45:[function(require,module,exports){
module.exports = DOMStream

var Stream = require('stream').Stream

function DOMStream(el, mode, mimetype) {
  this.el = el
  this.mode = mode
  this.mimetype = mimetype || 'text/html'

  Stream.call(this)
}

var cons = DOMStream
  , proto = cons.prototype = Object.create(Stream.prototype)

proto.constructor = cons

cons.APPEND = 0
cons.WRITE = 1

proto.writable = true

proto.setMimetype = function(mime) {
  this.mimetype = mime
}

proto.write = function(data) {
  var result = (this.mode === cons.APPEND) ? this.append(data) : this.insert(data)
  this.emit('data', this.el.childNodes)
  return result
}

proto.end = function() {

}

proto.insert = function(data) {
  this.el.innerHTML = ''
  return this.append(data)
}

proto.append = function(data) {
  var result = this[this.resolveMimetypeHandler()](data)

  for(var i = 0, len = result.length; i < len; ++i) {
    this.el.appendChild(result[i])
  }

  return true
}

proto.resolveMimetypeHandler = function() {
  var type = this.mimetype.replace(/(\/\w)/, function(x) {
    return x.slice(1).toUpperCase()
  })
  type = type.charAt(0).toUpperCase() + type.slice(1)

  return 'construct'+type
}

proto.constructTextHtml = function(data) {
  var isTableFragment = /(tr|td|th)/.test(data) && !/table/.test(data)
    , div

  if(isTableFragment) {
    // wuh-oh.
    div = document.createElement('table')
  }

  div = div || document.createElement('div')
  div.innerHTML = data 

  return [].slice.call(div.childNodes)
}

proto.constructTextPlain = function(data) {
  var textNode = document.createTextNode(data)

  return [textNode]
}

},{"stream":24}],46:[function(require,module,exports){
(function (process){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)



exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end) {
  write = write || function (data) { this.emit('data', data) }
  end = end || function () { this.emit('end') }

  var ended = false, destroyed = false
  var stream = new Stream(), buffer = []
  stream.buffer = buffer
  stream.readable = stream.writable = true
  stream.paused = false
  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = function (data) {
    buffer.push(data)
    drain()
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    stream.emit('pause')
  }
  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
  }
  return stream
}


}).call(this,require('_process'))

},{"_process":10,"stream":24}],47:[function(require,module,exports){
module.exports = fullscreen
fullscreen.available = available

var EE = require('events').EventEmitter

function available() {
  return !!shim(document.body)
}

function fullscreen(el) {
  var ael = el.addEventListener || el.attachEvent
    , doc = el.ownerDocument
    , body = doc.body
    , rfs = shim(el)
    , ee = new EE

  var vendors = ['', 'webkit', 'moz', 'ms', 'o']

  for(var i = 0, len = vendors.length; i < len; ++i) {
    ael.call(doc, vendors[i]+'fullscreenchange', onfullscreenchange)
    ael.call(doc, vendors[i]+'fullscreenerror', onfullscreenerror)
  }

  ee.release = release
  ee.request = request
  ee.target = fullscreenelement

  if(!shim) {
    setTimeout(function() {
      ee.emit('error', new Error('fullscreen is not supported'))
    }, 0)
  }
  return ee

  function onfullscreenchange() {
    if(!fullscreenelement()) {
      return ee.emit('release')
    }
    ee.emit('attain')
  }

  function onfullscreenerror() {
    ee.emit('error')
  }

  function request() {
    return rfs.call(el)
  }

  function release() {
    (el.exitFullscreen ||
    el.exitFullscreen ||
    el.webkitExitFullScreen ||
    el.webkitExitFullscreen ||
    el.mozExitFullScreen ||
    el.mozExitFullscreen ||
    el.msExitFullScreen ||
    el.msExitFullscreen ||
    el.oExitFullScreen ||
    el.oExitFullscreen).call(el)
  } 

  function fullscreenelement() {
    return 0 ||
      doc.fullScreenElement ||
      doc.fullscreenElement ||
      doc.webkitFullScreenElement ||
      doc.webkitFullscreenElement ||
      doc.mozFullScreenElement ||
      doc.mozFullscreenElement ||
      doc.msFullScreenElement ||
      doc.msFullscreenElement ||
      doc.oFullScreenElement ||
      doc.oFullscreenElement ||
      null
  }
}

function shim(el) {
  return (el.requestFullscreen ||
    el.webkitRequestFullscreen ||
    el.webkitRequestFullScreen ||
    el.mozRequestFullscreen ||
    el.mozRequestFullScreen ||
    el.msRequestFullscreen ||
    el.msRequestFullScreen ||
    el.oRequestFullscreen ||
    el.oRequestFullScreen)
}

},{"events":6}],48:[function(require,module,exports){
module.exports = pointer

pointer.available = available

var EE = require('events').EventEmitter
  , Stream = require('stream').Stream

function available() {
  return !!shim(document.body)
}

function pointer(el) {
  var ael = el.addEventListener || el.attachEvent
    , rel = el.removeEventListener || el.detachEvent
    , doc = el.ownerDocument
    , body = doc.body
    , rpl = shim(el) 
    , out = {dx: 0, dy: 0, dt: 0}
    , ee = new EE
    , stream = null
    , lastPageX, lastPageY
    , needsFullscreen = false
    , mouseDownMS

  ael.call(el, 'mousedown', onmousedown, false)
  ael.call(el, 'mouseup', onmouseup, false)
  ael.call(body, 'mousemove', onmove, false)

  var vendors = ['', 'webkit', 'moz', 'ms', 'o']

  for(var i = 0, len = vendors.length; i < len; ++i) {
    ael.call(doc, vendors[i]+'pointerlockchange', onpointerlockchange)
    ael.call(doc, vendors[i]+'pointerlockerror', onpointerlockerror)
  }

  ee.release = release
  ee.target = pointerlockelement
  ee.request = onmousedown
  ee.destroy = function() {
    rel.call(el, 'mouseup', onmouseup, false)
    rel.call(el, 'mousedown', onmousedown, false)
    rel.call(el, 'mousemove', onmove, false)
  }

  if(!shim) {
    setTimeout(function() {
      ee.emit('error', new Error('pointer lock is not supported'))
    }, 0)
  }
  return ee

  function onmousedown(ev) {
    if(pointerlockelement()) {
      return
    }
    mouseDownMS = +new Date
    rpl.call(el)
  }

  function onmouseup(ev) {
    if(!needsFullscreen) {
      return
    }

    ee.emit('needs-fullscreen')
    needsFullscreen = false
  }

  function onpointerlockchange(ev) {
    if(!pointerlockelement()) {
      if(stream) release()
      return
    }

    stream = new Stream
    stream.readable = true
    stream.initial = {x: lastPageX, y: lastPageY, t: Date.now()}

    ee.emit('attain', stream)
  }

  function onpointerlockerror(ev) {
    var dt = +(new Date) - mouseDownMS
    if(dt < 100) {
      // we errored immediately, we need to do fullscreen first.
      needsFullscreen = true
      return
    }

    if(stream) {
      stream.emit('error', ev)
      stream = null
    }
  }

  function release() {
    ee.emit('release')

    if(stream) {
      stream.emit('end')
      stream.readable = false
      stream.emit('close')
      stream = null
    }

    var pel = pointerlockelement()
    if(!pel) {
      return
    }

    (doc.exitPointerLock ||
    doc.mozExitPointerLock ||
    doc.webkitExitPointerLock ||
    doc.msExitPointerLock ||
    doc.oExitPointerLock).call(doc)
  }

  function onmove(ev) {
    lastPageX = ev.pageX
    lastPageY = ev.pageY

    if(!stream) return

    // we're reusing a single object
    // because I'd like to avoid piling up
    // a ton of objects for the garbage
    // collector.
    out.dx =
      ev.movementX || ev.webkitMovementX ||
      ev.mozMovementX || ev.msMovementX ||
      ev.oMovementX || 0

    out.dy = 
      ev.movementY || ev.webkitMovementY ||
      ev.mozMovementY || ev.msMovementY ||
      ev.oMovementY || 0

    out.dt = Date.now() - stream.initial.t

    ee.emit('data', out)
    stream.emit('data', out)
  }

  function pointerlockelement() {
    return 0 ||
      doc.pointerLockElement ||
      doc.mozPointerLockElement ||
      doc.webkitPointerLockElement ||
      doc.msPointerLockElement ||
      doc.oPointerLockElement ||
      null
  }
}

function shim(el) {
  return el.requestPointerLock ||
    el.webkitRequestPointerLock ||
    el.mozRequestPointerLock ||
    el.msRequestPointerLock ||
    el.oRequestPointerLock ||
    null
}

},{"events":6,"stream":24}],49:[function(require,module,exports){
var ever = require('ever')
  , vkey = require('vkey')
  , max = Math.max

module.exports = function(el, bindings, state) {
  if(bindings === undefined || !el.ownerDocument) {
    state = bindings
    bindings = el
    el = this.document.body
  }

  var ee = ever(el)
    , measured = {}
    , enabled = true

  state = state || {}

  // always initialize the state.
  for(var key in bindings) {
    if(bindings[key] === 'enabled' ||
       bindings[key] === 'enable' ||
       bindings[key] === 'disable' ||
       bindings[key] === 'destroy') {
      throw new Error(bindings[key]+' is reserved')
    }
    state[bindings[key]] = 0
    measured[key] = 1
  }

  ee.on('keyup', wrapped(onoff(kb, false)))
  ee.on('keydown', wrapped(onoff(kb, true)))
  ee.on('mouseup', wrapped(onoff(mouse, false)))
  ee.on('mousedown', wrapped(onoff(mouse, true)))

  state.enabled = function() {
    return enabled
  }

  state.enable = enable_disable(true)
  state.disable = enable_disable(false)
  state.destroy = function() {
    ee.removeAllListeners()
  } 
  return state

  function clear() {
    // always initialize the state.
    for(var key in bindings) {
      state[bindings[key]] = 0
      measured[key] = 1
    }
  }

  function enable_disable(on_or_off) {
    return function() {
      clear()
      enabled = on_or_off
      return this
    }
  }

  function wrapped(fn) {
    return function(ev) {
      if(enabled) {
        ev.preventDefault()
        fn(ev)
      } else {
        return
      }
    }
  }

  function onoff(find, on_or_off) {
    return function(ev) {
      var key = find(ev)
        , binding = bindings[key]

      if(binding) {
        state[binding] += on_or_off ? max(measured[key]--, 0) : -(measured[key] = 1)

        if(!on_or_off && state[binding] < 0) {
          state[binding] = 0
        }
      }
    }
  }

  function mouse(ev) {
    return '<mouse '+ev.which+'>'
  }

  function kb(ev) {
    return vkey[ev.keyCode] || ev.char
  }
}

},{"ever":50,"vkey":53}],50:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./init.json":51,"./types.json":52,"dup":27,"events":6}],51:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],52:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],53:[function(require,module,exports){
var ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''
  , isOSX = /OS X/.test(ua)
  , isOpera = /Opera/.test(ua)
  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera

var i, output = module.exports = {
  0:  isOSX ? '<menu>' : '<UNK>'
, 1:  '<mouse 1>'
, 2:  '<mouse 2>'
, 3:  '<break>'
, 4:  '<mouse 3>'
, 5:  '<mouse 4>'
, 6:  '<mouse 5>'
, 8:  '<backspace>'
, 9:  '<tab>'
, 12: '<clear>'
, 13: '<enter>'
, 16: '<shift>'
, 17: '<control>'
, 18: '<alt>'
, 19: '<pause>'
, 20: '<caps-lock>'
, 21: '<ime-hangul>'
, 23: '<ime-junja>'
, 24: '<ime-final>'
, 25: '<ime-kanji>'
, 27: '<escape>'
, 28: '<ime-convert>'
, 29: '<ime-nonconvert>'
, 30: '<ime-accept>'
, 31: '<ime-mode-change>'
, 27: '<escape>'
, 32: '<space>'
, 33: '<page-up>'
, 34: '<page-down>'
, 35: '<end>'
, 36: '<home>'
, 37: '<left>'
, 38: '<up>'
, 39: '<right>'
, 40: '<down>'
, 41: '<select>'
, 42: '<print>'
, 43: '<execute>'
, 44: '<snapshot>'
, 45: '<insert>'
, 46: '<delete>'
, 47: '<help>'
, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.
, 92: '<meta>'  // meta-right
, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).
, 95: '<sleep>'
, 106: '<num-*>'
, 107: '<num-+>'
, 108: '<num-enter>'
, 109: '<num-->'
, 110: '<num-.>'
, 111: '<num-/>'
, 144: '<num-lock>'
, 145: '<scroll-lock>'
, 160: '<shift-left>'
, 161: '<shift-right>'
, 162: '<control-left>'
, 163: '<control-right>'
, 164: '<alt-left>'
, 165: '<alt-right>'
, 166: '<browser-back>'
, 167: '<browser-forward>'
, 168: '<browser-refresh>'
, 169: '<browser-stop>'
, 170: '<browser-search>'
, 171: '<browser-favorites>'
, 172: '<browser-home>'

  // ff/osx reports '<volume-mute>' for '-'
, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'
, 174: '<volume-down>'
, 175: '<volume-up>'
, 176: '<next-track>'
, 177: '<prev-track>'
, 178: '<stop>'
, 179: '<play-pause>'
, 180: '<launch-mail>'
, 181: '<launch-media-select>'
, 182: '<launch-app 1>'
, 183: '<launch-app 2>'
, 186: ';'
, 187: '='
, 188: ','
, 189: '-'
, 190: '.'
, 191: '/'
, 192: '`'
, 219: '['
, 220: '\\'
, 221: ']'
, 222: "'"
, 223: '<meta>'
, 224: '<meta>'       // firefox reports meta here.
, 226: '<alt-gr>'
, 229: '<ime-process>'
, 231: isOpera ? '`' : '<unicode>'
, 246: '<attention>'
, 247: '<crsel>'
, 248: '<exsel>'
, 249: '<erase-eof>'
, 250: '<play>'
, 251: '<zoom>'
, 252: '<no-name>'
, 253: '<pa-1>'
, 254: '<clear>'
}

for(i = 58; i < 65; ++i) {
  output[i] = String.fromCharCode(i)
}

// 0-9
for(i = 48; i < 58; ++i) {
  output[i] = (i - 48)+''
}

// A-Z
for(i = 65; i < 91; ++i) {
  output[i] = String.fromCharCode(i)
}

// num0-9
for(i = 96; i < 106; ++i) {
  output[i] = '<num-'+(i - 96)+'>'
}

// F1-F24
for(i = 112; i < 136; ++i) {
  output[i] = 'F'+(i-111)
}

},{}],54:[function(require,module,exports){
module.exports = pin

var pins = {}
  , stack_holder = {}
  , pin_holder

function make_pin_for(name, obj) {
  var container = document.createElement('div')
    , header = document.createElement('h4')
    , body = document.createElement('pre')

  container.style.background = 'white'
  container.style.marginBottom = '4px'
  container.appendChild(header)
  container.appendChild(body)
  header.textContents = header.innerText = obj && obj.repr ? obj.repr() : name
  body.style.padding = '8px'


  if(!pin_holder) {
    pin_holder = document.createElement('div')
    pin_holder.style.position = 'absolute'
    pin_holder.style.top =
    pin_holder.style.right = '4px'

    document.body.appendChild(pin_holder)
  }

  pin_holder.appendChild(container)

  return (pins[name] = pins[name] || []).push({body: body, last: -Infinity, for_object: obj}), pins[name]
}

function update_pin(item, into, retain, depth) {
  if(!retain) into.innerHTML = ''
  if(depth > 1) return
  depth = depth || 0

  switch(typeof item) {
    case 'number': into.innerText += item.toFixed(3); break
    case 'string': into.innerText += '"'+item+'"'; break
    case 'undefined':
    case 'object':
      if(item) {
        for(var key in item) if(item.hasOwnProperty(key)) {
          into.innerText += key +':'
          update_pin(item[key], into, true, depth+1)
          into.innerText += '\n'
        } 
        break
      }
    case 'boolean': into.innerText += ''+item; break
  }  
}

function pin(item, every, obj, name) {
  if(!name) Error.captureStackTrace(stack_holder)
  var location = name || stack_holder.stack.split('\n').slice(2)[0].replace(/^\s+at /g, '')
    , target = pins[location] || make_pin_for(location, obj)
    , now = Date.now()
    , every = every || 0

  if(arguments.length < 3) target = target[0]
  else {
    for(var i = 0, len = target.length; i < len; ++i) {
    if(target[i].for_object === obj) {
      target = target[i]
      break   
    }
  }
    if(i === len) {
      pins[location].push(target = make_pin_for(location, obj))
    }
  }

  if(now - target.last > every) {
    update_pin(item, target.body)
    target.last = now 
  }
}

},{}],55:[function(require,module,exports){
module.exports = raf

var EE = require('events').EventEmitter
  , global = typeof window === 'undefined' ? this : window

var _raf =
  global.requestAnimationFrame ||
  global.webkitRequestAnimationFrame ||
  global.mozRequestAnimationFrame ||
  global.msRequestAnimationFrame ||
  global.oRequestAnimationFrame ||
  (global.setImmediate ? function(fn, el) {
    setImmediate(fn)
  } :
  function(fn, el) {
    setTimeout(fn, 0)
  })

function raf(el) {
  var now = raf.now()
    , ee = new EE

  ee.pause = function() { ee.paused = true }
  ee.resume = function() { ee.paused = false }

  _raf(iter, el)

  return ee

  function iter(timestamp) {
    var _now = raf.now()
      , dt = _now - now
    
    now = _now

    ee.emit('data', dt)

    if(!ee.paused) {
      _raf(iter, el)
    }
  }
}

raf.polyfill = _raf
raf.now = function() { return Date.now() }

},{"events":6}],56:[function(require,module,exports){
module.exports = SpatialEventEmitter

var slice = [].slice
  , Tree = require('./tree')
  , aabb = require('aabb-3d')

function SpatialEventEmitter() {
  this.root = null
  this.infinites = {}
}

var cons = SpatialEventEmitter
  , proto = cons.prototype

proto.size = 16

proto.addListener = 
proto.addEventListener = 
proto.on = function(event, bbox, listener) {
  if(!finite(bbox)) {
    (this.infinites[event] = this.infinites[event] || []).push({
      bbox: bbox
    , func: listener
    })
    return this
  }

  (this.root = this.root || this.create_root(bbox))
    .add(event, bbox, listener)

  return this
}

proto.once = function(event, bbox, listener) {
  var self = this

  self.on(event, bbox, function once() {
    listener.apply(null, arguments)
    self.remove(event, once)
  })

  return self
}

proto.removeListener =
proto.removeEventListener =
proto.remove = function(event, listener) {
  if(this.root) {
    this.root.remove(event, listener)
  }

  if(!this.infinites[event]) {
    return this
  }

  for(var i = 0, len = this.infinites[event].length; i < len; ++i) {
    if(this.infinites[event][i].func === listener) {
      break
    }
  }

  if(i !== len) {
    this.infinites[event].splice(i, 1)
  }

  return this
}

proto.emit = function(event, bbox/*, ...args */) {
  var args = slice.call(arguments, 2)

  // support point emitting
  if('0' in bbox) {
    bbox = aabb(bbox, [0, 0, 0]) 
  }

  if(this.root) {
    this.root.send(event, bbox, args)
  }

  if(!this.infinites[event]) {
    return this
  }

  var list = this.infinites[event].slice()
  for(var i = 0, len = list.length; i < len; ++i) {
    if(list[i].bbox.intersects(bbox)) {
      list[i].func.apply(null, args) 
    }
  }

  return this
}

proto.rootSize = function(size) {
  proto.size = size
}

proto.create_root = function(bbox) {
  var self = this
    , size = self.size
    , base = [
        Math.floor(bbox.x0() / size) * size
      , Math.floor(bbox.y0() / size) * size
      , Math.floor(bbox.z0() / size) * size
      ]
    , tree_bbox = new bbox.constructor(base, [size, size, size])

  function OurTree(size, bbox) {
    Tree.call(this, size, bbox, null)
  }

  OurTree.prototype = Object.create(Tree.prototype)
  OurTree.prototype.constructor = OurTree
  OurTree.prototype.grow = function(new_root) {
    self.root = new_root
  }
  OurTree.prototype.min_size = size

  return new OurTree(size, tree_bbox) 
}

function finite(bbox) {
  return isFinite(bbox.x0()) &&
         isFinite(bbox.x1()) &&
         isFinite(bbox.y0()) &&
         isFinite(bbox.y1()) &&
         isFinite(bbox.z0()) &&
         isFinite(bbox.z1())
}

},{"./tree":57,"aabb-3d":36}],57:[function(require,module,exports){
module.exports = Tree

var aabb = require('aabb-3d')

function Tree(size, bbox, parent) {
  this.listeners = {}
  this.size = size
  this.bbox = bbox
  this.parent = parent
  this.children = []
}

var cons = Tree
  , proto = cons.prototype

proto.add = function(event, bbox, listener) {
  if(!this.parent && !this.contains(bbox)) {
    return this.expand(bbox).add(event, bbox, listener)
  }

  for(var i = 0, len = this.children.length; i < len; ++i) {
    if(this.children[i].contains(bbox)) {
      return this.children[i].add(event, bbox, listener)
    }
  }

  var size = this.size / 2

  if(size > this.min_size && bbox.vec[0] < size && bbox.vec[1] < size && bbox.vec[2] < size) {
    // if it fits into a child node, make that childnode
    if(Math.floor(bbox.x0() / size) === Math.floor(bbox.x1() / size) &&
       Math.floor(bbox.y0() / size) === Math.floor(bbox.y1() / size) &&
       Math.floor(bbox.z0() / size) === Math.floor(bbox.z1() / size)) {
      var inst = new this.constructor(
          size
        , aabb([
              Math.floor(bbox.x0() / size) * size
            , Math.floor(bbox.y0() / size) * size
            , Math.floor(bbox.z0() / size) * size
            ]
          , [size, size, size]
          )
        , this
      )
      this.children.push(inst)
      return inst.add(event, bbox, listener)
    }
  }

  (this.listeners[event] = this.listeners[event] || [])
    .push({bbox: bbox, func: listener})
}

proto.contains = function(bbox) {
  return bbox.x0() >= this.bbox.x0() &&
         bbox.y0() >= this.bbox.y0() &&
         bbox.z0() >= this.bbox.z0() &&
         bbox.x1() <= this.bbox.x1() &&
         bbox.y1() <= this.bbox.y1() &&
         bbox.z1() <= this.bbox.z1()
}

proto.expand = function(bbox) {
  var size = this.size
    , new_size = size * 2
    , expanded = this.bbox.expand(bbox)
    , new_i = Math.floor(bbox.x0() / size)
    , new_j = Math.floor(bbox.y0() / size)
    , new_k = Math.floor(bbox.z0() / size)
    , cur_i = Math.floor(this.bbox.x0() / size)
    , cur_j = Math.floor(this.bbox.y0() / size)
    , cur_k = Math.floor(this.bbox.z0() / size)
    , new_base = [
        new_i - cur_i >= 0 ? cur_i : cur_i - 1
      , new_j - cur_j >= 0 ? cur_j : cur_j - 1
      , new_k - cur_k >= 0 ? cur_k : cur_k - 1
      ].map(function(ii) { return ii * size })
    , new_bbox = aabb(new_base, [new_size, new_size, new_size])
    , new_root = new this.constructor(new_size, new_bbox)
    , self = this

  this.parent = new_root
  this.grow(this.parent)

  new_root.children.push(self)

  return new_root
}

proto.remove = function(event, listener) {
  var list = this.listeners[event]
  if(list) {
    for(var i = 0, len = list.length; i < len; ++i) {
      if(list[i].func === listener)
        break
    }

    if(i !== len) {
      list.splice(i, 1)
    }
  }
  for(var i = 0, len = this.children.length; i < len; ++i) {
    this.children[i].remove(event, listener)
  }
}

proto.send = function(event, bbox, args) {
  for(var i = 0, len = this.children.length; i < len; ++i) {
    if(bbox.intersects(this.children[i].bbox)) {
      this.children[i].send(event, bbox, args)
    }
  }

  var list = this.listeners[event]
  if(!list) {
    return
  }

  for(var i = 0, len = list.length; i < len; ++i) {
    if(list[i].bbox.intersects(bbox)) {
      list[i].func.apply(null, args)
    }
  }
}

},{"aabb-3d":36}],58:[function(require,module,exports){
(function (process){

var window = window || {};
var self = self || {};

// High-resulution counter: emulate window.performance.now() for THREE.CLOCK
if( window.performance === undefined ) {

	window.performance = { };

}

if( window.performance.now === undefined ) {

	window.performance.now = function () {

		var time = process.hrtime();
		return ( time[0] + time[1] / 1e9 ) * 1000;

	};

}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author Larry Battle / http://bateru.com/news
 */

var THREE = THREE || { REVISION: '56' };

self.console = self.console || {

	info: function () {},
	log: function () {},
	debug: function () {},
	warn: function () {},
	error: function () {}

};

self.Int32Array = self.Int32Array || Array;
self.Float32Array = self.Float32Array || Array;

String.prototype.trim = String.prototype.trim || function () {

	return this.replace( /^\s+|\s+$/g, '' );

};

// based on https://github.com/documentcloud/underscore/blob/bf657be243a075b5e72acc8a83e6f12a564d8f55/underscore.js#L767
THREE.extend = function ( obj, source ) {

	// ECMAScript5 compatibility based on: http://www.nczonline.net/blog/2012/12/11/are-your-mixins-ecmascript-5-compatible/
	if ( Object.keys ) {

		var keys = Object.keys( source );

		for (var i = 0, il = keys.length; i < il; i++) {

			var prop = keys[i];
			Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );

		}

	} else {

		var safeHasOwnProperty = {}.hasOwnProperty;

		for ( var prop in source ) {

			if ( safeHasOwnProperty.call( source, prop ) ) {

				obj[prop] = source[prop];

			}

		}

	}

	return obj;

};

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Mller
// fixes from Paul Irish and Tino Zijdel

( function () {

	var lastTime = 0;
	var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

	for ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++ x ) {

		window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
		window.cancelAnimationFrame = window[ vendors[ x ] + 'CancelAnimationFrame' ] || window[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

	}

	if ( window.requestAnimationFrame === undefined ) {

		window.requestAnimationFrame = function ( callback ) {

			var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
			var id = window.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );
			lastTime = currTime + timeToCall;
			return id;

		};

	}

	window.cancelAnimationFrame = window.cancelAnimationFrame || function ( id ) { window.clearTimeout( id ) };

}() );

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = function () {};

THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};

THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;

// Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;

/*
// Potential future PVRTC compressed texture formats
THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
*/
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( value ) {

	if ( value !== undefined ) this.set( value );

	return this;

};

THREE.extend( THREE.Color.prototype, {

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		switch ( typeof value ) {

			case "number":
				this.setHex( value );
				break;

			case "string":
				this.setStyle( value );
				break;

		}

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSV: function ( h, s, v ) {

		console.log( 'DEPRECATED: Color\'s .setHSV() will be removed. Use .setHSL( h, s, l ) instead.' );
		return this.setHSL(h,s*v/((h=(2-s)*v)<1?h:2-h),h/2); // https://gist.github.com/xpansive/1337890

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var hue2rgb = function ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			};

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		// rgb(255,0,0)

		if ( /^rgb\((\d+),(\d+),(\d+)\)$/i.test( style ) ) {

			var color = /^rgb\((\d+),(\d+),(\d+)\)$/i.exec( style );

			this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
			this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
			this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

			return this;

		}

		// rgb(100%,0%,0%)

		if ( /^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.test( style ) ) {

			var color = /^rgb\((\d+)\%,(\d+)\%,(\d+)\%\)$/i.exec( style );

			this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
			this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
			this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

			return this;

		}

		// #ff0000

		if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

			var color = /^\#([0-9a-f]{6})$/i.exec( style );

			this.setHex( parseInt( color[ 1 ], 16 ) );

			return this;

		}

		// #f00

		if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

			var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

			this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

			return this;

		}

		// red

		if ( /^(\w+)$/i.test( style ) ) {

			this.setHex( THREE.ColorKeywords[ style ] );

			return this;

		}


	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color ) {

		this.r = color.r * color.r;
		this.g = color.g * color.g;
		this.b = color.b * color.b;

		return this;

	},

	copyLinearToGamma: function ( color ) {

		this.r = Math.sqrt( color.r );
		this.g = Math.sqrt( color.g );
		this.b = Math.sqrt( color.b );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function () {

		var hsl = { h: 0, s: 0, l: 0 };

		return function () {

			// h,s,l ranges are in 0.0 - 1.0

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			hsl.h = hue;
			hsl.s = saturation;
			hsl.l = lightness;

			return hsl;

		};

	}(),

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	clone: function () {

		return new THREE.Color().setRGB( this.r, this.g, this.b );

	}

} );

THREE.ColorKeywords = { "aliceblue": 0xF0F8FF, "antiquewhite": 0xFAEBD7, "aqua": 0x00FFFF, "aquamarine": 0x7FFFD4, "azure": 0xF0FFFF,
"beige": 0xF5F5DC, "bisque": 0xFFE4C4, "black": 0x000000, "blanchedalmond": 0xFFEBCD, "blue": 0x0000FF, "blueviolet": 0x8A2BE2,
"brown": 0xA52A2A, "burlywood": 0xDEB887, "cadetblue": 0x5F9EA0, "chartreuse": 0x7FFF00, "chocolate": 0xD2691E, "coral": 0xFF7F50,
"cornflowerblue": 0x6495ED, "cornsilk": 0xFFF8DC, "crimson": 0xDC143C, "cyan": 0x00FFFF, "darkblue": 0x00008B, "darkcyan": 0x008B8B,
"darkgoldenrod": 0xB8860B, "darkgray": 0xA9A9A9, "darkgreen": 0x006400, "darkgrey": 0xA9A9A9, "darkkhaki": 0xBDB76B, "darkmagenta": 0x8B008B,
"darkolivegreen": 0x556B2F, "darkorange": 0xFF8C00, "darkorchid": 0x9932CC, "darkred": 0x8B0000, "darksalmon": 0xE9967A, "darkseagreen": 0x8FBC8F,
"darkslateblue": 0x483D8B, "darkslategray": 0x2F4F4F, "darkslategrey": 0x2F4F4F, "darkturquoise": 0x00CED1, "darkviolet": 0x9400D3,
"deeppink": 0xFF1493, "deepskyblue": 0x00BFFF, "dimgray": 0x696969, "dimgrey": 0x696969, "dodgerblue": 0x1E90FF, "firebrick": 0xB22222,
"floralwhite": 0xFFFAF0, "forestgreen": 0x228B22, "fuchsia": 0xFF00FF, "gainsboro": 0xDCDCDC, "ghostwhite": 0xF8F8FF, "gold": 0xFFD700,
"goldenrod": 0xDAA520, "gray": 0x808080, "green": 0x008000, "greenyellow": 0xADFF2F, "grey": 0x808080, "honeydew": 0xF0FFF0, "hotpink": 0xFF69B4,
"indianred": 0xCD5C5C, "indigo": 0x4B0082, "ivory": 0xFFFFF0, "khaki": 0xF0E68C, "lavender": 0xE6E6FA, "lavenderblush": 0xFFF0F5, "lawngreen": 0x7CFC00,
"lemonchiffon": 0xFFFACD, "lightblue": 0xADD8E6, "lightcoral": 0xF08080, "lightcyan": 0xE0FFFF, "lightgoldenrodyellow": 0xFAFAD2, "lightgray": 0xD3D3D3,
"lightgreen": 0x90EE90, "lightgrey": 0xD3D3D3, "lightpink": 0xFFB6C1, "lightsalmon": 0xFFA07A, "lightseagreen": 0x20B2AA, "lightskyblue": 0x87CEFA,
"lightslategray": 0x778899, "lightslategrey": 0x778899, "lightsteelblue": 0xB0C4DE, "lightyellow": 0xFFFFE0, "lime": 0x00FF00, "limegreen": 0x32CD32,
"linen": 0xFAF0E6, "magenta": 0xFF00FF, "maroon": 0x800000, "mediumaquamarine": 0x66CDAA, "mediumblue": 0x0000CD, "mediumorchid": 0xBA55D3,
"mediumpurple": 0x9370DB, "mediumseagreen": 0x3CB371, "mediumslateblue": 0x7B68EE, "mediumspringgreen": 0x00FA9A, "mediumturquoise": 0x48D1CC,
"mediumvioletred": 0xC71585, "midnightblue": 0x191970, "mintcream": 0xF5FFFA, "mistyrose": 0xFFE4E1, "moccasin": 0xFFE4B5, "navajowhite": 0xFFDEAD,
"navy": 0x000080, "oldlace": 0xFDF5E6, "olive": 0x808000, "olivedrab": 0x6B8E23, "orange": 0xFFA500, "orangered": 0xFF4500, "orchid": 0xDA70D6,
"palegoldenrod": 0xEEE8AA, "palegreen": 0x98FB98, "paleturquoise": 0xAFEEEE, "palevioletred": 0xDB7093, "papayawhip": 0xFFEFD5, "peachpuff": 0xFFDAB9,
"peru": 0xCD853F, "pink": 0xFFC0CB, "plum": 0xDDA0DD, "powderblue": 0xB0E0E6, "purple": 0x800080, "red": 0xFF0000, "rosybrown": 0xBC8F8F,
"royalblue": 0x4169E1, "saddlebrown": 0x8B4513, "salmon": 0xFA8072, "sandybrown": 0xF4A460, "seagreen": 0x2E8B57, "seashell": 0xFFF5EE,
"sienna": 0xA0522D, "silver": 0xC0C0C0, "skyblue": 0x87CEEB, "slateblue": 0x6A5ACD, "slategray": 0x708090, "slategrey": 0x708090, "snow": 0xFFFAFA,
"springgreen": 0x00FF7F, "steelblue": 0x4682B4, "tan": 0xD2B48C, "teal": 0x008080, "thistle": 0xD8BFD8, "tomato": 0xFF6347, "turquoise": 0x40E0D0,
"violet": 0xEE82EE, "wheat": 0xF5DEB3, "white": 0xFFFFFF, "whitesmoke": 0xF5F5F5, "yellow": 0xFFFF00, "yellowgreen": 0x9ACD32 };
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.extend( THREE.Quaternion.prototype, {

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	copy: function ( q ) {

		this.x = q.x;
		this.y = q.y;
		this.z = q.z;
		this.w = q.w;

		return this;

	},

	setFromEuler: function ( v, order ) {

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( v.x / 2 );
		var c2 = Math.cos( v.y / 2 );
		var c3 = Math.cos( v.z / 2 );
		var s1 = Math.sin( v.x / 2 );
		var s2 = Math.sin( v.y / 2 );
		var s3 = Math.sin( v.z / 2 );

		if ( order === undefined || order === 'XYZ' ) {

			this.x = s1 * c2 * c3 + c1 * s2 * s3;
			this.y = c1 * s2 * c3 - s1 * c2 * s3;
			this.z = c1 * c2 * s3 + s1 * s2 * c3;
			this.w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this.x = s1 * c2 * c3 + c1 * s2 * s3;
			this.y = c1 * s2 * c3 - s1 * c2 * s3;
			this.z = c1 * c2 * s3 - s1 * s2 * c3;
			this.w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this.x = s1 * c2 * c3 - c1 * s2 * s3;
			this.y = c1 * s2 * c3 + s1 * c2 * s3;
			this.z = c1 * c2 * s3 + s1 * s2 * c3;
			this.w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this.x = s1 * c2 * c3 - c1 * s2 * s3;
			this.y = c1 * s2 * c3 + s1 * c2 * s3;
			this.z = c1 * c2 * s3 - s1 * s2 * c3;
			this.w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this.x = s1 * c2 * c3 + c1 * s2 * s3;
			this.y = c1 * s2 * c3 + s1 * c2 * s3;
			this.z = c1 * c2 * s3 - s1 * s2 * c3;
			this.w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this.x = s1 * c2 * c3 - c1 * s2 * s3;
			this.y = c1 * s2 * c3 - s1 * c2 * s3;
			this.z = c1 * c2 * s3 + s1 * s2 * c3;
			this.w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
		// axis have to be normalized

		var halfAngle = angle / 2,
			s = Math.sin( halfAngle );

		this.x = axis.x * s;
		this.y = axis.y * s;
		this.z = axis.z * s;
		this.w = Math.cos( halfAngle );

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[0], m12 = te[4], m13 = te[8],
			m21 = te[1], m22 = te[5], m23 = te[9],
			m31 = te[2], m32 = te[6], m33 = te[10],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this.w = 0.25 / s;
			this.x = ( m32 - m23 ) * s;
			this.y = ( m13 - m31 ) * s;
			this.z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this.w = (m32 - m23 ) / s;
			this.x = 0.25 * s;
			this.y = (m12 + m21 ) / s;
			this.z = (m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this.w = (m13 - m31 ) / s;
			this.x = (m12 + m21 ) / s;
			this.y = 0.25 * s;
			this.z = (m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this.w = ( m21 - m12 ) / s;
			this.x = ( m13 + m31 ) / s;
			this.y = ( m23 + m32 ) / s;
			this.z = 0.25 * s;

		}

		return this;

	},

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this.x *= -1;
		this.y *= -1;
		this.z *= -1;

		return this;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		} else {

			l = 1 / l;

			this.x = this.x * l;
			this.y = this.y * l;
			this.z = this.z * l;
			this.w = this.w * l;

		}

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;
		var qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;

		this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		var x = this.x, y = this.y, z = this.z, w = this.w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb.w + x * qb.x + y * qb.y + z * qb.z;

		if ( cosHalfTheta < 0 ) {

			this.w = -qb.w;
			this.x = -qb.x;
			this.y = -qb.y;
			this.z = -qb.z;

			cosHalfTheta = -cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this.w = w;
			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this.w = 0.5 * ( w + this.w );
			this.x = 0.5 * ( x + this.x );
			this.y = 0.5 * ( y + this.y );
			this.z = 0.5 * ( z + this.z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this.w = ( w * ratioA + this.w * ratioB );
		this.x = ( x * ratioA + this.x * ratioB );
		this.y = ( y * ratioA + this.y * ratioB );
		this.z = ( z * ratioA + this.z * ratioB );

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	clone: function () {

		return new THREE.Quaternion( this.x, this.y, this.z, this.w );

	}

} );

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.extend( THREE.Vector2.prototype, {

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},


	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divideScalar: function ( s ) {

		if ( s !== 0 ) {

			this.x /= s;
			this.y /= s;

		} else {

			this.set( 0, 0 );

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		return this;

	},

	negate: function() {

		return this.multiplyScalar( - 1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	equals: function( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	toArray: function () {

		return [ this.x, this.y ];
		
	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	}

} );
/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.extend( THREE.Vector3.prototype, {

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;
		this.z *= s;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[3] * y + e[6] * z;
		this.y = e[1] * x + e[4] * y + e[7] * z;
		this.z = e[2] * x + e[5] * y + e[8] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8]  * z + e[12];
		this.y = e[1] * x + e[5] * y + e[9]  * z + e[13];
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide

		this.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;
		this.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;
		this.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = -qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

		return this;

	},

	applyEuler: function () {

		var q1 = new THREE.Quaternion();

		return function ( v, eulerOrder ) {

			var quaternion = q1.setFromEuler( v, eulerOrder );

			this.applyQuaternion( quaternion );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			var quaternion = q1.setFromAxisAngle( axis, angle );

			this.applyQuaternion( quaternion );

			return this;

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8]  * z;
		this.y = e[1] * x + e[5] * y + e[9]  * z;
		this.z = e[2] * x + e[6] * y + e[10] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( s ) {

		if ( s !== 0 ) {

			this.x /= s;
			this.y /= s;
			this.z /= s;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		return this;

	},

	negate: function () {

		return this.multiplyScalar( - 1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength  ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		this.x = a.y * b.z - a.z * b.y;
		this.y = a.z * b.x - a.x * b.z;
		this.z = a.x * b.y - a.y * b.x;

		return this;

	},

	projectOnVector: function () {

		var v1 = new THREE.Vector3();

		return function( vector ) {

			v1.copy( vector ).normalize();
			var d = this.dot( v1 );
			return this.copy( v1 ).multiplyScalar( d );

		};

	}(),

	projectOnPlane: function () {

		var v1 = new THREE.Vector3();

		return function( planeNormal ) {

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		var v1 = new THREE.Vector3();

		return function ( vector ) {

		    v1.copy( this ).projectOnVector( vector ).multiplyScalar( 2 );

		    return this.subVectors( v1, this );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, -1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	getPositionFromMatrix: function ( m ) {

		this.x = m.elements[12];
		this.y = m.elements[13];
		this.z = m.elements[14];

		return this;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		// clamp, to handle numerical problems

		function clamp( x ) {

			return Math.min( Math.max( x, -1 ), 1 );

		}

		var te = m.elements;
		var m11 = te[0], m12 = te[4], m13 = te[8];
		var m21 = te[1], m22 = te[5], m23 = te[9];
		var m31 = te[2], m32 = te[6], m33 = te[10];

		if ( order === undefined || order === 'XYZ' ) {

			this.y = Math.asin( clamp( m13 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this.x = Math.atan2( - m23, m33 );
				this.z = Math.atan2( - m12, m11 );

			} else {

				this.x = Math.atan2( m32, m22 );
				this.z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this.x = Math.asin( - clamp( m23 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this.y = Math.atan2( m13, m33 );
				this.z = Math.atan2( m21, m22 );

			} else {

				this.y = Math.atan2( - m31, m11 );
				this.z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this.x = Math.asin( clamp( m32 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this.y = Math.atan2( - m31, m33 );
				this.z = Math.atan2( - m12, m22 );

			} else {

				this.y = 0;
				this.z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this.y = Math.asin( - clamp( m31 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this.x = Math.atan2( m32, m33 );
				this.z = Math.atan2( m21, m11 );

			} else {

				this.x = 0;
				this.z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this.z = Math.asin( clamp( m21 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this.x = Math.atan2( - m23, m22 );
				this.y = Math.atan2( - m31, m11 );

			} else {

				this.x = 0;
				this.y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this.z = Math.asin( - clamp( m12 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this.x = Math.atan2( m32, m22 );
				this.y = Math.atan2( m13, m11 );

			} else {

				this.x = Math.atan2( - m23, m33 );
				this.y = 0;

			}

		}

		return this;

	},

	setEulerFromQuaternion: function ( q, order ) {

		// q is assumed to be normalized

		// clamp, to handle numerical problems

		function clamp( x ) {

			return Math.min( Math.max( x, -1 ), 1 );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m

		var sqx = q.x * q.x;
		var sqy = q.y * q.y;
		var sqz = q.z * q.z;
		var sqw = q.w * q.w;

		if ( order === undefined || order === 'XYZ' ) {

			this.x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
			this.y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );
			this.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order ===  'YXZ' ) {

			this.x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );
			this.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
			this.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZXY' ) {

			this.x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );
			this.y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
			this.z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZYX' ) {

			this.x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
			this.y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );
			this.z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order === 'YZX' ) {

			this.x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
			this.y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
			this.z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );

		} else if ( order === 'XZY' ) {

			this.x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
			this.y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
			this.z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );

		}

		return this;

	},

	getScaleFromMatrix: function ( m ) {

		var sx = this.set( m.elements[0], m.elements[1], m.elements[2] ).length();
		var sy = this.set( m.elements[4], m.elements[5], m.elements[6] ).length();
		var sz = this.set( m.elements[8], m.elements[9], m.elements[10] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;
	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	toArray: function () {

		return [ this.x, this.y, this.z ];
		
	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	}

} );
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.extend( THREE.Vector4.prototype, {

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;
		this.z *= s;
		this.w *= s;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
		this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
		this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

		return this;

	},

	divideScalar: function ( s ) {

		if ( s !== 0 ) {

			this.x /= s;
			this.y /= s;
			this.z /= s;
			this.w /= s;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		}

		return this;

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[0], m12 = te[4], m13 = te[8],
			m21 = te[1], m22 = te[5], m23 = te[9],
			m31 = te[2], m32 = te[6], m33 = te[10];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		  && ( Math.abs( m13 - m31 ) < epsilon )
		  && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			  && ( Math.abs( m13 + m31 ) < epsilon2 )
			  && ( Math.abs( m23 + m32 ) < epsilon2 )
			  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) { // m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else { // m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						 + ( m13 - m31 ) * ( m13 - m31 )
						 + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		if ( this.w > v.w ) {

			this.w = v.w;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		if ( this.w < v.w ) {

			this.w = v.w;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		if ( this.w < min.w ) {

			this.w = min.w;

		} else if ( this.w > max.w ) {

			this.w = max.w;

		}

		return this;

	},

	negate: function() {

		return this.multiplyScalar( -1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	toArray: function () {

		return [ this.x, this.y, this.z, this.w ];
		
	},

	clone: function () {

		return new THREE.Vector4( this.x, this.y, this.z, this.w );

	}

} );
/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );

};

THREE.extend( THREE.Box2.prototype, {

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		if ( points.length > 0 ) {

			var point = points[ 0 ];

			this.min.copy( point );
			this.max.copy( point );

			for ( var i = 1, il = points.length; i < il; i ++ ) {

				point = points[ i ];

				if ( point.x < this.min.x ) {

					this.min.x = point.x;

				} else if ( point.x > this.max.x ) {

					this.max.x = point.x;

				}

				if ( point.y < this.min.y ) {

					this.min.y = point.y;

				} else if ( point.y > this.max.y ) {

					this.max.y = point.y;

				}

			}

		} else {

			this.makeEmpty();

		}

		return this;

	},

	setFromCenterAndSize: function() {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = -Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;
	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;
	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( -scalar );
		this.max.addScalar( scalar );

		return this;
	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return new THREE.Vector2(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function() {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box2().copy( this );

	}

} );
/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );

};

THREE.extend( THREE.Box3.prototype, {

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		if ( points.length > 0 ) {

			var point = points[ 0 ];

			this.min.copy( point );
			this.max.copy( point );

			for ( var i = 1, il = points.length; i < il; i ++ ) {

				point = points[ i ];

				if ( point.x < this.min.x ) {

					this.min.x = point.x;

				} else if ( point.x > this.max.x ) {

					this.max.x = point.x;

				}

				if ( point.y < this.min.y ) {

					this.min.y = point.y;

				} else if ( point.y > this.max.y ) {

					this.max.y = point.y;

				}

				if ( point.z < this.min.z ) {

					this.min.z = point.z;

				} else if ( point.z > this.max.z ) {

					this.max.z = point.z;

				}

			}

		} else {

			this.makeEmpty();

		}

		return this;

	},

	setFromCenterAndSize: function() {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = -Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( -scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		return new THREE.Vector3(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function() {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function() {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function() {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
			];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box3().copy( this );

	}

} );
/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

	this.elements = new Float32Array(9);

	this.set(

		( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,
		n21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,
		n31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1

	);
};

THREE.extend( THREE.Matrix3.prototype, {

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[0] = n11; te[3] = n12; te[6] = n13;
		te[1] = n21; te[4] = n22; te[7] = n23;
		te[2] = n31; te[5] = n32; te[8] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[0], me[3], me[6],
			me[1], me[4], me[7],
			me[2], me[5], me[8]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function() {

		var v1 = new THREE.Vector3();

		return function ( a ) {

			for ( var i = 0, il = a.length; i < il; i += 3 ) {

				v1.x = a[ i ];
				v1.y = a[ i + 1 ];
				v1.z = a[ i + 2 ];

				v1.applyMatrix3(this);

				a[ i ]     = v1.x;
				a[ i + 1 ] = v1.y;
				a[ i + 2 ] = v1.z;

			}

			return a;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[0] *= s; te[3] *= s; te[6] *= s;
		te[1] *= s; te[4] *= s; te[7] *= s;
		te[2] *= s; te[5] *= s; te[8] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[0], b = te[1], c = te[2],
			d = te[3], e = te[4], f = te[5],
			g = te[6], h = te[7], i = te[8];

		return a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[10] * me[5] - me[6] * me[9];
		te[ 1 ] = - me[10] * me[1] + me[2] * me[9];
		te[ 2 ] =   me[6] * me[1] - me[2] * me[5];
		te[ 3 ] = - me[10] * me[4] + me[6] * me[8];
		te[ 4 ] =   me[10] * me[0] - me[2] * me[8];
		te[ 5 ] = - me[6] * me[0] + me[2] * me[4];
		te[ 6 ] =   me[9] * me[4] - me[5] * me[8];
		te[ 7 ] = - me[9] * me[0] + me[1] * me[8];
		te[ 8 ] =   me[5] * me[0] - me[1] * me[4];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg ); 

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[1]; m[1] = m[3]; m[3] = tmp;
		tmp = m[2]; m[2] = m[6]; m[6] = tmp;
		tmp = m[5]; m[5] = m[7]; m[7] = tmp;

		return this;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	clone: function () {

		var te = this.elements;

		return new THREE.Matrix3(

			te[0], te[3], te[6],
			te[1], te[4], te[7],
			te[2], te[5], te[8]

		);

	}

} );
/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 */


THREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

	var te = this.elements = new Float32Array( 16 );

	// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix
	//   we should not support semi specification of Matrix4, it is just weird.

	te[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;
	te[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;
	te[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;
	te[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;

};

THREE.extend( THREE.Matrix4.prototype, {

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
		te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
		te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
		te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[0], me[4], me[8], me[12],
			me[1], me[5], me[9], me[13],
			me[2], me[6], me[10], me[14],
			me[3], me[7], me[11], me[15]

		);

		return this;

	},

	setRotationFromEuler: function ( v, order ) {

		var te = this.elements;

		var x = v.x, y = v.y, z = v.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( order === undefined || order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[0] = c * e;
			te[4] = - c * f;
			te[8] = d;

			te[1] = af + be * d;
			te[5] = ae - bf * d;
			te[9] = - b * c;

			te[2] = bf - ae * d;
			te[6] = be + af * d;
			te[10] = a * c;

		} else if ( order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[0] = ce + df * b;
			te[4] = de * b - cf;
			te[8] = a * d;

			te[1] = a * f;
			te[5] = a * e;
			te[9] = - b;

			te[2] = cf * b - de;
			te[6] = df + ce * b;
			te[10] = a * c;

		} else if ( order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[0] = ce - df * b;
			te[4] = - a * f;
			te[8] = de + cf * b;

			te[1] = cf + de * b;
			te[5] = a * e;
			te[9] = df - ce * b;

			te[2] = - a * d;
			te[6] = b;
			te[10] = a * c;

		} else if ( order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[0] = c * e;
			te[4] = be * d - af;
			te[8] = ae * d + bf;

			te[1] = c * f;
			te[5] = bf * d + ae;
			te[9] = af * d - be;

			te[2] = - d;
			te[6] = b * c;
			te[10] = a * c;

		} else if ( order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[0] = c * e;
			te[4] = bd - ac * f;
			te[8] = bc * f + ad;

			te[1] = f;
			te[5] = a * e;
			te[9] = - b * e;

			te[2] = - d * e;
			te[6] = ad * f + bc;
			te[10] = ac - bd * f;

		} else if ( order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[0] = c * e;
			te[4] = - f;
			te[8] = d * e;

			te[1] = ac * f + bd;
			te[5] = a * e;
			te[9] = ad * f - bc;

			te[2] = bc * f - ad;
			te[6] = b * e;
			te[10] = bd * f + ac;

		}

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[0] = 1 - ( yy + zz );
		te[4] = xy - wz;
		te[8] = xz + wy;

		te[1] = xy + wz;
		te[5] = 1 - ( xx + zz );
		te[9] = yz - wx;

		te[2] = xz - wy;
		te[6] = yz + wx;
		te[10] = 1 - ( xx + yy );

		return this;

	},

	lookAt: function() {

		var x = new THREE.Vector3();
		var y = new THREE.Vector3();
		var z = new THREE.Vector3();

		return function ( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.length() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.length() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[0] = x.x; te[4] = y.x; te[8] = z.x;
			te[1] = x.y; te[5] = y.y; te[9] = z.y;
			te[2] = x.z; te[6] = y.z; te[10] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
		var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
		var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
		var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];

		var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
		var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
		var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
		var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];

		te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];
		r[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];
		r[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];
		r[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
		te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
		te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
		te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function() {

		var v1 = new THREE.Vector3();

		return function ( a ) {

			for ( var i = 0, il = a.length; i < il; i += 3 ) {

				v1.x = a[ i ];
				v1.y = a[ i + 1 ];
				v1.z = a[ i + 2 ];

				v1.applyProjection( this );

				a[ i ]     = v1.x;
				a[ i + 1 ] = v1.y;
				a[ i + 2 ] = v1.z;

			}

			return a;

		};

	}(),

	rotateAxis: function ( v ) {

		var te = this.elements;
		var vx = v.x, vy = v.y, vz = v.z;

		v.x = vx * te[0] + vy * te[4] + vz * te[8];
		v.y = vx * te[1] + vy * te[5] + vz * te[9];
		v.z = vx * te[2] + vy * te[6] + vz * te[10];

		v.normalize();

		return v;

	},

	crossVector: function ( a ) {

		var te = this.elements;
		var v = new THREE.Vector4();

		v.x = te[0] * a.x + te[4] * a.y + te[8] * a.z + te[12] * a.w;
		v.y = te[1] * a.x + te[5] * a.y + te[9] * a.z + te[13] * a.w;
		v.z = te[2] * a.x + te[6] * a.y + te[10] * a.z + te[14] * a.w;

		v.w = ( a.w ) ? te[3] * a.x + te[7] * a.y + te[11] * a.z + te[15] * a.w : 1;

		return v;

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
		var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
		var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
		var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+n14 * n23 * n32
				-n13 * n24 * n32
				-n14 * n22 * n33
				+n12 * n24 * n33
				+n13 * n22 * n34
				-n12 * n23 * n34
			) +
			n42 * (
				+n11 * n23 * n34
				-n11 * n24 * n33
				+n14 * n21 * n33
				-n13 * n21 * n34
				+n13 * n24 * n31
				-n14 * n23 * n31
			) +
			n43 * (
				+n11 * n24 * n32
				-n11 * n22 * n34
				-n14 * n21 * n32
				+n12 * n21 * n34
				+n14 * n22 * n31
				-n12 * n24 * n31
			) +
			n44 * (
				-n13 * n22 * n31
				-n11 * n23 * n32
				+n11 * n22 * n33
				+n13 * n21 * n32
				-n12 * n21 * n33
				+n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[1]; te[1] = te[4]; te[4] = tmp;
		tmp = te[2]; te[2] = te[8]; te[8] = tmp;
		tmp = te[6]; te[6] = te[9]; te[9] = tmp;

		tmp = te[3]; te[3] = te[12]; te[12] = tmp;
		tmp = te[7]; te[7] = te[13]; te[13] = tmp;
		tmp = te[11]; te[11] = te[14]; te[14] = tmp;

		return this;

	},

	flattenToArray: function ( flat ) {

		var te = this.elements;
		flat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];
		flat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];
		flat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];
		flat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];

		return flat;

	},

	flattenToArrayOffset: function( flat, offset ) {

		var te = this.elements;
		flat[ offset ] = te[0];
		flat[ offset + 1 ] = te[1];
		flat[ offset + 2 ] = te[2];
		flat[ offset + 3 ] = te[3];

		flat[ offset + 4 ] = te[4];
		flat[ offset + 5 ] = te[5];
		flat[ offset + 6 ] = te[6];
		flat[ offset + 7 ] = te[7];

		flat[ offset + 8 ]  = te[8];
		flat[ offset + 9 ]  = te[9];
		flat[ offset + 10 ] = te[10];
		flat[ offset + 11 ] = te[11];

		flat[ offset + 12 ] = te[12];
		flat[ offset + 13 ] = te[13];
		flat[ offset + 14 ] = te[14];
		flat[ offset + 15 ] = te[15];

		return flat;

	},

	getPosition: function() {

		var v1 = new THREE.Vector3();

		return function () {

			console.warn( 'DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.getPositionFromMatrix( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[12], te[13], te[14] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[12] = v.x;
		te[13] = v.y;
		te[14] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
		var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
		var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
		var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];

		te[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;
		te[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;
		te[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;
		te[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;
		te[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;
		te[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;
		te[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;
		te[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;
		te[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;
		te[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;
		te[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;
		te[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;
		te[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;
		te[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;
		te[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;
		te[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 4 ] + me[ 2 ] * te[ 8 ] + me[ 3 ] * te[ 12 ];

		if ( det == 0 ) {

			var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg ); 

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;
		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	compose: function() {

		var mRotation = new THREE.Matrix4(),
			mScale = new THREE.Matrix4();
		
		return function ( translation, rotation, scale ) {

			var te = this.elements;

			mRotation.identity();
			mRotation.setRotationFromQuaternion( rotation );

			mScale.makeScale( scale.x, scale.y, scale.z );

			this.multiplyMatrices( mRotation, mScale );

			te[12] = translation.x;
			te[13] = translation.y;
			te[14] = translation.z;

			return this;

		};

	}(),

	decompose: function() {

		var x = new THREE.Vector3(),
			y = new THREE.Vector3(),
			z = new THREE.Vector3(),
			matrix = new THREE.Matrix4();

		return function ( translation, rotation, scale ) {

			var te = this.elements;

			// grab the axis vectors
			x.set( te[0], te[1], te[2] );
			y.set( te[4], te[5], te[6] );
			z.set( te[8], te[9], te[10] );

			translation = ( translation instanceof THREE.Vector3 ) ? translation : new THREE.Vector3();
			rotation = ( rotation instanceof THREE.Quaternion ) ? rotation : new THREE.Quaternion();
			scale = ( scale instanceof THREE.Vector3 ) ? scale : new THREE.Vector3();

			scale.x = x.length();
			scale.y = y.length();
			scale.z = z.length();

			translation.x = te[12];
			translation.y = te[13];
			translation.z = te[14];

			// scale the rotation part

			matrix.copy( this );

			matrix.elements[0] /= scale.x;
			matrix.elements[1] /= scale.x;
			matrix.elements[2] /= scale.x;

			matrix.elements[4] /= scale.y;
			matrix.elements[5] /= scale.y;
			matrix.elements[6] /= scale.y;

			matrix.elements[8] /= scale.z;
			matrix.elements[9] /= scale.z;
			matrix.elements[10] /= scale.z;

			rotation.setFromRotationMatrix( matrix );

			return [ translation, rotation, scale ];

		};

	}(),

	extractPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];

		return this;

	},

	extractRotation: function() {

		var v1 = new THREE.Vector3();

		return function ( m ) {

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();
			var scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();
			var scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;

			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;

			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;

			return this;

		};

	}(),

	translate: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[12] = te[0] * x + te[4] * y + te[8] * z + te[12];
		te[13] = te[1] * x + te[5] * y + te[9] * z + te[13];
		te[14] = te[2] * x + te[6] * y + te[10] * z + te[14];
		te[15] = te[3] * x + te[7] * y + te[11] * z + te[15];

		return this;

	},

	rotateX: function ( angle ) {

		var te = this.elements;
		var m12 = te[4];
		var m22 = te[5];
		var m32 = te[6];
		var m42 = te[7];
		var m13 = te[8];
		var m23 = te[9];
		var m33 = te[10];
		var m43 = te[11];
		var c = Math.cos( angle );
		var s = Math.sin( angle );

		te[4] = c * m12 + s * m13;
		te[5] = c * m22 + s * m23;
		te[6] = c * m32 + s * m33;
		te[7] = c * m42 + s * m43;

		te[8] = c * m13 - s * m12;
		te[9] = c * m23 - s * m22;
		te[10] = c * m33 - s * m32;
		te[11] = c * m43 - s * m42;

		return this;

	},

	rotateY: function ( angle ) {

		var te = this.elements;
		var m11 = te[0];
		var m21 = te[1];
		var m31 = te[2];
		var m41 = te[3];
		var m13 = te[8];
		var m23 = te[9];
		var m33 = te[10];
		var m43 = te[11];
		var c = Math.cos( angle );
		var s = Math.sin( angle );

		te[0] = c * m11 - s * m13;
		te[1] = c * m21 - s * m23;
		te[2] = c * m31 - s * m33;
		te[3] = c * m41 - s * m43;

		te[8] = c * m13 + s * m11;
		te[9] = c * m23 + s * m21;
		te[10] = c * m33 + s * m31;
		te[11] = c * m43 + s * m41;

		return this;

	},

	rotateZ: function ( angle ) {

		var te = this.elements;
		var m11 = te[0];
		var m21 = te[1];
		var m31 = te[2];
		var m41 = te[3];
		var m12 = te[4];
		var m22 = te[5];
		var m32 = te[6];
		var m42 = te[7];
		var c = Math.cos( angle );
		var s = Math.sin( angle );

		te[0] = c * m11 + s * m12;
		te[1] = c * m21 + s * m22;
		te[2] = c * m31 + s * m32;
		te[3] = c * m41 + s * m42;

		te[4] = c * m12 - s * m11;
		te[5] = c * m22 - s * m21;
		te[6] = c * m32 - s * m31;
		te[7] = c * m42 - s * m41;

		return this;

	},

	rotateByAxis: function ( axis, angle ) {

		var te = this.elements;

		// optimize by checking axis

		if ( axis.x === 1 && axis.y === 0 && axis.z === 0 ) {

			return this.rotateX( angle );

		} else if ( axis.x === 0 && axis.y === 1 && axis.z === 0 ) {

			return this.rotateY( angle );

		} else if ( axis.x === 0 && axis.y === 0 && axis.z === 1 ) {

			return this.rotateZ( angle );

		}

		var x = axis.x, y = axis.y, z = axis.z;
		var n = Math.sqrt(x * x + y * y + z * z);

		x /= n;
		y /= n;
		z /= n;

		var xx = x * x, yy = y * y, zz = z * z;
		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var oneMinusCosine = 1 - c;
		var xy = x * y * oneMinusCosine;
		var xz = x * z * oneMinusCosine;
		var yz = y * z * oneMinusCosine;
		var xs = x * s;
		var ys = y * s;
		var zs = z * s;

		var r11 = xx + (1 - xx) * c;
		var r21 = xy + zs;
		var r31 = xz - ys;
		var r12 = xy - zs;
		var r22 = yy + (1 - yy) * c;
		var r32 = yz + xs;
		var r13 = xz + ys;
		var r23 = yz - xs;
		var r33 = zz + (1 - zz) * c;

		var m11 = te[0], m21 = te[1], m31 = te[2], m41 = te[3];
		var m12 = te[4], m22 = te[5], m32 = te[6], m42 = te[7];
		var m13 = te[8], m23 = te[9], m33 = te[10], m43 = te[11];

		te[0] = r11 * m11 + r21 * m12 + r31 * m13;
		te[1] = r11 * m21 + r21 * m22 + r31 * m23;
		te[2] = r11 * m31 + r21 * m32 + r31 * m33;
		te[3] = r11 * m41 + r21 * m42 + r31 * m43;

		te[4] = r12 * m11 + r22 * m12 + r32 * m13;
		te[5] = r12 * m21 + r22 * m22 + r32 * m23;
		te[6] = r12 * m31 + r22 * m32 + r32 * m33;
		te[7] = r12 * m41 + r22 * m42 + r32 * m43;

		te[8] = r13 * m11 + r23 * m12 + r33 * m13;
		te[9] = r13 * m21 + r23 * m22 + r33 * m23;
		te[10] = r13 * m31 + r23 * m32 + r33 * m33;
		te[11] = r13 * m41 + r23 * m42 + r33 * m43;

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[0] *= x; te[4] *= y; te[8] *= z;
		te[1] *= x; te[5] *= y; te[9] *= z;
		te[2] *= x; te[6] *= y; te[10] *= z;
		te[3] *= x; te[7] *= y; te[11] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
		var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
		var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, -s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			-s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, -s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[0] = x;	te[4] = 0;	te[8] = a;	te[12] = 0;
		te[1] = 0;	te[5] = y;	te[9] = b;	te[13] = 0;
		te[2] = 0;	te[6] = 0;	te[10] = c;	te[14] = d;
		te[3] = 0;	te[7] = 0;	te[11] = - 1;	te[15] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[0] = 2 / w;	te[4] = 0;	te[8] = 0;	te[12] = -x;
		te[1] = 0;	te[5] = 2 / h;	te[9] = 0;	te[13] = -y;
		te[2] = 0;	te[6] = 0;	te[10] = -2/p;	te[14] = -z;
		te[3] = 0;	te[7] = 0;	te[11] = 0;	te[15] = 1;

		return this;

	},

	clone: function () {

		var te = this.elements;

		return new THREE.Matrix4(

			te[0], te[4], te[8], te[12],
			te[1], te[5], te[9], te[13],
			te[2], te[6], te[10], te[14],
			te[3], te[7], te[11], te[15]

		);

	}

} );
/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.extend( THREE.Ray.prototype, {

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function() {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function() {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceTo( point );

		};

	}(),

	isIntersectionSphere: function( sphere ) {

		return ( this.distanceToPoint( sphere.center ) <= sphere.radius );

	},

	isIntersectionPlane: function ( plane ) {

		// check if the line and plane are non-perpendicular, if they
		// eventually they will intersect.
		var denominator = plane.normal.dot( this.direction );
		if ( denominator != 0 ) {

			return true;

		}

		// line is coplanar, return origin
		if( plane.distanceToPoint( this.origin ) == 0 ) {

			return true;

		}

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator == 0 ) {

			// line is coplanar, return origin
			if( plane.distanceToPoint( this.origin ) == 0 ) {

				return 0;

			}

			// Unsure if this is the correct method to handle this case.
			return undefined;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		return t;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === undefined ) {

			return undefined;
		}

		return this.at( t, optionalTarget );

	},

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );

		return this;
	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	},

	clone: function () {

		return new THREE.Ray().copy( this );

	}

} );
/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.extend( THREE.Sphere.prototype, {

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;
	},

	setFromCenterAndPoints: function ( center, points ) {

		var maxRadiusSq = 0;

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			var radiusSq = center.distanceToSquared( points[ i ] );
			maxRadiusSq = Math.max( maxRadiusSq, radiusSq );

		}

		this.center = center;
		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	},

	clone: function () {

		return new THREE.Sphere().copy( this );

	}

} );
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.extend( THREE.Frustum.prototype, {

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[0].copy( p0 );
		planes[1].copy( p1 );
		planes[2].copy( p2 );
		planes[3].copy( p3 );
		planes[4].copy( p4 );
		planes[5].copy( p5 );

		return this;

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for( var i = 0; i < 6; i ++ ) {

			planes[i].copy( frustum.planes[i] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
		var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
		var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
		var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var center = new THREE.Vector3();

		return function ( object ) {

			// this method is expanded inlined for performance reasons.

			var matrix = object.matrixWorld;
			var planes = this.planes;
			var negRadius = - object.geometry.boundingSphere.radius * matrix.getMaxScaleOnAxis();

			center.getPositionFromMatrix( matrix );

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = -sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	clone: function () {

		return new THREE.Frustum().copy( this );

	}

} );
/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.extend( THREE.Plane.prototype, {

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function() {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),


	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= -1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function() {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if( this.distanceToPoint( line.start ) == 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function() {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			optionalNormalMatrix = optionalNormalMatrix || new THREE.Matrix3().getInverse( matrix ).transpose();
			var newNormal = v1.copy( this.normal ).applyMatrix3( optionalNormalMatrix );

			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

	},

	clone: function () {

		return new THREE.Plane().copy( this );

	}

} );
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Math = {

	// Clamp value to range <a, b>

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	// Clamp value to range <a, inf)

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min )/( max - min );

		return x*x*(3 - 2*x);

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min )/( max - min );

		return x*x*x*(x*(x*6 - 15) + 10);

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	sign: function ( x ) {

		return ( x < 0 ) ? -1 : ( ( x > 0 ) ? 1 : 0 );

	},

	degToRad: function() {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function() {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}()

};
/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( !nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint != oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			linearDistance, realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

};
/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function() {

	var v0 = new THREE.Vector3();

	return function( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function() {

	var v0 = new THREE.Vector3(),
		v1 = new THREE.Vector3(),
		v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// colinear or singular triangle
		if( denom == 0 ) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( -2, -1, -1 );
		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycoordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function() {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.extend( THREE.Triangle.prototype, {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[i0] );
		this.b.copy( points[i1] );
		this.c.copy( points[i2] );

		return this;

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function() {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	},

	clone: function () {

		return new THREE.Triangle().copy( this );

	}

} );
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Vertex = function ( v ) {

	console.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')
	return v;

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.UV = function ( u, v ) {

	console.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')
	return new THREE.Vector2( u, v );

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.extend( THREE.Clock.prototype, {

	start: function () {

		this.startTime = window.performance !== undefined && window.performance.now !== undefined
					? window.performance.now()
					: Date.now();

		this.oldTime = this.startTime;
		this.running = true;
	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = window.performance !== undefined && window.performance.now !== undefined
					? window.performance.now()
					: Date.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

} );
/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {

	var listeners = {};

	this.addEventListener = function ( type, listener ) {

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	};

	this.removeEventListener = function ( type, listener ) {

		var index = listeners[ type ].indexOf( listener );

		if ( index !== - 1 ) {

			listeners[ type ].splice( index, 1 );

		}

	};

	this.dispatchEvent = function ( event ) {

		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			for ( var i = 0, l = listenerArray.length; i < l; i ++ ) {

				listenerArray[ i ].call( this, event );

			}

		}

	};

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );

		// normalized ray.direction required for accurate distance calculations
		if( this.ray.direction.lengthSq() > 0 ) {

			this.ray.direction.normalize();

		}

		this.near = near || 0;
		this.far = far || Infinity;

	};

	var sphere = new THREE.Sphere();
	var localRay = new THREE.Ray();
	var facePlane = new THREE.Plane();
	var intersectPoint = new THREE.Vector3();
	var matrixPosition = new THREE.Vector3();

	var inverseMatrix = new THREE.Matrix4();

	var descSort = function ( a, b ) {

		return a.distance - b.distance;

	};

	var intersectObject = function ( object, raycaster, intersects ) {

		if ( object instanceof THREE.Particle ) {

			matrixPosition.getPositionFromMatrix( object.matrixWorld );
			var distance = raycaster.ray.distanceToPoint( matrixPosition );

			if ( distance > object.scale.x ) {

				return intersects;

			}

			intersects.push( {

				distance: distance,
				point: object.position,
				face: null,
				object: object

			} );

		} else if ( object instanceof THREE.Mesh ) {

			// Checking boundingSphere distance to ray
			matrixPosition.getPositionFromMatrix( object.matrixWorld );
			sphere.set(
				matrixPosition,
				object.geometry.boundingSphere.radius * object.matrixWorld.getMaxScaleOnAxis() );

			if ( ! raycaster.ray.isIntersectionSphere( sphere ) ) {

				return intersects;

			}

			// Checking faces

			var geometry = object.geometry;
			var vertices = geometry.vertices;

			var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
			var objectMaterials = isFaceMaterial === true ? object.material.materials : null;

			var side = object.material.side;

			var a, b, c, d;
			var precision = raycaster.precision;

			object.matrixRotationWorld.extractRotation( object.matrixWorld );

			inverseMatrix.getInverse( object.matrixWorld );

			localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

				var face = geometry.faces[ f ];

				var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;

				if ( material === undefined ) continue;

				facePlane.setFromNormalAndCoplanarPoint( face.normal, vertices[face.a] );

				var planeDistance = localRay.distanceToPlane( facePlane );

				// bail if raycaster and plane are parallel
				if ( Math.abs( planeDistance ) < precision ) continue;

				// if negative distance, then plane is behind raycaster
				if ( planeDistance < 0 ) continue;

				// check if we hit the wrong side of a single sided face
				side = material.side;
				if( side !== THREE.DoubleSide ) {

					var planeSign = localRay.direction.dot( facePlane.normal );

					if( ! ( side === THREE.FrontSide ? planeSign < 0 : planeSign > 0 ) ) continue;

				}

				// this can be done using the planeDistance from localRay because localRay wasn't normalized, but ray was
				if ( planeDistance < raycaster.near || planeDistance > raycaster.far ) continue;

				intersectPoint = localRay.at( planeDistance, intersectPoint ); // passing in intersectPoint avoids a copy

				if ( face instanceof THREE.Face3 ) {

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];

					if ( ! THREE.Triangle.containsPoint( intersectPoint, a, b, c ) ) continue;

				} else if ( face instanceof THREE.Face4 ) {

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];
					d = vertices[ face.d ];

					if ( ( ! THREE.Triangle.containsPoint( intersectPoint, a, b, d ) ) &&
						 ( ! THREE.Triangle.containsPoint( intersectPoint, b, c, d ) ) ) continue;

				} else {

					// This is added because if we call out of this if/else group when none of the cases
					//    match it will add a point to the intersection list erroneously.
					throw Error( "face type not supported" );

				}

				intersects.push( {

					distance: planeDistance,	// this works because the original ray was normalized, and the transformed localRay wasn't
					point: raycaster.ray.at( planeDistance ),
					face: face,
					faceIndex: f,
					object: object

				} );

			}

		}

	};

	var intersectDescendants = function ( object, raycaster, intersects ) {

		var descendants = object.getDescendants();

		for ( var i = 0, l = descendants.length; i < l; i ++ ) {

			intersectObject( descendants[ i ], raycaster, intersects );

		}
	};

	//

	THREE.Raycaster.prototype.precision = 0.0001;

	THREE.Raycaster.prototype.set = function ( origin, direction ) {

		this.ray.set( origin, direction );

		// normalized ray.direction required for accurate distance calculations
		if( this.ray.direction.length() > 0 ) {

			this.ray.direction.normalize();

		}

	};

	THREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {

		var intersects = [];

		if ( recursive === true ) {

			intersectDescendants( object, this, intersects );

		}

		intersectObject( object, this, intersects );

		intersects.sort( descSort );

		return intersects;

	};

	THREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {

		var intersects = [];

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects );

			if ( recursive === true ) {

				intersectDescendants( objects[ i ], this, intersects );

			}
		}

		intersects.sort( descSort );

		return intersects;

	};

}( THREE ) );
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Object3D = function () {

	this.id = THREE.Object3DIdCount ++;

	this.name = '';
	this.properties = {};

	this.parent = undefined;
	this.children = [];

	this.up = new THREE.Vector3( 0, 1, 0 );

	this.position = new THREE.Vector3();
	this.rotation = new THREE.Vector3();
	this.eulerOrder = THREE.Object3D.defaultEulerOrder;
	this.scale = new THREE.Vector3( 1, 1, 1 );

	this.renderDepth = null;

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();
	this.matrixRotationWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = true;
	this.matrixWorldNeedsUpdate = true;

	this.quaternion = new THREE.Quaternion();
	this.useQuaternion = false;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;

	this._vector = new THREE.Vector3();

};


THREE.Object3D.prototype = {

	constructor: THREE.Object3D,

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.scale.getScaleFromMatrix( this.matrix );

		var mat = new THREE.Matrix4().extractRotation( this.matrix );
		this.rotation.setEulerFromRotationMatrix( mat, this.eulerOrder );

		this.position.getPositionFromMatrix( this.matrix );

	},

	translate: function ( distance, axis ) {

		this.matrix.rotateAxis( axis );
		this.position.add( axis.multiplyScalar( distance ) );

	},

	translateX: function ( distance ) {

		this.translate( distance, this._vector.set( 1, 0, 0 ) );

	},

	translateY: function ( distance ) {

		this.translate( distance, this._vector.set( 0, 1, 0 ) );

	},

	translateZ: function ( distance ) {

		this.translate( distance, this._vector.set( 0, 0, 1 ) );

	},

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function ( vector ) {

		return vector.applyMatrix4( THREE.Object3D.__m1.getInverse( this.matrixWorld ) );

	},

	lookAt: function ( vector ) {

		// TODO: Add hierarchy support.

		this.matrix.lookAt( vector, this.position, this.up );

		if ( this.rotationAutoUpdate ) {

			if ( this.useQuaternion === false )  {

				this.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );

			} else {

				this.quaternion.copy( this.matrix.decompose()[ 1 ] );

			}

		}

	},

	add: function ( object ) {

		if ( object === this ) {

			console.warn( 'THREE.Object3D.add: An object can\'t be added as a child of itself.' );
			return;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== undefined ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			// add to scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene )  {

				scene.__addObject( object );

			}

		}

	},

	remove: function ( object ) {

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = undefined;
			this.children.splice( index, 1 );

			// remove from scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene ) {

				scene.__removeObject( object );

			}

		}

	},

	traverse: function ( callback ) {

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverse( callback );

		}

	},

	getChildByName: function ( name, recursive ) {

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child.name === name ) {

				return child;

			}

			if ( recursive === true ) {

				child = child.getChildByName( name, recursive );

				if ( child !== undefined ) {

					return child;

				}

			}

		}

		return undefined;

	},

	getDescendants: function ( array ) {

		if ( array === undefined ) array = [];

		Array.prototype.push.apply( array, this.children );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].getDescendants( array );

		}

		return array;

	},

	updateMatrix: function () {

		this.matrix.setPosition( this.position );

		if ( this.useQuaternion === false )  {

			this.matrix.setRotationFromEuler( this.rotation, this.eulerOrder );

		} else {

			this.matrix.setRotationFromQuaternion( this.quaternion );

		}

		if ( this.scale.x !== 1 || this.scale.y !== 1 || this.scale.z !== 1 ) {

			this.matrix.scale( this.scale );

		}

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === undefined ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	clone: function ( object ) {

		if ( object === undefined ) object = new THREE.Object3D();

		object.name = this.name;

		object.up.copy( this.up );

		object.position.copy( this.position );
		if ( object.rotation instanceof THREE.Vector3 ) object.rotation.copy( this.rotation ); // because of Sprite madness
		object.eulerOrder = this.eulerOrder;
		object.scale.copy( this.scale );

		object.renderDepth = this.renderDepth;

		object.rotationAutoUpdate = this.rotationAutoUpdate;

		object.matrix.copy( this.matrix );
		object.matrixWorld.copy( this.matrixWorld );
		object.matrixRotationWorld.copy( this.matrixRotationWorld );

		object.matrixAutoUpdate = this.matrixAutoUpdate;
		object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

		object.quaternion.copy( this.quaternion );
		object.useQuaternion = this.useQuaternion;

		object.visible = this.visible;

		object.castShadow = this.castShadow;
		object.receiveShadow = this.receiveShadow;

		object.frustumCulled = this.frustumCulled;

		for ( var i = 0; i < this.children.length; i ++ ) {

			var child = this.children[ i ];
			object.add( child.clone() );

		}

		return object;

	}

};

THREE.Object3D.__m1 = new THREE.Matrix4();
THREE.Object3D.defaultEulerOrder = 'XYZ',

THREE.Object3DIdCount = 0;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */

THREE.Projector = function () {

	var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
	_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
	_face, _face3Count, _face3Pool = [], _face3PoolLength = 0,
	_face4Count, _face4Pool = [], _face4PoolLength = 0,
	_line, _lineCount, _linePool = [], _linePoolLength = 0,
	_particle, _particleCount, _particlePool = [], _particlePoolLength = 0,

	_renderData = { objects: [], sprites: [], lights: [], elements: [] },

	_vector3 = new THREE.Vector3(),
	_vector4 = new THREE.Vector4(),

	_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),
	_boundingBox = new THREE.Box3(),
	_points3 = new Array( 3 ),
	_points4 = new Array( 4 ),

	_viewMatrix = new THREE.Matrix4(),
	_viewProjectionMatrix = new THREE.Matrix4(),

	_modelMatrix,
	_modelViewProjectionMatrix = new THREE.Matrix4(),

	_normalMatrix = new THREE.Matrix3(),
	_normalViewMatrix = new THREE.Matrix3(),

	_centroid = new THREE.Vector3(),

	_frustum = new THREE.Frustum(),

	_clippedVertex1PositionScreen = new THREE.Vector4(),
	_clippedVertex2PositionScreen = new THREE.Vector4();

	this.projectVector = function ( vector, camera ) {

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );

		return vector.applyProjection( _viewProjectionMatrix );

	};

	this.unprojectVector = function ( vector, camera ) {

		camera.projectionMatrixInverse.getInverse( camera.projectionMatrix );

		_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, camera.projectionMatrixInverse );

		return vector.applyProjection( _viewProjectionMatrix );

	};

	this.pickingRay = function ( vector, camera ) {

		// set two vectors with opposing z values
		vector.z = -1.0;
		var end = new THREE.Vector3( vector.x, vector.y, 1.0 );

		this.unprojectVector( vector, camera );
		this.unprojectVector( end, camera );

		// find direction from vector to end
		end.sub( vector ).normalize();

		return new THREE.Raycaster( vector, end );

	};

	var projectGraph = function ( root, sortObjects ) {

		_objectCount = 0;

		_renderData.objects.length = 0;
		_renderData.sprites.length = 0;
		_renderData.lights.length = 0;

		var projectObject = function ( parent ) {

			for ( var c = 0, cl = parent.children.length; c < cl; c ++ ) {

				var object = parent.children[ c ];

				if ( object.visible === false ) continue;

				if ( object instanceof THREE.Light ) {

					_renderData.lights.push( object );

				} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line ) {

					if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

						_object = getNextObjectInPool();
						_object.object = object;

						if ( object.renderDepth !== null ) {

							_object.z = object.renderDepth;

						} else {

							_vector3.getPositionFromMatrix( object.matrixWorld );
							_vector3.applyProjection( _viewProjectionMatrix );
							_object.z = _vector3.z;

						}

						_renderData.objects.push( _object );

					}

				} else if ( object instanceof THREE.Sprite || object instanceof THREE.Particle ) {

					_object = getNextObjectInPool();
					_object.object = object;

					// TODO: Find an elegant and performant solution and remove this dupe code.

					if ( object.renderDepth !== null ) {

						_object.z = object.renderDepth;

					} else {

						_vector3.getPositionFromMatrix( object.matrixWorld );
						_vector3.applyProjection( _viewProjectionMatrix );
						_object.z = _vector3.z;

					}

					_renderData.sprites.push( _object );

				} else {

					_object = getNextObjectInPool();
					_object.object = object;

					if ( object.renderDepth !== null ) {

						_object.z = object.renderDepth;

					} else {

						_vector3.getPositionFromMatrix( object.matrixWorld );
						_vector3.applyProjection( _viewProjectionMatrix );
						_object.z = _vector3.z;

					}

					_renderData.objects.push( _object );

				}

				projectObject( object );

			}

		};

		projectObject( root );

		if ( sortObjects === true ) _renderData.objects.sort( painterSort );

		return _renderData;

	};

	this.projectScene = function ( scene, camera, sortObjects, sortElements ) {

		var visible = false,
		o, ol, v, vl, f, fl, n, nl, c, cl, u, ul, object,
		geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,
		v1, v2, v3, v4, isFaceMaterial, objectMaterials;

		_face3Count = 0;
		_face4Count = 0;
		_lineCount = 0;
		_particleCount = 0;

		_renderData.elements.length = 0;

		scene.updateMatrixWorld();

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );
		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

		_normalViewMatrix.getInverse( _viewMatrix );
		_normalViewMatrix.transpose();

		_frustum.setFromMatrix( _viewProjectionMatrix );

		_renderData = projectGraph( scene, sortObjects );

		for ( o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {

			object = _renderData.objects[ o ].object;

			_modelMatrix = object.matrixWorld;

			_vertexCount = 0;

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				vertices = geometry.vertices;
				faces = geometry.faces;
				faceVertexUvs = geometry.faceVertexUvs;

				_normalMatrix.getInverse( _modelMatrix );
				_normalMatrix.transpose();

				isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
				objectMaterials = isFaceMaterial === true ? object.material : null;

				for ( v = 0, vl = vertices.length; v < vl; v ++ ) {

					_vertex = getNextVertexInPool();

					_vertex.positionWorld.copy( vertices[ v ] ).applyMatrix4( _modelMatrix );
					_vertex.positionScreen.copy( _vertex.positionWorld ).applyMatrix4( _viewProjectionMatrix );

					_vertex.positionScreen.x /= _vertex.positionScreen.w;
					_vertex.positionScreen.y /= _vertex.positionScreen.w;
					_vertex.positionScreen.z /= _vertex.positionScreen.w;

					_vertex.visible = ! ( _vertex.positionScreen.x < -1 || _vertex.positionScreen.x > 1 ||
							      _vertex.positionScreen.y < -1 || _vertex.positionScreen.y > 1 ||
							      _vertex.positionScreen.z < -1 || _vertex.positionScreen.z > 1 );

				}

				for ( f = 0, fl = faces.length; f < fl; f ++ ) {

					face = faces[ f ];

					var material = isFaceMaterial === true
						? objectMaterials.materials[ face.materialIndex ]
						: object.material;

					if ( material === undefined ) continue;

					var side = material.side;

					if ( face instanceof THREE.Face3 ) {

						v1 = _vertexPool[ face.a ];
						v2 = _vertexPool[ face.b ];
						v3 = _vertexPool[ face.c ];

						_points3[ 0 ] = v1.positionScreen;
						_points3[ 1 ] = v2.positionScreen;
						_points3[ 2 ] = v3.positionScreen;

						if ( v1.visible === true || v2.visible === true || v3.visible === true ||
							_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {

							visible = ( ( v3.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -
								( v3.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;

							if ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {

								_face = getNextFace3InPool();

								_face.v1.copy( v1 );
								_face.v2.copy( v2 );
								_face.v3.copy( v3 );

							} else {

								continue;

							}

						} else {

							continue;

						}

					} else if ( face instanceof THREE.Face4 ) {

						v1 = _vertexPool[ face.a ];
						v2 = _vertexPool[ face.b ];
						v3 = _vertexPool[ face.c ];
						v4 = _vertexPool[ face.d ];

						_points4[ 0 ] = v1.positionScreen;
						_points4[ 1 ] = v2.positionScreen;
						_points4[ 2 ] = v3.positionScreen;
						_points4[ 3 ] = v4.positionScreen;

						if ( v1.visible === true || v2.visible === true || v3.visible === true || v4.visible === true ||
							_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points4 ) ) ) {

							visible = ( v4.positionScreen.x - v1.positionScreen.x ) * ( v2.positionScreen.y - v1.positionScreen.y ) -
								( v4.positionScreen.y - v1.positionScreen.y ) * ( v2.positionScreen.x - v1.positionScreen.x ) < 0 ||
								( v2.positionScreen.x - v3.positionScreen.x ) * ( v4.positionScreen.y - v3.positionScreen.y ) -
								( v2.positionScreen.y - v3.positionScreen.y ) * ( v4.positionScreen.x - v3.positionScreen.x ) < 0;


							if ( side === THREE.DoubleSide || visible === ( side === THREE.FrontSide ) ) {

								_face = getNextFace4InPool();

								_face.v1.copy( v1 );
								_face.v2.copy( v2 );
								_face.v3.copy( v3 );
								_face.v4.copy( v4 );

							} else {

								continue;

							}

						} else {

							continue;

						}

					}

					_face.normalModel.copy( face.normal );

					if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

						_face.normalModel.negate();

					}

					_face.normalModel.applyMatrix3( _normalMatrix ).normalize();

					_face.normalModelView.copy( _face.normalModel ).applyMatrix3( _normalViewMatrix );

					_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );

					faceVertexNormals = face.vertexNormals;

					for ( n = 0, nl = faceVertexNormals.length; n < nl; n ++ ) {

						var normalModel = _face.vertexNormalsModel[ n ];
						normalModel.copy( faceVertexNormals[ n ] );

						if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

							normalModel.negate();

						}

						normalModel.applyMatrix3( _normalMatrix ).normalize();

						var normalModelView = _face.vertexNormalsModelView[ n ];
						normalModelView.copy( normalModel ).applyMatrix3( _normalViewMatrix );

					}

					_face.vertexNormalsLength = faceVertexNormals.length;

					for ( c = 0, cl = faceVertexUvs.length; c < cl; c ++ ) {

						uvs = faceVertexUvs[ c ][ f ];

						if ( uvs === undefined ) continue;

						for ( u = 0, ul = uvs.length; u < ul; u ++ ) {

							_face.uvs[ c ][ u ] = uvs[ u ];

						}

					}

					_face.color = face.color;
					_face.material = material;

					_centroid.copy( _face.centroidModel ).applyProjection( _viewProjectionMatrix );

					_face.z = _centroid.z;

					_renderData.elements.push( _face );

				}

			} else if ( object instanceof THREE.Line ) {

				_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

				vertices = object.geometry.vertices;

				v1 = getNextVertexInPool();
				v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );

				// Handle LineStrip and LinePieces
				var step = object.type === THREE.LinePieces ? 2 : 1;

				for ( v = 1, vl = vertices.length; v < vl; v ++ ) {

					v1 = getNextVertexInPool();
					v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );

					if ( ( v + 1 ) % step > 0 ) continue;

					v2 = _vertexPool[ _vertexCount - 2 ];

					_clippedVertex1PositionScreen.copy( v1.positionScreen );
					_clippedVertex2PositionScreen.copy( v2.positionScreen );

					if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {

						// Perform the perspective divide
						_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
						_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

						_line = getNextLineInPool();
						_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
						_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

						_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

						_line.material = object.material;

						_renderData.elements.push( _line );

					}

				}

			}

		}

		for ( o = 0, ol = _renderData.sprites.length; o < ol; o++ ) {

			object = _renderData.sprites[ o ].object;

			_modelMatrix = object.matrixWorld;

			if ( object instanceof THREE.Particle ) {

				_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );
				_vector4.applyMatrix4( _viewProjectionMatrix );

				_vector4.z /= _vector4.w;

				if ( _vector4.z > 0 && _vector4.z < 1 ) {

					_particle = getNextParticleInPool();
					_particle.object = object;
					_particle.x = _vector4.x / _vector4.w;
					_particle.y = _vector4.y / _vector4.w;
					_particle.z = _vector4.z;

					_particle.rotation = object.rotation.z;

					_particle.scale.x = object.scale.x * Math.abs( _particle.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );
					_particle.scale.y = object.scale.y * Math.abs( _particle.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );

					_particle.material = object.material;

					_renderData.elements.push( _particle );

				}

			}

		}

		if ( sortElements === true ) _renderData.elements.sort( painterSort );

		return _renderData;

	};

	// Pools

	function getNextObjectInPool() {

		if ( _objectCount === _objectPoolLength ) {

			var object = new THREE.RenderableObject();
			_objectPool.push( object );
			_objectPoolLength ++;
			_objectCount ++;
			return object;

		}

		return _objectPool[ _objectCount ++ ];

	}

	function getNextVertexInPool() {

		if ( _vertexCount === _vertexPoolLength ) {

			var vertex = new THREE.RenderableVertex();
			_vertexPool.push( vertex );
			_vertexPoolLength ++;
			_vertexCount ++;
			return vertex;

		}

		return _vertexPool[ _vertexCount ++ ];

	}

	function getNextFace3InPool() {

		if ( _face3Count === _face3PoolLength ) {

			var face = new THREE.RenderableFace3();
			_face3Pool.push( face );
			_face3PoolLength ++;
			_face3Count ++;
			return face;

		}

		return _face3Pool[ _face3Count ++ ];


	}

	function getNextFace4InPool() {

		if ( _face4Count === _face4PoolLength ) {

			var face = new THREE.RenderableFace4();
			_face4Pool.push( face );
			_face4PoolLength ++;
			_face4Count ++;
			return face;

		}

		return _face4Pool[ _face4Count ++ ];

	}

	function getNextLineInPool() {

		if ( _lineCount === _linePoolLength ) {

			var line = new THREE.RenderableLine();
			_linePool.push( line );
			_linePoolLength ++;
			_lineCount ++
			return line;

		}

		return _linePool[ _lineCount ++ ];

	}

	function getNextParticleInPool() {

		if ( _particleCount === _particlePoolLength ) {

			var particle = new THREE.RenderableParticle();
			_particlePool.push( particle );
			_particlePoolLength ++;
			_particleCount ++
			return particle;

		}

		return _particlePool[ _particleCount ++ ];

	}

	//

	function painterSort( a, b ) {

		return b.z - a.z;

	}

	function clipLine( s1, s2 ) {

		var alpha1 = 0, alpha2 = 1,

		// Calculate the boundary coordinate of each vertex for the near and far clip planes,
		// Z = -1 and Z = +1, respectively.
		bc1near =  s1.z + s1.w,
		bc2near =  s2.z + s2.w,
		bc1far =  - s1.z + s1.w,
		bc2far =  - s2.z + s2.w;

		if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

			// Both vertices lie entirely within all clip planes.
			return true;

		} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {

			// Both vertices lie entirely outside one of the clip planes.
			return false;

		} else {

			// The line segment spans at least one clip plane.

			if ( bc1near < 0 ) {

				// v1 lies outside the near plane, v2 inside
				alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

			} else if ( bc2near < 0 ) {

				// v2 lies outside the near plane, v1 inside
				alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

			}

			if ( bc1far < 0 ) {

				// v1 lies outside the far plane, v2 inside
				alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

			} else if ( bc2far < 0 ) {

				// v2 lies outside the far plane, v2 inside
				alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

			}

			if ( alpha2 < alpha1 ) {

				// The line segment spans two boundaries, but is outside both of them.
				// (This can't happen when we're only clipping against just near/far but good
				//  to leave the check here for future usage if other clip planes are added.)
				return false;

			} else {

				// Update the s1 and s2 vertices to match the clipped line segment.
				s1.lerp( s2, alpha1 );
				s2.lerp( s1, 1 - alpha2 );

				return true;

			}

		}

	}

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [ ];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	this.centroid = new THREE.Vector3();

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		var face = new THREE.Face3( this.a, this.b, this.c );

		face.normal.copy( this.normal );
		face.color.copy( this.color );
		face.centroid.copy( this.centroid );

		face.materialIndex = this.materialIndex;

		var i, il;
		for ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();
		for ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();
		for ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

		return face;

	}

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;
	this.d = d;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [ ];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	this.centroid = new THREE.Vector3();

};

THREE.Face4.prototype = {

	constructor: THREE.Face4,

	clone: function () {

		var face = new THREE.Face4( this.a, this.b, this.c, this.d );

		face.normal.copy( this.normal );
		face.color.copy( this.color );
		face.centroid.copy( this.centroid );

		face.materialIndex = this.materialIndex;

		var i, il;
		for ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();
		for ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();
		for ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

		return face;

	}

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

	THREE.EventDispatcher.call( this );

	this.id = THREE.GeometryIdCount ++;

	this.name = '';

	this.vertices = [];
	this.colors = [];  // one-to-one vertex colors, used in ParticleSystem, Line and Ribbon
	this.normals = []; // one-to-one vertex normals, used in Ribbon

	this.faces = [];

	this.faceUvs = [[]];
	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphColors = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.tangentsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;

	this.buffersNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getInverse( matrix ).transpose();

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

			face.centroid.applyMatrix4( matrix );

		}

	},

	computeCentroids: function () {

		var f, fl, face;

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			face.centroid.set( 0, 0, 0 );

			if ( face instanceof THREE.Face3 ) {

				face.centroid.add( this.vertices[ face.a ] );
				face.centroid.add( this.vertices[ face.b ] );
				face.centroid.add( this.vertices[ face.c ] );
				face.centroid.divideScalar( 3 );

			} else if ( face instanceof THREE.Face4 ) {

				face.centroid.add( this.vertices[ face.a ] );
				face.centroid.add( this.vertices[ face.b ] );
				face.centroid.add( this.vertices[ face.c ] );
				face.centroid.add( this.vertices[ face.d ] );
				face.centroid.divideScalar( 4 );

			}

		}

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		// create internal buffers for reuse when calling this method repeatedly
		// (otherwise memory allocation / deallocation every frame is big resource hog)

		if ( this.__tmpVertices === undefined ) {

			this.__tmpVertices = new Array( this.vertices.length );
			vertices = this.__tmpVertices;

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new THREE.Vector3();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( face instanceof THREE.Face3 ) {

					face.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

				} else if ( face instanceof THREE.Face4 ) {

					face.vertexNormals = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

				}

			}

		} else {

			vertices = this.__tmpVertices;

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].set( 0, 0, 0 );

			}

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC, vD;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
				db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( face instanceof THREE.Face3 ) {

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				} else if ( face instanceof THREE.Face4 ) {

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];
					vD = this.vertices[ face.d ];

					// abd

					db.subVectors( vD, vB );
					ab.subVectors( vA, vB );
					db.cross( ab );

					vertices[ face.a ].add( db );
					vertices[ face.b ].add( db );
					vertices[ face.d ].add( db );

					// bcd

					dc.subVectors( vD, vC );
					bc.subVectors( vB, vC );
					dc.cross( bc );

					vertices[ face.b ].add( dc );
					vertices[ face.c ].add( dc );
					vertices[ face.d ].add( dc );

				}

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( face instanceof THREE.Face3 ) {

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				} else if ( face instanceof THREE.Face4 ) {

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );
					vertices[ face.d ].add( face.normal );

				}

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( face instanceof THREE.Face3 ) {

				face.vertexNormals[ 0 ].copy( vertices[ face.a ] );
				face.vertexNormals[ 1 ].copy( vertices[ face.b ] );
				face.vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else if ( face instanceof THREE.Face4 ) {

				face.vertexNormals[ 0 ].copy( vertices[ face.a ] );
				face.vertexNormals[ 1 ].copy( vertices[ face.b ] );
				face.vertexNormals[ 2 ].copy( vertices[ face.c ] );
				face.vertexNormals[ 3 ].copy( vertices[ face.d ] );

			}

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = new THREE.Vector3();

					if ( face instanceof THREE.Face3 ) {

						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					} else {

						vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3(), d: new THREE.Vector3() };

					}

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				if ( face instanceof THREE.Face3 ) {

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				} else {

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );
					vertexNormals.d.copy( face.vertexNormals[ 3 ] );

				}

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// tangents go to vertices

		var f, fl, v, vl, i, il, vertexIndex,
			face, uv, vA, vB, vC, uvA, uvB, uvC,
			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r, t, test,
			tan1 = [], tan2 = [],
			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
			n = new THREE.Vector3(), w;

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			tan1[ v ] = new THREE.Vector3();
			tan2[ v ] = new THREE.Vector3();

		}

		function handleTriangle( context, a, b, c, ua, ub, uc ) {

			vA = context.vertices[ a ];
			vB = context.vertices[ b ];
			vC = context.vertices[ c ];

			uvA = uv[ ua ];
			uvB = uv[ ub ];
			uvC = uv[ uc ];

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;
			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;
			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;
			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );
			sdir.set( ( t2 * x1 - t1 * x2 ) * r,
					  ( t2 * y1 - t1 * y2 ) * r,
					  ( t2 * z1 - t1 * z2 ) * r );
			tdir.set( ( s1 * x2 - s2 * x1 ) * r,
					  ( s1 * y2 - s2 * y1 ) * r,
					  ( s1 * z2 - s2 * z1 ) * r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

			if ( face instanceof THREE.Face3 ) {

				handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

			} else if ( face instanceof THREE.Face4 ) {

				handleTriangle( this, face.a, face.b, face.d, 0, 1, 3 );
				handleTriangle( this, face.b, face.c, face.d, 1, 2, 3 );

			}

		}

		var faceIndex = [ 'a', 'b', 'c', 'd' ];

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			for ( i = 0; i < face.vertexNormals.length; i++ ) {

				n.copy( face.vertexNormals[ i ] );

				vertexIndex = face[ faceIndex[ i ] ];

				t = tan1[ vertexIndex ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( face.vertexNormals[ i ], t );
				test = tmp2.dot( tan2[ vertexIndex ] );
				w = (test < 0.0) ? -1.0 : 1.0;

				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

			}

		}

		this.hasTangents = true;

	},

	computeLineDistances: function ( ) {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromCenterAndPoints( this.boundingSphere.center, this.vertices );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i,il, face;
		var indices, k, j, jl, u;

		// reset cache of vertices as it now will be changing.
		this.__tmpVertices = undefined;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = [ Math.round( v.x * precision ), Math.round( v.y * precision ), Math.round( v.z * precision ) ].join( '_' );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		};


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			if ( face instanceof THREE.Face3 ) {

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				var dupIndex = -1;

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
					if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

						dupIndex = n;
						faceIndicesToRemove.push( i );
						break;

					}
				}

			} else if ( face instanceof THREE.Face4 ) {

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];
				face.d = changes[ face.d ];

				// check dups in (a, b, c, d) and convert to -> face3

				indices = [ face.a, face.b, face.c, face.d ];

				var dupIndex = -1;

				for ( var n = 0; n < 4; n ++ ) {

					if ( indices[ n ] == indices[ ( n + 1 ) % 4 ] ) {

						// if more than one duplicated vertex is found
						// we can't generate any valid Face3's, thus
						// we need to remove this face complete.
						if ( dupIndex >= 0 ) {

							faceIndicesToRemove.push( i );

						}

						dupIndex = n;

					}
				}

				if ( dupIndex >= 0 ) {

					indices.splice( dupIndex, 1 );

					var newFace = new THREE.Face3( indices[0], indices[1], indices[2], face.normal, face.color, face.materialIndex );

					for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

						u = this.faceVertexUvs[ j ][ i ];

						if ( u ) {
							u.splice( dupIndex, 1 );
						}

					}

					if( face.vertexNormals && face.vertexNormals.length > 0) {

						newFace.vertexNormals = face.vertexNormals;
						newFace.vertexNormals.splice( dupIndex, 1 );

					}

					if( face.vertexColors && face.vertexColors.length > 0 ) {

						newFace.vertexColors = face.vertexColors;
						newFace.vertexColors.splice( dupIndex, 1 );
					}

					this.faces[ i ] = newFace;
				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			this.faces.splice( i, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( i, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	clone: function () {

		var geometry = new THREE.Geometry();

		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			geometry.vertices.push( vertices[ i ].clone() );

		}

		var faces = this.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			geometry.faces.push( faces[ i ].clone() );

		}

		var uvs = this.faceVertexUvs[ 0 ];

		for ( var i = 0, il = uvs.length; i < il; i ++ ) {

			var uv = uvs[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			geometry.faceVertexUvs[ 0 ].push( uvCopy );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.GeometryIdCount = 0;
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.BufferGeometry = function () {

	THREE.EventDispatcher.call( this );

	this.id = THREE.GeometryIdCount ++;

	// attributes

	this.attributes = {};

	// attributes typed arrays are kept only if dynamic flag is set

	this.dynamic = false;

	// offsets for chunks when using indexed elements

	this.offsets = [];

	// boundings

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	// for compatibility

	this.morphTargets = [];

};

THREE.BufferGeometry.prototype = {

	constructor : THREE.BufferGeometry,

	applyMatrix: function ( matrix ) {

		var positionArray;
		var normalArray;

		if ( this.attributes[ "position" ] ) positionArray = this.attributes[ "position" ].array;
		if ( this.attributes[ "normal" ] ) normalArray = this.attributes[ "normal" ].array;

		if ( positionArray !== undefined ) {

			matrix.multiplyVector3Array( positionArray );
			this.verticesNeedUpdate = true;

		}

		if ( normalArray !== undefined ) {

			var normalMatrix = new THREE.Matrix3();
			normalMatrix.getInverse( matrix ).transpose();

			normalMatrix.multiplyVector3Array( normalArray );

			this.normalizeNormals();

			this.normalsNeedUpdate = true;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		var positions = this.attributes[ "position" ].array;

		if ( positions ) {

			var bb = this.boundingBox;
			var x, y, z;

			if( positions.length >= 3 ) {
				bb.min.x = bb.max.x = positions[ 0 ];
				bb.min.y = bb.max.y = positions[ 1 ];
				bb.min.z = bb.max.z = positions[ 2 ];
			}

			for ( var i = 3, il = positions.length; i < il; i += 3 ) {

				x = positions[ i ];
				y = positions[ i + 1 ];
				z = positions[ i + 2 ];

				// bounding box

				if ( x < bb.min.x ) {

					bb.min.x = x;

				} else if ( x > bb.max.x ) {

					bb.max.x = x;

				}

				if ( y < bb.min.y ) {

					bb.min.y = y;

				} else if ( y > bb.max.y ) {

					bb.max.y = y;

				}

				if ( z < bb.min.z ) {

					bb.min.z = z;

				} else if ( z > bb.max.z ) {

					bb.max.z = z;

				}

			}

		}

		if ( positions === undefined || positions.length === 0 ) {

			this.boundingBox.min.set( 0, 0, 0 );
			this.boundingBox.max.set( 0, 0, 0 );

		}

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		var positions = this.attributes[ "position" ].array;

		if ( positions ) {

			var radiusSq, maxRadiusSq = 0;
			var x, y, z;

			for ( var i = 0, il = positions.length; i < il; i += 3 ) {

				x = positions[ i ];
				y = positions[ i + 1 ];
				z = positions[ i + 2 ];

				radiusSq =  x * x + y * y + z * z;
				if ( radiusSq > maxRadiusSq ) maxRadiusSq = radiusSq;

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

		}

	},

	computeVertexNormals: function () {

		if ( this.attributes[ "position" ] ) {

			var i, il;
			var j, jl;

			var nVertexElements = this.attributes[ "position" ].array.length;

			if ( this.attributes[ "normal" ] === undefined ) {

				this.attributes[ "normal" ] = {

					itemSize: 3,
					array: new Float32Array( nVertexElements ),
					numItems: nVertexElements

				};

			} else {

				// reset existing normals to zero

				for ( i = 0, il = this.attributes[ "normal" ].array.length; i < il; i ++ ) {

					this.attributes[ "normal" ].array[ i ] = 0;

				}

			}

			var positions = this.attributes[ "position" ].array;
			var normals = this.attributes[ "normal" ].array;

			var vA, vB, vC, x, y, z,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( this.attributes[ "index" ] ) {

				var indices = this.attributes[ "index" ].array;

				var offsets = this.offsets;

				for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

					var start = offsets[ j ].start;
					var count = offsets[ j ].count;
					var index = offsets[ j ].index;

					for ( i = start, il = start + count; i < il; i += 3 ) {

						vA = index + indices[ i ];
						vB = index + indices[ i + 1 ];
						vC = index + indices[ i + 2 ];

						x = positions[ vA * 3 ];
						y = positions[ vA * 3 + 1 ];
						z = positions[ vA * 3 + 2 ];
						pA.set( x, y, z );

						x = positions[ vB * 3 ];
						y = positions[ vB * 3 + 1 ];
						z = positions[ vB * 3 + 2 ];
						pB.set( x, y, z );

						x = positions[ vC * 3 ];
						y = positions[ vC * 3 + 1 ];
						z = positions[ vC * 3 + 2 ];
						pC.set( x, y, z );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA * 3 ]     += cb.x;
						normals[ vA * 3 + 1 ] += cb.y;
						normals[ vA * 3 + 2 ] += cb.z;

						normals[ vB * 3 ]     += cb.x;
						normals[ vB * 3 + 1 ] += cb.y;
						normals[ vB * 3 + 2 ] += cb.z;

						normals[ vC * 3 ]     += cb.x;
						normals[ vC * 3 + 1 ] += cb.y;
						normals[ vC * 3 + 2 ] += cb.z;

					}

				}

			// non-indexed elements (unconnected triangle soup)

			} else {

				for ( i = 0, il = positions.length; i < il; i += 9 ) {

					x = positions[ i ];
					y = positions[ i + 1 ];
					z = positions[ i + 2 ];
					pA.set( x, y, z );

					x = positions[ i + 3 ];
					y = positions[ i + 4 ];
					z = positions[ i + 5 ];
					pB.set( x, y, z );

					x = positions[ i + 6 ];
					y = positions[ i + 7 ];
					z = positions[ i + 8 ];
					pC.set( x, y, z );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] 	 = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			this.normalsNeedUpdate = true;

		}

	},

	normalizeNormals: function () {

		var normals = this.attributes[ "normal" ].array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i ] 	 *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( this.attributes[ "index" ] === undefined ||
			 this.attributes[ "position" ] === undefined ||
			 this.attributes[ "normal" ] === undefined ||
			 this.attributes[ "uv" ] === undefined ) {

			console.warn( "Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()" );
			return;

		}

		var indices = this.attributes[ "index" ].array;
		var positions = this.attributes[ "position" ].array;
		var normals = this.attributes[ "normal" ].array;
		var uvs = this.attributes[ "uv" ].array;

		var nVertices = positions.length / 3;

		if ( this.attributes[ "tangent" ] === undefined ) {

			var nTangentElements = 4 * nVertices;

			this.attributes[ "tangent" ] = {

				itemSize: 4,
				array: new Float32Array( nTangentElements ),
				numItems: nTangentElements

			};

		}

		var tangents = this.attributes[ "tangent" ].array;

		var tan1 = [], tan2 = [];

		for ( var k = 0; k < nVertices; k ++ ) {

			tan1[ k ] = new THREE.Vector3();
			tan2[ k ] = new THREE.Vector3();

		}

		var xA, yA, zA,
			xB, yB, zB,
			xC, yC, zC,

			uA, vA,
			uB, vB,
			uC, vC,

			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r;

		var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

		function handleTriangle( a, b, c ) {

			xA = positions[ a * 3 ];
			yA = positions[ a * 3 + 1 ];
			zA = positions[ a * 3 + 2 ];

			xB = positions[ b * 3 ];
			yB = positions[ b * 3 + 1 ];
			zB = positions[ b * 3 + 2 ];

			xC = positions[ c * 3 ];
			yC = positions[ c * 3 + 1 ];
			zC = positions[ c * 3 + 2 ];

			uA = uvs[ a * 2 ];
			vA = uvs[ a * 2 + 1 ];

			uB = uvs[ b * 2 ];
			vB = uvs[ b * 2 + 1 ];

			uC = uvs[ c * 2 ];
			vC = uvs[ c * 2 + 1 ];

			x1 = xB - xA;
			x2 = xC - xA;

			y1 = yB - yA;
			y2 = yC - yA;

			z1 = zB - zA;
			z2 = zC - zA;

			s1 = uB - uA;
			s2 = uC - uA;

			t1 = vB - vA;
			t2 = vC - vA;

			r = 1.0 / ( s1 * t2 - s2 * t1 );

			sdir.set(
				( t2 * x1 - t1 * x2 ) * r,
				( t2 * y1 - t1 * y2 ) * r,
				( t2 * z1 - t1 * z2 ) * r
			);

			tdir.set(
				( s1 * x2 - s2 * x1 ) * r,
				( s1 * y2 - s2 * y1 ) * r,
				( s1 * z2 - s2 * z1 ) * r
			);

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		var i, il;
		var j, jl;
		var iA, iB, iC;

		var offsets = this.offsets;

		for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

			var start = offsets[ j ].start;
			var count = offsets[ j ].count;
			var index = offsets[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleTriangle( iA, iB, iC );

			}

		}

		var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
		var n = new THREE.Vector3(), n2 = new THREE.Vector3();
		var w, t, test;

		function handleVertex( v ) {

			n.x = normals[ v * 3 ];
			n.y = normals[ v * 3 + 1 ];
			n.z = normals[ v * 3 + 2 ];

			n2.copy( n );

			t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			test = tmp2.dot( tan2[ v ] );
			w = ( test < 0.0 ) ? -1.0 : 1.0;

			tangents[ v * 4 ] 	  = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

			var start = offsets[ j ].start;
			var count = offsets[ j ].count;
			var index = offsets[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleVertex( iA );
				handleVertex( iB );
				handleVertex( iC );

			}

		}

		this.hasTangents = true;
		this.tangentsNeedUpdate = true;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.matrixWorldInverse = new THREE.Matrix4();

	this.projectionMatrix = new THREE.Matrix4();
	this.projectionMatrixInverse = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );

THREE.Camera.prototype.lookAt = function ( vector ) {

	// TODO: Add hierarchy support.

	this.matrix.lookAt( this.position, vector, this.up );

	if ( this.rotationAutoUpdate === true ) {

		if ( this.useQuaternion === false )  {

			this.rotation.setEulerFromRotationMatrix( this.matrix, this.eulerOrder );

		} else {

			this.quaternion.copy( this.matrix.decompose()[ 1 ] );

		}

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	this.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;
		var bottom = -top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );

	}

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
 
THREE.Light = function ( hex ) {

	THREE.Object3D.call( this );

	this.color = new THREE.Color( hex );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( hex ) {

	THREE.Light.call( this, hex );

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );
/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( hex, intensity ) {

	THREE.Light.call( this, hex );

	this.normal = new THREE.Vector3( 0, -1, 0 );
	this.right = new THREE.Vector3( 1, 0, 0 );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.width = 1.0;
	this.height = 1.0;

	this.constantAttenuation = 1.5;
	this.linearAttenuation = 0.5;
	this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( hex, intensity ) {

	THREE.Light.call( this, hex );

	this.position = new THREE.Vector3( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;

	this.shadowCameraLeft = -500;
	this.shadowCameraRight = 500;
	this.shadowCameraTop = 500;
	this.shadowCameraBottom = -500;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowCascade = false;

	this.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );
	this.shadowCascadeCount = 2;

	this.shadowCascadeBias = [ 0, 0, 0 ];
	this.shadowCascadeWidth = [ 512, 512, 512 ];
	this.shadowCascadeHeight = [ 512, 512, 512 ];

	this.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];
	this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

	this.shadowCascadeArray = [];

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColorHex, groundColorHex, intensity ) {

	THREE.Light.call( this, skyColorHex );

	this.groundColor = new THREE.Color( groundColorHex );

	this.position = new THREE.Vector3( 0, 100, 0 );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( hex, intensity, distance ) {

	THREE.Light.call( this, hex );

	this.position = new THREE.Vector3( 0, 0, 0 );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( hex, intensity, distance, angle, exponent ) {

	THREE.Light.call( this, hex );

	this.position = new THREE.Vector3( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 2;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;
	this.shadowCameraFov = 50;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

	this.showStatus = showStatus;
	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: 'anonymous',

	addStatusElement: function () {

		var e = document.createElement( "div" );

		e.style.position = "absolute";
		e.style.right = "0px";
		e.style.top = "0px";
		e.style.fontSize = "0.8em";
		e.style.textAlign = "left";
		e.style.background = "rgba(0,0,0,0.25)";
		e.style.color = "#fff";
		e.style.width = "120px";
		e.style.padding = "0.5em 0.5em 0.5em 0.5em";
		e.style.zIndex = 1000;

		e.innerHTML = "Loading ...";

		return e;

	},

	updateProgress: function ( progress ) {

		var message = "Loaded ";

		if ( progress.total ) {

			message += ( 100 * progress.loaded / progress.total ).toFixed(0) + "%";


		} else {

			message += ( progress.loaded / 1000 ).toFixed(2) + " KB";

		}

		this.statusDomElement.innerHTML = message;

	},

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );
		parts.pop();
		return ( parts.length < 1 ? '.' : parts.join( '/' ) ) + '/';

	},

	initMaterials: function ( materials, texturePath ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );

		}

		return array;

	},

	needsTangents: function ( materials ) {

		for( var i = 0, il = materials.length; i < il; i ++ ) {

			var m = materials[ i ];

			if ( m instanceof THREE.ShaderMaterial ) return true;

		}

		return false;

	},

	createMaterial: function ( m, texturePath ) {

		var _this = this;

		function is_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.floor( l ) == l;

		}

		function nearest_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.pow( 2, Math.round(  l ) );

		}

		function load_image( where, url ) {

			var image = new Image();

			image.onload = function () {

				if ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {

					var width = nearest_pow2( this.width );
					var height = nearest_pow2( this.height );

					where.image.width = width;
					where.image.height = height;
					where.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );

				} else {

					where.image = this;

				}

				where.needsUpdate = true;

			};

			image.crossOrigin = _this.crossOrigin;
			image.src = url;

		}

		function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

			var isCompressed = /\.dds$/i.test( sourceFile );
			var fullPath = texturePath + "/" + sourceFile;

			if ( isCompressed ) {

				var texture = THREE.ImageUtils.loadCompressedTexture( fullPath );

				where[ name ] = texture;

			} else {

				var texture = document.createElement( 'canvas' );

				where[ name ] = new THREE.Texture( texture );

			}

			where[ name ].sourceFile = sourceFile;

			if( repeat ) {

				where[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );

				if ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;

			}

			if ( offset ) {

				where[ name ].offset.set( offset[ 0 ], offset[ 1 ] );

			}

			if ( wrap ) {

				var wrapMap = {
					"repeat": THREE.RepeatWrapping,
					"mirror": THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];
				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];

			}

			if ( anisotropy ) {

				where[ name ].anisotropy = anisotropy;

			}

			if ( ! isCompressed ) {

				load_image( where[ name ], fullPath );

			}

		}

		function rgb2hex( rgb ) {

			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

		}

		// defaults

		var mtype = "MeshLambertMaterial";
		var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

		// parameters from model file

		if ( m.shading ) {

			var shading = m.shading.toLowerCase();

			if ( shading === "phong" ) mtype = "MeshPhongMaterial";
			else if ( shading === "basic" ) mtype = "MeshBasicMaterial";

		}

		if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

			mpars.blending = THREE[ m.blending ];

		}

		if ( m.transparent !== undefined || m.opacity < 1.0 ) {

			mpars.transparent = m.transparent;

		}

		if ( m.depthTest !== undefined ) {

			mpars.depthTest = m.depthTest;

		}

		if ( m.depthWrite !== undefined ) {

			mpars.depthWrite = m.depthWrite;

		}

		if ( m.visible !== undefined ) {

			mpars.visible = m.visible;

		}

		if ( m.flipSided !== undefined ) {

			mpars.side = THREE.BackSide;

		}

		if ( m.doubleSided !== undefined ) {

			mpars.side = THREE.DoubleSide;

		}

		if ( m.wireframe !== undefined ) {

			mpars.wireframe = m.wireframe;

		}

		if ( m.vertexColors !== undefined ) {

			if ( m.vertexColors === "face" ) {

				mpars.vertexColors = THREE.FaceColors;

			} else if ( m.vertexColors ) {

				mpars.vertexColors = THREE.VertexColors;

			}

		}

		// colors

		if ( m.colorDiffuse ) {

			mpars.color = rgb2hex( m.colorDiffuse );

		} else if ( m.DbgColor ) {

			mpars.color = m.DbgColor;

		}

		if ( m.colorSpecular ) {

			mpars.specular = rgb2hex( m.colorSpecular );

		}

		if ( m.colorAmbient ) {

			mpars.ambient = rgb2hex( m.colorAmbient );

		}

		// modifiers

		if ( m.transparency ) {

			mpars.opacity = m.transparency;

		}

		if ( m.specularCoef ) {

			mpars.shininess = m.specularCoef;

		}

		// textures

		if ( m.mapDiffuse && texturePath ) {

			create_texture( mpars, "map", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

		}

		if ( m.mapLight && texturePath ) {

			create_texture( mpars, "lightMap", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

		}

		if ( m.mapBump && texturePath ) {

			create_texture( mpars, "bumpMap", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

		}

		if ( m.mapNormal && texturePath ) {

			create_texture( mpars, "normalMap", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

		}

		if ( m.mapSpecular && texturePath ) {

			create_texture( mpars, "specularMap", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

		}

		//

		if ( m.mapBumpScale ) {

			mpars.bumpScale = m.mapBumpScale;

		}

		// special case for normal mapped material

		if ( m.mapNormal ) {

			var shader = THREE.ShaderLib[ "normalmap" ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			uniforms[ "tNormal" ].value = mpars.normalMap;

			if ( m.mapNormalFactor ) {

				uniforms[ "uNormalScale" ].value.set( m.mapNormalFactor, m.mapNormalFactor );

			}

			if ( mpars.map ) {

				uniforms[ "tDiffuse" ].value = mpars.map;
				uniforms[ "enableDiffuse" ].value = true;

			}

			if ( mpars.specularMap ) {

				uniforms[ "tSpecular" ].value = mpars.specularMap;
				uniforms[ "enableSpecular" ].value = true;

			}

			if ( mpars.lightMap ) {

				uniforms[ "tAO" ].value = mpars.lightMap;
				uniforms[ "enableAO" ].value = true;

			}

			// for the moment don't handle displacement texture

			uniforms[ "uDiffuseColor" ].value.setHex( mpars.color );
			uniforms[ "uSpecularColor" ].value.setHex( mpars.specular );
			uniforms[ "uAmbientColor" ].value.setHex( mpars.ambient );

			uniforms[ "uShininess" ].value = mpars.shininess;

			if ( mpars.opacity !== undefined ) {

				uniforms[ "uOpacity" ].value = mpars.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
			var material = new THREE.ShaderMaterial( parameters );

			if ( mpars.transparent ) {

				material.transparent = true;

			}

		} else {

			var material = new THREE[ mtype ]( mpars );

		}

		if ( m.DbgName !== undefined ) material.name = m.DbgName;

		return material;

	}

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function () {

	THREE.EventDispatcher.call( this );

	this.crossOrigin = null;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, image ) {

		var scope = this;

		if ( image === undefined ) image = new Image();

		image.addEventListener( 'load', function () {

			scope.dispatchEvent( { type: 'load', content: image } );

		}, false );

		image.addEventListener( 'error', function () {

			scope.dispatchEvent( { type: 'error', message: 'Couldn\'t load URL [' + url + ']' } );

		}, false );

		if ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;

		image.src = url;

	}

}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

	var scope = this;

	// todo: unify load API to for easier SceneLoader use

	texturePath = texturePath && ( typeof texturePath === "string" ) ? texturePath : this.extractUrlBase( url );

	this.onLoadStart();
	this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	var length = 0;

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === xhr.DONE ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				if ( xhr.responseText ) {

					var json = JSON.parse( xhr.responseText );
					context.createModel( json, callback, texturePath );

				} else {

					console.warn( "THREE.JSONLoader: [" + url + "] seems to be unreachable or file there is empty" );

				}

				// in context of more complex asset initialization
				// do not block on single failed file
				// maybe should go even one more level up

				context.onLoadComplete();

			} else {

				console.error( "THREE.JSONLoader: Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		} else if ( xhr.readyState === xhr.LOADING ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( "Content-Length" );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

			length = xhr.getResponseHeader( "Content-Length" );

		}

	};

	xhr.open( "GET", url, true );
	xhr.withCredentials = this.withCredentials;
	xhr.send( null );

};

THREE.JSONLoader.prototype.createModel = function ( json, callback, texturePath ) {

	var scope = this,
	geometry = new THREE.Geometry(),
	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

	parseModel( scale );

	parseSkin();
	parseMorphing( scale );

	geometry.computeCentroids();
	geometry.computeFaceNormals();

	function parseModel( scale ) {

		function isBitSet( value, position ) {

			return value & ( 1 << position );

		}

		var i, j, fi,

		offset, zLength, nVertices,

		colorIndex, normalIndex, uvIndex, materialIndex,

		type,
		isQuad,
		hasMaterial,
		hasFaceUv, hasFaceVertexUv,
		hasFaceNormal, hasFaceVertexNormal,
		hasFaceColor, hasFaceVertexColor,

		vertex, face, color, normal,

		uvLayer, uvs, u, v,

		faces = json.faces,
		vertices = json.vertices,
		normals = json.normals,
		colors = json.colors,

		nUvLayers = 0;

		// disregard empty arrays

		for ( i = 0; i < json.uvs.length; i++ ) {

			if ( json.uvs[ i ].length ) nUvLayers ++;

		}

		for ( i = 0; i < nUvLayers; i++ ) {

			geometry.faceUvs[ i ] = [];
			geometry.faceVertexUvs[ i ] = [];

		}

		offset = 0;
		zLength = vertices.length;

		while ( offset < zLength ) {

			vertex = new THREE.Vector3();

			vertex.x = vertices[ offset ++ ] * scale;
			vertex.y = vertices[ offset ++ ] * scale;
			vertex.z = vertices[ offset ++ ] * scale;

			geometry.vertices.push( vertex );

		}

		offset = 0;
		zLength = faces.length;

		while ( offset < zLength ) {

			type = faces[ offset ++ ];


			isQuad          	= isBitSet( type, 0 );
			hasMaterial         = isBitSet( type, 1 );
			hasFaceUv           = isBitSet( type, 2 );
			hasFaceVertexUv     = isBitSet( type, 3 );
			hasFaceNormal       = isBitSet( type, 4 );
			hasFaceVertexNormal = isBitSet( type, 5 );
			hasFaceColor	    = isBitSet( type, 6 );
			hasFaceVertexColor  = isBitSet( type, 7 );

			//console.log("type", type, "bits", isQuad, hasMaterial, hasFaceUv, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

			if ( isQuad ) {

				face = new THREE.Face4();

				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];
				face.d = faces[ offset ++ ];

				nVertices = 4;

			} else {

				face = new THREE.Face3();

				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];

				nVertices = 3;

			}

			if ( hasMaterial ) {

				materialIndex = faces[ offset ++ ];
				face.materialIndex = materialIndex;

			}

			// to get face <=> uv index correspondence

			fi = geometry.faces.length;

			if ( hasFaceUv ) {

				for ( i = 0; i < nUvLayers; i++ ) {

					uvLayer = json.uvs[ i ];

					uvIndex = faces[ offset ++ ];

					u = uvLayer[ uvIndex * 2 ];
					v = uvLayer[ uvIndex * 2 + 1 ];

					geometry.faceUvs[ i ][ fi ] = new THREE.Vector2( u, v );

				}

			}

			if ( hasFaceVertexUv ) {

				for ( i = 0; i < nUvLayers; i++ ) {

					uvLayer = json.uvs[ i ];

					uvs = [];

					for ( j = 0; j < nVertices; j ++ ) {

						uvIndex = faces[ offset ++ ];

						u = uvLayer[ uvIndex * 2 ];
						v = uvLayer[ uvIndex * 2 + 1 ];

						uvs[ j ] = new THREE.Vector2( u, v );

					}

					geometry.faceVertexUvs[ i ][ fi ] = uvs;

				}

			}

			if ( hasFaceNormal ) {

				normalIndex = faces[ offset ++ ] * 3;

				normal = new THREE.Vector3();

				normal.x = normals[ normalIndex ++ ];
				normal.y = normals[ normalIndex ++ ];
				normal.z = normals[ normalIndex ];

				face.normal = normal;

			}

			if ( hasFaceVertexNormal ) {

				for ( i = 0; i < nVertices; i++ ) {

					normalIndex = faces[ offset ++ ] * 3;

					normal = new THREE.Vector3();

					normal.x = normals[ normalIndex ++ ];
					normal.y = normals[ normalIndex ++ ];
					normal.z = normals[ normalIndex ];

					face.vertexNormals.push( normal );

				}

			}


			if ( hasFaceColor ) {

				colorIndex = faces[ offset ++ ];

				color = new THREE.Color( colors[ colorIndex ] );
				face.color = color;

			}


			if ( hasFaceVertexColor ) {

				for ( i = 0; i < nVertices; i++ ) {

					colorIndex = faces[ offset ++ ];

					color = new THREE.Color( colors[ colorIndex ] );
					face.vertexColors.push( color );

				}

			}

			geometry.faces.push( face );

		}

	};

	function parseSkin() {

		var i, l, x, y, z, w, a, b, c, d;

		if ( json.skinWeights ) {

			for ( i = 0, l = json.skinWeights.length; i < l; i += 2 ) {

				x = json.skinWeights[ i     ];
				y = json.skinWeights[ i + 1 ];
				z = 0;
				w = 0;

				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

			}

		}

		if ( json.skinIndices ) {

			for ( i = 0, l = json.skinIndices.length; i < l; i += 2 ) {

				a = json.skinIndices[ i     ];
				b = json.skinIndices[ i + 1 ];
				c = 0;
				d = 0;

				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

			}

		}

		geometry.bones = json.bones;
		geometry.animation = json.animation;

	};

	function parseMorphing( scale ) {

		if ( json.morphTargets !== undefined ) {

			var i, l, v, vl, dstVertices, srcVertices;

			for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

				geometry.morphTargets[ i ] = {};
				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
				geometry.morphTargets[ i ].vertices = [];

				dstVertices = geometry.morphTargets[ i ].vertices;
				srcVertices = json.morphTargets [ i ].vertices;

				for( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

					var vertex = new THREE.Vector3();
					vertex.x = srcVertices[ v ] * scale;
					vertex.y = srcVertices[ v + 1 ] * scale;
					vertex.z = srcVertices[ v + 2 ] * scale;

					dstVertices.push( vertex );

				}

			}

		}

		if ( json.morphColors !== undefined ) {

			var i, l, c, cl, dstColors, srcColors, color;

			for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

				geometry.morphColors[ i ] = {};
				geometry.morphColors[ i ].name = json.morphColors[ i ].name;
				geometry.morphColors[ i ].colors = [];

				dstColors = geometry.morphColors[ i ].colors;
				srcColors = json.morphColors [ i ].colors;

				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

					color = new THREE.Color( 0xffaa00 );
					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
					dstColors.push( color );

				}

			}

		}

	};

	var materials = this.initMaterials( json.materials, texturePath );

	if ( this.needsTangents( materials ) ) geometry.computeTangents();

	callback( geometry, materials );

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingMonitor = function () {

	THREE.EventDispatcher.call( this );

	var scope = this;

	var loaded = 0;
	var total = 0;

	var onLoad = function ( event ) {

		loaded ++;

		scope.dispatchEvent( { type: 'progress', loaded: loaded, total: total } );

		if ( loaded === total ) {

			scope.dispatchEvent( { type: 'load' } );

		}

	};

	this.add = function ( loader ) {

		total ++;

		loader.addEventListener( 'load', onLoad, false );

	};

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneLoader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function() {};
	this.onLoadComplete = function () {};

	this.callbackSync = function () {};
	this.callbackProgress = function () {};

	this.geometryHandlerMap = {};
	this.hierarchyHandlerMap = {};

	this.addGeometryHandler( "ascii", THREE.JSONLoader );

};

THREE.SceneLoader.prototype.constructor = THREE.SceneLoader;

THREE.SceneLoader.prototype.load = function ( url, callbackFinished ) {

	var scope = this;

	var xhr = new XMLHttpRequest();

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === 4 ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				var json = JSON.parse( xhr.responseText );
				scope.parse( json, callbackFinished, url );

			} else {

				console.error( "THREE.SceneLoader: Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.send( null );

};

THREE.SceneLoader.prototype.addGeometryHandler = function ( typeID, loaderClass ) {

	this.geometryHandlerMap[ typeID ] = { "loaderClass": loaderClass };

};

THREE.SceneLoader.prototype.addHierarchyHandler = function ( typeID, loaderClass ) {

	this.hierarchyHandlerMap[ typeID ] = { "loaderClass": loaderClass };

};

THREE.SceneLoader.prototype.parse = function ( json, callbackFinished, url ) {

	var scope = this;

	var urlBase = THREE.Loader.prototype.extractUrlBase( url );

	var geometry, material, camera, fog,
		texture, images, color,
		light, hex, intensity,
		counter_models, counter_textures,
		total_models, total_textures,
		result;

	var target_array = [];

	var data = json;

	// async geometry loaders

	for ( var typeID in this.geometryHandlerMap ) {

		var loaderClass = this.geometryHandlerMap[ typeID ][ "loaderClass" ];
		this.geometryHandlerMap[ typeID ][ "loaderObject" ] = new loaderClass();

	}

	// async hierachy loaders

	for ( var typeID in this.hierarchyHandlerMap ) {

		var loaderClass = this.hierarchyHandlerMap[ typeID ][ "loaderClass" ];
		this.hierarchyHandlerMap[ typeID ][ "loaderObject" ] = new loaderClass();

	}

	counter_models = 0;
	counter_textures = 0;

	result = {

		scene: new THREE.Scene(),
		geometries: {},
		face_materials: {},
		materials: {},
		textures: {},
		objects: {},
		cameras: {},
		lights: {},
		fogs: {},
		empties: {},
		groups: {}

	};

	if ( data.transform ) {

		var position = data.transform.position,
			rotation = data.transform.rotation,
			scale = data.transform.scale;

		if ( position )
			result.scene.position.set( position[ 0 ], position[ 1 ], position [ 2 ] );

		if ( rotation )
			result.scene.rotation.set( rotation[ 0 ], rotation[ 1 ], rotation [ 2 ] );

		if ( scale )
			result.scene.scale.set( scale[ 0 ], scale[ 1 ], scale [ 2 ] );

		if ( position || rotation || scale ) {

			result.scene.updateMatrix();
			result.scene.updateMatrixWorld();

		}

	}

	function get_url( source_url, url_type ) {

		if ( url_type == "relativeToHTML" ) {

			return source_url;

		} else {

			return urlBase + "/" + source_url;

		}

	};

	// toplevel loader function, delegates to handle_children

	function handle_objects() {

		handle_children( result.scene, data.objects );

	}

	// handle all the children from the loaded json and attach them to given parent

	function handle_children( parent, children ) {

		var mat, dst, pos, rot, scl, quat;

		for ( var objID in children ) {

			// check by id if child has already been handled,
			// if not, create new object

			if ( result.objects[ objID ] === undefined ) {

				var objJSON = children[ objID ];

				var object = null;

				// meshes

				if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlerMap ) ) {

					if ( objJSON.loading === undefined ) {

						var reservedTypes = { "type": 1, "url": 1, "material": 1,
											  "position": 1, "rotation": 1, "scale" : 1,
											  "visible": 1, "children": 1, "properties": 1,
											  "skin": 1, "morph": 1, "mirroredLoop": 1, "duration": 1 };

						var loaderParameters = {};

						for ( var parType in objJSON ) {

							if ( ! ( parType in reservedTypes ) ) {

								loaderParameters[ parType ] = objJSON[ parType ];

							}

						}

						material = result.materials[ objJSON.material ];

						objJSON.loading = true;

						var loader = scope.hierarchyHandlerMap[ objJSON.type ][ "loaderObject" ];

						// ColladaLoader

						if ( loader.options ) {

							loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );

						// UTF8Loader
						// OBJLoader

						} else {

							loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );

						}

					}

				} else if ( objJSON.geometry !== undefined ) {

					geometry = result.geometries[ objJSON.geometry ];

					// geometry already loaded

					if ( geometry ) {

						var needsTangents = false;

						material = result.materials[ objJSON.material ];
						needsTangents = material instanceof THREE.ShaderMaterial;

						pos = objJSON.position;
						rot = objJSON.rotation;
						scl = objJSON.scale;
						mat = objJSON.matrix;
						quat = objJSON.quaternion;

						// use materials from the model file
						// if there is no material specified in the object

						if ( ! objJSON.material ) {

							material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

						}

						// use materials from the model file
						// if there is just empty face material
						// (must create new material as each model has its own face material)

						if ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {

							material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

						}

						if ( material instanceof THREE.MeshFaceMaterial ) {

							for ( var i = 0; i < material.materials.length; i ++ ) {

								needsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );

							}

						}

						if ( needsTangents ) {

							geometry.computeTangents();

						}

						if ( objJSON.skin ) {

							object = new THREE.SkinnedMesh( geometry, material );

						} else if ( objJSON.morph ) {

							object = new THREE.MorphAnimMesh( geometry, material );

							if ( objJSON.duration !== undefined ) {

								object.duration = objJSON.duration;

							}

							if ( objJSON.time !== undefined ) {

								object.time = objJSON.time;

							}

							if ( objJSON.mirroredLoop !== undefined ) {

								object.mirroredLoop = objJSON.mirroredLoop;

							}

							if ( material.morphNormals ) {

								geometry.computeMorphNormals();

							}

						} else {

							object = new THREE.Mesh( geometry, material );

						}

						object.name = objID;

						if ( mat ) {

							object.matrixAutoUpdate = false;
							object.matrix.set(
								mat[0],  mat[1],  mat[2],  mat[3],
								mat[4],  mat[5],  mat[6],  mat[7],
								mat[8],  mat[9],  mat[10], mat[11],
								mat[12], mat[13], mat[14], mat[15]
							);

						} else {

							object.position.set( pos[0], pos[1], pos[2] );

							if ( quat ) {

								object.quaternion.set( quat[0], quat[1], quat[2], quat[3] );
								object.useQuaternion = true;

							} else {

								object.rotation.set( rot[0], rot[1], rot[2] );

							}

							object.scale.set( scl[0], scl[1], scl[2] );

						}

						object.visible = objJSON.visible;
						object.castShadow = objJSON.castShadow;
						object.receiveShadow = objJSON.receiveShadow;

						parent.add( object );

						result.objects[ objID ] = object;

					}

				// lights

				} else if ( objJSON.type === "DirectionalLight" || objJSON.type === "PointLight" || objJSON.type === "AmbientLight" ) {

					hex = ( objJSON.color !== undefined ) ? objJSON.color : 0xffffff;
					intensity = ( objJSON.intensity !== undefined ) ? objJSON.intensity : 1;

					if ( objJSON.type === "DirectionalLight" ) {

						pos = objJSON.direction;

						light = new THREE.DirectionalLight( hex, intensity );
						light.position.set( pos[0], pos[1], pos[2] );

						if ( objJSON.target ) {

							target_array.push( { "object": light, "targetName" : objJSON.target } );

							// kill existing default target
							// otherwise it gets added to scene when parent gets added

							light.target = null;

						}

					} else if ( objJSON.type === "PointLight" ) {

						pos = objJSON.position;
						dst = objJSON.distance;

						light = new THREE.PointLight( hex, intensity, dst );
						light.position.set( pos[0], pos[1], pos[2] );

					} else if ( objJSON.type === "AmbientLight" ) {

						light = new THREE.AmbientLight( hex );

					}

					parent.add( light );

					light.name = objID;
					result.lights[ objID ] = light;
					result.objects[ objID ] = light;

				// cameras

				} else if ( objJSON.type === "PerspectiveCamera" || objJSON.type === "OrthographicCamera" ) {

					if ( objJSON.type === "PerspectiveCamera" ) {

						camera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );

					} else if ( objJSON.type === "OrthographicCamera" ) {

						camera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );

					}

					pos = objJSON.position;
					camera.position.set( pos[0], pos[1], pos[2] );
					parent.add( camera );

					camera.name = objID;
					result.cameras[ objID ] = camera;
					result.objects[ objID ] = camera;

				// pure Object3D

				} else {

					pos = objJSON.position;
					rot = objJSON.rotation;
					scl = objJSON.scale;
					quat = objJSON.quaternion;

					object = new THREE.Object3D();
					object.name = objID;
					object.position.set( pos[0], pos[1], pos[2] );

					if ( quat ) {

						object.quaternion.set( quat[0], quat[1], quat[2], quat[3] );
						object.useQuaternion = true;

					} else {

						object.rotation.set( rot[0], rot[1], rot[2] );

					}

					object.scale.set( scl[0], scl[1], scl[2] );
					object.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;

					parent.add( object );

					result.objects[ objID ] = object;
					result.empties[ objID ] = object;

				}

				if ( object ) {

					if ( objJSON.properties !== undefined )  {

						for ( var key in objJSON.properties ) {

							var value = objJSON.properties[ key ];
							object.properties[ key ] = value;

						}

					}

					if ( objJSON.groups !== undefined ) {

						for ( var i = 0; i < objJSON.groups.length; i ++ ) {

							var groupID = objJSON.groups[ i ];

							if ( result.groups[ groupID ] === undefined ) {

								result.groups[ groupID ] = [];

							}

							result.groups[ groupID ].push( objID );

						}

					}

					if ( objJSON.children !== undefined ) {

						handle_children( object, objJSON.children );

					}

				}

			}

		}

	};

	function handle_mesh( geo, mat, id ) {

		result.geometries[ id ] = geo;
		result.face_materials[ id ] = mat;
		handle_objects();

	};

	function handle_hierarchy( node, id, parent, material, obj ) {

		var p = obj.position;
		var r = obj.rotation;
		var q = obj.quaternion;
		var s = obj.scale;

		node.position.set( p[0], p[1], p[2] );

		if ( q ) {

			node.quaternion.set( q[0], q[1], q[2], q[3] );
			node.useQuaternion = true;

		} else {

			node.rotation.set( r[0], r[1], r[2] );

		}

		node.scale.set( s[0], s[1], s[2] );

		// override children materials
		// if object material was specified in JSON explicitly

		if ( material ) {

			node.traverse( function ( child )  {

				child.material = material;

			} );

		}

		// override children visibility
		// with root node visibility as specified in JSON

		var visible = ( obj.visible !== undefined ) ? obj.visible : true;

		node.traverse( function ( child )  {

			child.visible = visible;

		} );

		parent.add( node );

		node.name = id;

		result.objects[ id ] = node;
		handle_objects();

	};

	function create_callback_geometry( id ) {

		return function( geo, mat ) {

			handle_mesh( geo, mat, id );

			counter_models -= 1;

			scope.onLoadComplete();

			async_callback_gate();

		}

	};

	function create_callback_hierachy( id, parent, material, obj ) {

		return function( event ) {

			var result;

			// loaders which use EventDispatcher

			if ( event.content ) {

				result = event.content;

			// ColladaLoader

			} else if ( event.dae ) {

				result = event.scene;


			// UTF8Loader

			} else {

				result = event;

			}

			handle_hierarchy( result, id, parent, material, obj );

			counter_models -= 1;

			scope.onLoadComplete();

			async_callback_gate();

		}

	};

	function create_callback_embed( id ) {

		return function( geo, mat ) {

			result.geometries[ id ] = geo;
			result.face_materials[ id ] = mat;

		}

	};

	function async_callback_gate() {

		var progress = {

			totalModels : total_models,
			totalTextures : total_textures,
			loadedModels : total_models - counter_models,
			loadedTextures : total_textures - counter_textures

		};

		scope.callbackProgress( progress, result );

		scope.onLoadProgress();

		if ( counter_models === 0 && counter_textures === 0 ) {

			finalize();
			callbackFinished( result );

		}

	};

	function finalize() {

		// take care of targets which could be asynchronously loaded objects

		for ( var i = 0; i < target_array.length; i ++ ) {

			var ta = target_array[ i ];

			var target = result.objects[ ta.targetName ];

			if ( target ) {

				ta.object.target = target;

			} else {

				// if there was error and target of specified name doesn't exist in the scene file
				// create instead dummy target
				// (target must be added to scene explicitly as parent is already added)

				ta.object.target = new THREE.Object3D();
				result.scene.add( ta.object.target );

			}

			ta.object.target.properties.targetInverse = ta.object;

		}

	};

	var callbackTexture = function ( count ) {

		counter_textures -= count;
		async_callback_gate();

		scope.onLoadComplete();

	};

	// must use this instead of just directly calling callbackTexture
	// because of closure in the calling context loop

	var generateTextureCallback = function ( count ) {

		return function() {

			callbackTexture( count );

		};

	};

	// first go synchronous elements

	// fogs

	var fogID, fogJSON;

	for ( fogID in data.fogs ) {

		fogJSON = data.fogs[ fogID ];

		if ( fogJSON.type === "linear" ) {

			fog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );

		} else if ( fogJSON.type === "exp2" ) {

			fog = new THREE.FogExp2( 0x000000, fogJSON.density );

		}

		color = fogJSON.color;
		fog.color.setRGB( color[0], color[1], color[2] );

		result.fogs[ fogID ] = fog;

	}

	// now come potentially asynchronous elements

	// geometries

	// count how many geometries will be loaded asynchronously

	var geoID, geoJSON;

	for ( geoID in data.geometries ) {

		geoJSON = data.geometries[ geoID ];

		if ( geoJSON.type in this.geometryHandlerMap ) {

			counter_models += 1;

			scope.onLoadStart();

		}

	}

	// count how many hierarchies will be loaded asynchronously

	var objID, objJSON;

	for ( objID in data.objects ) {

		objJSON = data.objects[ objID ];

		if ( objJSON.type && ( objJSON.type in this.hierarchyHandlerMap ) ) {

			counter_models += 1;

			scope.onLoadStart();

		}

	}

	total_models = counter_models;

	for ( geoID in data.geometries ) {

		geoJSON = data.geometries[ geoID ];

		if ( geoJSON.type === "cube" ) {

			geometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );
			result.geometries[ geoID ] = geometry;

		} else if ( geoJSON.type === "plane" ) {

			geometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );
			result.geometries[ geoID ] = geometry;

		} else if ( geoJSON.type === "sphere" ) {

			geometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );
			result.geometries[ geoID ] = geometry;

		} else if ( geoJSON.type === "cylinder" ) {

			geometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );
			result.geometries[ geoID ] = geometry;

		} else if ( geoJSON.type === "torus" ) {

			geometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );
			result.geometries[ geoID ] = geometry;

		} else if ( geoJSON.type === "icosahedron" ) {

			geometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );
			result.geometries[ geoID ] = geometry;

		} else if ( geoJSON.type in this.geometryHandlerMap ) {

			var loaderParameters = {};

			for ( var parType in geoJSON ) {

				if ( parType !== "type" && parType !== "url" ) {

					loaderParameters[ parType ] = geoJSON[ parType ];

				}

			}

			var loader = this.geometryHandlerMap[ geoJSON.type ][ "loaderObject" ];
			loader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );

		} else if ( geoJSON.type === "embedded" ) {

			var modelJson = data.embeds[ geoJSON.id ],
				texture_path = "";

			// pass metadata along to jsonLoader so it knows the format version

			modelJson.metadata = data.metadata;

			if ( modelJson ) {

				var jsonLoader = this.geometryHandlerMap[ "ascii" ][ "loaderObject" ];
				jsonLoader.createModel( modelJson, create_callback_embed( geoID ), texture_path );

			}

		}

	}

	// textures

	// count how many textures will be loaded asynchronously

	var textureID, textureJSON;

	for ( textureID in data.textures ) {

		textureJSON = data.textures[ textureID ];

		if ( textureJSON.url instanceof Array ) {

			counter_textures += textureJSON.url.length;

			for( var n = 0; n < textureJSON.url.length; n ++ ) {

				scope.onLoadStart();

			}

		} else {

			counter_textures += 1;

			scope.onLoadStart();

		}

	}

	total_textures = counter_textures;

	for ( textureID in data.textures ) {

		textureJSON = data.textures[ textureID ];

		if ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined  ) {

			textureJSON.mapping = new THREE[ textureJSON.mapping ]();

		}

		if ( textureJSON.url instanceof Array ) {

			var count = textureJSON.url.length;
			var url_array = [];

			for( var i = 0; i < count; i ++ ) {

				url_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );

			}

			var isCompressed = /\.dds$/i.test( url_array[ 0 ] );

			if ( isCompressed ) {

				texture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

			} else {

				texture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

			}

		} else {

			var isCompressed = /\.dds$/i.test( textureJSON.url );
			var fullUrl = get_url( textureJSON.url, data.urlBaseType );
			var textureCallback = generateTextureCallback( 1 );

			if ( isCompressed ) {

				texture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );

			} else {

				texture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );

			}

			if ( THREE[ textureJSON.minFilter ] !== undefined )
				texture.minFilter = THREE[ textureJSON.minFilter ];

			if ( THREE[ textureJSON.magFilter ] !== undefined )
				texture.magFilter = THREE[ textureJSON.magFilter ];

			if ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;

			if ( textureJSON.repeat ) {

				texture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );

				if ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
				if ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

			}

			if ( textureJSON.offset ) {

				texture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );

			}

			// handle wrap after repeat so that default repeat can be overriden

			if ( textureJSON.wrap ) {

				var wrapMap = {
				"repeat" 	: THREE.RepeatWrapping,
				"mirror"	: THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];
				if ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];

			}

		}

		result.textures[ textureID ] = texture;

	}

	// materials

	var matID, matJSON;
	var parID;

	for ( matID in data.materials ) {

		matJSON = data.materials[ matID ];

		for ( parID in matJSON.parameters ) {

			if ( parID === "envMap" || parID === "map" || parID === "lightMap" || parID === "bumpMap" ) {

				matJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];

			} else if ( parID === "shading" ) {

				matJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === "flat" ) ? THREE.FlatShading : THREE.SmoothShading;

			} else if ( parID === "side" ) {

				if ( matJSON.parameters[ parID ] == "double" ) {

					matJSON.parameters[ parID ] = THREE.DoubleSide;

				} else if ( matJSON.parameters[ parID ] == "back" ) {

					matJSON.parameters[ parID ] = THREE.BackSide;

				} else {

					matJSON.parameters[ parID ] = THREE.FrontSide;

				}

			} else if ( parID === "blending" ) {

				matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;

			} else if ( parID === "combine" ) {

				matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;

			} else if ( parID === "vertexColors" ) {

				if ( matJSON.parameters[ parID ] == "face" ) {

					matJSON.parameters[ parID ] = THREE.FaceColors;

				// default to vertex colors if "vertexColors" is anything else face colors or 0 / null / false

				} else if ( matJSON.parameters[ parID ] )   {

					matJSON.parameters[ parID ] = THREE.VertexColors;

				}

			} else if ( parID === "wrapRGB" ) {

				var v3 = matJSON.parameters[ parID ];
				matJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );

			}

		}

		if ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {

			matJSON.parameters.transparent = true;

		}

		if ( matJSON.parameters.normalMap ) {

			var shader = THREE.ShaderLib[ "normalmap" ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			var diffuse = matJSON.parameters.color;
			var specular = matJSON.parameters.specular;
			var ambient = matJSON.parameters.ambient;
			var shininess = matJSON.parameters.shininess;

			uniforms[ "tNormal" ].value = result.textures[ matJSON.parameters.normalMap ];

			if ( matJSON.parameters.normalScale ) {

				uniforms[ "uNormalScale" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );

			}

			if ( matJSON.parameters.map ) {

				uniforms[ "tDiffuse" ].value = matJSON.parameters.map;
				uniforms[ "enableDiffuse" ].value = true;

			}

			if ( matJSON.parameters.envMap ) {

				uniforms[ "tCube" ].value = matJSON.parameters.envMap;
				uniforms[ "enableReflection" ].value = true;
				uniforms[ "uReflectivity" ].value = matJSON.parameters.reflectivity;

			}

			if ( matJSON.parameters.lightMap ) {

				uniforms[ "tAO" ].value = matJSON.parameters.lightMap;
				uniforms[ "enableAO" ].value = true;

			}

			if ( matJSON.parameters.specularMap ) {

				uniforms[ "tSpecular" ].value = result.textures[ matJSON.parameters.specularMap ];
				uniforms[ "enableSpecular" ].value = true;

			}

			if ( matJSON.parameters.displacementMap ) {

				uniforms[ "tDisplacement" ].value = result.textures[ matJSON.parameters.displacementMap ];
				uniforms[ "enableDisplacement" ].value = true;

				uniforms[ "uDisplacementBias" ].value = matJSON.parameters.displacementBias;
				uniforms[ "uDisplacementScale" ].value = matJSON.parameters.displacementScale;

			}

			uniforms[ "uDiffuseColor" ].value.setHex( diffuse );
			uniforms[ "uSpecularColor" ].value.setHex( specular );
			uniforms[ "uAmbientColor" ].value.setHex( ambient );

			uniforms[ "uShininess" ].value = shininess;

			if ( matJSON.parameters.opacity ) {

				uniforms[ "uOpacity" ].value = matJSON.parameters.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };

			material = new THREE.ShaderMaterial( parameters );

		} else {

			material = new THREE[ matJSON.type ]( matJSON.parameters );

		}

		result.materials[ matID ] = material;

	}

	// second pass through all materials to initialize MeshFaceMaterials
	// that could be referring to other materials out of order

	for ( matID in data.materials ) {

		matJSON = data.materials[ matID ];

		if ( matJSON.parameters.materials ) {

			var materialArray = [];

			for ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {

				var label = matJSON.parameters.materials[ i ];
				materialArray.push( result.materials[ label ] );

			}

			result.materials[ matID ].materials = materialArray;

		}

	}

	// objects ( synchronous init of procedural primitives )

	handle_objects();

	// defaults

	if ( result.cameras && data.defaults.camera ) {

		result.currentCamera = result.cameras[ data.defaults.camera ];

	}

	if ( result.fogs && data.defaults.fog ) {

		result.scene.fog = result.fogs[ data.defaults.fog ];

	}

	// synchronous callback

	scope.callbackSync( result );

	// just in case there are no async elements

	async_callback_gate();

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function () {

	THREE.EventDispatcher.call( this );

	this.crossOrigin = null;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url ) {

		var scope = this;

		var image = new Image();

		image.addEventListener( 'load', function () {

			var texture = new THREE.Texture( image );
			texture.needsUpdate = true;

			scope.dispatchEvent( { type: 'load', content: texture } );

		}, false );

		image.addEventListener( 'error', function () {

			scope.dispatchEvent( { type: 'error', message: 'Couldn\'t load URL [' + url + ']' } );

		}, false );

		if ( scope.crossOrigin ) image.crossOrigin = scope.crossOrigin;

		image.src = url;

	}

}
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	THREE.EventDispatcher.call( this );

	this.id = THREE.MaterialIdCount ++;

	this.name = '';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.depthTest = true;
	this.depthWrite = true;

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = false; // Boolean for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this.needsUpdate = true;

};

THREE.Material.prototype.setValues = function ( values ) {

	if ( values === undefined ) return;

	for ( var key in values ) {

		var newValue = values[ key ];

		if ( newValue === undefined ) {

			console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
			continue;

		}

		if ( key in this ) {

			var currentValue = this[ key ];

			if ( currentValue instanceof THREE.Color && newValue instanceof THREE.Color ) {

				currentValue.copy( newValue );

			} else if ( currentValue instanceof THREE.Color ) {

				currentValue.set( newValue );

			} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	}

};

THREE.Material.prototype.clone = function ( material ) {

	if ( material === undefined ) material = new THREE.Material();

	material.name = this.name;

	material.side = this.side;

	material.opacity = this.opacity;
	material.transparent = this.transparent;

	material.blending = this.blending;

	material.blendSrc = this.blendSrc;
	material.blendDst = this.blendDst;
	material.blendEquation = this.blendEquation;

	material.depthTest = this.depthTest;
	material.depthWrite = this.depthWrite;

	material.polygonOffset = this.polygonOffset;
	material.polygonOffsetFactor = this.polygonOffsetFactor;
	material.polygonOffsetUnits = this.polygonOffsetUnits;

	material.alphaTest = this.alphaTest;

	material.overdraw = this.overdraw;

	material.visible = this.visible;

	return material;

};

THREE.Material.prototype.dispose = function () {

	this.dispatchEvent( { type: 'dispose' } );

};

THREE.MaterialIdCount = 0;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineBasicMaterial.prototype.clone = function () {

	var material = new THREE.LineBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;
	material.linecap = this.linecap;
	material.linejoin = this.linejoin;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineDashedMaterial.prototype.clone = function () {

	var material = new THREE.LineDashedMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;

	material.scale = this.scale;
	material.dashSize = this.dashSize;
	material.gapSize = this.gapSize;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshBasicMaterial.prototype.clone = function () {

	var material = new THREE.MeshBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;

	return material;

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshLambertMaterial.prototype.clone = function () {

	var material = new THREE.MeshLambertMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;
	this.perPixel = true;

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhongMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhongMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );
	material.specular.copy( this.specular );
	material.shininess = this.shininess;

	material.metal = this.metal;
	material.perPixel = this.perPixel;

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshDepthMaterial.prototype.clone = function () {

	var material = new THREE.LineBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.shading = THREE.FlatShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshNormalMaterial.prototype.clone = function () {

	var material = new THREE.MeshNormalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

	this.materials = materials instanceof Array ? materials : [];

};

THREE.MeshFaceMaterial.prototype.clone = function () {

	return new THREE.MeshFaceMaterial( this.materials.slice( 0 ) );

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ParticleBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.ParticleBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ParticleBasicMaterial.prototype.clone = function () {

	var material = new THREE.ParticleBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.size = this.size;
	material.sizeAttenuation = this.sizeAttenuation;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};
/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <hex>,
 *  program: <function>,
 *  opacity: <float>,
 *  blending: THREE.NormalBlending
 * }
 */

THREE.ParticleCanvasMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );
	this.program = function ( context, color ) {};

	this.setValues( parameters );

};

THREE.ParticleCanvasMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ParticleCanvasMaterial.prototype.clone = function () {

	var material = new THREE.ParticleCanvasMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.program = this.program;

	return material;

};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  defines: { "label" : "value" },
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.fragmentShader = "void main() {}";
	this.vertexShader = "void main() {}";
	this.uniforms = {};
	this.defines = {};
	this.attributes = null;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.setValues( parameters );

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ShaderMaterial.prototype.clone = function () {

	var material = new THREE.ShaderMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.fragmentShader = this.fragmentShader;
	material.vertexShader = this.vertexShader;

	material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

	material.attributes = this.attributes;
	material.defines = this.defines;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	material.fog = this.fog;

	material.lights = this.lights;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;

	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  useScreenCoordinates: <bool>,
 *  sizeAttenuation: <bool>,
 *  scaleByViewport: <bool>,
 *  alignment: THREE.SpriteAlignment.center,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	// defaults

	this.color = new THREE.Color( 0xffffff );
	this.map = new THREE.Texture();

	this.useScreenCoordinates = true;
	this.depthTest = !this.useScreenCoordinates;
	this.sizeAttenuation = !this.useScreenCoordinates;
	this.scaleByViewport = !this.sizeAttenuation;
	this.alignment = THREE.SpriteAlignment.center.clone();

	this.fog = false;

	this.uvOffset = new THREE.Vector2( 0, 0 );
	this.uvScale  = new THREE.Vector2( 1, 1 );

	// set parameters

	this.setValues( parameters );

	// override coupled defaults if not specified explicitly by parameters

	parameters = parameters || {};

	if ( parameters.depthTest === undefined ) this.depthTest = !this.useScreenCoordinates;
	if ( parameters.sizeAttenuation === undefined ) this.sizeAttenuation = !this.useScreenCoordinates;
	if ( parameters.scaleByViewport === undefined ) this.scaleByViewport = !this.sizeAttenuation;

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteMaterial.prototype.clone = function () {

	var material = new THREE.SpriteMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;

	material.useScreenCoordinates = this.useScreenCoordinates;
	material.sizeAttenuation = this.sizeAttenuation;
	material.scaleByViewport = this.scaleByViewport;
	material.alignment.copy( this.alignment );

	material.uvOffset.copy( this.uvOffset );
	material.uvScale.copy( this.uvScale );

	material.fog = this.fog;

	return material;

};

// Alignment enums

THREE.SpriteAlignment = {};
THREE.SpriteAlignment.topLeft = new THREE.Vector2( 1, -1 );
THREE.SpriteAlignment.topCenter = new THREE.Vector2( 0, -1 );
THREE.SpriteAlignment.topRight = new THREE.Vector2( -1, -1 );
THREE.SpriteAlignment.centerLeft = new THREE.Vector2( 1, 0 );
THREE.SpriteAlignment.center = new THREE.Vector2( 0, 0 );
THREE.SpriteAlignment.centerRight = new THREE.Vector2( -1, 0 );
THREE.SpriteAlignment.bottomLeft = new THREE.Vector2( 1, 1 );
THREE.SpriteAlignment.bottomCenter = new THREE.Vector2( 0, 1 );
THREE.SpriteAlignment.bottomRight = new THREE.Vector2( -1, 1 );
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.EventDispatcher.call( this );

	this.id = THREE.TextureIdCount ++;

	this.name = '';

	this.image = image;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this.needsUpdate = false;
	this.onUpdate = null;

};

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	clone: function ( texture ) {

		if ( texture === undefined ) texture = new THREE.Texture();

		texture.image = this.image;
		texture.mipmaps = this.mipmaps.slice(0);

		texture.mapping = this.mapping;

		texture.wrapS = this.wrapS;
		texture.wrapT = this.wrapT;

		texture.magFilter = this.magFilter;
		texture.minFilter = this.minFilter;

		texture.anisotropy = this.anisotropy;

		texture.format = this.format;
		texture.type = this.type;

		texture.offset.copy( this.offset );
		texture.repeat.copy( this.repeat );

		texture.generateMipmaps = this.generateMipmaps;
		texture.premultiplyAlpha = this.premultiplyAlpha;
		texture.flipY = this.flipY;
		texture.unpackAlignment = this.unpackAlignment;

		return texture;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.TextureIdCount = 0;
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	this.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CompressedTexture.prototype.clone = function () {

	var texture = new THREE.CompressedTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.DataTexture.prototype.clone = function () {

	var texture = new THREE.DataTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Particle = function ( material ) {

	THREE.Object3D.call( this );

	this.material = material;

};

THREE.Particle.prototype = Object.create( THREE.Object3D.prototype );

THREE.Particle.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Particle( this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ParticleSystem = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry;
	this.material = ( material !== undefined ) ? material : new THREE.ParticleBasicMaterial( { color: Math.random() * 0xffffff } );

	this.sortParticles = false;

	if ( this.geometry ) {

		// calc bound radius

		if( this.geometry.boundingSphere === null ) {

			this.geometry.computeBoundingSphere();

		}

	}

	this.frustumCulled = false;

};

THREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );

THREE.ParticleSystem.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );
	object.sortParticles = this.sortParticles;

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, type ) {

	THREE.Object3D.call( this );

	this.geometry = geometry;
	this.material = ( material !== undefined ) ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );
	this.type = ( type !== undefined ) ? type : THREE.LineStrip;

	if ( this.geometry ) {

		if ( ! this.geometry.boundingSphere ) {

			this.geometry.computeBoundingSphere();

		}

	}

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );

THREE.Line.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry;
	this.material = ( material !== undefined ) ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } );

	if ( this.geometry !== undefined ) {

		if ( this.geometry.boundingSphere === null ) {

			this.geometry.computeBoundingSphere();

		}

		this.updateMorphTargets();

	}

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = -1;
		this.morphTargetForcedOrder = [];
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.log( "THREE.Mesh.getMorphTargetIndexByName: morph target " + name + " does not exist. Returning 0." );

	return 0;

};

THREE.Mesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Bone = function( belongsToSkin ) {

	THREE.Object3D.call( this );

	this.skin = belongsToSkin;
	this.skinMatrix = new THREE.Matrix4();

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );

THREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {

	// update local

	if ( this.matrixAutoUpdate ) {

		forceUpdate |= this.updateMatrix();

	}

	// update skin matrix

	if ( forceUpdate || this.matrixWorldNeedsUpdate ) {

		if( parentSkinMatrix ) {

			this.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );

		} else {

			this.skinMatrix.copy( this.matrix );

		}

		this.matrixWorldNeedsUpdate = false;
		forceUpdate = true;

	}

	// update children

	var child, i, l = this.children.length;

	for ( i = 0; i < l; i ++ ) {

		this.children[ i ].update( this.skinMatrix, forceUpdate );

	}

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	//

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	// init bones

	this.identityMatrix = new THREE.Matrix4();

	this.bones = [];
	this.boneMatrices = [];

	var b, bone, gbone, p, q, s;

	if ( this.geometry && this.geometry.bones !== undefined ) {

		for ( b = 0; b < this.geometry.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];

			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;

			bone = this.addBone();

			bone.name = gbone.name;
			bone.position.set( p[0], p[1], p[2] );
			bone.quaternion.set( q[0], q[1], q[2], q[3] );
			bone.useQuaternion = true;

			if ( s !== undefined ) {

				bone.scale.set( s[0], s[1], s[2] );

			} else {

				bone.scale.set( 1, 1, 1 );

			}

		}

		for ( b = 0; b < this.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];
			bone = this.bones[ b ];

			if ( gbone.parent === -1 ) {

				this.add( bone );

			} else {

				this.bones[ gbone.parent ].add( bone );

			}

		}

		//

		var nBones = this.bones.length;

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//	RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
			//  	 16x16 pixel texture max   64 bones (16 * 16 / 4)
			//  	 32x32 pixel texture max  256 bones (32 * 32 / 4)
			//  	 64x64 pixel texture max 1024 bones (64 * 64 / 4)

			var size;

			if ( nBones > 256 )
				size = 64;
			else if ( nBones > 64 )
				size = 32;
			else if ( nBones > 16 )
				size = 16;
			else
				size = 8;

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
			this.boneTexture.minFilter = THREE.NearestFilter;
			this.boneTexture.magFilter = THREE.NearestFilter;
			this.boneTexture.generateMipmaps = false;
			this.boneTexture.flipY = false;

		} else {

			this.boneMatrices = new Float32Array( 16 * nBones );

		}

		this.pose();

	}

};

THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.SkinnedMesh.prototype.addBone = function( bone ) {

	if ( bone === undefined ) {

		bone = new THREE.Bone( this );

	}

	this.bones.push( bone );

	return bone;

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function ( force ) {

	this.matrixAutoUpdate && this.updateMatrix();

	// update matrixWorld

	if ( this.matrixWorldNeedsUpdate || force ) {

		if ( this.parent ) {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		} else {

			this.matrixWorld.copy( this.matrix );

		}

		this.matrixWorldNeedsUpdate = false;

		force = true;

	}

	// update children

	for ( var i = 0, l = this.children.length; i < l; i ++ ) {

		var child = this.children[ i ];

		if ( child instanceof THREE.Bone ) {

			child.update( this.identityMatrix, false );

		} else {

			child.updateMatrixWorld( true );

		}

	}

	// make a snapshot of the bones' rest position

	if ( this.boneInverses == undefined ) {

		this.boneInverses = [];

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			var inverse = new THREE.Matrix4();

			inverse.getInverse( this.bones[ b ].skinMatrix );

			this.boneInverses.push( inverse );

		}

	}

	// flatten bone matrices to array

	for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

		// compute the offset between the current and the original transform;

		//TODO: we could get rid of this multiplication step if the skinMatrix
		// was already representing the offset; however, this requires some
		// major changes to the animation system

		THREE.SkinnedMesh.offsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );

		THREE.SkinnedMesh.offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

	}

	if ( this.useVertexTexture ) {

		this.boneTexture.needsUpdate = true;

	}

};

THREE.SkinnedMesh.prototype.pose = function () {

	this.updateMatrixWorld( true );

	for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

		// normalize weights

		var sw = this.geometry.skinWeights[ i ];

		var scale = 1.0 / sw.lengthManhattan();

		if ( scale !== Infinity ) {

			sw.multiplyScalar( scale );

		} else {

			sw.set( 1 ); // this will be normalized by the shader anyway

		}

	}

};

THREE.SkinnedMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

THREE.SkinnedMesh.offsetMatrix = new THREE.Matrix4();
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	// API

	this.duration = 1000; // milliseconds
	this.mirroredLoop = false;
	this.time = 0;

	// internals

	this.lastKeyframe = 0;
	this.currentKeyframe = 0;

	this.direction = 1;
	this.directionBackwards = false;

	this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

	this.startKeyframe = start;
	this.endKeyframe = end;

	this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

	this.direction = 1;
	this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

	this.direction = -1;
	this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

	var geometry = this.geometry;

	if ( ! geometry.animations ) geometry.animations = {};

	var firstAnimation, animations = geometry.animations;

	var pattern = /([a-z]+)(\d+)/;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var parts = morph.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var label = parts[ 1 ];
			var num = parts[ 2 ];

			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };

			var animation = animations[ label ];

			if ( i < animation.start ) animation.start = i;
			if ( i > animation.end ) animation.end = i;

			if ( ! firstAnimation ) firstAnimation = label;

		}

	}

	geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

	if ( ! this.geometry.animations ) this.geometry.animations = {};

	this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

	var animation = this.geometry.animations[ label ];

	if ( animation ) {

		this.setFrameRange( animation.start, animation.end );
		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
		this.time = 0;

	} else {

		console.warn( "animation[" + label + "] undefined" );

	}

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

	var frameTime = this.duration / this.length;

	this.time += this.direction * delta;

	if ( this.mirroredLoop ) {

		if ( this.time > this.duration || this.time < 0 ) {

			this.direction *= -1;

			if ( this.time > this.duration ) {

				this.time = this.duration;
				this.directionBackwards = true;

			}

			if ( this.time < 0 ) {

				this.time = 0;
				this.directionBackwards = false;

			}

		}

	} else {

		this.time = this.time % this.duration;

		if ( this.time < 0 ) this.time += this.duration;

	}

	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

	if ( keyframe !== this.currentKeyframe ) {

		this.morphTargetInfluences[ this.lastKeyframe ] = 0;
		this.morphTargetInfluences[ this.currentKeyframe ] = 1;

		this.morphTargetInfluences[ keyframe ] = 0;

		this.lastKeyframe = this.currentKeyframe;
		this.currentKeyframe = keyframe;

	}

	var mix = ( this.time % frameTime ) / frameTime;

	if ( this.directionBackwards ) {

		mix = 1 - mix;

	}

	this.morphTargetInfluences[ this.currentKeyframe ] = mix;
	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

	object.duration = this.duration;
	object.mirroredLoop = this.mirroredLoop;
	object.time = this.time;

	object.lastKeyframe = this.lastKeyframe;
	object.currentKeyframe = this.currentKeyframe;

	object.direction = this.direction;
	object.directionBackwards = this.directionBackwards;

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Ribbon = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry;
	this.material = material;

};

THREE.Ribbon.prototype = Object.create( THREE.Object3D.prototype );

THREE.Ribbon.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Ribbon( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.LODs = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );

THREE.LOD.prototype.addLevel = function ( object3D, visibleAtDistance ) {

	if ( visibleAtDistance === undefined ) {

		visibleAtDistance = 0;

	}

	visibleAtDistance = Math.abs( visibleAtDistance );

	for ( var l = 0; l < this.LODs.length; l ++ ) {

		if ( visibleAtDistance < this.LODs[ l ].visibleAtDistance ) {

			break;

		}

	}

	this.LODs.splice( l, 0, { visibleAtDistance: visibleAtDistance, object3D: object3D } );
	this.add( object3D );

};

THREE.LOD.prototype.update = function ( camera ) {

	if ( this.LODs.length > 1 ) {

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		var inverse  = camera.matrixWorldInverse;
		var distance = -( inverse.elements[2] * this.matrixWorld.elements[12] + inverse.elements[6] * this.matrixWorld.elements[13] + inverse.elements[10] * this.matrixWorld.elements[14] + inverse.elements[14] );

		this.LODs[ 0 ].object3D.visible = true;

		for ( var l = 1; l < this.LODs.length; l ++ ) {

			if( distance >= this.LODs[ l ].visibleAtDistance ) {

				this.LODs[ l - 1 ].object3D.visible = false;
				this.LODs[ l     ].object3D.visible = true;

			} else {

				break;

			}

		}

		for( ; l < this.LODs.length; l ++ ) {

			this.LODs[ l ].object3D.visible = false;

		}

	}

};

THREE.LOD.prototype.clone = function () {

	// TODO

};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = function ( material ) {

	THREE.Object3D.call( this );

	this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

	this.rotation3d = this.rotation;
	this.rotation = 0;

};

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );

/*
 * Custom update matrix
 */

THREE.Sprite.prototype.updateMatrix = function () {

	this.matrix.setPosition( this.position );

	this.rotation3d.set( 0, 0, this.rotation );
	this.matrix.setRotationFromEuler( this.rotation3d );

	if ( this.scale.x !== 1 || this.scale.y !== 1 ) {

		this.matrix.scale( this.scale );

	}

	this.matrixWorldNeedsUpdate = true;

};

THREE.Sprite.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Sprite( this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.fog = null;
	this.overrideMaterial = null;

	this.matrixAutoUpdate = false;

	this.__objects = [];
	this.__lights = [];

	this.__objectsAdded = [];
	this.__objectsRemoved = [];

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );

THREE.Scene.prototype.__addObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		if ( this.__lights.indexOf( object ) === - 1 ) {

			this.__lights.push( object );

		}

		if ( object.target && object.target.parent === undefined ) {

			this.add( object.target );

		}

	} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {

		if ( this.__objects.indexOf( object ) === - 1 ) {

			this.__objects.push( object );
			this.__objectsAdded.push( object );

			// check if previously removed

			var i = this.__objectsRemoved.indexOf( object );

			if ( i !== -1 ) {

				this.__objectsRemoved.splice( i, 1 );

			}

		}

	}

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.__addObject( object.children[ c ] );

	}

};

THREE.Scene.prototype.__removeObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		var i = this.__lights.indexOf( object );

		if ( i !== -1 ) {

			this.__lights.splice( i, 1 );

		}

	} else if ( !( object instanceof THREE.Camera ) ) {

		var i = this.__objects.indexOf( object );

		if( i !== -1 ) {

			this.__objects.splice( i, 1 );
			this.__objectsRemoved.push( object );

			// check if previously added

			var ai = this.__objectsAdded.indexOf( object );

			if ( ai !== -1 ) {

				this.__objectsAdded.splice( ai, 1 );

			}

		}

	}

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.__removeObject( object.children[ c ] );

	}

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( hex, near, far ) {

	this.name = '';

	this.color = new THREE.Color( hex );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( hex, density ) {

	this.name = '';
	this.color = new THREE.Color( hex );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasRenderer = function ( parameters ) {

	console.log( 'THREE.CanvasRenderer', THREE.REVISION );

	var smoothstep = THREE.Math.smoothstep;

	parameters = parameters || {};

	var _this = this,
	_renderData, _elements, _lights,
	_projector = new THREE.Projector(),

	_canvas = parameters.canvas !== undefined
			? parameters.canvas
			: document.createElement( 'canvas' ),

	_canvasWidth, _canvasHeight, _canvasWidthHalf, _canvasHeightHalf,
	_context = _canvas.getContext( '2d' ),

	_clearColor = new THREE.Color( 0x000000 ),
	_clearOpacity = 0,

	_contextGlobalAlpha = 1,
	_contextGlobalCompositeOperation = 0,
	_contextStrokeStyle = null,
	_contextFillStyle = null,
	_contextLineWidth = null,
	_contextLineCap = null,
	_contextLineJoin = null,
	_contextDashSize = null,
	_contextGapSize = 0,

	_v1, _v2, _v3, _v4,
	_v5 = new THREE.RenderableVertex(),
	_v6 = new THREE.RenderableVertex(),

	_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,
	_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,

	_color = new THREE.Color(),
	_color1 = new THREE.Color(),
	_color2 = new THREE.Color(),
	_color3 = new THREE.Color(),
	_color4 = new THREE.Color(),

	_diffuseColor = new THREE.Color(),
	_emissiveColor = new THREE.Color(),

	_lightColor = new THREE.Color(),

	_patterns = {}, _imagedatas = {},

	_near, _far,

	_image, _uvs,
	_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,

	_clipBox = new THREE.Box2(),
	_clearBox = new THREE.Box2(),
	_elemBox = new THREE.Box2(),

	_enableLighting = false,
	_ambientLight = new THREE.Color(),
	_directionalLights = new THREE.Color(),
	_pointLights = new THREE.Color(),

	_vector3 = new THREE.Vector3(), // Needed for PointLight

	_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,
	_gradientMap, _gradientMapContext, _gradientMapQuality = 16;

	_pixelMap = document.createElement( 'canvas' );
	_pixelMap.width = _pixelMap.height = 2;

	_pixelMapContext = _pixelMap.getContext( '2d' );
	_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';
	_pixelMapContext.fillRect( 0, 0, 2, 2 );

	_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );
	_pixelMapData = _pixelMapImage.data;

	_gradientMap = document.createElement( 'canvas' );
	_gradientMap.width = _gradientMap.height = _gradientMapQuality;

	_gradientMapContext = _gradientMap.getContext( '2d' );
	_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );
	_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );

	_gradientMapQuality --; // Fix UVs

	// dash+gap fallbacks for Firefox and everything else

	if ( _context.setLineDash === undefined ) {

		if ( _context.mozDash !== undefined ) {

			_context.setLineDash = function ( values ) {

				_context.mozDash = values[ 0 ] !== null ? values : null;

			}

		} else {

			_context.setLineDash = function () {}

		}

	}

	this.domElement = _canvas;

	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: window.devicePixelRatio !== undefined
					? window.devicePixelRatio
					: 1;

	this.autoClear = true;
	this.sortObjects = true;
	this.sortElements = true;

	this.info = {

		render: {

			vertices: 0,
			faces: 0

		}

	}

	// WebGLRenderer compatibility

	this.supportsVertexTextures = function () {};
	this.setFaceCulling = function () {};

	this.setSize = function ( width, height ) {

		_canvasWidth = width * this.devicePixelRatio;
		_canvasHeight = height * this.devicePixelRatio;

		_canvasWidthHalf = Math.floor( _canvasWidth / 2 );
		_canvasHeightHalf = Math.floor( _canvasHeight / 2 );

		_canvas.width = _canvasWidth;
		_canvas.height = _canvasHeight;

		_canvas.style.width = width + 'px';
		_canvas.style.height = height + 'px';

		_clipBox.set(
			new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
			new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
		);

		_clearBox.set(
			new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
			new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
		);

		_contextGlobalAlpha = 1;
		_contextGlobalCompositeOperation = 0;
		_contextStrokeStyle = null;
		_contextFillStyle = null;
		_contextLineWidth = null;
		_contextLineCap = null;
		_contextLineJoin = null;

	};

	this.setClearColor = function ( color, opacity ) {

		_clearColor.copy( color );
		_clearOpacity = opacity !== undefined ? opacity : 1;

		_clearBox.set(
			new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
			new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
		);

	};

	this.setClearColorHex = function ( hex, opacity ) {

		_clearColor.setHex( hex );
		_clearOpacity = opacity !== undefined ? opacity : 1;

		_clearBox.set(
			new THREE.Vector2( - _canvasWidthHalf, - _canvasHeightHalf ),
			new THREE.Vector2( _canvasWidthHalf, _canvasHeightHalf )
		);

	};

	this.getMaxAnisotropy  = function () {

		return 0;

	};

	this.clear = function () {

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		if ( _clearBox.empty() === false ) {

			_clearBox.intersect( _clipBox );
			_clearBox.expandByScalar( 2 );

			if ( _clearOpacity < 1 ) {

				_context.clearRect(
					_clearBox.min.x | 0,
					_clearBox.min.y | 0,
					( _clearBox.max.x - _clearBox.min.x ) | 0,
					( _clearBox.max.y - _clearBox.min.y ) | 0
				);

			}

			if ( _clearOpacity > 0 ) {

				setBlending( THREE.NormalBlending );
				setOpacity( 1 );

				setFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearOpacity + ')' );

				_context.fillRect(
					_clearBox.min.x | 0,
					_clearBox.min.y | 0,
					( _clearBox.max.x - _clearBox.min.x ) | 0,
					( _clearBox.max.y - _clearBox.min.y ) | 0
				);

			}

			_clearBox.makeEmpty();

		}


	};

	this.render = function ( scene, camera ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( this.autoClear === true ) {

			this.clear();

		}

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;

		_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );
		_elements = _renderData.elements;
		_lights = _renderData.lights;

		/* DEBUG
		setFillStyle( 'rgba( 0, 255, 255, 0.5 )' );
		_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );
		*/

		_enableLighting = _lights.length > 0;

		if ( _enableLighting === true ) {

			 calculateLights();

		}

		for ( var e = 0, el = _elements.length; e < el; e++ ) {

			var element = _elements[ e ];

			var material = element.material;

			if ( material === undefined || material.visible === false ) continue;

			_elemBox.makeEmpty();

			if ( element instanceof THREE.RenderableParticle ) {

				_v1 = element;
				_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;

				renderParticle( _v1, element, material );

			} else if ( element instanceof THREE.RenderableLine ) {

				_v1 = element.v1; _v2 = element.v2;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;

				_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen ] );

				if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {

					renderLine( _v1, _v2, element, material );

				}

			} else if ( element instanceof THREE.RenderableFace3 ) {

				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

				if ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;
				if ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;
				if ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
				_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;

				if ( material.overdraw === true ) {

					expand( _v1.positionScreen, _v2.positionScreen );
					expand( _v2.positionScreen, _v3.positionScreen );
					expand( _v3.positionScreen, _v1.positionScreen );

				}

				_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen ] );

				renderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );

			} else if ( element instanceof THREE.RenderableFace4 ) {

				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3; _v4 = element.v4;

				if ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;
				if ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;
				if ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;
				if ( _v4.positionScreen.z < -1 || _v4.positionScreen.z > 1 ) continue;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
				_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;
				_v4.positionScreen.x *= _canvasWidthHalf; _v4.positionScreen.y *= _canvasHeightHalf;

				_v5.positionScreen.copy( _v2.positionScreen );
				_v6.positionScreen.copy( _v4.positionScreen );

				if ( material.overdraw === true ) {

					expand( _v1.positionScreen, _v2.positionScreen );
					expand( _v2.positionScreen, _v4.positionScreen );
					expand( _v4.positionScreen, _v1.positionScreen );

					expand( _v3.positionScreen, _v5.positionScreen );
					expand( _v3.positionScreen, _v6.positionScreen );

				}

				_elemBox.setFromPoints( [ _v1.positionScreen, _v2.positionScreen, _v3.positionScreen, _v4.positionScreen ] );

				renderFace4( _v1, _v2, _v3, _v4, _v5, _v6, element, material, scene );

			}

			/* DEBUG
			setLineWidth( 1 );
			setStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );
			_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );
			*/

			_clearBox.union( _elemBox );

		}

		/* DEBUG
		setLineWidth( 1 );
		setStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );
		_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );
		*/

		_context.setTransform( 1, 0, 0, 1, 0, 0 );

		//

		function calculateLights() {

			_ambientLight.setRGB( 0, 0, 0 );
			_directionalLights.setRGB( 0, 0, 0 );
			_pointLights.setRGB( 0, 0, 0 );

			for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

				var light = _lights[ l ];
				var lightColor = light.color;

				if ( light instanceof THREE.AmbientLight ) {

					_ambientLight.add( lightColor );

				} else if ( light instanceof THREE.DirectionalLight ) {

					// for particles

					_directionalLights.add( lightColor );

				} else if ( light instanceof THREE.PointLight ) {

					// for particles

					_pointLights.add( lightColor );

				}

			}

		}

		function calculateLight( position, normal, color ) {

			for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

				var light = _lights[ l ];

				_lightColor.copy( light.color );

				if ( light instanceof THREE.DirectionalLight ) {

					var lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld ).normalize();

					var amount = normal.dot( lightPosition );

					if ( amount <= 0 ) continue;

					amount *= light.intensity;

					color.add( _lightColor.multiplyScalar( amount ) );

				} else if ( light instanceof THREE.PointLight ) {

					var lightPosition = _vector3.getPositionFromMatrix( light.matrixWorld );

					var amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );

					if ( amount <= 0 ) continue;

					amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );

					if ( amount == 0 ) continue;

					amount *= light.intensity;

					color.add( _lightColor.multiplyScalar( amount ) );

				}

			}

		}

		function renderParticle( v1, element, material ) {

			setOpacity( material.opacity );
			setBlending( material.blending );

			var width, height, scaleX, scaleY,
			bitmap, bitmapWidth, bitmapHeight;

			if ( material instanceof THREE.ParticleBasicMaterial ) {

				if ( material.map === null ) {

					scaleX = element.object.scale.x;
					scaleY = element.object.scale.y;

					// TODO: Be able to disable this

					scaleX *= element.scale.x * _canvasWidthHalf;
					scaleY *= element.scale.y * _canvasHeightHalf;

					_elemBox.min.set( v1.x - scaleX, v1.y - scaleY );
					_elemBox.max.set( v1.x + scaleX, v1.y + scaleY );

					if ( _clipBox.isIntersectionBox( _elemBox ) === false ) {

						return;

					}

					setFillStyle( material.color.getStyle() );

					_context.save();
					_context.translate( v1.x, v1.y );
					_context.rotate( - element.rotation );
					_context.scale( scaleX, scaleY );
					_context.fillRect( -1, -1, 2, 2 );
					_context.restore();

				} else {

					bitmap = material.map.image;
					bitmapWidth = bitmap.width >> 1;
					bitmapHeight = bitmap.height >> 1;

					scaleX = element.scale.x * _canvasWidthHalf;
					scaleY = element.scale.y * _canvasHeightHalf;

					width = scaleX * bitmapWidth;
					height = scaleY * bitmapHeight;

					// TODO: Rotations break this...

					_elemBox.min.set( v1.x - width, v1.y - height );
					_elemBox.max.set( v1.x + width, v1.y + height );

					if ( _clipBox.isIntersectionBox( _elemBox ) === false ) {

						return;

					}

					_context.save();
					_context.translate( v1.x, v1.y );
					_context.rotate( - element.rotation );
					_context.scale( scaleX, - scaleY );

					_context.translate( - bitmapWidth, - bitmapHeight );
					_context.drawImage( bitmap, 0, 0 );
					_context.restore();

				}

				/* DEBUG
				setStrokeStyle( 'rgb(255,255,0)' );
				_context.beginPath();
				_context.moveTo( v1.x - 10, v1.y );
				_context.lineTo( v1.x + 10, v1.y );
				_context.moveTo( v1.x, v1.y - 10 );
				_context.lineTo( v1.x, v1.y + 10 );
				_context.stroke();
				*/

			} else if ( material instanceof THREE.ParticleCanvasMaterial ) {

				width = element.scale.x * _canvasWidthHalf;
				height = element.scale.y * _canvasHeightHalf;

				_elemBox.min.set( v1.x - width, v1.y - height );
				_elemBox.max.set( v1.x + width, v1.y + height );

				if ( _clipBox.isIntersectionBox( _elemBox ) === false ) {

					return;

				}

				setStrokeStyle( material.color.getStyle() );
				setFillStyle( material.color.getStyle() );

				_context.save();
				_context.translate( v1.x, v1.y );
				_context.rotate( - element.rotation );
				_context.scale( width, height );

				material.program( _context );

				_context.restore();

			}

		}

		function renderLine( v1, v2, element, material ) {

			setOpacity( material.opacity );
			setBlending( material.blending );

			_context.beginPath();
			_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );
			_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );

			if ( material instanceof THREE.LineBasicMaterial ) {

				setLineWidth( material.linewidth );
				setLineCap( material.linecap );
				setLineJoin( material.linejoin );
				setStrokeStyle( material.color.getStyle() );
				setDashAndGap( null, null );

				_context.stroke();
				_elemBox.expandByScalar( material.linewidth * 2 );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				setLineWidth( material.linewidth );
				setLineCap( material.linecap );
				setLineJoin( material.linejoin );
				setStrokeStyle( material.color.getStyle() );
				setDashAndGap( material.dashSize, material.gapSize );

				_context.stroke();
				_elemBox.expandByScalar( material.linewidth * 2 );

			}

		}

		function renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {

			_this.info.render.vertices += 3;
			_this.info.render.faces ++;

			setOpacity( material.opacity );
			setBlending( material.blending );

			_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
			_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
			_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;

			drawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );

			if ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {

				_diffuseColor.copy( material.color );
				_emissiveColor.copy( material.emissive );

				if ( material.vertexColors === THREE.FaceColors ) {

					_diffuseColor.multiply( element.color );

				}

				if ( _enableLighting === true ) {

					if ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 3 ) {

						_color1.copy( _ambientLight );
						_color2.copy( _ambientLight );
						_color3.copy( _ambientLight );

						calculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );
						calculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );
						calculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );

						_color1.multiply( _diffuseColor ).add( _emissiveColor );
						_color2.multiply( _diffuseColor ).add( _emissiveColor );
						_color3.multiply( _diffuseColor ).add( _emissiveColor );
						_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

						_image = getGradientTexture( _color1, _color2, _color3, _color4 );

						clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

					} else {

						_color.copy( _ambientLight );

						calculateLight( element.centroidModel, element.normalModel, _color );

						_color.multiply( _diffuseColor ).add( _emissiveColor );

						material.wireframe === true
							? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
							: fillPath( _color );

					}

				} else {

					material.wireframe === true
						? strokePath( material.color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
						: fillPath( material.color );

				}

			} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {

				if ( material.map !== null ) {

					if ( material.map.mapping instanceof THREE.UVMapping ) {

						_uvs = element.uvs[ 0 ];
						patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );

					}


				} else if ( material.envMap !== null ) {

					if ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {

						_vector3.copy( element.vertexNormalsModelView[ uv1 ] );
						_uv1x = 0.5 * _vector3.x + 0.5;
						_uv1y = 0.5 * _vector3.y + 0.5;

						_vector3.copy( element.vertexNormalsModelView[ uv2 ] );
						_uv2x = 0.5 * _vector3.x + 0.5;
						_uv2y = 0.5 * _vector3.y + 0.5;

						_vector3.copy( element.vertexNormalsModelView[ uv3 ] );
						_uv3x = 0.5 * _vector3.x + 0.5;
						_uv3y = 0.5 * _vector3.y + 0.5;

						patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );

					}/* else if ( material.envMap.mapping == THREE.SphericalRefractionMapping ) {



					}*/


				} else {

					_color.copy( material.color );

					if ( material.vertexColors === THREE.FaceColors ) {

						_color.multiply( element.color );

					}

					material.wireframe === true
						? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
						: fillPath( _color );

				}

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				_near = camera.near;
				_far = camera.far;

				_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );
				_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );
				_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );
				_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				var normal;

				if ( material.shading == THREE.FlatShading ) {

					normal = element.normalModelView;

					_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

					material.wireframe === true
						? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
						: fillPath( _color );

				} else if ( material.shading == THREE.SmoothShading ) {

					normal = element.vertexNormalsModelView[ uv1 ];
					_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

					normal = element.vertexNormalsModelView[ uv2 ];
					_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

					normal = element.vertexNormalsModelView[ uv3 ];
					_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

					_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

					_image = getGradientTexture( _color1, _color2, _color3, _color4 );

					clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

				}

			}

		}

		function renderFace4( v1, v2, v3, v4, v5, v6, element, material ) {

			_this.info.render.vertices += 4;
			_this.info.render.faces ++;

			setOpacity( material.opacity );
			setBlending( material.blending );

			if ( ( material.map !== undefined && material.map !== null ) || ( material.envMap !== undefined && material.envMap !== null ) ) {

				// Let renderFace3() handle this

				renderFace3( v1, v2, v4, 0, 1, 3, element, material );
				renderFace3( v5, v3, v6, 1, 2, 3, element, material );

				return;

			}

			_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
			_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
			_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;
			_v4x = v4.positionScreen.x; _v4y = v4.positionScreen.y;
			_v5x = v5.positionScreen.x; _v5y = v5.positionScreen.y;
			_v6x = v6.positionScreen.x; _v6y = v6.positionScreen.y;

			if ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {

				_diffuseColor.copy( material.color );
				_emissiveColor.copy( material.emissive );

				if ( material.vertexColors === THREE.FaceColors ) {

					_diffuseColor.multiply( element.color );

				}

				if ( _enableLighting === true ) {

					if ( material.wireframe === false && material.shading == THREE.SmoothShading && element.vertexNormalsLength == 4 ) {

						_color1.copy( _ambientLight );
						_color2.copy( _ambientLight );
						_color3.copy( _ambientLight );
						_color4.copy( _ambientLight );

						calculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );
						calculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );
						calculateLight( element.v4.positionWorld, element.vertexNormalsModel[ 3 ], _color3 );
						calculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color4 );

						_color1.multiply( _diffuseColor ).add( _emissiveColor );
						_color2.multiply( _diffuseColor ).add( _emissiveColor );
						_color3.multiply( _diffuseColor ).add( _emissiveColor );
						_color4.multiply( _diffuseColor ).add( _emissiveColor );

						_image = getGradientTexture( _color1, _color2, _color3, _color4 );

						// TODO: UVs are incorrect, v4->v3?

						drawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );
						clipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );

						drawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );
						clipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );

					} else {

						_color.copy( _ambientLight );

						calculateLight( element.centroidModel, element.normalModel, _color );

						_color.multiply( _diffuseColor ).add( _emissiveColor );

						drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );

						material.wireframe === true
							? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
							: fillPath( _color );

					}

				} else {

					_color.addColors( _diffuseColor, _emissiveColor );

					drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );

					material.wireframe === true
						? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
						: fillPath( _color );

				}

			} else if ( material instanceof THREE.MeshBasicMaterial ) {

				_color.copy( material.color );

				if ( material.vertexColors === THREE.FaceColors ) {

					_color.multiply( element.color );

				}

				drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				var normal;

				if ( material.shading == THREE.FlatShading ) {

					normal = element.normalModelView;
					_color.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

					drawQuad( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _v4x, _v4y );

					material.wireframe === true
						? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
						: fillPath( _color );

				} else if ( material.shading == THREE.SmoothShading ) {

					normal = element.vertexNormalsModelView[ 0 ];
					_color1.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

					normal = element.vertexNormalsModelView[ 1 ];
					_color2.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

					normal = element.vertexNormalsModelView[ 3 ];
					_color3.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

					normal = element.vertexNormalsModelView[ 2 ];
					_color4.setRGB( normal.x, normal.y, normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

					_image = getGradientTexture( _color1, _color2, _color3, _color4 );

					drawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );
					clipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );

					drawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );
					clipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );

				}



			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				_near = camera.near;
				_far = camera.far;

				_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );
				_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );
				_color3.r = _color3.g = _color3.b = 1 - smoothstep( v4.positionScreen.z * v4.positionScreen.w, _near, _far );
				_color4.r = _color4.g = _color4.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				// TODO: UVs are incorrect, v4->v3?

				drawTriangle( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y );
				clipImage( _v1x, _v1y, _v2x, _v2y, _v4x, _v4y, 0, 0, 1, 0, 0, 1, _image );

				drawTriangle( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y );
				clipImage( _v5x, _v5y, _v3x, _v3y, _v6x, _v6y, 1, 0, 1, 1, 0, 1, _image );

			}

		}

		//

		function drawTriangle( x0, y0, x1, y1, x2, y2 ) {

			_context.beginPath();
			_context.moveTo( x0, y0 );
			_context.lineTo( x1, y1 );
			_context.lineTo( x2, y2 );
			_context.closePath();

		}

		function drawQuad( x0, y0, x1, y1, x2, y2, x3, y3 ) {

			_context.beginPath();
			_context.moveTo( x0, y0 );
			_context.lineTo( x1, y1 );
			_context.lineTo( x2, y2 );
			_context.lineTo( x3, y3 );
			_context.closePath();

		}

		function strokePath( color, linewidth, linecap, linejoin ) {

			setLineWidth( linewidth );
			setLineCap( linecap );
			setLineJoin( linejoin );
			setStrokeStyle( color.getStyle() );

			_context.stroke();

			_elemBox.expandByScalar( linewidth * 2 );

		}

		function fillPath( color ) {

			setFillStyle( color.getStyle() );
			_context.fill();

		}

		function patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {

			if ( texture instanceof THREE.DataTexture || texture.image === undefined || texture.image.width == 0 ) return;

			if ( texture.needsUpdate === true ) {

				var repeatX = texture.wrapS == THREE.RepeatWrapping;
				var repeatY = texture.wrapT == THREE.RepeatWrapping;

				_patterns[ texture.id ] = _context.createPattern(
					texture.image, repeatX === true && repeatY === true
						? 'repeat'
						: repeatX === true && repeatY === false
							? 'repeat-x'
							: repeatX === false && repeatY === true
								? 'repeat-y'
								: 'no-repeat'
				);

				texture.needsUpdate = false;

			}

			_patterns[ texture.id ] === undefined
				? setFillStyle( 'rgba(0,0,0,1)' )
				: setFillStyle( _patterns[ texture.id ] );

			// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

			var a, b, c, d, e, f, det, idet,
			offsetX = texture.offset.x / texture.repeat.x,
			offsetY = texture.offset.y / texture.repeat.y,
			width = texture.image.width * texture.repeat.x,
			height = texture.image.height * texture.repeat.y;

			u0 = ( u0 + offsetX ) * width;
			v0 = ( 1.0 - v0 + offsetY ) * height;

			u1 = ( u1 + offsetX ) * width;
			v1 = ( 1.0 - v1 + offsetY ) * height;

			u2 = ( u2 + offsetX ) * width;
			v2 = ( 1.0 - v2 + offsetY ) * height;

			x1 -= x0; y1 -= y0;
			x2 -= x0; y2 -= y0;

			u1 -= u0; v1 -= v0;
			u2 -= u0; v2 -= v0;

			det = u1 * v2 - u2 * v1;

			if ( det === 0 ) {

				if ( _imagedatas[ texture.id ] === undefined ) {

					var canvas = document.createElement( 'canvas' )
					canvas.width = texture.image.width;
					canvas.height = texture.image.height;

					var context = canvas.getContext( '2d' );
					context.drawImage( texture.image, 0, 0 );

					_imagedatas[ texture.id ] = context.getImageData( 0, 0, texture.image.width, texture.image.height ).data;

				}

				var data = _imagedatas[ texture.id ];
				var index = ( Math.floor( u0 ) + Math.floor( v0 ) * texture.image.width ) * 4;

				_color.setRGB( data[ index ] / 255, data[ index + 1 ] / 255, data[ index + 2 ] / 255 );
				fillPath( _color );

				return;

			}

			idet = 1 / det;

			a = ( v2 * x1 - v1 * x2 ) * idet;
			b = ( v2 * y1 - v1 * y2 ) * idet;
			c = ( u1 * x2 - u2 * x1 ) * idet;
			d = ( u1 * y2 - u2 * y1 ) * idet;

			e = x0 - a * u0 - c * v0;
			f = y0 - b * u0 - d * v0;

			_context.save();
			_context.transform( a, b, c, d, e, f );
			_context.fill();
			_context.restore();

		}

		function clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {

			// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

			var a, b, c, d, e, f, det, idet,
			width = image.width - 1,
			height = image.height - 1;

			u0 *= width; v0 *= height;
			u1 *= width; v1 *= height;
			u2 *= width; v2 *= height;

			x1 -= x0; y1 -= y0;
			x2 -= x0; y2 -= y0;

			u1 -= u0; v1 -= v0;
			u2 -= u0; v2 -= v0;

			det = u1 * v2 - u2 * v1;

			idet = 1 / det;

			a = ( v2 * x1 - v1 * x2 ) * idet;
			b = ( v2 * y1 - v1 * y2 ) * idet;
			c = ( u1 * x2 - u2 * x1 ) * idet;
			d = ( u1 * y2 - u2 * y1 ) * idet;

			e = x0 - a * u0 - c * v0;
			f = y0 - b * u0 - d * v0;

			_context.save();
			_context.transform( a, b, c, d, e, f );
			_context.clip();
			_context.drawImage( image, 0, 0 );
			_context.restore();

		}

		function getGradientTexture( color1, color2, color3, color4 ) {

			// http://mrdoob.com/blog/post/710

			_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;
			_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;
			_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;

			_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;
			_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;
			_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;

			_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;
			_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;
			_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;

			_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;
			_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;
			_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;

			_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );
			_gradientMapContext.drawImage( _pixelMap, 0, 0 );

			return _gradientMap;

		}

		// Hide anti-alias gaps

		function expand( v1, v2 ) {

			var x = v2.x - v1.x, y =  v2.y - v1.y,
			det = x * x + y * y, idet;

			if ( det === 0 ) return;

			idet = 1 / Math.sqrt( det );

			x *= idet; y *= idet;

			v2.x += x; v2.y += y;
			v1.x -= x; v1.y -= y;

		}
	};

	// Context cached methods.

	function setOpacity( value ) {

		if ( _contextGlobalAlpha !== value ) {

			_context.globalAlpha = value;
			_contextGlobalAlpha = value;

		}

	}

	function setBlending( value ) {

		if ( _contextGlobalCompositeOperation !== value ) {

			if ( value === THREE.NormalBlending ) {

				_context.globalCompositeOperation = 'source-over';

			} else if ( value === THREE.AdditiveBlending ) {

				_context.globalCompositeOperation = 'lighter';

			} else if ( value === THREE.SubtractiveBlending ) {

				_context.globalCompositeOperation = 'darker';

			}

			_contextGlobalCompositeOperation = value;

		}

	}

	function setLineWidth( value ) {

		if ( _contextLineWidth !== value ) {

			_context.lineWidth = value;
			_contextLineWidth = value;

		}

	}

	function setLineCap( value ) {

		// "butt", "round", "square"

		if ( _contextLineCap !== value ) {

			_context.lineCap = value;
			_contextLineCap = value;

		}

	}

	function setLineJoin( value ) {

		// "round", "bevel", "miter"

		if ( _contextLineJoin !== value ) {

			_context.lineJoin = value;
			_contextLineJoin = value;

		}

	}

	function setStrokeStyle( value ) {

		if ( _contextStrokeStyle !== value ) {

			_context.strokeStyle = value;
			_contextStrokeStyle = value;

		}

	}

	function setFillStyle( value ) {

		if ( _contextFillStyle !== value ) {

			_context.fillStyle = value;
			_contextFillStyle = value;

		}

	}

	function setDashAndGap( dashSizeValue, gapSizeValue ) {

		if ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {

			_context.setLineDash( [ dashSizeValue, gapSizeValue ] );
			_contextDashSize = dashSizeValue;
			_contextGapSize = gapSizeValue;

		}

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

THREE.ShaderChunk = {

	// FOG

	fog_pars_fragment: [

		"#ifdef USE_FOG",

			"uniform vec3 fogColor;",

			"#ifdef FOG_EXP2",

				"uniform float fogDensity;",

			"#else",

				"uniform float fogNear;",
				"uniform float fogFar;",

			"#endif",

		"#endif"

	].join("\n"),

	fog_fragment: [

		"#ifdef USE_FOG",

			"float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"#ifdef FOG_EXP2",

				"const float LOG2 = 1.442695;",
				"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
				"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",

			"#else",

				"float fogFactor = smoothstep( fogNear, fogFar, depth );",

			"#endif",

			"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

		"#endif"

	].join("\n"),

	// ENVIRONMENT MAP

	envmap_pars_fragment: [

		"#ifdef USE_ENVMAP",

			"uniform float reflectivity;",
			"uniform samplerCube envMap;",
			"uniform float flipEnvMap;",
			"uniform int combine;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"uniform bool useRefract;",
				"uniform float refractionRatio;",

			"#else",

				"varying vec3 vReflect;",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_fragment: [

		"#ifdef USE_ENVMAP",

			"vec3 reflectVec;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

				"if ( useRefract ) {",

					"reflectVec = refract( cameraToVertex, normal, refractionRatio );",

				"} else { ",

					"reflectVec = reflect( cameraToVertex, normal );",

				"}",

			"#else",

				"reflectVec = vReflect;",

			"#endif",

			"#ifdef DOUBLE_SIDED",

				"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
				"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#else",

				"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#endif",

			"#ifdef GAMMA_INPUT",

				"cubeColor.xyz *= cubeColor.xyz;",

			"#endif",

			"if ( combine == 1 ) {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );",

			"} else if ( combine == 2 ) {",

				"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;",

			"} else {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );",

			"}",

		"#endif"

	].join("\n"),

	envmap_pars_vertex: [

		"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"varying vec3 vReflect;",

			"uniform float refractionRatio;",
			"uniform bool useRefract;",

		"#endif"

	].join("\n"),

	worldpos_vertex : [

		"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",

			"#ifdef USE_SKINNING",

				"vec4 worldPosition = modelMatrix * skinned;",

			"#endif",

			"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );",

			"#endif",

			"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_vertex : [

		"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;",
			"worldNormal = normalize( worldNormal );",

			"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",

			"if ( useRefract ) {",

				"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",

			"} else {",

				"vReflect = reflect( cameraToVertex, worldNormal );",

			"}",

		"#endif"

	].join("\n"),

	// COLOR MAP (particles)

	map_particle_pars_fragment: [

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),


	map_particle_fragment: [

		"#ifdef USE_MAP",

			"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );",

		"#endif"

	].join("\n"),

	// COLOR MAP (triangles)

	map_pars_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"varying vec2 vUv;",
			"uniform vec4 offsetRepeat;",

		"#endif"

	].join("\n"),

	map_pars_fragment: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"varying vec2 vUv;",

		"#endif",

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),

	map_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",

		"#endif"

	].join("\n"),

	map_fragment: [

		"#ifdef USE_MAP",

			"vec4 texelColor = texture2D( map, vUv );",

			"#ifdef GAMMA_INPUT",

				"texelColor.xyz *= texelColor.xyz;",

			"#endif",

			"gl_FragColor = gl_FragColor * texelColor;",

		"#endif"

	].join("\n"),

	// LIGHT MAP

	lightmap_pars_fragment: [

		"#ifdef USE_LIGHTMAP",

			"varying vec2 vUv2;",
			"uniform sampler2D lightMap;",

		"#endif"

	].join("\n"),

	lightmap_pars_vertex: [

		"#ifdef USE_LIGHTMAP",

			"varying vec2 vUv2;",

		"#endif"

	].join("\n"),

	lightmap_fragment: [

		"#ifdef USE_LIGHTMAP",

			"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );",

		"#endif"

	].join("\n"),

	lightmap_vertex: [

		"#ifdef USE_LIGHTMAP",

			"vUv2 = uv2;",

		"#endif"

	].join("\n"),

	// BUMP MAP

	bumpmap_pars_fragment: [

		"#ifdef USE_BUMPMAP",

			"uniform sampler2D bumpMap;",
			"uniform float bumpScale;",

			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html

			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

			"vec2 dHdxy_fwd() {",

				"vec2 dSTdx = dFdx( vUv );",
				"vec2 dSTdy = dFdy( vUv );",

				"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
				"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
				"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",

				"return vec2( dBx, dBy );",

			"}",

			"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",

				"vec3 vSigmaX = dFdx( surf_pos );",
				"vec3 vSigmaY = dFdy( surf_pos );",
				"vec3 vN = surf_norm;",		// normalized

				"vec3 R1 = cross( vSigmaY, vN );",
				"vec3 R2 = cross( vN, vSigmaX );",

				"float fDet = dot( vSigmaX, R1 );",

				"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
				"return normalize( abs( fDet ) * surf_norm - vGrad );",

			"}",

		"#endif"

	].join("\n"),

	// NORMAL MAP

	normalmap_pars_fragment: [

		"#ifdef USE_NORMALMAP",

			"uniform sampler2D normalMap;",
			"uniform vec2 normalScale;",

			// Per-Pixel Tangent Space Normal Mapping
			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

			"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",

				"vec3 q0 = dFdx( eye_pos.xyz );",
				"vec3 q1 = dFdy( eye_pos.xyz );",
				"vec2 st0 = dFdx( vUv.st );",
				"vec2 st1 = dFdy( vUv.st );",

				"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
				"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
				"vec3 N = normalize( surf_norm );",

				"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;",
				"mapN.xy = normalScale * mapN.xy;",
				"mat3 tsn = mat3( S, T, N );",
				"return normalize( tsn * mapN );",

			"}",

		"#endif"

	].join("\n"),

	// SPECULAR MAP

	specularmap_pars_fragment: [

		"#ifdef USE_SPECULARMAP",

			"uniform sampler2D specularMap;",

		"#endif"

	].join("\n"),

	specularmap_fragment: [

		"float specularStrength;",

		"#ifdef USE_SPECULARMAP",

			"vec4 texelSpecular = texture2D( specularMap, vUv );",
			"specularStrength = texelSpecular.r;",

		"#else",

			"specularStrength = 1.0;",

		"#endif"

	].join("\n"),

	// LIGHTS LAMBERT

	lights_lambert_pars_vertex: [

		"uniform vec3 ambient;",
		"uniform vec3 diffuse;",
		"uniform vec3 emissive;",

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif"

	].join("\n"),

	lights_lambert_vertex: [

		"vLightFront = vec3( 0.0 );",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = vec3( 0.0 );",

		"#endif",

		"transformedNormal = normalize( transformedNormal );",

		"#if MAX_DIR_LIGHTS > 0",

		"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

			"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
			"vec3 dirVector = normalize( lDirection.xyz );",

			"float dotProduct = dot( transformedNormal, dirVector );",
			"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",

			"#ifdef DOUBLE_SIDED",

				"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

				"#ifdef WRAP_AROUND",

					"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

				"#endif",

			"#endif",

			"#ifdef WRAP_AROUND",

				"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
				"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",

				"#ifdef DOUBLE_SIDED",

					"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",

				"#endif",

			"#endif",

			"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",

			"#ifdef DOUBLE_SIDED",

				"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",

			"#endif",

		"}",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( pointLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

				"lVector = normalize( lVector );",
				"float dotProduct = dot( transformedNormal, lVector );",

				"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",

				"#ifdef DOUBLE_SIDED",

					"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

					"#ifdef WRAP_AROUND",

						"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

					"#endif",

				"#endif",

				"#ifdef WRAP_AROUND",

					"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
					"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",

					"#ifdef DOUBLE_SIDED",

						"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",

					"#endif",

				"#endif",

				"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					"float lDistance = 1.0;",
					"if ( spotLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

					"float dotProduct = dot( transformedNormal, lVector );",
					"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",

					"#ifdef DOUBLE_SIDED",

						"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

						"#ifdef WRAP_AROUND",

							"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

						"#endif",

					"#endif",

					"#ifdef WRAP_AROUND",

						"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
						"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",

						"#ifdef DOUBLE_SIDED",

							"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",

						"#endif",

					"#endif",

					"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;",

					"#ifdef DOUBLE_SIDED",

						"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;",

					"#endif",

				"}",

			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				"float dotProduct = dot( transformedNormal, lVector );",

				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
				"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",

				"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",

				"#endif",

			"}",

		"#endif",

		"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;",

		"#endif"

	].join("\n"),

	// LIGHTS PHONG

	lights_phong_pars_vertex: [

		"#ifndef PHONG_PER_PIXEL",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif"

	].join("\n"),


	lights_phong_vertex: [

		"#ifndef PHONG_PER_PIXEL",

		"#if MAX_POINT_LIGHTS > 0",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( pointLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

				"vPointLight[ i ] = vec4( lVector, lDistance );",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( spotLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

				"vSpotLight[ i ] = vec4( lVector, lDistance );",

			"}",

		"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"vWorldPosition = worldPosition.xyz;",

		"#endif"

	].join("\n"),

	lights_phong_pars_fragment: [

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",

			"#ifdef PHONG_PER_PIXEL",

				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#else",

				"varying vec4 vPointLight[ MAX_POINT_LIGHTS ];",

			"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",

			"#ifdef PHONG_PER_PIXEL",

				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#else",

				"varying vec4 vSpotLight[ MAX_SPOT_LIGHTS ];",

			"#endif",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif",

		"varying vec3 vViewPosition;",
		"varying vec3 vNormal;"

	].join("\n"),

	lights_phong_fragment: [

		"vec3 normal = normalize( vNormal );",
		"vec3 viewPosition = normalize( vViewPosition );",

		"#ifdef DOUBLE_SIDED",

			"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

		"#endif",

		"#ifdef USE_NORMALMAP",

			"normal = perturbNormal2Arb( -viewPosition, normal );",

		"#elif defined( USE_BUMPMAP )",

			"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"vec3 pointDiffuse  = vec3( 0.0 );",
			"vec3 pointSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"#ifdef PHONG_PER_PIXEL",

					"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

					"float lDistance = 1.0;",
					"if ( pointLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

				"#else",

					"vec3 lVector = normalize( vPointLight[ i ].xyz );",
					"float lDistance = vPointLight[ i ].w;",

				"#endif",

				// diffuse

				"float dotProduct = dot( normal, lVector );",

				"#ifdef WRAP_AROUND",

					"float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
					"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

					"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

				"#else",

					"float pointDiffuseWeight = max( dotProduct, 0.0 );",

				"#endif",

				"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;",

				// specular

				"vec3 pointHalfVector = normalize( lVector + viewPosition );",
				"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
				"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

				"#ifdef PHYSICALLY_BASED_SHADING",

					// 2.0 => 2.0001 is hack to work around ANGLE bug

					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, pointHalfVector ), 5.0 );",
					"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;",

				"#else",

					"pointSpecular += specular * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"vec3 spotDiffuse  = vec3( 0.0 );",
			"vec3 spotSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"#ifdef PHONG_PER_PIXEL",

					"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
					"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

					"float lDistance = 1.0;",
					"if ( spotLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

				"#else",

					"vec3 lVector = normalize( vSpotLight[ i ].xyz );",
					"float lDistance = vSpotLight[ i ].w;",

				"#endif",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					// diffuse

					"float dotProduct = dot( normal, lVector );",

					"#ifdef WRAP_AROUND",

						"float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
						"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

						"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

					"#else",

						"float spotDiffuseWeight = max( dotProduct, 0.0 );",

					"#endif",

					"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;",

					// specular

					"vec3 spotHalfVector = normalize( lVector + viewPosition );",
					"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
					"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

					"#ifdef PHYSICALLY_BASED_SHADING",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, spotHalfVector ), 5.0 );",
						"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",

					"#else",

						"spotSpecular += specular * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * spotEffect;",

					"#endif",

				"}",

			"}",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"vec3 dirDiffuse  = vec3( 0.0 );",
			"vec3 dirSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"vec3 dirVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, dirVector );",

				"#ifdef WRAP_AROUND",

					"float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
					"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

					"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",

				"#else",

					"float dirDiffuseWeight = max( dotProduct, 0.0 );",

				"#endif",

				"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",

				// specular

				"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
				"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
				"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

				"#ifdef PHYSICALLY_BASED_SHADING",

					/*
					// fresnel term from skin shader
					"const float F0 = 0.128;",

					"float base = 1.0 - dot( viewPosition, dirHalfVector );",
					"float exponential = pow( base, 5.0 );",

					"float fresnel = exponential + F0 * ( 1.0 - exponential );",
					*/

					/*
					// fresnel term from fresnel shader
					"const float mFresnelBias = 0.08;",
					"const float mFresnelScale = 0.3;",
					"const float mFresnelPower = 5.0;",

					"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );",
					*/

					// 2.0 => 2.0001 is hack to work around ANGLE bug

					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

					//"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;",

					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
					"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

				"#else",

					"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"vec3 hemiDiffuse  = vec3( 0.0 );",
			"vec3 hemiSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, lVector );",
				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

				"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"hemiDiffuse += diffuse * hemiColor;",

				// specular (sky light)

				"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
				"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
				"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",

				// specular (ground light)

				"vec3 lVectorGround = -lVector;",

				"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
				"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
				"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",

				"#ifdef PHYSICALLY_BASED_SHADING",

					"float dotProductGround = dot( normal, lVectorGround );",

					// 2.0 => 2.0001 is hack to work around ANGLE bug

					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

					"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
					"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
					"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

				"#else",

					"hemiSpecular += specular * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;",

				"#endif",

			"}",

		"#endif",

		"vec3 totalDiffuse = vec3( 0.0 );",
		"vec3 totalSpecular = vec3( 0.0 );",

		"#if MAX_DIR_LIGHTS > 0",

			"totalDiffuse += dirDiffuse;",
			"totalSpecular += dirSpecular;",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"totalDiffuse += hemiDiffuse;",
			"totalSpecular += hemiSpecular;",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"totalDiffuse += pointDiffuse;",
			"totalSpecular += pointSpecular;",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"totalDiffuse += spotDiffuse;",
			"totalSpecular += spotSpecular;",

		"#endif",

		"#ifdef METAL",

			"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );",

		"#else",

			"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

		"#endif"

	].join("\n"),

	// VERTEX COLORS

	color_pars_fragment: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_fragment: [

		"#ifdef USE_COLOR",

			"gl_FragColor = gl_FragColor * vec4( vColor, opacity );",

		"#endif"

	].join("\n"),

	color_pars_vertex: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_vertex: [

		"#ifdef USE_COLOR",

			"#ifdef GAMMA_INPUT",

				"vColor = color * color;",

			"#else",

				"vColor = color;",

			"#endif",

		"#endif"

	].join("\n"),

	// SKINNING

	skinning_pars_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef BONE_TEXTURE",

				"uniform sampler2D boneTexture;",

				"mat4 getBoneMatrix( const in float i ) {",

					"float j = i * 4.0;",
					"float x = mod( j, N_BONE_PIXEL_X );",
					"float y = floor( j / N_BONE_PIXEL_X );",

					"const float dx = 1.0 / N_BONE_PIXEL_X;",
					"const float dy = 1.0 / N_BONE_PIXEL_Y;",

					"y = dy * ( y + 0.5 );",

					"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
					"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
					"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
					"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",

					"mat4 bone = mat4( v1, v2, v3, v4 );",

					"return bone;",

				"}",

			"#else",

				"uniform mat4 boneGlobalMatrices[ MAX_BONES ];",

				"mat4 getBoneMatrix( const in float i ) {",

					"mat4 bone = boneGlobalMatrices[ int(i) ];",
					"return bone;",

				"}",

			"#endif",

		"#endif"

	].join("\n"),

	skinbase_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 boneMatX = getBoneMatrix( skinIndex.x );",
			"mat4 boneMatY = getBoneMatrix( skinIndex.y );",

		"#endif"

	].join("\n"),

	skinning_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef USE_MORPHTARGETS",

			"vec4 skinVertex = vec4( morphed, 1.0 );",

			"#else",

			"vec4 skinVertex = vec4( position, 1.0 );",

			"#endif",

			"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
			"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

		"#endif"

	].join("\n"),

	// MORPHING

	morphtarget_pars_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"#ifndef USE_MORPHNORMALS",

			"uniform float morphTargetInfluences[ 8 ];",

			"#else",

			"uniform float morphTargetInfluences[ 4 ];",

			"#endif",

		"#endif"

	].join("\n"),

	morphtarget_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"vec3 morphed = vec3( 0.0 );",
			"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
			"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
			"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
			"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",

			"#ifndef USE_MORPHNORMALS",

			"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
			"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
			"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
			"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",

			"#endif",

			"morphed += position;",

		"#endif"

	].join("\n"),

	default_vertex : [

		"vec4 mvPosition;",

		"#ifdef USE_SKINNING",

			"mvPosition = modelViewMatrix * skinned;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( position, 1.0 );",

		"#endif",

		"gl_Position = projectionMatrix * mvPosition;"

	].join("\n"),

	morphnormal_vertex: [

		"#ifdef USE_MORPHNORMALS",

			"vec3 morphedNormal = vec3( 0.0 );",

			"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
			"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
			"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
			"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",

			"morphedNormal += normal;",

		"#endif"

	].join("\n"),

	skinnormal_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 skinMatrix = skinWeight.x * boneMatX;",
			"skinMatrix 	+= skinWeight.y * boneMatY;",

			"#ifdef USE_MORPHNORMALS",

			"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );",

			"#else",

			"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	defaultnormal_vertex: [

		"vec3 objectNormal;",

		"#ifdef USE_SKINNING",

			"objectNormal = skinnedNormal.xyz;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )",

			"objectNormal = morphedNormal;",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )",

			"objectNormal = normal;",

		"#endif",

		"#ifdef FLIP_SIDED",

			"objectNormal = -objectNormal;",

		"#endif",

		"vec3 transformedNormal = normalMatrix * objectNormal;"

	].join("\n"),

	// SHADOW MAP

	// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples
	//  http://spidergl.org/example.php?id=6
	// 	http://fabiensanglard.net/shadowmapping

	shadowmap_pars_fragment: [

		"#ifdef USE_SHADOWMAP",

			"uniform sampler2D shadowMap[ MAX_SHADOWS ];",
			"uniform vec2 shadowMapSize[ MAX_SHADOWS ];",

			"uniform float shadowDarkness[ MAX_SHADOWS ];",
			"uniform float shadowBias[ MAX_SHADOWS ];",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",

			"float unpackDepth( const in vec4 rgba_depth ) {",

				"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"float depth = dot( rgba_depth, bit_shift );",
				"return depth;",

			"}",

		"#endif"

	].join("\n"),

	shadowmap_fragment: [

		"#ifdef USE_SHADOWMAP",

			"#ifdef SHADOWMAP_DEBUG",

				"vec3 frustumColors[3];",
				"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
				"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
				"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",

			"#endif",

			"#ifdef SHADOWMAP_CASCADE",

				"int inFrustumCount = 0;",

			"#endif",

			"float fDepth;",
			"vec3 shadowColor = vec3( 1.0 );",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",

				// "if ( something && something )" 		 breaks ATI OpenGL shader compiler
				// "if ( all( something, something ) )"  using this instead

				"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
				"bool inFrustum = all( inFrustumVec );",

				// don't shadow pixels outside of light frustum
				// use just first frustum (for cascades)
				// don't shadow pixels behind far plane of light frustum

				"#ifdef SHADOWMAP_CASCADE",

					"inFrustumCount += int( inFrustum );",
					"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );",

				"#else",

					"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",

				"#endif",

				"bool frustumTest = all( frustumTestVec );",

				"if ( frustumTest ) {",

					"shadowCoord.z += shadowBias[ i ];",

					"#if defined( SHADOWMAP_TYPE_PCF )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						/*
						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL
						// must enroll loop manually

						"for ( float y = -1.25; y <= 1.25; y += 1.25 )",
							"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {",

								"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );",

								// doesn't seem to produce any noticeable visual difference compared to simple "texture2D" lookup
								//"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );",

								"float fDepth = unpackDepth( rgbaDepth );",

								"if ( fDepth < shadowCoord.z )",
									"shadow += 1.0;",

						"}",

						"shadow /= 9.0;",

						*/

						"const float shadowDelta = 1.0 / 9.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.25 * xPixelOffset;",
						"float dy0 = -1.25 * yPixelOffset;",
						"float dx1 = 1.25 * xPixelOffset;",
						"float dy1 = 1.25 * yPixelOffset;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.0 * xPixelOffset;",
						"float dy0 = -1.0 * yPixelOffset;",
						"float dx1 = 1.0 * xPixelOffset;",
						"float dy1 = 1.0 * yPixelOffset;",

						"mat3 shadowKernel;",
						"mat3 depthKernel;",

						"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"if ( depthKernel[0][0] < shadowCoord.z ) shadowKernel[0][0] = 0.25;",
						"else shadowKernel[0][0] = 0.0;",

						"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"if ( depthKernel[0][1] < shadowCoord.z ) shadowKernel[0][1] = 0.25;",
						"else shadowKernel[0][1] = 0.0;",

						"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"if ( depthKernel[0][2] < shadowCoord.z ) shadowKernel[0][2] = 0.25;",
						"else shadowKernel[0][2] = 0.0;",

						"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"if ( depthKernel[1][0] < shadowCoord.z ) shadowKernel[1][0] = 0.25;",
						"else shadowKernel[1][0] = 0.0;",

						"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"if ( depthKernel[1][1] < shadowCoord.z ) shadowKernel[1][1] = 0.25;",
						"else shadowKernel[1][1] = 0.0;",

						"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"if ( depthKernel[1][2] < shadowCoord.z ) shadowKernel[1][2] = 0.25;",
						"else shadowKernel[1][2] = 0.0;",

						"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"if ( depthKernel[2][0] < shadowCoord.z ) shadowKernel[2][0] = 0.25;",
						"else shadowKernel[2][0] = 0.0;",

						"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"if ( depthKernel[2][1] < shadowCoord.z ) shadowKernel[2][1] = 0.25;",
						"else shadowKernel[2][1] = 0.0;",

						"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
						"if ( depthKernel[2][2] < shadowCoord.z ) shadowKernel[2][2] = 0.25;",
						"else shadowKernel[2][2] = 0.0;",

						"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );",

						"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
						"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",

						"vec4 shadowValues;",
						"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
						"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
						"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
						"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",

						"shadow = dot( shadowValues, vec4( 1.0 ) );",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#else",

						"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
						"float fDepth = unpackDepth( rgbaDepth );",

						"if ( fDepth < shadowCoord.z )",

							// spot with multiple shadows is darker

							"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );",

							// spot with multiple shadows has the same color as single shadow spot

							//"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );",

					"#endif",

				"}",


				"#ifdef SHADOWMAP_DEBUG",

					"#ifdef SHADOWMAP_CASCADE",

						"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#else",

						"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#endif",

				"#endif",

			"}",

			"#ifdef GAMMA_OUTPUT",

				"shadowColor *= shadowColor;",

			"#endif",

			"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",

		"#endif"

	].join("\n"),

	shadowmap_pars_vertex: [

		"#ifdef USE_SHADOWMAP",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
			"uniform mat4 shadowMatrix[ MAX_SHADOWS ];",

		"#endif"

	].join("\n"),

	shadowmap_vertex: [

		"#ifdef USE_SHADOWMAP",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

			"}",

		"#endif"

	].join("\n"),

	// ALPHATEST

	alphatest_fragment: [

		"#ifdef ALPHATEST",

			"if ( gl_FragColor.a < ALPHATEST ) discard;",

		"#endif"

	].join("\n"),

	// LINEAR SPACE

	linear_to_gamma_fragment: [

		"#ifdef GAMMA_OUTPUT",

			"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",

		"#endif"

	].join("\n")


};

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var u, p, tmp, merged = {};

		for ( u = 0; u < uniforms.length; u ++ ) {

			tmp = this.clone( uniforms[ u ] );

			for ( p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var u, p, parameter, parameter_src, uniforms_dst = {};

		for ( u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( p in uniforms_src[ u ] ) {

				parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( parameter_src instanceof Array ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"lightMap" : { type: "t", value: null },
		"specularMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: -1 },
		"useRefract" : { type: "i", value: 0 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 },
		"combine" : { type: "i", value: 0 },

		"morphTargetInfluences" : { type: "f", value: 0 }

	},

	bump: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] }

	},

	particle: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};

THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

				"#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"#endif",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

				"varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

				"varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				"#ifdef DOUBLE_SIDED",

					//"float isFront = float( gl_FrontFacing );",
					//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

					"if ( gl_FrontFacing )",
						"gl_FragColor.xyz *= vLightFront;",
					"else",
						"gl_FragColor.xyz *= vLightBack;",

				"#else",

					"gl_FragColor.xyz *= vLightFront;",

				"#endif",

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bump" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"vNormal = normalize( transformedNormal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				"vViewPosition = -mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'particle_basic': {

		uniforms:  THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "particle" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"#ifdef USE_SIZEATTENUATION",
					"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"#else",
					"gl_PointSize = size;",
				"#endif",

				"gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( psColor, opacity );",

				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale":     { type: "f", value: 1 },
				"dashSize":  { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vLineDistance = scale * lineDistance;",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"gl_Position = projectionMatrix * mvPosition;",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],

			"void main() {",

				"if ( mod( vLineDistance, totalSize ) > dashSize ) {",

					"discard;",

				"}",

				"gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"void main() {",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			"void main() {",

				"float depth = gl_FragCoord.z / gl_FragCoord.w;",
				"float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join("\n")

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			"void main() {",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"vNormal = normalize( normalMatrix * normal );",

				"gl_Position = projectionMatrix * mvPosition;",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			"void main() {",

				"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Normal map shader
	//		- Blinn-Phong
	//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
	//		- point and directional lights (use with "lights: true" material option)
	 ------------------------------------------------------------------------- */

	'normalmap' : {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{

			"enableAO"		  : { type: "i", value: 0 },
			"enableDiffuse"	  : { type: "i", value: 0 },
			"enableSpecular"  : { type: "i", value: 0 },
			"enableReflection": { type: "i", value: 0 },
			"enableDisplacement": { type: "i", value: 0 },

			"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
			"tDiffuse"	   : { type: "t", value: null },
			"tCube"		   : { type: "t", value: null },
			"tNormal"	   : { type: "t", value: null },
			"tSpecular"	   : { type: "t", value: null },
			"tAO"		   : { type: "t", value: null },

			"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"uDisplacementBias": { type: "f", value: 0.0 },
			"uDisplacementScale": { type: "f", value: 1.0 },

			"uDiffuseColor": { type: "c", value: new THREE.Color( 0xffffff ) },
			"uSpecularColor": { type: "c", value: new THREE.Color( 0x111111 ) },
			"uAmbientColor": { type: "c", value: new THREE.Color( 0xffffff ) },
			"uShininess": { type: "f", value: 30 },
			"uOpacity": { type: "f", value: 1 },

			"useRefract": { type: "i", value: 0 },
			"uRefractionRatio": { type: "f", value: 0.98 },
			"uReflectivity": { type: "f", value: 0.5 },

			"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
			"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

			}

		] ),

		fragmentShader: [

			"uniform vec3 uAmbientColor;",
			"uniform vec3 uDiffuseColor;",
			"uniform vec3 uSpecularColor;",
			"uniform float uShininess;",
			"uniform float uOpacity;",

			"uniform bool enableDiffuse;",
			"uniform bool enableSpecular;",
			"uniform bool enableAO;",
			"uniform bool enableReflection;",

			"uniform sampler2D tDiffuse;",
			"uniform sampler2D tNormal;",
			"uniform sampler2D tSpecular;",
			"uniform sampler2D tAO;",

			"uniform samplerCube tCube;",

			"uniform vec2 uNormalScale;",

			"uniform bool useRefract;",
			"uniform float uRefractionRatio;",
			"uniform float uReflectivity;",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"uniform vec3 ambientLightColor;",

			"#if MAX_DIR_LIGHTS > 0",

				"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
				"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

			"#endif",

			"#if MAX_HEMI_LIGHTS > 0",

				"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

			"#endif",

			"#if MAX_POINT_LIGHTS > 0",

				"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#endif",

			"#if MAX_SPOT_LIGHTS > 0",

				"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#endif",

			"#ifdef WRAP_AROUND",

				"uniform vec3 wrapRGB;",

			"#endif",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3( 1.0 ), uOpacity );",

				"vec3 specularTex = vec3( 1.0 );",

				"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
				"normalTex.xy *= uNormalScale;",
				"normalTex = normalize( normalTex );",

				"if( enableDiffuse ) {",

					"#ifdef GAMMA_INPUT",

						"vec4 texelColor = texture2D( tDiffuse, vUv );",
						"texelColor.xyz *= texelColor.xyz;",

						"gl_FragColor = gl_FragColor * texelColor;",

					"#else",

						"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

					"#endif",

				"}",

				"if( enableAO ) {",

					"#ifdef GAMMA_INPUT",

						"vec4 aoColor = texture2D( tAO, vUv );",
						"aoColor.xyz *= aoColor.xyz;",

						"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",

					"#else",

						"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

					"#endif",

				"}",

				"if( enableSpecular )",
					"specularTex = texture2D( tSpecular, vUv ).xyz;",

				"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
				"vec3 finalNormal = tsb * normalTex;",

				"#ifdef FLIP_SIDED",

					"finalNormal = -finalNormal;",

				"#endif",

				"vec3 normal = normalize( finalNormal );",
				"vec3 viewPosition = normalize( vViewPosition );",

				// point lights

				"#if MAX_POINT_LIGHTS > 0",

					"vec3 pointDiffuse = vec3( 0.0 );",
					"vec3 pointSpecular = vec3( 0.0 );",

					"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

						"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
						"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

						"float pointDistance = 1.0;",
						"if ( pointLightDistance[ i ] > 0.0 )",
							"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

						"pointVector = normalize( pointVector );",

						// diffuse

						"#ifdef WRAP_AROUND",

							"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
							"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

							"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

						"#else",

							"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

						"#endif",

						"pointDiffuse += pointDistance * pointLightColor[ i ] * uDiffuseColor * pointDiffuseWeight;",

						// specular

						"vec3 pointHalfVector = normalize( pointVector + viewPosition );",
						"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
						"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, uShininess ), 0.0 );",

						"#ifdef PHYSICALLY_BASED_SHADING",

							// 2.0 => 2.0001 is hack to work around ANGLE bug

							"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",

							"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );",
							"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

						"#else",

							"pointSpecular += pointDistance * pointLightColor[ i ] * uSpecularColor * pointSpecularWeight * pointDiffuseWeight;",

						"#endif",

					"}",

				"#endif",

				// spot lights

				"#if MAX_SPOT_LIGHTS > 0",

					"vec3 spotDiffuse = vec3( 0.0 );",
					"vec3 spotSpecular = vec3( 0.0 );",

					"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

						"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
						"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

						"float spotDistance = 1.0;",
						"if ( spotLightDistance[ i ] > 0.0 )",
							"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

						"spotVector = normalize( spotVector );",

						"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

						"if ( spotEffect > spotLightAngleCos[ i ] ) {",

							"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

							// diffuse

							"#ifdef WRAP_AROUND",

								"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
								"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

								"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

							"#else",

								"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

							"#endif",

							"spotDiffuse += spotDistance * spotLightColor[ i ] * uDiffuseColor * spotDiffuseWeight * spotEffect;",

							// specular

							"vec3 spotHalfVector = normalize( spotVector + viewPosition );",
							"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
							"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, uShininess ), 0.0 );",

							"#ifdef PHYSICALLY_BASED_SHADING",

								// 2.0 => 2.0001 is hack to work around ANGLE bug

								"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",

								"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );",
								"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

							"#else",

								"spotSpecular += spotDistance * spotLightColor[ i ] * uSpecularColor * spotSpecularWeight * spotDiffuseWeight * spotEffect;",

							"#endif",

						"}",

					"}",

				"#endif",

				// directional lights

				"#if MAX_DIR_LIGHTS > 0",

					"vec3 dirDiffuse = vec3( 0.0 );",
					"vec3 dirSpecular = vec3( 0.0 );",

					"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

						"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
						"vec3 dirVector = normalize( lDirection.xyz );",

						// diffuse

						"#ifdef WRAP_AROUND",

							"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
							"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

							"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

						"#else",

							"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

						"#endif",

						"dirDiffuse += directionalLightColor[ i ] * uDiffuseColor * dirDiffuseWeight;",

						// specular

						"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
						"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
						"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, uShininess ), 0.0 );",

						"#ifdef PHYSICALLY_BASED_SHADING",

							// 2.0 => 2.0001 is hack to work around ANGLE bug

							"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",

							"vec3 schlick = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
							"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

						"#else",

							"dirSpecular += directionalLightColor[ i ] * uSpecularColor * dirSpecularWeight * dirDiffuseWeight;",

						"#endif",

					"}",

				"#endif",

				// hemisphere lights

				"#if MAX_HEMI_LIGHTS > 0",

					"vec3 hemiDiffuse  = vec3( 0.0 );",
					"vec3 hemiSpecular = vec3( 0.0 );" ,

					"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

						"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
						"vec3 lVector = normalize( lDirection.xyz );",

						// diffuse

						"float dotProduct = dot( normal, lVector );",
						"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

						"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

						"hemiDiffuse += uDiffuseColor * hemiColor;",

						// specular (sky light)


						"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
						"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
						"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, uShininess ), 0.0 );",

						// specular (ground light)

						"vec3 lVectorGround = -lVector;",

						"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
						"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
						"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, uShininess ), 0.0 );",

						"#ifdef PHYSICALLY_BASED_SHADING",

							"float dotProductGround = dot( normal, lVectorGround );",

							// 2.0 => 2.0001 is hack to work around ANGLE bug

							"float specularNormalization = ( uShininess + 2.0001 ) / 8.0;",

							"vec3 schlickSky = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
							"vec3 schlickGround = uSpecularColor + vec3( 1.0 - uSpecularColor ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
							"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

						"#else",

							"hemiSpecular += uSpecularColor * hemiColor * ( hemiSpecularWeightSky + hemiSpecularWeightGround ) * hemiDiffuseWeight;",

						"#endif",

					"}",

				"#endif",

				// all lights contribution summation

				"vec3 totalDiffuse = vec3( 0.0 );",
				"vec3 totalSpecular = vec3( 0.0 );",

				"#if MAX_DIR_LIGHTS > 0",

					"totalDiffuse += dirDiffuse;",
					"totalSpecular += dirSpecular;",

				"#endif",

				"#if MAX_HEMI_LIGHTS > 0",

					"totalDiffuse += hemiDiffuse;",
					"totalSpecular += hemiSpecular;",

				"#endif",

				"#if MAX_POINT_LIGHTS > 0",

					"totalDiffuse += pointDiffuse;",
					"totalSpecular += pointSpecular;",

				"#endif",

				"#if MAX_SPOT_LIGHTS > 0",

					"totalDiffuse += spotDiffuse;",
					"totalSpecular += spotSpecular;",

				"#endif",

				"#ifdef METAL",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor + totalSpecular );",

				"#else",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * uAmbientColor ) + totalSpecular;",

				"#endif",

				"if ( enableReflection ) {",

					"vec3 vReflect;",
					"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

					"if ( useRefract ) {",

						"vReflect = refract( cameraToVertex, normal, uRefractionRatio );",

					"} else {",

						"vReflect = reflect( cameraToVertex, normal );",

					"}",

					"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

					"#ifdef GAMMA_INPUT",

						"cubeColor.xyz *= cubeColor.xyz;",

					"#endif",

					"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * uReflectivity );",

				"}",

				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n"),

		vertexShader: [

			"attribute vec4 tangent;",

			"uniform vec2 uOffset;",
			"uniform vec2 uRepeat;",

			"uniform bool enableDisplacement;",

			"#ifdef VERTEX_TEXTURES",

				"uniform sampler2D tDisplacement;",
				"uniform float uDisplacementScale;",
				"uniform float uDisplacementBias;",

			"#endif",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],

				// normal, tangent and binormal vectors

				"#ifdef USE_SKINNING",

					"vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

					"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
					"vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

				"#else",

					"vNormal = normalize( normalMatrix * normal );",
					"vTangent = normalize( normalMatrix * tangent.xyz );",

				"#endif",

				"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

				"vUv = uv * uRepeat + uOffset;",

				// displacement mapping

				"vec3 displacedPosition;",

				"#ifdef VERTEX_TEXTURES",

					"if ( enableDisplacement ) {",

						"vec3 dv = texture2D( tDisplacement, uv ).xyz;",
						"float df = uDisplacementScale * dv.x + uDisplacementBias;",
						"displacedPosition = position + normalize( normal ) * df;",

					"} else {",

						"#ifdef USE_SKINNING",

							"vec4 skinVertex = vec4( position, 1.0 );",

							"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
							"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

							"displacedPosition  = skinned.xyz;",

						"#else",

							"displacedPosition = position;",

						"#endif",

					"}",

				"#else",

					"#ifdef USE_SKINNING",

						"vec4 skinVertex = vec4( position, 1.0 );",

						"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
						"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

						"displacedPosition  = skinned.xyz;",

					"#else",

						"displacedPosition = position;",

					"#endif",

				"#endif",

				//

				"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
				"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

				"gl_Position = projectionMatrix * mvPosition;",

				//

				"vWorldPosition = worldPosition.xyz;",
				"vViewPosition = -mvPosition.xyz;",

				// shadows

				"#ifdef USE_SHADOWMAP",

					"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

						"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

					"}",

				"#endif",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: -1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			"void main() {",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
				"vWorldPosition = worldPosition.xyz;",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			"void main() {",

				"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

			"}"

		].join("\n")

	},

	// Depth encoding into RGBA texture
	// 	based on SpiderGL shadow map example
	// 		http://spidergl.org/example.php?id=6
	// 	originally from
	//		http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	// 	see also here:
	//		http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"vec4 pack_depth( const in float depth ) {",

				"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"vec4 res = fract( depth * bit_shift );",
				"res -= res.xxyz * bit_mask;",
				"return res;",

			"}",

			"void main() {",

				"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join("\n")

	}

};
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

	_alpha = parameters.alpha !== undefined ? parameters.alpha : true,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

	_clearColor = parameters.clearColor !== undefined ? new THREE.Color( parameters.clearColor ) : new THREE.Color( 0x000000 ),
	_clearAlpha = parameters.clearAlpha !== undefined ? parameters.clearAlpha : 0;

	// public properties

	this.domElement = _canvas;
	this.context = null;
	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: window.devicePixelRatio !== undefined
					? window.devicePixelRatio
					: 1;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	this.autoUpdateObjects = true;
	this.autoUpdateScene = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;
	this.physicallyBasedShading = false;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapAutoUpdate = true;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// custom render plugins

	this.renderPluginsPre = [];
	this.renderPluginsPost = [];

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],
	_programs_counter = 0,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentGeometryGroupHash = null,
	_currentCamera = null,
	_geometryGroupCounter = 0,

	_usedTextureUnits = 0,

	// GL state cache

	_oldDoubleSided = -1,
	_oldFlipSided = -1,

	_oldBlending = -1,

	_oldBlendEquation = -1,
	_oldBlendSrc = -1,
	_oldBlendDst = -1,

	_oldDepthTest = -1,
	_oldDepthWrite = -1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = 0,
	_viewportHeight = 0,
	_currentWidth = 0,
	_currentHeight = 0,

	_enabledAttributes = {},

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_projScreenMatrixPS = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: new Array(), positions: new Array() },
		point: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },
		spot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },
		hemi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }

	};

	// initialize

	var _gl;

	var _glExtensionTextureFloat;
	var _glExtensionStandardDerivatives;
	var _glExtensionTextureFilterAnisotropic;
	var _glExtensionCompressedTextureS3TC;

	initGL();

	setDefaultGLState();

	this.context = _gl;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

	var _supportsVertexTextures = ( _maxVertexTextures > 0 );
	var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;

	var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];

	//

	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

	var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );
	var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );
	var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );

	var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );
	var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );
	var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );

	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precision === "highp" && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precision = "mediump";
			console.warn( "WebGLRenderer: highp not supported, using mediump" );

		} else {

			_precision = "lowp";
			console.warn( "WebGLRenderer: highp and mediump not supported, using lowp" );

		}

	}

	if ( _precision === "mediump" && ! mediumpAvailable ) {

		_precision = "lowp";
		console.warn( "WebGLRenderer: mediump not supported, using lowp" );

	}

	// API

	this.getContext = function () {

		return _gl;

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return _glExtensionTextureFloat;

	};
	
	this.supportsStandardDerivatives = function () {

		return _glExtensionStandardDerivatives;

	};
	
	this.supportsCompressedTextureS3TC = function () {

		return _glExtensionCompressedTextureS3TC;

	};
	
	this.getMaxAnisotropy  = function () {

		return _maxAnisotropy;

	};

	this.getPrecision = function () {

		return _precision;

	};

	this.setSize = function ( width, height ) {

		_canvas.width = width * this.devicePixelRatio;
		_canvas.height = height * this.devicePixelRatio;

		_canvas.style.width = width + 'px';
		_canvas.style.height = height + 'px';

		this.setViewport( 0, 0, _canvas.width, _canvas.height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x !== undefined ? x : 0;
		_viewportY = y !== undefined ? y : 0;

		_viewportWidth = width !== undefined ? width : _canvas.width;
		_viewportHeight = height !== undefined ? height : _canvas.height;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor( x, y, width, height );

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.setClearColorHex = function ( hex, alpha ) {

		_clearColor.setHex( hex );
		_clearAlpha = alpha;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.copy( color );
		_clearAlpha = alpha;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.getClearColor = function () {

		return _clearColor;

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Plugins

	this.addPostPlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPost.push( plugin );

	};

	this.addPrePlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPre.push( plugin );

	};

	// Rendering

	this.updateShadowMap = function ( scene, camera ) {

		_currentProgram = null;
		_oldBlending = -1;
		_oldDepthTest = -1;
		_oldDepthWrite = -1;
		_currentGeometryGroupHash = -1;
		_currentMaterialId = -1;
		_lightsNeedUpdate = true;
		_oldDoubleSided = -1;
		_oldFlipSided = -1;

		this.shadowMapPlugin.update( scene, camera );

	};

	// Internal functions

	// Buffer allocation

	function createParticleBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createRibbonBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglNormalBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

			}

		}

		_this.info.memory.geometries ++;

	};

	// Events

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

		_this.info.memory.geometries --;

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deallocateGeometry = function ( geometry ) {

		geometry.__webglInit = undefined;

		if ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
		if ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
		if ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
		if ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );
		if ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );
		if ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );

		if ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
		if ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );

		if ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
		if ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );

		if ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );

		// geometry groups

		if ( geometry.geometryGroups !== undefined ) {

			for ( var g in geometry.geometryGroups ) {

				var geometryGroup = geometry.geometryGroups[ g ];

				if ( geometryGroup.numMorphTargets !== undefined ) {

					for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

						_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

					}

				}

				if ( geometryGroup.numMorphNormals !== undefined ) {

					for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

						_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

					}

				}

				deleteCustomAttributesBuffers( geometryGroup );

			}

		}

		deleteCustomAttributesBuffers( geometry );

	};

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

		} else {

			// 2D texture

			if ( ! texture.__webglInit ) return;

			texture.__webglInit = false;
			_gl.deleteTexture( texture.__webglTexture );

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( !renderTarget || ! renderTarget.__webglTexture ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

	};

	var deallocateMaterial = function ( material ) {

		var program = material.program;

		if ( program === undefined ) return;

		material.program = undefined;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	//

	/*
	function deleteParticleBuffers ( geometry ) {

		_gl.deleteBuffer( geometry.__webglVertexBuffer );
		_gl.deleteBuffer( geometry.__webglColorBuffer );

		deleteCustomAttributesBuffers( geometry );

		_this.info.memory.geometries --;

	};

	function deleteLineBuffers ( geometry ) {

		_gl.deleteBuffer( geometry.__webglVertexBuffer );
		_gl.deleteBuffer( geometry.__webglColorBuffer );
		_gl.deleteBuffer( geometry.__webglLineDistanceBuffer );

		deleteCustomAttributesBuffers( geometry );

		_this.info.memory.geometries --;

	};

	function deleteRibbonBuffers ( geometry ) {

		_gl.deleteBuffer( geometry.__webglVertexBuffer );
		_gl.deleteBuffer( geometry.__webglColorBuffer );
		_gl.deleteBuffer( geometry.__webglNormalBuffer );

		deleteCustomAttributesBuffers( geometry );

		_this.info.memory.geometries --;

	};

	function deleteMeshBuffers ( geometryGroup ) {

		_gl.deleteBuffer( geometryGroup.__webglVertexBuffer );
		_gl.deleteBuffer( geometryGroup.__webglNormalBuffer );
		_gl.deleteBuffer( geometryGroup.__webglTangentBuffer );
		_gl.deleteBuffer( geometryGroup.__webglColorBuffer );
		_gl.deleteBuffer( geometryGroup.__webglUVBuffer );
		_gl.deleteBuffer( geometryGroup.__webglUV2Buffer );

		_gl.deleteBuffer( geometryGroup.__webglSkinIndicesBuffer );
		_gl.deleteBuffer( geometryGroup.__webglSkinWeightsBuffer );

		_gl.deleteBuffer( geometryGroup.__webglFaceBuffer );
		_gl.deleteBuffer( geometryGroup.__webglLineBuffer );

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

			}

		}

		deleteCustomAttributesBuffers( geometryGroup );

		_this.info.memory.geometries --;

	};
	*/

	function deleteCustomAttributesBuffers( geometry ) {

		if ( geometry.__webglCustomAttributesList ) {

			for ( var id in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );

			}

		}

	};

	// Buffer initialization

	function initCustomAttributes ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		var material = object.material;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				var attribute = material.attributes[ a ];

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if ( attribute.type === "v2" ) size = 2;
					else if ( attribute.type === "v3" ) size = 3;
					else if ( attribute.type === "v4" ) size = 4;
					else if ( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initParticleBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initRibbonBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__normalArray = new Float32Array( nvertices * 3 );

		geometry.__webglVertexCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,
			faces4 = geometryGroup.faces4,

			nvertices = faces3.length * 3 + faces4.length * 4,
			ntris     = faces3.length * 1 + faces4.length * 2,
			nlines    = faces3.length * 3 + faces4.length * 4,

			material = getBufferMaterial( object, geometryGroup ),

			uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		//console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );

		if ( normalType ) {

			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceUvs.length > 0 || geometry.faceVertexUvs.length > 0 ) {

				geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			}

			if ( geometry.faceUvs.length > 1 || geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		geometryGroup.__faceArray = new Uint16Array( ntris * 3 );
		geometryGroup.__lineArray = new Uint16Array( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__morphTargetsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__morphNormalsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ a ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if( attribute.type === "v2" ) size = 2;
					else if( attribute.type === "v3" ) size = 3;
					else if( attribute.type === "v4" ) size = 4;
					else if( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ geometryGroup.materialIndex ]
			: object.material;

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	function bufferGuessNormalType ( material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {

			return false;

		}

		if ( materialNeedsSmoothNormals( material ) ) {

			return THREE.SmoothShading;

		} else {

			return THREE.FlatShading;

		}

	};

	function bufferGuessVertexColorType ( material ) {

		if ( material.vertexColors ) {

			return material.vertexColors;

		}

		return false;

	};

	function bufferGuessUVType ( material ) {

		// material must use some texture to require uvs

		if ( material.map || material.lightMap || material.bumpMap || material.normalMap || material.specularMap || material instanceof THREE.ShaderMaterial ) {

			return true;

		}

		return false;

	};

	//

	function initDirectBuffers( geometry ) {

		var a, attribute, type;

		for ( a in geometry.attributes ) {

			if ( a === "index" ) {

				type = _gl.ELEMENT_ARRAY_BUFFER;

			} else {

				type = _gl.ARRAY_BUFFER;

			}

			attribute = geometry.attributes[ a ];

			attribute.buffer = _gl.createBuffer();

			_gl.bindBuffer( type, attribute.buffer );
			_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );

		}

	};

	// Buffer setting

	function setParticleBuffers ( geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.copy( _projScreenMatrix );
			_projScreenMatrixPS.multiply( object.matrixWorld );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.copy( vertex );
				_vector3.applyProjection( _projScreenMatrixPS );

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( numericalSort );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ sortArray[v][1] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c < cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[c][1] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
						   customAttribute.boundTo === "vertices") ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === "c" ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}


	};

	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
					   customAttribute.boundTo === "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	};

	function setRibbonBuffers ( geometry, hint ) {

		var v, c, n, vertex, offset, color, normal,

		i, il, ca, cal, customAttribute, value,

		vertices = geometry.vertices,
		colors = geometry.colors,
		normals = geometry.normals,

		vl = vertices.length,
		cl = colors.length,
		nl = normals.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		normalArray = geometry.__normalArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyNormals ) {

			for ( n = 0; n < nl; n ++ ) {

				normal = normals[ n ];

				offset = n * 3;

				normalArray[ offset ]     = normal.x;
				normalArray[ offset + 1 ] = normal.y;
				normalArray[ offset + 2 ] = normal.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
					   customAttribute.boundTo === "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	};

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType === THREE.SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3, c4,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		chunk_faces4 = geometryGroup.faces4,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];
				v4 = vertices[ face.d ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				vertexArray[ offset + 9 ]  = v4.x;
				vertexArray[ offset + 10 ] = v4.y;
				vertexArray[ offset + 11 ] = v4.z;

				offset += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

				offset_morphTarget = 0;

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

					chf = chunk_faces4[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];
					v4 = morphTargets[ vk ].vertices[ face.d ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					vka[ offset_morphTarget + 9 ]  = v4.x;
					vka[ offset_morphTarget + 10 ] = v4.y;
					vka[ offset_morphTarget + 11 ] = v4.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;
							n4 = faceVertexNormals.d;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;
							n4 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

						nka[ offset_morphTarget + 9 ]  = n4.x;
						nka[ offset_morphTarget + 10 ] = n4.y;
						nka[ offset_morphTarget + 11 ] = n4.z;

					}

					//

					offset_morphTarget += 12;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( obj_skinWeights.length ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];
				sw4 = obj_skinWeights[ face.d ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				skinWeightArray[ offset_skin + 12 ] = sw4.x;
				skinWeightArray[ offset_skin + 13 ] = sw4.y;
				skinWeightArray[ offset_skin + 14 ] = sw4.z;
				skinWeightArray[ offset_skin + 15 ] = sw4.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];
				si4 = obj_skinIndices[ face.d ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				skinIndexArray[ offset_skin + 12 ] = si4.x;
				skinIndexArray[ offset_skin + 13 ] = si4.y;
				skinIndexArray[ offset_skin + 14 ] = si4.z;
				skinIndexArray[ offset_skin + 15 ] = si4.w;

				offset_skin += 16;

			}

			if ( offset_skin > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors && vertexColorType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 4 && vertexColorType === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];
					c4 = vertexColors[ 3 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;
					c4 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				colorArray[ offset_color + 9 ]  = c4.r;
				colorArray[ offset_color + 10 ] = c4.g;
				colorArray[ offset_color + 11 ] = c4.b;

				offset_color += 12;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];
				t4 = vertexTangents[ 3 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				tangentArray[ offset_tangent + 12 ] = t4.x;
				tangentArray[ offset_tangent + 13 ] = t4.y;
				tangentArray[ offset_tangent + 14 ] = t4.z;
				tangentArray[ offset_tangent + 15 ] = t4.w;

				offset_tangent += 16;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals && normalType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces4[ f ] ];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 4 && needsSmoothNormals ) {

					for ( i = 0; i < 4; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 4; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				fi = chunk_faces4[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 4; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				fi = chunk_faces4[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 4; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

				faceArray[ offset_face ]     = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 3;

				faceArray[ offset_face + 3 ] = vertexIndex + 1;
				faceArray[ offset_face + 4 ] = vertexIndex + 2;
				faceArray[ offset_face + 5 ] = vertexIndex + 3;

				offset_face += 6;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 3;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				lineArray[ offset_line + 6 ] = vertexIndex + 2;
				lineArray[ offset_line + 7 ] = vertexIndex + 3;

				offset_line += 8;

				vertexIndex += 4;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];
							customAttribute.array[ offset_custom + 3 ] = customAttribute.value[ face.d ];

							offset_custom += 4;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;
							customAttribute.array[ offset_custom + 3 ] = value;

							offset_custom += 4;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							customAttribute.array[ offset_custom + 6 ] = v4.x;
							customAttribute.array[ offset_custom + 7 ] = v4.y;

							offset_custom += 8;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							customAttribute.array[ offset_custom + 6 ] = v4.x;
							customAttribute.array[ offset_custom + 7 ] = v4.y;

							offset_custom += 8;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];
							v4 = value[ 3 ];

							customAttribute.array[ offset_custom  ] 	= v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1  ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2  ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3  ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4  ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5  ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6  ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7  ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8  ] = v3[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 9  ] = v4[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 10 ] = v4[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 11 ] = v4[ pp[ 2 ] ];

							offset_custom += 12;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces4[ f ] ];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];
							v4 = customAttribute.value[ face.d ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;
							v4 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

						for ( f = 0, fl = chunk_faces4.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces4[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];
							v4 = value[ 3 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							customAttribute.array[ offset_custom + 12 ] = v4.x;
							customAttribute.array[ offset_custom + 13 ] = v4.y;
							customAttribute.array[ offset_custom + 14 ] = v4.z;
							customAttribute.array[ offset_custom + 15 ] = v4.w;

							offset_custom += 16;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};

	function setDirectBuffers ( geometry, hint, dispose ) {

		var attributes = geometry.attributes;

		var index = attributes[ "index" ];
		var position = attributes[ "position" ];
		var normal = attributes[ "normal" ];
		var uv = attributes[ "uv" ];
		var color = attributes[ "color" ];
		var tangent = attributes[ "tangent" ];

		if ( geometry.elementsNeedUpdate && index !== undefined ) {

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, index.array, hint );

		}

		if ( geometry.verticesNeedUpdate && position !== undefined ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, position.array, hint );

		}

		if ( geometry.normalsNeedUpdate && normal !== undefined ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normal.array, hint );

		}

		if ( geometry.uvsNeedUpdate && uv !== undefined ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, uv.array, hint );

		}

		if ( geometry.colorsNeedUpdate && color !== undefined ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, color.array, hint );

		}

		if ( geometry.tangentsNeedUpdate && tangent !== undefined ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangent.array, hint );

		}

		if ( dispose ) {

			for ( var i in geometry.attributes ) {

				delete geometry.attributes[ i ].array;

			}

		}

	};

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
		if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
		if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
		if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.position );
			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

			if ( material.shading === THREE.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for( i = 0; i < il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ] 	 = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.normal );
			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.uv );
			_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.color );
			_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

		if ( material.visible === false ) return;

		var program, attributes, linewidth, primitives, a, attribute;

		program = setProgram( camera, lights, fog, material, object );

		attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var index = geometry.attributes[ "index" ];

			// indexed triangles

			if ( index ) {

				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets.length > 1 ) updateBuffers = true;

				for ( var i = 0, il = offsets.length; i < il; i ++ ) {

					var startIndex = offsets[ i ].index;

					if ( updateBuffers ) {

						// vertices

						var position = geometry.attributes[ "position" ];
						var positionSize = position.itemSize;

						_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );
						enableAttribute( attributes.position );
						_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, startIndex * positionSize * 4 ); // 4 bytes per Float32

						// normals

						var normal = geometry.attributes[ "normal" ];

						if ( attributes.normal >= 0 && normal ) {

							var normalSize = normal.itemSize;

							_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );
							enableAttribute( attributes.normal );
							_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, startIndex * normalSize * 4 );

						}

						// uvs

						var uv = geometry.attributes[ "uv" ];

						if ( attributes.uv >= 0 && uv ) {

							var uvSize = uv.itemSize;

							_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );
							enableAttribute( attributes.uv );
							_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, startIndex * uvSize * 4 );

						}

						// colors

						var color = geometry.attributes[ "color" ];

						if ( attributes.color >= 0 && color ) {

							var colorSize = color.itemSize;

							_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );
							enableAttribute( attributes.color );
							_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, startIndex * colorSize * 4 );

						}

						// tangents

						var tangent = geometry.attributes[ "tangent" ];

						if ( attributes.tangent >= 0 && tangent ) {

							var tangentSize = tangent.itemSize;

							_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );
							enableAttribute( attributes.tangent );
							_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, startIndex * tangentSize * 4 );

						}

						// indices

						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					// render indexed triangles

					_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16

					_this.info.render.calls ++;
					_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
					_this.info.render.faces += offsets[ i ].count / 3;

				}

			// non-indexed triangles

			} else {

				if ( updateBuffers ) {

					// vertices

					var position = geometry.attributes[ "position" ];
					var positionSize = position.itemSize;

					_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );
					enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );

					// normals

					var normal = geometry.attributes[ "normal" ];

					if ( attributes.normal >= 0 && normal ) {

						var normalSize = normal.itemSize;

						_gl.bindBuffer( _gl.ARRAY_BUFFER, normal.buffer );
						enableAttribute( attributes.normal );
						_gl.vertexAttribPointer( attributes.normal, normalSize, _gl.FLOAT, false, 0, 0 );

					}

					// uvs

					var uv = geometry.attributes[ "uv" ];

					if ( attributes.uv >= 0 && uv ) {

						var uvSize = uv.itemSize;

						_gl.bindBuffer( _gl.ARRAY_BUFFER, uv.buffer );
						enableAttribute( attributes.uv );
						_gl.vertexAttribPointer( attributes.uv, uvSize, _gl.FLOAT, false, 0, 0 );

					}

					// colors

					var color = geometry.attributes[ "color" ];

					if ( attributes.color >= 0 && color ) {

						var colorSize = color.itemSize;

						_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );
						enableAttribute( attributes.color );
						_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );

					}

					// tangents

					var tangent = geometry.attributes[ "tangent" ];

					if ( attributes.tangent >= 0 && tangent ) {

						var tangentSize = tangent.itemSize;

						_gl.bindBuffer( _gl.ARRAY_BUFFER, tangent.buffer );
						enableAttribute( attributes.tangent );
						_gl.vertexAttribPointer( attributes.tangent, tangentSize, _gl.FLOAT, false, 0, 0 );

					}

				}

				// render non-indexed triangles

				_gl.drawArrays( _gl.TRIANGLES, 0, position.numItems / 3 );

				_this.info.render.calls ++;
				_this.info.render.vertices += position.numItems / 3;
				_this.info.render.faces += position.numItems / 3 / 3;

			}

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			if ( updateBuffers ) {

				// vertices

				var position = geometry.attributes[ "position" ];
				var positionSize = position.itemSize;

				_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );

				// colors

				var color = geometry.attributes[ "color" ];

				if ( attributes.color >= 0 && color ) {

					var colorSize = color.itemSize;

					_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );

				}

				// render particles

				_gl.drawArrays( _gl.POINTS, 0, position.numItems / 3 );

				_this.info.render.calls ++;
				_this.info.render.points += position.numItems / 3;

			}

		} else if ( object instanceof THREE.Line ) {

			if ( updateBuffers ) {

				// vertices

				var position = geometry.attributes[ "position" ];
				var positionSize = position.itemSize;

				_gl.bindBuffer( _gl.ARRAY_BUFFER, position.buffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, positionSize, _gl.FLOAT, false, 0, 0 );

				// colors

				var color = geometry.attributes[ "color" ];

				if ( attributes.color >= 0 && color ) {

					var colorSize = color.itemSize;

					_gl.bindBuffer( _gl.ARRAY_BUFFER, color.buffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, colorSize, _gl.FLOAT, false, 0, 0 );

				}

				// render lines

				setLineWidth( material.linewidth );

				_gl.drawArrays( _gl.LINE_STRIP, 0, position.numItems / 3 );

				_this.info.render.calls ++;
				_this.info.render.points += position.numItems;

			}

    }

	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		var program, attributes, linewidth, primitives, a, attribute, i, il;

		program = setProgram( camera, lights, fog, material, object );

		attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// vertices

		if ( !material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( object.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, object );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				enableAttribute( attributes.color );
				_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				enableAttribute( attributes.uv );
				_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( attributes.uv2 >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				enableAttribute( attributes.uv2 );
				_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

			}

			if ( material.skinning &&
				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes.skinIndex );
				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes.skinWeight );
				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );

			}

			_this.info.render.calls ++;
			_this.info.render.vertices += geometryGroup.__webglFaceCount;
			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

		// render lines

		} else if ( object instanceof THREE.Line ) {

			primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );

			_this.info.render.calls ++;

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

			_this.info.render.calls ++;
			_this.info.render.points += geometryGroup.__webglParticleCount;

		// render ribbon

		} else if ( object instanceof THREE.Ribbon ) {

			_gl.drawArrays( _gl.TRIANGLE_STRIP, 0, geometryGroup.__webglVertexCount );

			_this.info.render.calls ++;

		}

	};

	function enableAttribute( attribute ) {

		if ( ! _enabledAttributes[ attribute ] ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ attribute ] = true;

		}

	};

	function disableAttributes() {

		for ( var attribute in _enabledAttributes ) {

			if ( _enabledAttributes[ attribute ] ) {

				_gl.disableVertexAttribArray( attribute );
				_enabledAttributes[ attribute ] = false;

			}

		}

	};

	function setupMorphTargets ( material, geometryGroup, object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		} else if ( attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m < material.numSupportedMorphTargets && m < order.length ) {

				if ( attributes[ "morphTarget" + m ] >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphTarget" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphNormal" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;
			}

		} else {

			// find the most influencing

			var influence, activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i < il; i ++ ) {

				influence = influences[ i ];

				if ( influence > 0 ) {

					activeInfluenceIndices.push( [ influence, i ] );

				}

			}

			if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length === 0 ) {

				activeInfluenceIndices.push( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m < material.numSupportedMorphTargets ) {

				if ( activeInfluenceIndices[ m ] ) {

					influenceIndex = activeInfluenceIndices[ m ][ 1 ];

					if ( attributes[ "morphTarget" + m ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphTarget" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}

					if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphNormal" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );


					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

				} else {

					/*
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}
					*/

					object.__webglMorphTargetInfluences[ m ] = 0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms.morphTargetInfluences !== null ) {

			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

		}

	};

	// Sorting

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	};

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	};


	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var i, il,

		webglObject, object,
		renderList,

		lights = scene.__lights,
		fog = scene.fog;

		// reset caching for this frame

		_currentMaterialId = -1;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( this.autoUpdateScene ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// update WebGL objects

		if ( this.autoUpdateObjects ) this.initWebGLObjects( scene );

		// custom render plugins (pre pass)

		renderPlugins( this.renderPluginsPre, scene, camera );

		//

		_this.info.render.calls = 0;
		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;
		_this.info.render.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		// set matrices for regular objects (frustum culled)

		renderList = scene.__webglObjects;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

					setupMatrices( object, camera );

					unrollBufferMaterial( webglObject );

					webglObject.render = true;

					if ( this.sortObjects === true ) {

						if ( object.renderDepth !== null ) {

							webglObject.z = object.renderDepth;

						} else {

							_vector3.getPositionFromMatrix( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

							webglObject.z = _vector3.z;

						}

						webglObject.id = object.id;

					}

				}

			}

		}

		if ( this.sortObjects ) {

			renderList.sort( painterSortStable );

		}

		// set matrices for immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				setupMatrices( object, camera );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial ) {

			var material = scene.overrideMaterial;

			this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			this.setDepthTest( material.depthTest );
			this.setDepthWrite( material.depthWrite );
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			renderObjects( scene.__webglObjects, false, "", camera, lights, fog, true, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "", camera, lights, fog, false, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			this.setBlending( THREE.NoBlending );

			renderObjects( scene.__webglObjects, true, "opaque", camera, lights, fog, false, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "opaque", camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( scene.__webglObjects, false, "transparent", camera, lights, fog, true, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "transparent", camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		renderPlugins( this.renderPluginsPost, scene, camera );


		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		this.setDepthTest( true );
		this.setDepthWrite( true );

		// _gl.finish();

	};

	function renderPlugins( plugins, scene, camera ) {

		if ( ! plugins.length ) return;

		for ( var i = 0, il = plugins.length; i < il; i ++ ) {

			// reset state for plugin (to start from clean slate)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

			plugins[ i ].render( scene, camera, _currentWidth, _currentHeight );

			// reset state after plugin (anything could have changed)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

		}

	};

	function renderObjects ( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, buffer, material, start, end, delta;

		if ( reverse ) {

			start = renderList.length - 1;
			end = -1;
			delta = -1;

		} else {

			start = 0;
			end = renderList.length;
			delta = 1;
		}

		for ( var i = start; i !== end; i += delta ) {

			webglObject = renderList[ i ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.setMaterialFaces( material );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

				} else {

					_this.renderBuffer( camera, lights, fog, material, buffer, object );

				}

			}

		}

	};

	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, material, program;

		for ( var i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	};

	this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = -1;

		_this.setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );

		}

	};

	function unrollImmediateBufferMaterial ( globject ) {

		var object = globject.object,
			material = object.material;

		if ( material.transparent ) {

			globject.transparent = material;
			globject.opaque = null;

		} else {

			globject.opaque = material;
			globject.transparent = null;

		}

	};

	function unrollBufferMaterial ( globject ) {

		var object = globject.object,
			buffer = globject.buffer,
			material, materialIndex, meshMaterial;

		meshMaterial = object.material;

		if ( meshMaterial instanceof THREE.MeshFaceMaterial ) {

			materialIndex = buffer.materialIndex;

			material = meshMaterial.materials[ materialIndex ];

			if ( material.transparent ) {

				globject.transparent = material;
				globject.opaque = null;

			} else {

				globject.opaque = material;
				globject.transparent = null;

			}

		} else {

			material = meshMaterial;

			if ( material ) {

				if ( material.transparent ) {

					globject.transparent = material;
					globject.opaque = null;

				} else {

					globject.opaque = material;
					globject.transparent = null;

				}

			}

		}

	};

	// Geometry splitting

	function sortFacesByMaterial ( geometry, material ) {

		var f, fl, face, materialIndex, vertices,
			groupHash, hash_map = {};

		var numMorphTargets = geometry.morphTargets.length;
		var numMorphNormals = geometry.morphNormals.length;

		var usesFaceMaterial = material instanceof THREE.MeshFaceMaterial;

		geometry.geometryGroups = {};

		for ( f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

			face = geometry.faces[ f ];
			materialIndex = usesFaceMaterial ? face.materialIndex : 0;

			if ( hash_map[ materialIndex ] === undefined ) {

				hash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };

			}

			groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

			if ( geometry.geometryGroups[ groupHash ] === undefined ) {

				geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };

			}

			vertices = face instanceof THREE.Face3 ? 3 : 4;

			if ( geometry.geometryGroups[ groupHash ].vertices + vertices > 65535 ) {

				hash_map[ materialIndex ].counter += 1;
				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( geometry.geometryGroups[ groupHash ] === undefined ) {

					geometry.geometryGroups[ groupHash ] = { 'faces3': [], 'faces4': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };

				}

			}

			if ( face instanceof THREE.Face3 ) {

				geometry.geometryGroups[ groupHash ].faces3.push( f );

			} else {

				geometry.geometryGroups[ groupHash ].faces4.push( f );

			}

			geometry.geometryGroups[ groupHash ].vertices += vertices;

		}

		geometry.geometryGroupsList = [];

		for ( var g in geometry.geometryGroups ) {

			geometry.geometryGroups[ g ].id = _geometryGroupCounter ++;

			geometry.geometryGroupsList.push( geometry.geometryGroups[ g ] );

		}

	};

	// Objects refresh

	this.initWebGLObjects = function ( scene ) {

		if ( !scene.__webglObjects ) {

			scene.__webglObjects = [];
			scene.__webglObjectsImmediate = [];
			scene.__webglSprites = [];
			scene.__webglFlares = [];

		}

		while ( scene.__objectsAdded.length ) {

			addObject( scene.__objectsAdded[ 0 ], scene );
			scene.__objectsAdded.splice( 0, 1 );

		}

		while ( scene.__objectsRemoved.length ) {

			removeObject( scene.__objectsRemoved[ 0 ], scene );
			scene.__objectsRemoved.splice( 0, 1 );

		}

		// update must be called after objects adding / removal

		for ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {

			updateObject( scene.__webglObjects[ o ].object );

		}

	};

	// Objects adding

	function addObject ( object, scene ) {

		var g, geometry, material, geometryGroup;

		if ( ! object.__webglInit ) {

			object.__webglInit = true;

			object._modelViewMatrix = new THREE.Matrix4();
			object._normalMatrix = new THREE.Matrix3();

			if ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {

				object.geometry.__webglInit = true;
				object.geometry.addEventListener( 'dispose', onGeometryDispose );

			}

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;
				material = object.material;

				if ( geometry instanceof THREE.Geometry ) {

					if ( geometry.geometryGroups === undefined ) {

						sortFacesByMaterial( geometry, material );

					}

					// create separate VBOs per geometry chunk

					for ( g in geometry.geometryGroups ) {

						geometryGroup = geometry.geometryGroups[ g ];

						// initialise VBO on the first access

						if ( ! geometryGroup.__webglVertexBuffer ) {

							createMeshBuffers( geometryGroup );
							initMeshBuffers( geometryGroup, object );

							geometry.verticesNeedUpdate = true;
							geometry.morphTargetsNeedUpdate = true;
							geometry.elementsNeedUpdate = true;
							geometry.uvsNeedUpdate = true;
							geometry.normalsNeedUpdate = true;
							geometry.tangentsNeedUpdate = true;
							geometry.colorsNeedUpdate = true;

						}

					}

				} else if ( geometry instanceof THREE.BufferGeometry ) {

					initDirectBuffers( geometry );

				}

			} else if ( object instanceof THREE.Ribbon ) {

				geometry = object.geometry;

				if ( ! geometry.__webglVertexBuffer ) {

					createRibbonBuffers( geometry );
					initRibbonBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.normalsNeedUpdate = true;

				}

			} else if ( object instanceof THREE.Line ) {

				geometry = object.geometry;

				if ( ! geometry.__webglVertexBuffer ) {

					if ( geometry instanceof THREE.Geometry ) {

            createLineBuffers( geometry );
            initLineBuffers( geometry, object );

            geometry.verticesNeedUpdate = true;
            geometry.colorsNeedUpdate = true;
            geometry.lineDistancesNeedUpdate = true;

          } else if ( geometry instanceof THREE.BufferGeometry ) {

						initDirectBuffers( geometry );

					}

				}

			} else if ( object instanceof THREE.ParticleSystem ) {

				geometry = object.geometry;

				if ( ! geometry.__webglVertexBuffer ) {

					if ( geometry instanceof THREE.Geometry ) {

						createParticleBuffers( geometry );
						initParticleBuffers( geometry, object );

						geometry.verticesNeedUpdate = true;
						geometry.colorsNeedUpdate = true;

					} else if ( geometry instanceof THREE.BufferGeometry ) {

						initDirectBuffers( geometry );

					}


				}

			}

		}

		if ( ! object.__webglActive ) {

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				if ( geometry instanceof THREE.BufferGeometry ) {

					addBuffer( scene.__webglObjects, geometry, object );

				} else if ( geometry instanceof THREE.Geometry ) {

					for ( g in geometry.geometryGroups ) {

						geometryGroup = geometry.geometryGroups[ g ];

						addBuffer( scene.__webglObjects, geometryGroup, object );

					}

				}

			} else if ( object instanceof THREE.Ribbon ||
						object instanceof THREE.Line ||
						object instanceof THREE.ParticleSystem ) {

				geometry = object.geometry;
				addBuffer( scene.__webglObjects, geometry, object );

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				addBufferImmediate( scene.__webglObjectsImmediate, object );

			} else if ( object instanceof THREE.Sprite ) {

				scene.__webglSprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				scene.__webglFlares.push( object );

			}

			object.__webglActive = true;

		}

	};

	function addBuffer ( objlist, buffer, object ) {

		objlist.push(
			{
				buffer: buffer,
				object: object,
				opaque: null,
				transparent: null
			}
		);

	};

	function addBufferImmediate ( objlist, object ) {

		objlist.push(
			{
				object: object,
				opaque: null,
				transparent: null
			}
		);

	};

	// Objects updates

	function updateObject ( object ) {

		var geometry = object.geometry,
			geometryGroup, customAttributesDirty, material;

		if ( object instanceof THREE.Mesh ) {

			if ( geometry instanceof THREE.BufferGeometry ) {

				if ( geometry.verticesNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate ) {

					setDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );

				}

				geometry.verticesNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

			} else {

				// check all geometry groups

				for( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {

					geometryGroup = geometry.geometryGroupsList[ i ];

					material = getBufferMaterial( object, geometryGroup );

					if ( geometry.buffersNeedUpdate ) {

						initMeshBuffers( geometryGroup, object );

					}

					customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

					if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
						 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
						 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

						setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );

					}

				}

				geometry.verticesNeedUpdate = false;
				geometry.morphTargetsNeedUpdate = false;
				geometry.elementsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.tangentsNeedUpdate = false;

				geometry.buffersNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );

			}

		} else if ( object instanceof THREE.Ribbon ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.normalsNeedUpdate || customAttributesDirty ) {

				setRibbonBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

      if ( geometry instanceof THREE.BufferGeometry ) {

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {

					setDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;

			} else {

        material = getBufferMaterial( object, geometry );

        customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

        if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

          setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

        }

        geometry.verticesNeedUpdate = false;
        geometry.colorsNeedUpdate = false;
        geometry.lineDistancesNeedUpdate = false;

        material.attributes && clearCustomAttributes( material );

      }

		} else if ( object instanceof THREE.ParticleSystem ) {

			if ( geometry instanceof THREE.BufferGeometry ) {

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate ) {

					setDirectBuffers( geometry, _gl.DYNAMIC_DRAW, !geometry.dynamic );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;

			} else {

				material = getBufferMaterial( object, geometry );

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

					setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

				}

				geometry.verticesNeedUpdate = false;
				geometry.colorsNeedUpdate = false;

				material.attributes && clearCustomAttributes( material );

			}

		}

	};

	// Objects updates - custom attributes check

	function areCustomAttributesDirty ( material ) {

		for ( var a in material.attributes ) {

			if ( material.attributes[ a ].needsUpdate ) return true;

		}

		return false;

	};

	function clearCustomAttributes ( material ) {

		for ( var a in material.attributes ) {

			material.attributes[ a ].needsUpdate = false;

		}

	};

	// Objects removal

	function removeObject ( object, scene ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.ParticleSystem ||
			 object instanceof THREE.Ribbon ||
			 object instanceof THREE.Line ) {

			removeInstances( scene.__webglObjects, object );

		} else if ( object instanceof THREE.Sprite ) {

			removeInstancesDirect( scene.__webglSprites, object );

		} else if ( object instanceof THREE.LensFlare ) {

			removeInstancesDirect( scene.__webglFlares, object );

		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

			removeInstances( scene.__webglObjectsImmediate, object );

		}

		object.__webglActive = false;

	};

	function removeInstances ( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	function removeInstancesDirect ( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ] === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	// Materials

	this.initMaterial = function ( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

		if ( material instanceof THREE.MeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material instanceof THREE.MeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material instanceof THREE.MeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material instanceof THREE.LineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			shaderID = 'dashed';

		} else if ( material instanceof THREE.ParticleBasicMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID ) {

			setMaterialShaders( material, THREE.ShaderLib[ shaderID ] );

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		maxLightCount = allocateLights( lights );

		maxShadows = allocateShadows( lights );

		maxBones = allocateBones( object );

		parameters = {

			map: !!material.map,
			envMap: !!material.envMap,
			lightMap: !!material.lightMap,
			bumpMap: !!material.bumpMap,
			normalMap: !!material.normalMap,
			specularMap: !!material.specularMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: material.sizeAttenuation,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,
			boneTextureWidth: object && object.boneTextureWidth,
			boneTextureHeight: object && object.boneTextureHeight,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: this.maxMorphTargets,
			maxMorphNormals: this.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: maxShadows,
			shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,
			shadowMapType: this.shadowMapType,
			shadowMapDebug: this.shadowMapDebug,
			shadowMapCascade: this.shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			perPixel: material.perPixel,
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		material.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters );

		var attributes = material.program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = "morphTarget";

			for ( i = 0; i < this.maxMorphTargets; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = "morphNormal";

			for ( i = 0; i < this.maxMorphNormals; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		for ( u in material.uniforms ) {

			material.uniformsList.push( [ material.uniforms[ u ], u ] );

		}

	};

	function setMaterialShaders( material, shaders ) {

		material.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );
		material.vertexShader = shaders.vertexShader;
		material.fragmentShader = shaders.fragmentShader;

	};

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program ) deallocateMaterial( material );

			_this.initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

			}

		}

		var refreshMaterial = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.uniforms;

		if ( program !== _currentProgram ) {

			_gl.useProgram( program );
			_currentProgram = program;

			refreshMaterial = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;
			refreshMaterial = true;

		}

		if ( refreshMaterial || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( camera !== _currentCamera ) _currentCamera = camera;

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( _supportsBoneTextures && object.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.boneTexture, textureUnit );

				}

			} else {

				if ( p_uniforms.boneGlobalMatrices !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					setupLights( program, lights );
					_lightsNeedUpdate = false;

				}

				refreshUniformsLights( m_uniforms, _lights );

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.ParticleBasicMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( program, material.uniformsList );

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.getPositionFromMatrix( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	};

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value = material.color;

		}

		uniforms.map.value = material.map;
		uniforms.lightMap.value = material.lightMap;
		uniforms.specularMap.value = material.specularMap;

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//	1. color map
		//	2. specular map
		//	3. normal map
		//	4. bump map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		}

		if ( uvScaleMap !== undefined ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;

		if ( _this.gammaInput ) {

			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
			uniforms.reflectivity.value = material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;
		uniforms.combine.value = material.combine;
		uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

	};

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	};

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	};

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

	};

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	};

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.specular.value.copyGammaToLinear( material.specular );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	};

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	};

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

		}

	};

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			console.warn( "WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	};

	function loadUniformsGeneric ( program, uniforms ) {

		var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;

		for ( j = 0, jl = uniforms.length; j < jl; j ++ ) {

			location = program.uniforms[ uniforms[ j ][ 1 ] ];
			if ( !location ) continue;

			uniform = uniforms[ j ][ 0 ];

			type = uniform.type;
			value = uniform.value;

			if ( type === "i" ) { // single integer

				_gl.uniform1i( location, value );

			} else if ( type === "f" ) { // single float

				_gl.uniform1f( location, value );

			} else if ( type === "v2" ) { // single THREE.Vector2

				_gl.uniform2f( location, value.x, value.y );

			} else if ( type === "v3" ) { // single THREE.Vector3

				_gl.uniform3f( location, value.x, value.y, value.z );

			} else if ( type === "v4" ) { // single THREE.Vector4

				_gl.uniform4f( location, value.x, value.y, value.z, value.w );

			} else if ( type === "c" ) { // single THREE.Color

				_gl.uniform3f( location, value.r, value.g, value.b );

			} else if ( type === "iv1" ) { // flat array of integers (JS or typed array)

				_gl.uniform1iv( location, value );

			} else if ( type === "iv" ) { // flat array of integers with 3 x N size (JS or typed array)

				_gl.uniform3iv( location, value );

			} else if ( type === "fv1" ) { // flat array of floats (JS or typed array)

				_gl.uniform1fv( location, value );

			} else if ( type === "fv" ) { // flat array of floats with 3 x N size (JS or typed array)

				_gl.uniform3fv( location, value );

			} else if ( type === "v2v" ) { // array of THREE.Vector2

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 2 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 2;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;

				}

				_gl.uniform2fv( location, uniform._array );

			} else if ( type === "v3v" ) { // array of THREE.Vector3

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 3 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 3;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;

				}

				_gl.uniform3fv( location, uniform._array );

			} else if ( type === "v4v" ) { // array of THREE.Vector4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 4 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 4;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;
					uniform._array[ offset + 3 ] = value[ i ].w;

				}

				_gl.uniform4fv( location, uniform._array );

			} else if ( type === "m4") { // single THREE.Matrix4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 16 );

				}

				value.flattenToArray( uniform._array );
				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "m4v" ) { // array of THREE.Matrix4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 16 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

				}

				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "t" ) { // single THREE.Texture (2d or cube)

				texture = value;
				textureUnit = getTextureUnit();

				_gl.uniform1i( location, textureUnit );

				if ( !texture ) continue;

				if ( texture.image instanceof Array && texture.image.length === 6 ) {

					setCubeTexture( texture, textureUnit );

				} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

					setCubeTextureDynamic( texture, textureUnit );

				} else {

					_this.setTexture( texture, textureUnit );

				}

			} else if ( type === "tv" ) { // array of THREE.Texture (2d)

				if ( uniform._array === undefined ) {

					uniform._array = [];

				}

				for( i = 0, il = uniform.value.length; i < il; i ++ ) {

					uniform._array[ i ] = getTextureUnit();

				}

				_gl.uniform1iv( location, uniform._array );

				for( i = 0, il = uniform.value.length; i < il; i ++ ) {

					texture = uniform.value[ i ];
					textureUnit = uniform._array[ i ];

					if ( !texture ) continue;

					_this.setTexture( texture, textureUnit );

				}

			}

		}

	};

	function setupMatrices ( object, camera ) {

		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

		object._normalMatrix.getInverse( object._modelViewMatrix );
		object._normalMatrix.transpose();

	};

	//

	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	};

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	};

	function setupLights ( program, lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.getPositionFromMatrix( light.matrixWorld );
				_vector3.getPositionFromMatrix( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				if ( _this.gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				_vector3.getPositionFromMatrix( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				_vector3.getPositionFromMatrix( light.matrixWorld );

				spotPositions[ spotOffset ]     = _vector3.x;
				spotPositions[ spotOffset + 1 ] = _vector3.y;
				spotPositions[ spotOffset + 2 ] = _vector3.z;

				spotDistances[ spotLength ] = distance;

				_direction.copy( _vector3 );
				_vector3.getPositionFromMatrix( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.getPositionFromMatrix( light.matrixWorld );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( _this.gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	};

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};

	this.setMaterialFaces = function ( material ) {

		var doubleSided = material.side === THREE.DoubleSide;
		var flipSided = material.side === THREE.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	};

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

		if ( blending !== _oldBlending ) {

			if ( blending === THREE.NoBlending ) {

				_gl.disable( _gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				_gl.enable( _gl.BLEND );

			} else {

				_gl.enable( _gl.BLEND );
				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	};

	// Defines

	function generateDefines ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = "#define " + d + " " + value;
			chunks.push( chunk );

		}

		return chunks.join( "\n" );

	};

	// Shaders

	function buildProgram ( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters ) {

		var p, pl, d, program, code;
		var chunks = [];

		// Generate code

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( fragmentShader );
			chunks.push( vertexShader );

		}

		for ( d in defines ) {

			chunks.push( d );
			chunks.push( defines[ d ] );

		}

		for ( p in parameters ) {

			chunks.push( p );
			chunks.push( parameters[ p ] );

		}

		code = chunks.join();

		// Check if code has been already compiled

		for ( p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code === code ) {

				//console.log( "Code already compiled." /*: \n\n" + code*/ );

				programInfo.usedTimes ++;

				return programInfo.program;

			}

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		//console.log( "building new program " );

		//

		var customDefines = generateDefines( defines );

		//

		program = _gl.createProgram();

		var prefix_vertex = [

			"precision " + _precision + " float;",

			customDefines,

			_supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
			_this.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
			"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
			"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			"#define MAX_BONES " + parameters.maxBones,

			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",

			parameters.skinning ? "#define USE_SKINNING" : "",
			parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
			parameters.boneTextureWidth ? "#define N_BONE_PIXEL_X " + parameters.boneTextureWidth.toFixed( 1 ) : "",
			parameters.boneTextureHeight ? "#define N_BONE_PIXEL_Y " + parameters.boneTextureHeight.toFixed( 1 ) : "",

			parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
			parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
			parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",
			parameters.wrapAround ? "#define WRAP_AROUND" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

			"uniform mat4 modelMatrix;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;",
			"uniform vec3 cameraPosition;",

			"attribute vec3 position;",
			"attribute vec3 normal;",
			"attribute vec2 uv;",
			"attribute vec2 uv2;",

			"#ifdef USE_COLOR",

				"attribute vec3 color;",

			"#endif",

			"#ifdef USE_MORPHTARGETS",

				"attribute vec3 morphTarget0;",
				"attribute vec3 morphTarget1;",
				"attribute vec3 morphTarget2;",
				"attribute vec3 morphTarget3;",

				"#ifdef USE_MORPHNORMALS",

					"attribute vec3 morphNormal0;",
					"attribute vec3 morphNormal1;",
					"attribute vec3 morphNormal2;",
					"attribute vec3 morphNormal3;",

				"#else",

					"attribute vec3 morphTarget4;",
					"attribute vec3 morphTarget5;",
					"attribute vec3 morphTarget6;",
					"attribute vec3 morphTarget7;",

				"#endif",

			"#endif",

			"#ifdef USE_SKINNING",

				"attribute vec4 skinIndex;",
				"attribute vec4 skinWeight;",

			"#endif",

			""

		].join("\n");

		var prefix_fragment = [

			"precision " + _precision + " float;",

			( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

			customDefines,

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
			"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
			"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",
			_this.physicallyBasedShading ? "#define PHYSICALLY_BASED_SHADING" : "",

			( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
			( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",

			parameters.metal ? "#define METAL" : "",
			parameters.perPixel ? "#define PHONG_PER_PIXEL" : "",
			parameters.wrapAround ? "#define WRAP_AROUND" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			"uniform mat4 viewMatrix;",
			"uniform vec3 cameraPosition;",
			""

		].join("\n");

		var glFragmentShader = getShader( "fragment", prefix_fragment + fragmentShader );
		var glVertexShader = getShader( "vertex", prefix_vertex + vertexShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		_gl.linkProgram( program );

		if ( !_gl.getProgramParameter( program, _gl.LINK_STATUS ) ) {

			console.error( "Could not initialise shader\n" + "VALIDATE_STATUS: " + _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) + ", gl error [" + _gl.getError() + "]" );

		}

		// clean up

		_gl.deleteShader( glFragmentShader );
		_gl.deleteShader( glVertexShader );

		//console.log( prefix_fragment + fragmentShader );
		//console.log( prefix_vertex + vertexShader );

		program.uniforms = {};
		program.attributes = {};

		var identifiers, u, a, i;

		// cache uniform locations

		identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
			'morphTargetInfluences'

		];

		if ( parameters.useVertexTexture ) {

			identifiers.push( 'boneTexture' );

		} else {

			identifiers.push( 'boneGlobalMatrices' );

		}

		for ( u in uniforms ) {

			identifiers.push( u );

		}

		cacheUniformLocations( program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinIndex", "skinWeight", "lineDistance"

		];

		for ( i = 0; i < parameters.maxMorphTargets; i ++ ) {

			identifiers.push( "morphTarget" + i );

		}

		for ( i = 0; i < parameters.maxMorphNormals; i ++ ) {

			identifiers.push( "morphNormal" + i );

		}

		for ( a in attributes ) {

			identifiers.push( a );

		}

		cacheAttributeLocations( program, identifiers );

		program.id = _programs_counter ++;

		_programs.push( { program: program, code: code, usedTimes: 1 } );

		_this.info.memory.programs = _programs.length;

		return program;

	};

	// Shader parameters cache

	function cacheUniformLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i ++ ) {

			id = identifiers[ i ];
			program.uniforms[ id ] = _gl.getUniformLocation( program, id );

		}

	};

	function cacheAttributeLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i ++ ) {

			id = identifiers[ i ];
			program.attributes[ id ] = _gl.getAttribLocation( program, id );

		}

	};

	function addLineNumbers ( string ) {

		var chunks = string.split( "\n" );

		for ( var i = 0, il = chunks.length; i < il; i ++ ) {

			// Chrome reports shader errors on lines
			// starting counting from 1

			chunks[ i ] = ( i + 1 ) + ": " + chunks[ i ];

		}

		return chunks.join( "\n" );

	};

	function getShader ( type, string ) {

		var shader;

		if ( type === "fragment" ) {

			shader = _gl.createShader( _gl.FRAGMENT_SHADER );

		} else if ( type === "vertex" ) {

			shader = _gl.createShader( _gl.VERTEX_SHADER );

		}

		_gl.shaderSource( shader, string );
		_gl.compileShader( shader );

		if ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {

			console.error( _gl.getShaderInfoLog( shader ) );
			console.error( addLineNumbers( string ) );
			return null;

		}

		return shader;

	};

	// Textures


	function isPowerOfTwo ( value ) {

		return ( value & ( value - 1 ) ) === 0;

	};

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		if ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	};

	this.setTexture = function ( texture, slot ) {

		if ( texture.needsUpdate ) {

			if ( ! texture.__webglInit ) {

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				texture.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

			}

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = texture.image,
			isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				// compressed textures can only use manually created mipmaps
				// WebGL can't generate mipmaps for DDS textures

				for( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

				}

			} else { // regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate ) texture.onUpdate();

		} else {

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width <= maxSize && image.height <= maxSize ) {

			return image;

		}

		// Warning: Scaling through the canvas will only work with images that use
		// premultiplied alpha.

		var maxDimension = Math.max( image.width, image.height );
		var newWidth = Math.floor( image.width * maxSize / maxDimension );
		var newHeight = Math.floor( image.height * maxSize / maxDimension );

		var canvas = document.createElement( 'canvas' );
		canvas.width = newWidth;
		canvas.height = newHeight;

		var ctx = canvas.getContext( "2d" );
		ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

		return canvas;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if ( isCompressed ) {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];
							_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						}

					} else {

						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

					}

				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	};

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	};

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	};

	function setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/
		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	};

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && ! renderTarget.__webglFramebuffer ) {

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = isPowerOfTwo( renderTarget.width ) && isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	function updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

		}

	};

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	};

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		if ( _glExtensionCompressedTextureS3TC !== undefined ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		return 0;

	};

	// Allocations

	function allocateBones ( object ) {

		if ( _supportsBoneTextures && object && object.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			// 	- leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.bones.length, maxBones );

				if ( maxBones < object.bones.length ) {

					console.warn( "WebGLRenderer: too many bones - " + object.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)" );

				}

			}

			return maxBones;

		}

	};

	function allocateLights ( lights ) {

		var l, ll, light, dirLights, pointLights, spotLights, hemiLights;

		dirLights = pointLights = spotLights = hemiLights = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };

	};

	function allocateShadows ( lights ) {

		var l, ll, light, maxShadows = 0;

		for ( l = 0, ll = lights.length; l < ll; l++ ) {

			light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	};

	// Initialization

	function initGL () {

		try {

			if ( ! ( _gl = _canvas.getContext( 'experimental-webgl', { alpha: _alpha, premultipliedAlpha: _premultipliedAlpha, antialias: _antialias, stencil: _stencil, preserveDrawingBuffer: _preserveDrawingBuffer } ) ) ) {

				throw 'Error creating WebGL context.';

			}

		} catch ( error ) {

			console.error( error );

		}

		_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
		_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );

		_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) ||
											   _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) ||
											   _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );


		_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) ||
											_gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) ||
											_gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );

		if ( ! _glExtensionTextureFloat ) {

			console.log( 'THREE.WebGLRenderer: Float textures not supported.' );

		}

		if ( ! _glExtensionStandardDerivatives ) {

			console.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );

		}

		if ( ! _glExtensionTextureFilterAnisotropic ) {

			console.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );

		}

		if ( ! _glExtensionCompressedTextureS3TC ) {

			console.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );

		}
		
		if ( _gl.getShaderPrecisionFormat === undefined ) {
			
			_gl.getShaderPrecisionFormat = function() { 
				
				return {
					"rangeMin"  : 1,
					"rangeMax"  : 1,
					"precision" : 1
				};
				
			}
		}

	};

	function setDefaultGLState () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	// default plugins (order is important)

	this.shadowMapPlugin = new THREE.ShadowMapPlugin();
	this.addPrePlugin( this.shadowMapPlugin );

	this.addPostPlugin( new THREE.SpritePlugin() );
	this.addPostPlugin( new THREE.LensFlarePlugin() );

};
/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	THREE.EventDispatcher.call( this );

	this.width = width;
	this.height = height;

	options = options || {};

	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.generateMipmaps = true;

	this.shareDepthFrom = null;

};

THREE.WebGLRenderTarget.prototype.clone = function() {

	var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

	tmp.wrapS = this.wrapS;
	tmp.wrapT = this.wrapT;

	tmp.magFilter = this.magFilter;
	tmp.minFilter = this.minFilter;

	tmp.anisotropy = this.anisotropy;

	tmp.offset.copy( this.offset );
	tmp.repeat.copy( this.repeat );

	tmp.format = this.format;
	tmp.type = this.type;

	tmp.depthBuffer = this.depthBuffer;
	tmp.stencilBuffer = this.stencilBuffer;

	tmp.generateMipmaps = this.generateMipmaps;

	tmp.shareDepthFrom = this.shareDepthFrom;

	return tmp;

};

THREE.WebGLRenderTarget.prototype.dispose = function () {

	this.dispatchEvent( { type: 'dispose' } );

};
/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableVertex = function () {

	this.positionWorld = new THREE.Vector3();
	this.positionScreen = new THREE.Vector4();

	this.visible = true;

};

THREE.RenderableVertex.prototype.copy = function ( vertex ) {

	this.positionWorld.copy( vertex.positionWorld );
	this.positionScreen.copy( vertex.positionScreen );

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableFace3 = function () {

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();
	this.v3 = new THREE.RenderableVertex();

	this.centroidModel = new THREE.Vector3();

	this.normalModel = new THREE.Vector3();
	this.normalModelView = new THREE.Vector3();

	this.vertexNormalsLength = 0;
	this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	this.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

	this.color = null;
	this.material = null;
	this.uvs = [[]];

	this.z = null;

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableFace4 = function () {

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();
	this.v3 = new THREE.RenderableVertex();
	this.v4 = new THREE.RenderableVertex();

	this.centroidModel = new THREE.Vector3();

	this.normalModel = new THREE.Vector3();
	this.normalModelView = new THREE.Vector3();

	this.vertexNormalsLength = 0;
	this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	this.vertexNormalsModelView = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];

	this.color = null;
	this.material = null;
	this.uvs = [[]];

	this.z = null;

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableObject = function () {

	this.object = null;
	this.z = null;

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableParticle = function () {

	this.object = null;

	this.x = null;
	this.y = null;
	this.z = null;

	this.rotation = null;
	this.scale = new THREE.Vector2();

	this.material = null;

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableLine = function () {

	this.z = null;

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();

	this.material = null;

};
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.GeometryUtils = {

	// Merge two geometries or geometry and geometry from object (using object's transform)

	merge: function ( geometry1, object2 /* mesh | geometry */ ) {

		var matrix, normalMatrix,
		vertexOffset = geometry1.vertices.length,
		uvPosition = geometry1.faceVertexUvs[ 0 ].length,
		geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,
		vertices1 = geometry1.vertices,
		vertices2 = geometry2.vertices,
		faces1 = geometry1.faces,
		faces2 = geometry2.faces,
		uvs1 = geometry1.faceVertexUvs[ 0 ],
		uvs2 = geometry2.faceVertexUvs[ 0 ];

		if ( object2 instanceof THREE.Mesh ) {

			object2.matrixAutoUpdate && object2.updateMatrix();

			matrix = object2.matrix;

			normalMatrix = new THREE.Matrix3();
			normalMatrix.getInverse( matrix );
			normalMatrix.transpose();

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			if ( face instanceof THREE.Face3 ) {

				faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );

			} else if ( face instanceof THREE.Face4 ) {

				faceCopy = new THREE.Face4( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset, face.d + vertexOffset );

			}

			faceCopy.normal.copy( face.normal );

			if ( normalMatrix ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex;

			faceCopy.centroid.copy( face.centroid );

			if ( matrix ) {

				faceCopy.centroid.applyMatrix4( matrix );

			}

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			uvs1.push( uvCopy );

		}

	},

	removeMaterials: function ( geometry, materialIndexArray ) {

		var materialIndexMap = {};

		for ( var i = 0, il = materialIndexArray.length; i < il; i ++ ) {

			materialIndexMap[ materialIndexArray[i] ] = true;

		}

		var face, newFaces = [];

		for ( var i = 0, il = geometry.faces.length; i < il; i ++ ) {

			face = geometry.faces[ i ];
			if ( ! ( face.materialIndex in materialIndexMap ) ) newFaces.push( face );

		}

		geometry.faces = newFaces;

	},

	// Get random point in triangle (via barycentric coordinates)
	// 	(uniform distribution)
	// 	http://www.cgafaq.info/wiki/Random_Point_In_Triangle

	randomPointInTriangle: function ( vectorA, vectorB, vectorC ) {

		var a, b, c,
			point = new THREE.Vector3(),
			tmp = THREE.GeometryUtils.__v1;

		a = THREE.GeometryUtils.random();
		b = THREE.GeometryUtils.random();

		if ( ( a + b ) > 1 ) {

			a = 1 - a;
			b = 1 - b;

		}

		c = 1 - a - b;

		point.copy( vectorA );
		point.multiplyScalar( a );

		tmp.copy( vectorB );
		tmp.multiplyScalar( b );

		point.add( tmp );

		tmp.copy( vectorC );
		tmp.multiplyScalar( c );

		point.add( tmp );

		return point;

	},

	// Get random point in face (triangle / quad)
	// (uniform distribution)

	randomPointInFace: function ( face, geometry, useCachedAreas ) {

		var vA, vB, vC, vD;

		if ( face instanceof THREE.Face3 ) {

			vA = geometry.vertices[ face.a ];
			vB = geometry.vertices[ face.b ];
			vC = geometry.vertices[ face.c ];

			return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );

		} else if ( face instanceof THREE.Face4 ) {

			vA = geometry.vertices[ face.a ];
			vB = geometry.vertices[ face.b ];
			vC = geometry.vertices[ face.c ];
			vD = geometry.vertices[ face.d ];

			var area1, area2;

			if ( useCachedAreas ) {

				if ( face._area1 && face._area2 ) {

					area1 = face._area1;
					area2 = face._area2;

				} else {

					area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );
					area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );

					face._area1 = area1;
					face._area2 = area2;

				}

			} else {

				area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD ),
				area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );

			}

			var r = THREE.GeometryUtils.random() * ( area1 + area2 );

			if ( r < area1 ) {

				return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vD );

			} else {

				return THREE.GeometryUtils.randomPointInTriangle( vB, vC, vD );

			}

		}

	},

	// Get uniformly distributed random points in mesh
	// 	- create array with cumulative sums of face areas
	//  - pick random number from 0 to total area
	//  - find corresponding place in area array by binary search
	//	- get random point in face

	randomPointsInGeometry: function ( geometry, n ) {

		var face, i,
			faces = geometry.faces,
			vertices = geometry.vertices,
			il = faces.length,
			totalArea = 0,
			cumulativeAreas = [],
			vA, vB, vC, vD;

		// precompute face areas

		for ( i = 0; i < il; i ++ ) {

			face = faces[ i ];

			if ( face instanceof THREE.Face3 ) {

				vA = vertices[ face.a ];
				vB = vertices[ face.b ];
				vC = vertices[ face.c ];

				face._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );

			} else if ( face instanceof THREE.Face4 ) {

				vA = vertices[ face.a ];
				vB = vertices[ face.b ];
				vC = vertices[ face.c ];
				vD = vertices[ face.d ];

				face._area1 = THREE.GeometryUtils.triangleArea( vA, vB, vD );
				face._area2 = THREE.GeometryUtils.triangleArea( vB, vC, vD );

				face._area = face._area1 + face._area2;

			}

			totalArea += face._area;

			cumulativeAreas[ i ] = totalArea;

		}

		// binary search cumulative areas array

		function binarySearchIndices( value ) {

			function binarySearch( start, end ) {

				// return closest larger index
				// if exact number is not found

				if ( end < start )
					return start;

				var mid = start + Math.floor( ( end - start ) / 2 );

				if ( cumulativeAreas[ mid ] > value ) {

					return binarySearch( start, mid - 1 );

				} else if ( cumulativeAreas[ mid ] < value ) {

					return binarySearch( mid + 1, end );

				} else {

					return mid;

				}

			}

			var result = binarySearch( 0, cumulativeAreas.length - 1 )
			return result;

		}

		// pick random face weighted by face area

		var r, index,
			result = [];

		var stats = {};

		for ( i = 0; i < n; i ++ ) {

			r = THREE.GeometryUtils.random() * totalArea;

			index = binarySearchIndices( r );

			result[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );

			if ( ! stats[ index ] ) {

				stats[ index ] = 1;

			} else {

				stats[ index ] += 1;

			}

		}

		return result;

	},

	// Get triangle area (half of parallelogram)
	//	http://mathworld.wolfram.com/TriangleArea.html

	triangleArea: function ( vectorA, vectorB, vectorC ) {

		var tmp1 = THREE.GeometryUtils.__v1,
			tmp2 = THREE.GeometryUtils.__v2;

		tmp1.subVectors( vectorB, vectorA );
		tmp2.subVectors( vectorC, vectorA );
		tmp1.cross( tmp2 );

		return 0.5 * tmp1.length();

	},

	// Center geometry so that 0,0,0 is in center of bounding box

	center: function ( geometry ) {

		geometry.computeBoundingBox();

		var bb = geometry.boundingBox;

		var offset = new THREE.Vector3();

		offset.addVectors( bb.min, bb.max );
		offset.multiplyScalar( -0.5 );

		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
		geometry.computeBoundingBox();

		return offset;

	},

	// Normalize UVs to be from <0,1>
	// (for now just the first set of UVs)

	normalizeUVs: function ( geometry ) {

		var uvSet = geometry.faceVertexUvs[ 0 ];

		for ( var i = 0, il = uvSet.length; i < il; i ++ ) {

			var uvs = uvSet[ i ];

			for ( var j = 0, jl = uvs.length; j < jl; j ++ ) {

				// texture repeat

				if( uvs[ j ].x !== 1.0 ) uvs[ j ].x = uvs[ j ].x - Math.floor( uvs[ j ].x );
				if( uvs[ j ].y !== 1.0 ) uvs[ j ].y = uvs[ j ].y - Math.floor( uvs[ j ].y );

			}

		}

	},

	triangulateQuads: function ( geometry ) {

		var i, il, j, jl;

		var faces = [];
		var faceUvs = [];
		var faceVertexUvs = [];

		for ( i = 0, il = geometry.faceUvs.length; i < il; i ++ ) {

			faceUvs[ i ] = [];

		}

		for ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

			faceVertexUvs[ i ] = [];

		}

		for ( i = 0, il = geometry.faces.length; i < il; i ++ ) {

			var face = geometry.faces[ i ];

			if ( face instanceof THREE.Face4 ) {

				var a = face.a;
				var b = face.b;
				var c = face.c;
				var d = face.d;

				var triA = new THREE.Face3();
				var triB = new THREE.Face3();

				triA.color.copy( face.color );
				triB.color.copy( face.color );

				triA.materialIndex = face.materialIndex;
				triB.materialIndex = face.materialIndex;

				triA.a = a;
				triA.b = b;
				triA.c = d;

				triB.a = b;
				triB.b = c;
				triB.c = d;

				if ( face.vertexColors.length === 4 ) {

					triA.vertexColors[ 0 ] = face.vertexColors[ 0 ].clone();
					triA.vertexColors[ 1 ] = face.vertexColors[ 1 ].clone();
					triA.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();

					triB.vertexColors[ 0 ] = face.vertexColors[ 1 ].clone();
					triB.vertexColors[ 1 ] = face.vertexColors[ 2 ].clone();
					triB.vertexColors[ 2 ] = face.vertexColors[ 3 ].clone();

				}

				faces.push( triA, triB );

				for ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {

					if ( geometry.faceVertexUvs[ j ].length ) {

						var uvs = geometry.faceVertexUvs[ j ][ i ];

						var uvA = uvs[ 0 ];
						var uvB = uvs[ 1 ];
						var uvC = uvs[ 2 ];
						var uvD = uvs[ 3 ];

						var uvsTriA = [ uvA.clone(), uvB.clone(), uvD.clone() ];
						var uvsTriB = [ uvB.clone(), uvC.clone(), uvD.clone() ];

						faceVertexUvs[ j ].push( uvsTriA, uvsTriB );

					}

				}

				for ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {

					if ( geometry.faceUvs[ j ].length ) {

						var faceUv = geometry.faceUvs[ j ][ i ];

						faceUvs[ j ].push( faceUv, faceUv );

					}

				}

			} else {

				faces.push( face );

				for ( j = 0, jl = geometry.faceUvs.length; j < jl; j ++ ) {

					faceUvs[ j ].push( geometry.faceUvs[ j ][ i ] );

				}

				for ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {

					faceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );

				}

			}

		}

		geometry.faces = faces;
		geometry.faceUvs = faceUvs;
		geometry.faceVertexUvs = faceVertexUvs;

		geometry.computeCentroids();
		geometry.computeFaceNormals();
		geometry.computeVertexNormals();

		if ( geometry.hasTangents ) geometry.computeTangents();

	},

	setMaterialIndex: function ( geometry, index, startFace, endFace ){

		var faces = geometry.faces;
		var start = startFace || 0;
		var end = endFace || faces.length - 1;

		for ( var i = start; i <= end; i ++ ) {

			faces[i].materialIndex = index;

		}

    }

};

THREE.GeometryUtils.random = THREE.Math.random16;

THREE.GeometryUtils.__v1 = new THREE.Vector3();
THREE.GeometryUtils.__v2 = new THREE.Vector3();
/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageUtils = {

	crossOrigin: 'anonymous',

	loadTexture: function ( url, mapping, onLoad, onError ) {

		var image = new Image();
		var texture = new THREE.Texture( image, mapping );

		var loader = new THREE.ImageLoader();

		loader.addEventListener( 'load', function ( event ) {

			texture.image = event.content;
			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		} );

		loader.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event.message );

		} );

		loader.crossOrigin = this.crossOrigin;
		loader.load( url, image );

		texture.sourceFile = url;

		return texture;

	},

	loadCompressedTexture: function ( url, mapping, onLoad, onError ) {

		var texture = new THREE.CompressedTexture();
		texture.mapping = mapping;

		var request = new XMLHttpRequest();

		request.onload = function () {

			var buffer = request.response;
			var dds = THREE.ImageUtils.parseDDS( buffer, true );

			texture.format = dds.format;

			texture.mipmaps = dds.mipmaps;
			texture.image.width = dds.width;
			texture.image.height = dds.height;

			// gl.generateMipmap fails for compressed textures
			// mipmaps must be embedded in the DDS file
			// or texture filters must not use mipmapping

			texture.generateMipmaps = false;

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		}

		request.onerror = onError;

		request.open( 'GET', url, true );
		request.responseType = "arraybuffer";
		request.send( null );

		return texture;

	},

	loadTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.Texture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping needed for cube textures

		texture.flipY = false;

		for ( var i = 0, il = array.length; i < il; ++ i ) {

			var cubeImage = new Image();
			images[ i ] = cubeImage;

			cubeImage.onload = function () {

				images.loadCount += 1;

				if ( images.loadCount === 6 ) {

					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			};

			cubeImage.onerror = onError;

			cubeImage.crossOrigin = this.crossOrigin;
			cubeImage.src = array[ i ];

		}

		return texture;

	},

	loadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.CompressedTexture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		texture.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		texture.generateMipmaps = false;

		var generateCubeFaceCallback = function ( rq, img ) {

			return function () {

				var buffer = rq.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				img.format = dds.format;

				img.mipmaps = dds.mipmaps;
				img.width = dds.width;
				img.height = dds.height;

				images.loadCount += 1;

				if ( images.loadCount === 6 ) {

					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			}

		}

		// compressed cubemap textures as 6 separate DDS files

		if ( array instanceof Array ) {

			for ( var i = 0, il = array.length; i < il; ++ i ) {

				var cubeImage = {};
				images[ i ] = cubeImage;

				var request = new XMLHttpRequest();

				request.onload = generateCubeFaceCallback( request, cubeImage );
				request.onerror = onError;

				var url = array[ i ];

				request.open( 'GET', url, true );
				request.responseType = "arraybuffer";
				request.send( null );

			}

		// compressed cubemap texture stored in a single DDS file

		} else {

			var url = array;
			var request = new XMLHttpRequest();

			request.onload = function( ) {

				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				if ( dds.isCubemap ) {

					var faces = dds.mipmaps.length / dds.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < dds.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
							images[ f ].format = dds.format;
							images[ f ].width = dds.width;
							images[ f ].height = dds.height;

						}

					}

					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			}

			request.onerror = onError;

			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );

		}

		return texture;

	},

	parseDDS: function ( buffer, loadMipmaps ) {

		var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

		// Adapted from @toji's DDS utils
		//	https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

		// All values and structures referenced from:
		// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

		var DDS_MAGIC = 0x20534444;

		var DDSD_CAPS = 0x1,
			DDSD_HEIGHT = 0x2,
			DDSD_WIDTH = 0x4,
			DDSD_PITCH = 0x8,
			DDSD_PIXELFORMAT = 0x1000,
			DDSD_MIPMAPCOUNT = 0x20000,
			DDSD_LINEARSIZE = 0x80000,
			DDSD_DEPTH = 0x800000;

		var DDSCAPS_COMPLEX = 0x8,
			DDSCAPS_MIPMAP = 0x400000,
			DDSCAPS_TEXTURE = 0x1000;

		var DDSCAPS2_CUBEMAP = 0x200,
			DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
			DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
			DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
			DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
			DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
			DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
			DDSCAPS2_VOLUME = 0x200000;

		var DDPF_ALPHAPIXELS = 0x1,
			DDPF_ALPHA = 0x2,
			DDPF_FOURCC = 0x4,
			DDPF_RGB = 0x40,
			DDPF_YUV = 0x200,
			DDPF_LUMINANCE = 0x20000;

		function fourCCToInt32( value ) {

			return value.charCodeAt(0) +
				(value.charCodeAt(1) << 8) +
				(value.charCodeAt(2) << 16) +
				(value.charCodeAt(3) << 24);

		}

		function int32ToFourCC( value ) {

			return String.fromCharCode(
				value & 0xff,
				(value >> 8) & 0xff,
				(value >> 16) & 0xff,
				(value >> 24) & 0xff
			);
		}

		var FOURCC_DXT1 = fourCCToInt32("DXT1");
		var FOURCC_DXT3 = fourCCToInt32("DXT3");
		var FOURCC_DXT5 = fourCCToInt32("DXT5");

		var headerLengthInt = 31; // The header length in 32 bit ints

		// Offsets into the header array

		var off_magic = 0;

		var off_size = 1;
		var off_flags = 2;
		var off_height = 3;
		var off_width = 4;

		var off_mipmapCount = 7;

		var off_pfFlags = 20;
		var off_pfFourCC = 21;

		var off_caps = 27;
		var off_caps2 = 28;
		var off_caps3 = 29;
		var off_caps4 = 30;

		// Parse header

		var header = new Int32Array( buffer, 0, headerLengthInt );

		if ( header[ off_magic ] !== DDS_MAGIC ) {

			console.error( "ImageUtils.parseDDS(): Invalid magic number in DDS header" );
			return dds;

		}

		if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {

			console.error( "ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code" );
			return dds;

		}

		var blockBytes;

		var fourCC = header[ off_pfFourCC ];

		switch ( fourCC ) {

			case FOURCC_DXT1:

				blockBytes = 8;
				dds.format = THREE.RGB_S3TC_DXT1_Format;
				break;

			case FOURCC_DXT3:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT3_Format;
				break;

			case FOURCC_DXT5:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT5_Format;
				break;

			default:

				console.error( "ImageUtils.parseDDS(): Unsupported FourCC code: ", int32ToFourCC( fourCC ) );
				return dds;

		}

		dds.mipmapCount = 1;

		if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {

			dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

		}

		//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.

		dds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;

		dds.width = header[ off_width ];
		dds.height = header[ off_height ];

		var dataOffset = header[ off_size ] + 4;

		// Extract mipmaps buffers

		var width = dds.width;
		var height = dds.height;

		var faces = dds.isCubemap ? 6 : 1;

		for ( var face = 0; face < faces; face ++ ) {

			for ( var i = 0; i < dds.mipmapCount; i ++ ) {

				var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
				var byteArray = new Uint8Array( buffer, dataOffset, dataLength );

				var mipmap = { "data": byteArray, "width": width, "height": height };
				dds.mipmaps.push( mipmap );

				dataOffset += dataLength;

				width = Math.max( width * 0.5, 1 );
				height = Math.max( height * 0.5, 1 );

			}

			width = dds.width;
			height = dds.height;

		}

		return dds;

	},

	getNormalMap: function ( image, depth ) {

		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

		var cross = function ( a, b ) {

			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

		}

		var subtract = function ( a, b ) {

			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

		}

		var normalize = function ( a ) {

			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

		}

		depth = depth | 1;

		var width = image.width;
		var height = image.height;

		var canvas = document.createElement( 'canvas' );
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext( '2d' );
		context.drawImage( image, 0, 0 );

		var data = context.getImageData( 0, 0, width, height ).data;
		var imageData = context.createImageData( width, height );
		var output = imageData.data;

		for ( var x = 0; x < width; x ++ ) {

			for ( var y = 0; y < height; y ++ ) {

				var ly = y - 1 < 0 ? 0 : y - 1;
				var uy = y + 1 > height - 1 ? height - 1 : y + 1;
				var lx = x - 1 < 0 ? 0 : x - 1;
				var ux = x + 1 > width - 1 ? width - 1 : x + 1;

				var points = [];
				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

				var normals = [];
				var num_points = points.length;

				for ( var i = 0; i < num_points; i ++ ) {

					var v1 = points[ i ];
					var v2 = points[ ( i + 1 ) % num_points ];
					v1 = subtract( v1, origin );
					v2 = subtract( v2, origin );
					normals.push( normalize( cross( v1, v2 ) ) );

				}

				var normal = [ 0, 0, 0 ];

				for ( var i = 0; i < normals.length; i ++ ) {

					normal[ 0 ] += normals[ i ][ 0 ];
					normal[ 1 ] += normals[ i ][ 1 ];
					normal[ 2 ] += normals[ i ][ 2 ];

				}

				normal[ 0 ] /= normals.length;
				normal[ 1 ] /= normals.length;
				normal[ 2 ] /= normals.length;

				var idx = ( y * width + x ) * 4;

				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
				output[ idx + 3 ] = 255;

			}

		}

		context.putImageData( imageData, 0, 0 );

		return canvas;

	},

	generateDataTexture: function ( width, height, color ) {

		var size = width * height;
		var data = new Uint8Array( 3 * size );

		var r = Math.floor( color.r * 255 );
		var g = Math.floor( color.g * 255 );
		var b = Math.floor( color.b * 255 );

		for ( var i = 0; i < size; i ++ ) {

			data[ i * 3 ] 	  = r;
			data[ i * 3 + 1 ] = g;
			data[ i * 3 + 2 ] = b;

		}

		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
		texture.needsUpdate = true;

		return texture;

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Object3D();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach : function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 * 	typeface.js and canvastext
 * 		For converting fonts and rendering with javascript
 *		http://typeface.neocracy.org
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

	faces : {},

	// Just for now. face[weight][style]

	face : "helvetiker",
	weight: "normal",
	style : "normal",
	size : 150,
	divisions : 10,

	getFace : function() {

		return this.faces[ this.face ][ this.weight ][ this.style ];

	},

	loadFace : function( data ) {

		var family = data.familyName.toLowerCase();

		var ThreeFont = this;

		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		return data;

	},

	drawText : function( text ) {

		var characterPts = [], allPts = [];

		// RenderText

		var i, p,
			face = this.getFace(),
			scale = this.size / face.resolution,
			offset = 0,
			chars = String( text ).split( '' ),
			length = chars.length;

		var fontPaths = [];

		for ( i = 0; i < length; i ++ ) {

			var path = new THREE.Path();

			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
			offset += ret.offset;

			fontPaths.push( ret.path );

		}

		// get the width

		var width = offset / 2;
		//
		// for ( p = 0; p < allPts.length; p++ ) {
		//
		// 	allPts[ p ].x -= width;
		//
		// }

		//var extract = this.extractPoints( allPts, characterPts );
		//extract.contour = allPts;

		//extract.paths = fontPaths;
		//extract.offset = width;

		return { paths : fontPaths, offset : width };

	},




	extractGlyphPoints : function( c, face, scale, offset, path ) {

		var pts = [];

		var i, i2, divisions,
			outline, action, length,
			scaleX, scaleY,
			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
			laste,
			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

		if ( !glyph ) return;

		if ( glyph.o ) {

			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
			length = outline.length;

			scaleX = scale;
			scaleY = scale;

			for ( i = 0; i < length; ) {

				action = outline[ i ++ ];

				//console.log( action );

				switch( action ) {

				case 'm':

					// Move To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;

					path.moveTo( x, y );
					break;

				case 'l':

					// Line To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;
					path.lineTo(x,y);
					break;

				case 'q':

					// QuadraticCurveTo

					cpx  = outline[ i++ ] * scaleX + offset;
					cpy  = outline[ i++ ] * scaleY;
					cpx1 = outline[ i++ ] * scaleX + offset;
					cpy1 = outline[ i++ ] * scaleY;

					path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
					  }

				  }

				  break;

				case 'b':

					// Cubic Bezier Curve

					cpx  = outline[ i++ ] *  scaleX + offset;
					cpy  = outline[ i++ ] *  scaleY;
					cpx1 = outline[ i++ ] *  scaleX + offset;
					cpy1 = outline[ i++ ] * -scaleY;
					cpx2 = outline[ i++ ] *  scaleX + offset;
					cpy2 = outline[ i++ ] * -scaleY;

					path.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

						}

					}

					break;

				}

			}
		}



		return { offset: glyph.ha*scale, path:path};
	}

};


THREE.FontUtils.generateShapes = function( text, parameters ) {

	// Parameters 

	parameters = parameters || {};

	var size = parameters.size !== undefined ? parameters.size : 100;
	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;

	var font = parameters.font !== undefined ? parameters.font : "helvetiker";
	var weight = parameters.weight !== undefined ? parameters.weight : "normal";
	var style = parameters.style !== undefined ? parameters.style : "normal";

	THREE.FontUtils.size = size;
	THREE.FontUtils.divisions = curveSegments;

	THREE.FontUtils.face = font;
	THREE.FontUtils.weight = weight;
	THREE.FontUtils.style = style;

	// Get a Font data json object

	var data = THREE.FontUtils.drawText( text );

	var paths = data.paths;
	var shapes = [];

	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

	}

	return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function( namespace ) {

	var EPSILON = 0.0000000001;

	// takes in an contour array and returns

	var process = function( contour, indices ) {

		var n = contour.length;

		if ( n < 3 ) return null;

		var result = [],
			verts = [],
			vertIndices = [];

		/* we want a counter-clockwise polygon in verts */

		var u, v, w;

		if ( area( contour ) > 0.0 ) {

			for ( v = 0; v < n; v++ ) verts[ v ] = v;

		} else {

			for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;

		}

		var nv = n;

		/*  remove nv - 2 vertices, creating 1 triangle every time */

		var count = 2 * nv;   /* error detection */

		for( v = nv - 1; nv > 2; ) {

			/* if we loop, it is probably a non-simple polygon */

			if ( ( count-- ) <= 0 ) {

				//** Triangulate: ERROR - probable bad polygon!

				//throw ( "Warning, unable to triangulate polygon!" );
				//return null;
				// Sometimes warning is fine, especially polygons are triangulated in reverse.
				console.log( "Warning, unable to triangulate polygon!" );

				if ( indices ) return vertIndices;
				return result;

			}

			/* three consecutive vertices in current polygon, <u,v,w> */

			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

			if ( snip( contour, u, v, w, nv, verts ) ) {

				var a, b, c, s, t;

				/* true names of the vertices */

				a = verts[ u ];
				b = verts[ v ];
				c = verts[ w ];

				/* output Triangle */

				result.push( [ contour[ a ],
					contour[ b ],
					contour[ c ] ] );


				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

				/* remove v from the remaining polygon */

				for( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv--;

				/* reset error detection counter */

				count = 2 * nv;

			}

		}

		if ( indices ) return vertIndices;
		return result;

	};

	// calculate area of the contour polygon

	var area = function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for( var p = n - 1, q = 0; q < n; p = q++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	};

	var snip = function ( contour, u, v, w, n, verts ) {

		var p;
		var ax, ay, bx, by;
		var cx, cy, px, py;

		ax = contour[ verts[ u ] ].x;
		ay = contour[ verts[ u ] ].y;

		bx = contour[ verts[ v ] ].x;
		by = contour[ verts[ v ] ].y;

		cx = contour[ verts[ w ] ].x;
		cy = contour[ verts[ w ] ].y;

		if ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;

		var aX, aY, bX, bY, cX, cY;
		var apx, apy, bpx, bpy, cpx, cpy;
		var cCROSSap, bCROSScp, aCROSSbp;

		aX = cx - bx;  aY = cy - by;
		bX = ax - cx;  bY = ay - cy;
		cX = bx - ax;  cY = by - ay;

		for ( p = 0; p < n; p++ ) {

			if( (p === u) || (p === v) || (p === w) ) continue;

			px = contour[ verts[ p ] ].x
			py = contour[ verts[ p ] ].y

			apx = px - ax;  apy = py - ay;
			bpx = px - bx;  bpy = py - by;
			cpx = px - cx;  cpy = py - cy;

			// see if p is inside triangle abc

			aCROSSbp = aX*bpy - aY*bpx;
			cCROSSap = cX*apy - cY*apx;
			bCROSScp = bX*cpy - bY*cpx;

			if ( (aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0) ) return false;

		}

		return true;

	};


	namespace.Triangulate = process;
	namespace.Triangulate.area = area;

	return namespace;

})(THREE.FontUtils);

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This file contains following classes:
 *
 * -- 2d classes --
 * THREE.Curve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

	console.log( "Warning, getPoint() not implemented!" );
	return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPoint( d / divisions ) );

	}

	return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPointAt( d / divisions ) );

	}

	return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

	var lengths = this.getLengths();
	return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

	if ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

	if ( this.cacheArcLengths
		&& ( this.cacheArcLengths.length == divisions + 1 )
		&& !this.needsUpdate) {

		//console.log( "cached", this.cacheArcLengths );
		return this.cacheArcLengths;

	}

	this.needsUpdate = false;

	var cache = [];
	var current, last = this.getPoint( 0 );
	var p, sum = 0;

	cache.push( 0 );

	for ( p = 1; p <= divisions; p ++ ) {

		current = this.getPoint ( p / divisions );
		sum += current.distanceTo( last );
		cache.push( sum );
		last = current;

	}

	this.cacheArcLengths = cache;

	return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
	this.needsUpdate = true;
	this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

	var arcLengths = this.getLengths();

	var i = 0, il = arcLengths.length;

	var targetArcLength; // The targeted u distance value to get

	if ( distance ) {

		targetArcLength = distance;

	} else {

		targetArcLength = u * arcLengths[ il - 1 ];

	}

	//var time = Date.now();

	// binary search for the index with largest value smaller than target u distance

	var low = 0, high = il - 1, comparison;

	while ( low <= high ) {

		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

		comparison = arcLengths[ i ] - targetArcLength;

		if ( comparison < 0 ) {

			low = i + 1;
			continue;

		} else if ( comparison > 0 ) {

			high = i - 1;
			continue;

		} else {

			high = i;
			break;

			// DONE

		}

	}

	i = high;

	//console.log('b' , i, low, high, Date.now()- time);

	if ( arcLengths[ i ] == targetArcLength ) {

		var t = i / ( il - 1 );
		return t;

	}

	// we could get finer grain at lengths, or use simple interpolatation between two points

	var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il -1 );

	return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

	var delta = 0.0001;
	var t1 = t - delta;
	var t2 = t + delta;

	// Capping in case of danger

	if ( t1 < 0 ) t1 = 0;
	if ( t2 > 1 ) t2 = 1;

	var pt1 = this.getPoint( t1 );
	var pt2 = this.getPoint( t2 );

	var vec = pt2.clone().sub(pt1);
	return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getTangent( t );

};

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub(this.v1);
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub(this.v1);

	return tangent.normalize();

};

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

	return new THREE.Vector2( tx, ty );

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

	// returns unit vector

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};


/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};


/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = (points == undefined) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var v = new THREE.Vector2();
	var c = [];
	var points = this.points, point, intPoint, weight;
	point = ( points.length - 1 ) * t;

	intPoint = Math.floor( point );
	weight = point - intPoint;

	c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
	c[ 1 ] = intPoint;
	c[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;
	c[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;

	v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
	v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );

	return v;

};

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius,
							aStartAngle, aEndAngle,
							aClockwise ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( !this.aClockwise ) {

		t = 1 - t;

	}

	var angle = this.aStartAngle + t * deltaAngle;

	var tx = this.aX + this.xRadius * Math.cos( angle );
	var ty = this.aY + this.yRadius * Math.sin( angle );

	return new THREE.Vector2( tx, ty );

};

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );


/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

		return -3 * p0 * (1 - t) * (1 - t)  +
			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
			6 * t *  p2 * (1-t) - 3 * t * t * p2 +
			3 * t * t * p3;
	},


	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3  3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3  2t^2 + t
		var h01 = -6 * t * t + 6 * t; 	//  2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3  t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};


/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var r = new THREE.Vector3();


		r.subVectors( this.v2, this.v1 ); // diff
		r.multiplyScalar( t );
		r.add( this.v1 );

		return r;

	}

);


/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
		tz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);



/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
		tz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);



/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

	function ( t ) {

		var v = new THREE.Vector3();
		var c = [];
		var points = this.points, point, intPoint, weight;
		point = ( points.length - 1 ) * t;

		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

		var pt0 = points[ c[0] ],
			pt1 = points[ c[1] ],
			pt2 = points[ c[2] ],
			pt3 = points[ c[3] ];

		v.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);
		v.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);
		v.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);

		return v;

	}

);


// THREE.SplineCurve3.prototype.getTangent = function(t) {
// 		var v = new THREE.Vector3();
// 		var c = [];
// 		var points = this.points, point, intPoint, weight;
// 		point = ( points.length - 1 ) * t;

// 		intPoint = Math.floor( point );
// 		weight = point - intPoint;

// 		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
// 		c[ 1 ] = intPoint;
// 		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
// 		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

// 		var pt0 = points[ c[0] ],
// 			pt1 = points[ c[1] ],
// 			pt2 = points[ c[2] ],
// 			pt3 = points[ c[3] ];

// 	// t = weight;
// 	v.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );
// 	v.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );
// 	v.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );

// 	return v;

// }

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

    function ( t ) {

        var v = new THREE.Vector3();
        var c = [];
        var points = this.points, point, intPoint, weight;
        point = ( points.length - 0 ) * t;
            // This needs to be from 0-length +1

        intPoint = Math.floor( point );
        weight = point - intPoint;

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
        c[ 0 ] = ( intPoint - 1 ) % points.length;
        c[ 1 ] = ( intPoint ) % points.length;
        c[ 2 ] = ( intPoint + 1 ) % points.length;
        c[ 3 ] = ( intPoint + 2 ) % points.length;

        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );
        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );

        return v;

    }

);
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];
	this.bends = [];
	
	this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[0].getPoint(0);
	var endPoint = this.curves[this.curves.length-1].getPoint(1);
	
	if (!startPoint.equals(endPoint)) {
		this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
	}
	
};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0, diff, curve;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			diff = curveLengths[ i ] - d;
			curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

			break;
		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

		return this.cacheLengths;

	};

	// Get length of subsurve
	// Push sums into cached array

	var lengths = [], sums = 0;
	var i, il = this.curves.length;

	for ( i = 0; i < il; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



// Returns min and max coordinates, as well as centroid

THREE.CurvePath.prototype.getBoundingBox = function () {

	var points = this.getPoints();

	var maxX, maxY, maxZ;
	var minX, minY, minZ;

	maxX = maxY = Number.NEGATIVE_INFINITY;
	minX = minY = Number.POSITIVE_INFINITY;

	var p, i, il, sum;

	var v3 = points[0] instanceof THREE.Vector3;

	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		if ( p.x > maxX ) maxX = p.x;
		else if ( p.x < minX ) minX = p.x;

		if ( p.y > maxY ) maxY = p.y;
		else if ( p.y < minY ) minY = p.y;

		if ( v3 ) {

			if ( p.z > maxZ ) maxZ = p.z;
			else if ( p.z < minZ ) minZ = p.z;

		}

		sum.add( p );

	}

	var ret = {

		minX: minX,
		minY: minY,
		maxX: maxX,
		maxY: maxY,
		centroid: sum.divideScalar( il )

	};

	if ( v3 ) {

		ret.maxZ = maxZ;
		ret.minZ = minZ;

	}

	return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or ParticleSystem objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < points.length; i ++ ) {

		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

	}

	return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

	this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

	var oldPts = this.getSpacedPoints( segments );

	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

	var bounds = this.getBoundingBox();

	var i, il, p, oldX, oldY, xNorm;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[ i ];

		oldX = p.x;
		oldY = p.y;

		xNorm = oldX / bounds.maxX;

		// If using actual distance, for length > path, requires line extrusions
		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

		xNorm = path.getUtoTmapping( xNorm, oldX );

		// check for out of bounds?

		var pathPt = path.getPoint( xNorm );
		var normal = path.getNormalVector( xNorm ).multiplyScalar( oldY );

		p.x = pathPt.x + normal.x;
		p.y = pathPt.y + normal.y;

	}

	return oldPts;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

	THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );

THREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {

	this.matrixAutoUpdate && this.updateMatrix();

	// update matrixWorld

	if ( this.matrixWorldNeedsUpdate || force ) {

		if ( this.parent ) {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			this.matrixWorld.decompose( this.translationWorld, this.rotationWorld, this.scaleWorld );
			this.matrix.decompose( this.translationObject, this.rotationObject, this.scaleObject );

			this.matrixWorld.compose( this.translationWorld, this.rotationObject, this.scaleWorld );


		} else {

			this.matrixWorld.copy( this.matrix );

		}


		this.matrixWorldNeedsUpdate = false;

		force = true;

	}

	// update children

	for ( var i = 0, l = this.children.length; i < l; i ++ ) {

		this.children[ i ].updateMatrixWorld( force );

	}

};

THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
THREE.Gyroscope.prototype.rotationWorld = new THREE.Quaternion();
THREE.Gyroscope.prototype.rotationObject = new THREE.Quaternion();
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call(this);

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );

THREE.PathActions = {

	MOVE_TO: 'moveTo',
	LINE_TO: 'lineTo',
	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
	ARC: 'arc',								// Circle
	ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

		this.lineTo( vectors[ v ].x, vectors[ v ].y );

	};

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );
	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCPx, aCPy ),
												new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
                                               aCP2x, aCP2y,
                                               aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
											new THREE.Vector2( aCP1x, aCP1y ),
											new THREE.Vector2( aCP2x, aCP2y ),
											new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );
	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];
//---
	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc(aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );
	
 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {
	this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };
 
THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
		aStartAngle, aEndAngle, aClockwise );

 };
 

THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var args = Array.prototype.slice.call( arguments );
	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
									aStartAngle, aEndAngle, aClockwise );
	this.curves.push( curve );

	var lastPoint = curve.getPoint(aClockwise ? 1 : 0);
	args.push(lastPoint.x);
	args.push(lastPoint.y);

	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	if (this.useSpacedPoints) {
		console.log('tata');
		return this.getSpacedPoints( divisions, closedPath );
	}

	divisions = divisions || 12;

	var points = [];

	var i, il, item, action, args;
	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, j,
		t, tx, ty;

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		action = item.action;
		args = item.args;

		switch( action ) {

		case THREE.PathActions.MOVE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.LINE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.QUADRATIC_CURVE_TO:

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

		  	}

			break;

		case THREE.PathActions.BEZIER_CURVE_TO:

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.CSPLINE_THRU:

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) ) ;

			}

			break;

		case THREE.PathActions.ARC:

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !!args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;
		  
		case THREE.PathActions.ELLIPSE:

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !!args[ 6 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1];
	var EPSILON = 0.0000000001;
	if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
             Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
		points.splice( points.length - 1, 1);
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

// Breaks path into shapes

THREE.Path.prototype.toShapes = function() {

	var i, il, item, action, args;

	var subPaths = [], lastPath = new THREE.Path();

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		args = item.args;
		action = item.action;

		if ( action == THREE.PathActions.MOVE_TO ) {

			if ( lastPath.actions.length != 0 ) {

				subPaths.push( lastPath );
				lastPath = new THREE.Path();

			}

		}

		lastPath[ action ].apply( lastPath, args );

	}

	if ( lastPath.actions.length != 0 ) {

		subPaths.push( lastPath );

	}

	// console.log(subPaths);

	if ( subPaths.length == 0 ) return [];

	var tmpPath, tmpShape, shapes = [];

	var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
	// console.log("Holes first", holesFirst);

	if ( subPaths.length == 1) {
		tmpPath = subPaths[0];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;
	};

	if ( holesFirst ) {

		tmpShape = new THREE.Shape();

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];

			if ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {

				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );
				tmpShape = new THREE.Shape();

				//console.log('cw', i);

			} else {

				tmpShape.holes.push( tmpPath );

				//console.log('ccw', i);

			}

		}

	} else {

		// Shapes first

		for ( i = 0, il = subPaths.length; i < il; i ++ ) {

			tmpPath = subPaths[ i ];

			if ( THREE.Shape.Utils.isClockWise( tmpPath.getPoints() ) ) {


				if ( tmpShape ) shapes.push( tmpShape );

				tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

			} else {

				tmpShape.holes.push( tmpPath );

			}

		}

		shapes.push( tmpShape );

	}

	//console.log("shape", shapes);

	return shapes;

};
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );
	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	var extruded = new THREE.ExtrudeGeometry( this, options );
	return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	var geometry = new THREE.ShapeGeometry( this, options );
	return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

	}

	return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getTransformedPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	if (this.useSpacedPoints) {
		return this.extractAllSpacedPoints(divisions);
	}

	return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

	return {

		shape: this.getTransformedSpacedPoints( divisions ),
		holes: this.getSpacedPointsHoles( divisions )

	};

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

	/*
		contour - array of vector2 for contour
		holes   - array of array of vector2
	*/

	removeHoles: function ( contour, holes ) {

		var shape = contour.concat(); // work on this shape
		var allpoints = shape.concat();

		/* For each isolated shape, find the closest points and break to the hole to allow triangulation */


		var prevShapeVert, nextShapeVert,
			prevHoleVert, nextHoleVert,
			holeIndex, shapeIndex,
			shapeId, shapeGroup,
			h, h2,
			hole, shortest, d,
			p, pts1, pts2,
			tmpShape1, tmpShape2,
			tmpHole1, tmpHole2,
			verts = [];

		for ( h = 0; h < holes.length; h ++ ) {

			hole = holes[ h ];

			/*
			shapeholes[ h ].concat(); // preserves original
			holes.push( hole );
			*/

			Array.prototype.push.apply( allpoints, hole );

			shortest = Number.POSITIVE_INFINITY;


			// Find the shortest pair of pts between shape and hole

			// Note: Actually, I'm not sure now if we could optimize this to be faster than O(m*n)
			// Using distanceToSquared() intead of distanceTo() should speed a little
			// since running square roots operations are reduced.

			for ( h2 = 0; h2 < hole.length; h2 ++ ) {

				pts1 = hole[ h2 ];
				var dist = [];

				for ( p = 0; p < shape.length; p++ ) {

					pts2 = shape[ p ];
					d = pts1.distanceToSquared( pts2 );
					dist.push( d );

					if ( d < shortest ) {

						shortest = d;
						holeIndex = h2;
						shapeIndex = p;

					}

				}

			}

			//console.log("shortest", shortest, dist);

			prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
			prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			var areaapts = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var areaa = THREE.FontUtils.Triangulate.area( areaapts );

			var areabpts = [

				hole[ holeIndex ],
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			var areab = THREE.FontUtils.Triangulate.area( areabpts );

			var shapeOffset = 1;
			var holeOffset = -1;

			var oldShapeIndex = shapeIndex, oldHoleIndex = holeIndex;
			shapeIndex += shapeOffset;
			holeIndex += holeOffset;

			if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
			shapeIndex %= shape.length;

			if ( holeIndex < 0 ) { holeIndex += hole.length;  }
			holeIndex %= hole.length;

			prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
			prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			areaapts = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var areaa2 = THREE.FontUtils.Triangulate.area( areaapts );

			areabpts = [

				hole[ holeIndex ],
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			var areab2 = THREE.FontUtils.Triangulate.area( areabpts );
			//console.log(areaa,areab ,areaa2,areab2, ( areaa + areab ),  ( areaa2 + areab2 ));

			if ( ( areaa + areab ) > ( areaa2 + areab2 ) ) {

				// In case areas are not correct.
				//console.log("USE THIS");

				shapeIndex = oldShapeIndex;
				holeIndex = oldHoleIndex ;

				if ( shapeIndex < 0 ) { shapeIndex += shape.length;  }
				shapeIndex %= shape.length;

				if ( holeIndex < 0 ) { holeIndex += hole.length;  }
				holeIndex %= hole.length;

				prevShapeVert = ( shapeIndex - 1 ) >= 0 ? shapeIndex - 1 : shape.length - 1;
				prevHoleVert = ( holeIndex - 1 ) >= 0 ? holeIndex - 1 : hole.length - 1;

			} else {

				//console.log("USE THAT ")

			}

			tmpShape1 = shape.slice( 0, shapeIndex );
			tmpShape2 = shape.slice( shapeIndex );
			tmpHole1 = hole.slice( holeIndex );
			tmpHole2 = hole.slice( 0, holeIndex );

			// Should check orders here again?

			var trianglea = [

				hole[ holeIndex ],
				shape[ shapeIndex ],
				shape[ prevShapeVert ]

			];

			var triangleb = [

				hole[ holeIndex ] ,
				hole[ prevHoleVert ],
				shape[ shapeIndex ]

			];

			verts.push( trianglea );
			verts.push( triangleb );

			shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

		}

		return {

			shape:shape, 		/* shape with no holes */
			isolatedPts: verts, /* isolated faces */
			allpoints: allpoints

		}


	},

	triangulateShape: function ( contour, holes ) {

		var shapeWithoutHoles = THREE.Shape.Utils.removeHoles( contour, holes );

		var shape = shapeWithoutHoles.shape,
			allpoints = shapeWithoutHoles.allpoints,
			isolatedPts = shapeWithoutHoles.isolatedPts;

		var triangles = THREE.FontUtils.Triangulate( shape, false ); // True returns indices for points of spooled shape

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		//console.log( "triangles",triangles, triangles.length );
		//console.log( "allpoints",allpoints, allpoints.length );

		var i, il, f, face,
			key, index,
			allPointsMap = {},
			isolatedPointsMap = {};

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.log( "Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		// check isolated points vertices against all points map

		for ( i = 0, il = isolatedPts.length; i < il; i ++ ) {

			face = isolatedPts[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat( isolatedPts );

	}, // end triangulate shapes

	/*
	triangulate2 : function( pts, holes ) {

		// For use with Poly2Tri.js

		var allpts = pts.concat();
		var shape = [];
		for (var p in pts) {
			shape.push(new js.poly2tri.Point(pts[p].x, pts[p].y));
		}

		var swctx = new js.poly2tri.SweepContext(shape);

		for (var h in holes) {
			var aHole = holes[h];
			var newHole = []
			for (i in aHole) {
				newHole.push(new js.poly2tri.Point(aHole[i].x, aHole[i].y));
				allpts.push(aHole[i]);
			}
			swctx.AddHole(newHole);
		}

		var find;
		var findIndexForPt = function (pt) {
			find = new THREE.Vector2(pt.x, pt.y);
			var p;
			for (p=0, pl = allpts.length; p<pl; p++) {
				if (allpts[p].equals(find)) return p;
			}
			return -1;
		};

		// triangulate
		js.poly2tri.sweep.Triangulate(swctx);

		var triangles =  swctx.GetTriangles();
		var tr ;
		var facesPts = [];
		for (var t in triangles) {
			tr =  triangles[t];
			facesPts.push([
				findIndexForPt(tr.GetPoint(0)),
				findIndexForPt(tr.GetPoint(1)),
				findIndexForPt(tr.GetPoint(2))
					]);
		}


	//	console.log(facesPts);
	//	console.log("triangles", triangles.length, triangles);

		// Returns array of faces with 3 element each
	return facesPts;
	},
*/

	isClockWise: function ( pts ) {

		return THREE.FontUtils.Triangulate.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * p;

	},

	b2p1: function ( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	},

	b2p2: function ( t, p ) {

		return t * t * p;

	},

	b2: function ( t, p0, p1, p2 ) {

		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

	},

	// Cubic Bezier Functions

	b3p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	},

	b3p1: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	},

	b3p2: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * t * t * p;

	},

	b3p3: function ( t, p ) {

		return t * t * t * p;

	},

	b3: function ( t, p0, p1, p2, p3 ) {

		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

	}

};

/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = (function() {

	var playing = [];
	var library = {};
	var that    = {};


	//--- update ---

	that.update = function( deltaTimeMS ) {

		for( var i = 0; i < playing.length; i ++ )
			playing[ i ].update( deltaTimeMS );

	};


	//--- add ---

	that.addToUpdate = function( animation ) {

		if ( playing.indexOf( animation ) === -1 )
			playing.push( animation );

	};


	//--- remove ---

	that.removeFromUpdate = function( animation ) {

		var index = playing.indexOf( animation );

		if( index !== -1 )
			playing.splice( index, 1 );

	};


	//--- add ---

	that.add = function( data ) {

		if ( library[ data.name ] !== undefined )
			console.log( "THREE.AnimationHandler.add: Warning! " + data.name + " already exists in library. Overwriting." );

		library[ data.name ] = data;
		initData( data );

	};


	//--- get ---

	that.get = function( name ) {

		if ( typeof name === "string" ) {

			if ( library[ name ] ) {

				return library[ name ];

			} else {

				console.log( "THREE.AnimationHandler.get: Couldn't find animation " + name );
				return null;

			}

		} else {

			// todo: add simple tween library

		}

	};

	//--- parse ---

	that.parse = function( root ) {

		// setup hierarchy

		var hierarchy = [];

		if ( root instanceof THREE.SkinnedMesh ) {

			for( var b = 0; b < root.bones.length; b++ ) {

				hierarchy.push( root.bones[ b ] );

			}

		} else {

			parseRecurseHierarchy( root, hierarchy );

		}

		return hierarchy;

	};

	var parseRecurseHierarchy = function( root, hierarchy ) {

		hierarchy.push( root );

		for( var c = 0; c < root.children.length; c++ )
			parseRecurseHierarchy( root.children[ c ], hierarchy );

	}


	//--- init data ---

	var initData = function( data ) {

		if( data.initialized === true )
			return;


		// loop through all keys

		for( var h = 0; h < data.hierarchy.length; h ++ ) {

			for( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				// remove minus times

				if( data.hierarchy[ h ].keys[ k ].time < 0 )
					data.hierarchy[ h ].keys[ k ].time = 0;


				// create quaternions

				if( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
				 !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

					var quat = data.hierarchy[ h ].keys[ k ].rot;
					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );

				}

			}


			// prepare morph target keys

			if( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

				// get all used

				var usedMorphTargets = {};

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
						usedMorphTargets[ morphTargetName ] = -1;

					}

				}

				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


				// set all used on all frames

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					var influences = {};

					for ( var morphTargetName in usedMorphTargets ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
								break;

							}

						}

						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

							influences[ morphTargetName ] = 0;

						}

					}

					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

				}

			}


			// remove all keys that are on the same time

			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

					data.hierarchy[ h ].keys.splice( k, 1 );
					k --;

				}

			}


			// set index

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				data.hierarchy[ h ].keys[ k ].index = k;

			}

		}


		// JIT

		var lengthInFrames = parseInt( data.length * data.fps, 10 );

		data.JIT = {};
		data.JIT.hierarchy = [];

		for( var h = 0; h < data.hierarchy.length; h ++ )
			data.JIT.hierarchy.push( new Array( lengthInFrames ) );


		// done

		data.initialized = true;

	};


	// interpolation types

	that.LINEAR = 0;
	that.CATMULLROM = 1;
	that.CATMULLROM_FORWARD = 2;

	return that;

}());
/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, name, interpolationType ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( name );
	this.hierarchy = THREE.AnimationHandler.parse( root );

	this.currentTime = 0;
	this.timeScale = 1;

	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	this.interpolationType = interpolationType !== undefined ? interpolationType : THREE.AnimationHandler.LINEAR;

	this.points = [];
	this.target = new THREE.Vector3();

};

THREE.Animation.prototype.play = function ( loop, startTimeMS ) {

	if ( this.isPlaying === false ) {

		this.isPlaying = true;
		this.loop = loop !== undefined ? loop : true;
		this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;

		// reset key cache

		var h, hl = this.hierarchy.length,
			object;

		for ( h = 0; h < hl; h ++ ) {

			object = this.hierarchy[ h ];

			if ( this.interpolationType !== THREE.AnimationHandler.CATMULLROM_FORWARD ) {

				object.useQuaternion = true;

			}

			object.matrixAutoUpdate = true;

			if ( object.animationCache === undefined ) {

				object.animationCache = {};
				object.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };
				object.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };
				object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

			}

			var prevKey = object.animationCache.prevKey;
			var nextKey = object.animationCache.nextKey;

			prevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];
			prevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];
			prevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];

			nextKey.pos = this.getNextKeyWith( "pos", h, 1 );
			nextKey.rot = this.getNextKeyWith( "rot", h, 1 );
			nextKey.scl = this.getNextKeyWith( "scl", h, 1 );

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};


THREE.Animation.prototype.pause = function() {

	if ( this.isPaused === true ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


THREE.Animation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;
	THREE.AnimationHandler.removeFromUpdate( this );

};


THREE.Animation.prototype.update = function ( deltaTimeMS ) {

	// early out

	if ( this.isPlaying === false ) return;


	// vars

	var types = [ "pos", "rot", "scl" ];
	var type;
	var scale;
	var vector;
	var prevXYZ, nextXYZ;
	var prevKey, nextKey;
	var object;
	var animationCache;
	var frame;
	var JIThierarchy = this.data.JIT.hierarchy;
	var currentTime, unloopedCurrentTime;
	var currentPoint, forwardPoint, angle;


	this.currentTime += deltaTimeMS * this.timeScale;

	unloopedCurrentTime = this.currentTime;
	currentTime = this.currentTime = this.currentTime % this.data.length;
	frame = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );


	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		object = this.hierarchy[ h ];
		animationCache = object.animationCache;

		// loop through pos/rot/scl

		for ( var t = 0; t < 3; t ++ ) {

			// get keys

			type    = types[ t ];
			prevKey = animationCache.prevKey[ type ];
			nextKey = animationCache.nextKey[ type ];

			// switch keys?

			if ( nextKey.time <= unloopedCurrentTime ) {

				// did we loop?

				if ( currentTime < unloopedCurrentTime ) {

					if ( this.loop ) {

						prevKey = this.data.hierarchy[ h ].keys[ 0 ];
						nextKey = this.getNextKeyWith( type, h, 1 );

						while( nextKey.time < currentTime ) {

							prevKey = nextKey;
							nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

						}

					} else {

						this.stop();
						return;

					}

				} else {

					do {

						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );

					} while( nextKey.time < currentTime )

				}

				animationCache.prevKey[ type ] = prevKey;
				animationCache.nextKey[ type ] = nextKey;

			}


			object.matrixAutoUpdate = true;
			object.matrixWorldNeedsUpdate = true;

			scale = ( currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );
			prevXYZ = prevKey[ type ];
			nextXYZ = nextKey[ type ];


			// check scale error

			if ( scale < 0 || scale > 1 ) {

				console.log( "THREE.Animation.update: Warning! Scale out of bounds:" + scale + " on bone " + h );
				scale = scale < 0 ? 0 : 1;

			}

			// interpolate

			if ( type === "pos" ) {

				vector = object.position;

				if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {

					vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

				} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
						    this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

					this.points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
					this.points[ 1 ] = prevXYZ;
					this.points[ 2 ] = nextXYZ;
					this.points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];

					scale = scale * 0.33 + 0.33;

					currentPoint = this.interpolateCatmullRom( this.points, scale );

					vector.x = currentPoint[ 0 ];
					vector.y = currentPoint[ 1 ];
					vector.z = currentPoint[ 2 ];

					if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

						forwardPoint = this.interpolateCatmullRom( this.points, scale * 1.01 );

						this.target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
						this.target.sub( vector );
						this.target.y = 0;
						this.target.normalize();

						angle = Math.atan2( this.target.x, this.target.z );
						object.rotation.set( 0, angle, 0 );

					}

				}

			} else if ( type === "rot" ) {

				THREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );

			} else if ( type === "scl" ) {

				vector = object.scale;

				vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
				vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
				vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;

			}

		}

	}

};

// Catmull-Rom spline

THREE.Animation.prototype.interpolateCatmullRom = function ( points, scale ) {

	var c = [], v3 = [],
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	point = ( points.length - 1 ) * scale;
	intPoint = Math.floor( point );
	weight = point - intPoint;

	c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
	c[ 1 ] = intPoint;
	c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
	c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

	pa = points[ c[ 0 ] ];
	pb = points[ c[ 1 ] ];
	pc = points[ c[ 2 ] ];
	pd = points[ c[ 3 ] ];

	w2 = weight * weight;
	w3 = weight * w2;

	v3[ 0 ] = this.interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
	v3[ 1 ] = this.interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
	v3[ 2 ] = this.interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );

	return v3;

};

THREE.Animation.prototype.interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {

	var v0 = ( p2 - p0 ) * 0.5,
		v1 = ( p3 - p1 ) * 0.5;

	return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

};



// Get next key with

THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key < keys.length - 1 ? key : keys.length - 1;

	} else {

		key = key % keys.length;

	}

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ 0 ];

};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key > 0 ? key : 0;

	} else {

		key = key >= 0 ? key : key + keys.length;

	}


	for ( ; key >= 0; key -- ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function( root, data, JITCompile ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( data );
	this.hierarchy = THREE.AnimationHandler.parse( root );
	this.currentTime = 0;
	this.timeScale = 0.001;
	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;
	this.JITCompile = JITCompile !== undefined ? JITCompile : true;

	// initialize to first keyframes

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

		var keys = this.data.hierarchy[h].keys,
			sids = this.data.hierarchy[h].sids,
			obj = this.hierarchy[h];

		if ( keys.length && sids ) {

			for ( var s = 0; s < sids.length; s++ ) {

				var sid = sids[ s ],
					next = this.getNextKeyWith( sid, h, 0 );

				if ( next ) {

					next.apply( sid );

				}

			}

			obj.matrixAutoUpdate = false;
			this.data.hierarchy[h].node.updateMatrix();
			obj.matrixWorldNeedsUpdate = true;

		}

	}

};

// Play

THREE.KeyFrameAnimation.prototype.play = function( loop, startTimeMS ) {

	if( !this.isPlaying ) {

		this.isPlaying = true;
		this.loop = loop !== undefined ? loop : true;
		this.currentTime = startTimeMS !== undefined ? startTimeMS : 0;
		this.startTimeMs = startTimeMS;
		this.startTime = 10000000;
		this.endTime = -this.startTime;


		// reset key cache

		var h, hl = this.hierarchy.length,
			object,
			node;

		for ( h = 0; h < hl; h++ ) {

			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];
			object.useQuaternion = true;

			if ( node.animationCache === undefined ) {

				node.animationCache = {};
				node.animationCache.prevKey = null;
				node.animationCache.nextKey = null;
				node.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

			}

			var keys = this.data.hierarchy[h].keys;

			if (keys.length) {

				node.animationCache.prevKey = keys[ 0 ];
				node.animationCache.nextKey = keys[ 1 ];

				this.startTime = Math.min( keys[0].time, this.startTime );
				this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

			}

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};



// Pause

THREE.KeyFrameAnimation.prototype.pause = function() {

	if( this.isPaused ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


// Stop

THREE.KeyFrameAnimation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;
	THREE.AnimationHandler.removeFromUpdate( this );


	// reset JIT matrix and remove cache

	for ( var h = 0; h < this.data.hierarchy.length; h++ ) {
        
        var obj = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		if ( node.animationCache !== undefined ) {

			var original = node.animationCache.originalMatrix;

			if( obj instanceof THREE.Bone ) {

				original.copy( obj.skinMatrix );
				obj.skinMatrix = original;

			} else {

				original.copy( obj.matrix );
				obj.matrix = original;

			}

			delete node.animationCache;

		}

	}

};


// Update

THREE.KeyFrameAnimation.prototype.update = function( deltaTimeMS ) {

	// early out

	if( !this.isPlaying ) return;


	// vars

	var prevKey, nextKey;
	var object;
	var node;
	var frame;
	var JIThierarchy = this.data.JIT.hierarchy;
	var currentTime, unloopedCurrentTime;
	var looped;


	// update

	this.currentTime += deltaTimeMS * this.timeScale;

	unloopedCurrentTime = this.currentTime;
	currentTime         = this.currentTime = this.currentTime % this.data.length;

	// if looped around, the current time should be based on the startTime
	if ( currentTime < this.startTimeMs ) {

		currentTime = this.currentTime = this.startTimeMs + currentTime;

	}

	frame               = parseInt( Math.min( currentTime * this.data.fps, this.data.length * this.data.fps ), 10 );
	looped 				= currentTime < unloopedCurrentTime;

	if ( looped && !this.loop ) {

		// Set the animation to the last keyframes and stop
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

			var keys = this.data.hierarchy[h].keys,
				sids = this.data.hierarchy[h].sids,
				end = keys.length-1,
				obj = this.hierarchy[h];

			if ( keys.length ) {

				for ( var s = 0; s < sids.length; s++ ) {

					var sid = sids[ s ],
						prev = this.getPrevKeyWith( sid, h, end );

					if ( prev ) {
						prev.apply( sid );

					}

				}

				this.data.hierarchy[h].node.updateMatrix();
				obj.matrixWorldNeedsUpdate = true;

			}

		}

		this.stop();
		return;

	}

	// check pre-infinity
	if ( currentTime < this.startTime ) {

		return;

	}

	// update

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

		object = this.hierarchy[ h ];
		node = this.data.hierarchy[ h ];

		var keys = node.keys,
			animationCache = node.animationCache;

		// use JIT?

		if ( this.JITCompile && JIThierarchy[ h ][ frame ] !== undefined ) {

			if( object instanceof THREE.Bone ) {

				object.skinMatrix = JIThierarchy[ h ][ frame ];
				object.matrixWorldNeedsUpdate = false;

			} else {

				object.matrix = JIThierarchy[ h ][ frame ];
				object.matrixWorldNeedsUpdate = true;

			}

		// use interpolation

		} else if ( keys.length ) {

			// make sure so original matrix and not JIT matrix is set

			if ( this.JITCompile && animationCache ) {

				if( object instanceof THREE.Bone ) {

					object.skinMatrix = animationCache.originalMatrix;

				} else {

					object.matrix = animationCache.originalMatrix;

				}

			}

			prevKey = animationCache.prevKey;
			nextKey = animationCache.nextKey;

			if ( prevKey && nextKey ) {

				// switch keys?

				if ( nextKey.time <= unloopedCurrentTime ) {

					// did we loop?

					if ( looped && this.loop ) {

						prevKey = keys[ 0 ];
						nextKey = keys[ 1 ];

						while ( nextKey.time < currentTime ) {

							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];

						}

					} else if ( !looped ) {

						var lastIndex = keys.length - 1;

						while ( nextKey.time < currentTime && nextKey.index !== lastIndex ) {

							prevKey = nextKey;
							nextKey = keys[ prevKey.index + 1 ];

						}

					}

					animationCache.prevKey = prevKey;
					animationCache.nextKey = nextKey;

				}
                if(nextKey.time >= currentTime)
                    prevKey.interpolate( nextKey, currentTime );
                else
                    prevKey.interpolate( nextKey, nextKey.time);

			}

			this.data.hierarchy[h].node.updateMatrix();
			object.matrixWorldNeedsUpdate = true;

		}

	}

	// update JIT?

	if ( this.JITCompile ) {

		if ( JIThierarchy[ 0 ][ frame ] === undefined ) {

			this.hierarchy[ 0 ].updateMatrixWorld( true );

			for ( var h = 0; h < this.hierarchy.length; h++ ) {

				if( this.hierarchy[ h ] instanceof THREE.Bone ) {

					JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].skinMatrix.clone();

				} else {

					JIThierarchy[ h ][ frame ] = this.hierarchy[ h ].matrix.clone();

				}

			}

		}

	}

};

// Get next key with

THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key % keys.length;

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ 0 ];

};

// Get previous key with

THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key >= 0 ? key : key + keys.length;

	for ( ; key >= 0; key-- ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ keys.length - 1 ];

};
/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, -1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, -1, 0 );
	cameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, -1 );
	cameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, -1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, -1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.generateMipmaps;

		renderTarget.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
/*
 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog
 *
 *	A general perpose camera, for setting FOV, Lens Focal Length,
 *		and switching between perspective and orthographic views easily.
 *		Use this only if you do not wish to manage
 *		both a Orthographic and Perspective Camera
 *
 */


THREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {

	THREE.Camera.call( this );

	this.fov = fov;

	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;

	// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects

	this.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 	orthoNear, orthoFar );
	this.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );

	this.zoom = 1;

	this.toPerspective();

	var aspect = width/height;

};

THREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.CombinedCamera.prototype.toPerspective = function () {

	// Switches to the Perspective Camera

	this.near = this.cameraP.near;
	this.far = this.cameraP.far;

	this.cameraP.fov =  this.fov / this.zoom ;

	this.cameraP.updateProjectionMatrix();

	this.projectionMatrix = this.cameraP.projectionMatrix;

	this.inPerspectiveMode = true;
	this.inOrthographicMode = false;

};

THREE.CombinedCamera.prototype.toOrthographic = function () {

	// Switches to the Orthographic camera estimating viewport from Perspective

	var fov = this.fov;
	var aspect = this.cameraP.aspect;
	var near = this.cameraP.near;
	var far = this.cameraP.far;

	// The size that we set is the mid plane of the viewing frustum

	var hyperfocus = ( near + far ) / 2;

	var halfHeight = Math.tan( fov / 2 ) * hyperfocus;
	var planeHeight = 2 * halfHeight;
	var planeWidth = planeHeight * aspect;
	var halfWidth = planeWidth / 2;

	halfHeight /= this.zoom;
	halfWidth /= this.zoom;

	this.cameraO.left = -halfWidth;
	this.cameraO.right = halfWidth;
	this.cameraO.top = halfHeight;
	this.cameraO.bottom = -halfHeight;

	// this.cameraO.left = -farHalfWidth;
	// this.cameraO.right = farHalfWidth;
	// this.cameraO.top = farHalfHeight;
	// this.cameraO.bottom = -farHalfHeight;

	// this.cameraO.left = this.left / this.zoom;
	// this.cameraO.right = this.right / this.zoom;
	// this.cameraO.top = this.top / this.zoom;
	// this.cameraO.bottom = this.bottom / this.zoom;

	this.cameraO.updateProjectionMatrix();

	this.near = this.cameraO.near;
	this.far = this.cameraO.far;
	this.projectionMatrix = this.cameraO.projectionMatrix;

	this.inPerspectiveMode = false;
	this.inOrthographicMode = true;

};


THREE.CombinedCamera.prototype.setSize = function( width, height ) {

	this.cameraP.aspect = width / height;
	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;

};


THREE.CombinedCamera.prototype.setFov = function( fov ) {

	this.fov = fov;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

// For mantaining similar API with PerspectiveCamera

THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toPerspective();
		this.toOrthographic();

	}

};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (fullframe) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
THREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );

	this.setFov( fov );

	return fov;
};


THREE.CombinedCamera.prototype.setZoom = function( zoom ) {

	this.zoom = zoom;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

THREE.CombinedCamera.prototype.toFrontView = function() {

	this.rotation.x = 0;
	this.rotation.y = 0;
	this.rotation.z = 0;

	// should we be modifing the matrix instead?

	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBackView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toLeftView = function() {

	this.rotation.x = 0;
	this.rotation.y = - Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toRightView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toTopView = function() {

	this.rotation.x = - Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBottomView = function() {

	this.rotation.x = Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- 3d asterisk shape (for line pieces THREE.Line)
 */

THREE.AsteriskGeometry = function ( innerRadius, outerRadius ) {

	THREE.Geometry.call( this );

	var sd = innerRadius;
	var ed = outerRadius;

	var sd2 = 0.707 * sd;
	var ed2 = 0.707 * ed;

	var rays = [ [ sd, 0, 0 ], [ ed, 0, 0 ], [ -sd, 0, 0 ], [ -ed, 0, 0 ],
				 [ 0, sd, 0 ], [ 0, ed, 0 ], [ 0, -sd, 0 ], [ 0, -ed, 0 ],
				 [ 0, 0, sd ], [ 0, 0, ed ], [ 0, 0, -sd ], [ 0, 0, -ed ],
				 [ sd2, sd2, 0 ], [ ed2, ed2, 0 ], [ -sd2, -sd2, 0 ], [ -ed2, -ed2, 0 ],
				 [ sd2, -sd2, 0 ], [ ed2, -ed2, 0 ], [ -sd2, sd2, 0 ], [ -ed2, ed2, 0 ],
				 [ sd2, 0, sd2 ], [ ed2, 0, ed2 ], [ -sd2, 0, -sd2 ], [ -ed2, 0, -ed2 ],
				 [ sd2, 0, -sd2 ], [ ed2, 0, -ed2 ], [ -sd2, 0, sd2 ], [ -ed2, 0, ed2 ],
				 [ 0, sd2, sd2 ], [ 0, ed2, ed2 ], [ 0, -sd2, -sd2 ], [ 0, -ed2, -ed2 ],
				 [ 0, sd2, -sd2 ], [ 0, ed2, -ed2 ], [ 0, -sd2, sd2 ], [ 0, -ed2, ed2 ]
	];

	for ( var i = 0, il = rays.length; i < il; i ++ ) {

		var x = rays[ i ][ 0 ];
		var y = rays[ i ][ 1 ];
		var z = rays[ i ][ 2 ];

		this.vertices.push( new THREE.Vector3( x, y, z ) );

	}

};

THREE.AsteriskGeometry.prototype = Object.create( THREE.Geometry.prototype );/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

    THREE.Geometry.call( this );

    radius = radius || 50;

    thetaStart = thetaStart !== undefined ? thetaStart : 0;
    thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
    segments = segments !== undefined ? Math.max( 3, segments ) : 8;

    var i, uvs = [],
    center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

    this.vertices.push(center);
    uvs.push( centerUV );

    for ( i = 0; i <= segments; i ++ ) {

        var vertex = new THREE.Vector3();

        vertex.x = radius * Math.cos( thetaStart + i / segments * thetaLength );
        vertex.y = radius * Math.sin( thetaStart + i / segments * thetaLength );

        this.vertices.push( vertex );
        uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, - ( vertex.y / radius + 1 ) / 2 + 1 ) );

    }

    var n = new THREE.Vector3( 0, 0, -1 );

    for ( i = 1; i <= segments; i ++ ) {

        var v1 = i;
        var v2 = i + 1 ;
        var v3 = 0;

        this.faces.push( new THREE.Face3( v1, v2, v3, [ n, n, n ] ) );
        this.faceVertexUvs[ 0 ].push( [ uvs[ i ], uvs[ i + 1 ], centerUV ] );

    }

    this.computeCentroids();
    this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.CubeGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.width = width;
	this.height = height;
	this.depth = depth;

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var width_half = this.width / 2;
	var height_half = this.height / 2;
	var depth_half = this.depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy++ ) {

			for ( ix = 0; ix < gridX; ix++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var face = new THREE.Face4( a + offset, b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [
							new THREE.Vector2( ix / gridX, 1 - iy / gridY ),
							new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY ),
							new THREE.Vector2( ( ix + 1 ) / gridX, 1- ( iy + 1 ) / gridY ),
							new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY )
						] );

			}

		}

	}

	this.computeCentroids();
	this.mergeVertices();

};

THREE.CubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded ) {

	THREE.Geometry.call( this );

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	var heightHalf = height / 2;
	var segmentsX = radiusSegments || 8;
	var segmentsY = heightSegments || 1;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= segmentsY; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / segmentsY;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= segmentsX; x ++ ) {

			var u = x / segmentsX;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * Math.PI * 2 );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * Math.PI * 2 );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < segmentsX; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < segmentsY; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );

		}

	}

	// top cap

	if ( !openEnded && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < segmentsX; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.u, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( !openEnded && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < segmentsX; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.u, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

}

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Amount
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  material: <int> // material index for front and back faces
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {
		shapes = [];
		return;
	}

	THREE.Geometry.call( this );

	shapes = shapes instanceof Array ? shapes : [ shapes ];

	this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();

	this.addShapeList( shapes, options );

	this.computeCentroids();
	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {
		var shape = shapes[ s ];
		this.addShape( shape, options );
	}
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	var material = options.material;
	var extrudeMaterial = options.extrudeMaterial;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var shapebb = this.shapebb;
	//shapebb = shape.getBoundingBox();



	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initalization

	var ahole, h, hl; // looping of holes
	var scope = this;
	var bevelPoints = [];

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( !vec ) console.log( "die" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length,
		cont, clen = contour.length;


	// Find directions for point movement

	var RAD_TO_DEGREES = 180 / Math.PI;


	function getBevelVec( pt_i, pt_j, pt_k ) {

		// Algorithm 2

		return getBevelVec2( pt_i, pt_j, pt_k );

	}

	function getBevelVec1( pt_i, pt_j, pt_k ) {

		var anglea = Math.atan2( pt_j.y - pt_i.y, pt_j.x - pt_i.x );
		var angleb = Math.atan2( pt_k.y - pt_i.y, pt_k.x - pt_i.x );

		if ( anglea > angleb ) {

			angleb += Math.PI * 2;

		}

		var anglec = ( anglea + angleb ) / 2;


		//console.log('angle1', anglea * RAD_TO_DEGREES,'angle2', angleb * RAD_TO_DEGREES, 'anglec', anglec *RAD_TO_DEGREES);

		var x = - Math.cos( anglec );
		var y = - Math.sin( anglec );

		var vec = new THREE.Vector2( x, y ); //.normalize();

		return vec;

	}

	function getBevelVec2( pt_i, pt_j, pt_k ) {

		var a = THREE.ExtrudeGeometry.__v1,
			b = THREE.ExtrudeGeometry.__v2,
			v_hat = THREE.ExtrudeGeometry.__v3,
			w_hat = THREE.ExtrudeGeometry.__v4,
			p = THREE.ExtrudeGeometry.__v5,
			q = THREE.ExtrudeGeometry.__v6,
			v, w,
			v_dot_w_hat, q_sub_p_dot_w_hat,
			s, intersection;

		// good reading for line-line intersection
		// http://sputsoft.com/blog/2010/03/line-line-intersection.html

		// define a as vector j->i
		// define b as vectot k->i

		a.set( pt_i.x - pt_j.x, pt_i.y - pt_j.y );
		b.set( pt_i.x - pt_k.x, pt_i.y - pt_k.y );

		// get unit vectors

		v = a.normalize();
		w = b.normalize();

		// normals from pt i

		v_hat.set( -v.y, v.x );
		w_hat.set( w.y, -w.x );

		// pts from i

		p.copy( pt_i ).add( v_hat );
		q.copy( pt_i ).add( w_hat );

		if ( p.equals( q ) ) {

			//console.log("Warning: lines are straight");
			return w_hat.clone();

		}

		// Points from j, k. helps prevents points cross overover most of the time

		p.copy( pt_j ).add( v_hat );
		q.copy( pt_k ).add( w_hat );

		v_dot_w_hat = v.dot( w_hat );
		q_sub_p_dot_w_hat = q.sub( p ).dot( w_hat );

		// We should not reach these conditions

		if ( v_dot_w_hat === 0 ) {

			console.log( "Either infinite or no solutions!" );

			if ( q_sub_p_dot_w_hat === 0 ) {

				console.log( "Its finite solutions." );

			} else {

				console.log( "Too bad, no solutions." );

			}

		}

		s = q_sub_p_dot_w_hat / v_dot_w_hat;

		if ( s < 0 ) {

			// in case of emergecy, revert to algorithm 1.

			return getBevelVec1( pt_i, pt_j, pt_k );

		}

		intersection = v.multiplyScalar( s ).add( p );

		return intersection.sub( pt_i ).clone(); // Don't normalize!, otherwise sharp corners become ugly

	}

	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		var pt_i = contour[ i ];
		var pt_j = contour[ j ];
		var pt_k = contour[ k ];

		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {
	//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
		//bs = bevelSize * t ; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			//vert = scalePt( contour[ i ], contourCentroid, bs, false );
			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
				//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );

				v( vert.x, vert.y,  -z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( !extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
			binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

			position2.copy( extrudePts[0] ).add(normal).add(binormal);

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( !extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[s] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( !extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0 ; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ], true );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );

			}
		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( --i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}
		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c, isBottom ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		// normal, color, material
		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

		var uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );

 		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

 		scope.faces.push( new THREE.Face4( a, b, c, d, null, null, extrudeMaterial ) );

 		var uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,
 		                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );
 		scope.faceVertexUvs[ 0 ].push( uvs );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {
		var ax = geometry.vertices[ indexA ].x,
			ay = geometry.vertices[ indexA ].y,

			bx = geometry.vertices[ indexB ].x,
			by = geometry.vertices[ indexB ].y,

			cx = geometry.vertices[ indexC ].x,
			cy = geometry.vertices[ indexC ].y;

		return [
			new THREE.Vector2( ax, ay ),
			new THREE.Vector2( bx, by ),
			new THREE.Vector2( cx, cy )
		];

	},

	generateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {

		return this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );

	},

	generateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,
	                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,
	                              contourIndex1, contourIndex2 ) {

		var ax = geometry.vertices[ indexA ].x,
			ay = geometry.vertices[ indexA ].y,
			az = geometry.vertices[ indexA ].z,

			bx = geometry.vertices[ indexB ].x,
			by = geometry.vertices[ indexB ].y,
			bz = geometry.vertices[ indexB ].z,

			cx = geometry.vertices[ indexC ].x,
			cy = geometry.vertices[ indexC ].y,
			cz = geometry.vertices[ indexC ].z,

			dx = geometry.vertices[ indexD ].x,
			dy = geometry.vertices[ indexD ].y,
			dz = geometry.vertices[ indexD ].z;

		if ( Math.abs( ay - by ) < 0.01 ) {
			return [
				new THREE.Vector2( ax, 1 - az ),
				new THREE.Vector2( bx, 1 - bz ),
				new THREE.Vector2( cx, 1 - cz ),
				new THREE.Vector2( dx, 1 - dz )
			];
		} else {
			return [
				new THREE.Vector2( ay, 1 - az ),
				new THREE.Vector2( by, 1 - bz ),
				new THREE.Vector2( cy, 1 - cz ),
				new THREE.Vector2( dy, 1 - dz )
			];
		}
	}
};

THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();
/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	if ( shapes instanceof Array === false ) shapes = [ shapes ];

	this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();

	this.addShapeList( shapes, options );

	this.computeCentroids();
	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	var shapebb = this.shapebb;

	//

	var i, l, hole, s;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i++ ) {

			hole = holes[ i ];

			if ( THREE.Shape.Utils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

	// Vertices

	var contour = vertices;

	for ( i = 0, l = holes.length; i < l; i++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;
	var cont, clen = contour.length;

	for ( i = 0; i < vlen; i++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );

	}

};
/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.
THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			this.faces.push( new THREE.Face4( a, b, c, d ) );

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ), 
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );

		}

	}

	this.mergeVertices();
	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.Geometry.call( this );

	this.width = width;
	this.height = height;

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;

	var ix, iz;
	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = this.widthSegments;
	var gridZ = this.heightSegments;

	var gridX1 = gridX + 1;
	var gridZ1 = gridZ + 1;

	var segment_width = this.width / gridX;
	var segment_height = this.height / gridZ;

	var normal = new THREE.Vector3( 0, 0, 1 );

	for ( iz = 0; iz < gridZ1; iz ++ ) {

		for ( ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;
			var y = iz * segment_height - height_half;

			this.vertices.push( new THREE.Vector3( x, - y, 0 ) );

		}

	}

	for ( iz = 0; iz < gridZ; iz ++ ) {

		for ( ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iz;
			var b = ix + gridX1 * ( iz + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iz + 1 );
			var d = ( ix + 1 ) + gridX1 * iz;

			var face = new THREE.Face4( a, b, c, d );
			face.normal.copy( normal );
			face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone(), normal.clone() );

			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [
				new THREE.Vector2( ix / gridX, 1 - iz / gridZ ),
				new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ ),
				new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ ),
				new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ )
			] );

		}

	}

	this.computeCentroids();

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.radius = radius || 50;

	this.widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	this.heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= this.heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		for ( x = 0; x <= this.widthSegments; x ++ ) {

			var u = x / this.widthSegments;
			var v = y / this.heightSegments;

			var vertex = new THREE.Vector3();
			vertex.x = - this.radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = this.radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = this.radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < this.heightSegments; y ++ ) {

		for ( x = 0; x < this.widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			var n1 = this.vertices[ v1 ].clone().normalize();
			var n2 = this.vertices[ v2 ].clone().normalize();
			var n3 = this.vertices[ v3 ].clone().normalize();
			var n4 = this.vertices[ v4 ].clone().normalize();

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x ].clone();
			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

			if ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {

				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

			} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {

				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			} else {

				this.faces.push( new THREE.Face4( v1, v2, v3, v4, [ n1, n2, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3, uv4 ] );

			}

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

	var textShapes = THREE.FontUtils.generateShapes( text, parameters );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	THREE.ExtrudeGeometry.call( this, textShapes, parameters );

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.radialSegments = radialSegments || 8;
	this.tubularSegments = tubularSegments || 6;
	this.arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= this.radialSegments; j ++ ) {

		for ( var i = 0; i <= this.tubularSegments; i ++ ) {

			var u = i / this.tubularSegments * this.arc;
			var v = j / this.radialSegments * Math.PI * 2;

			center.x = this.radius * Math.cos( u );
			center.y = this.radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = this.tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}
	}


	for ( var j = 1; j <= this.radialSegments; j ++ ) {

		for ( var i = 1; i <= this.tubularSegments; i ++ ) {

			var a = ( this.tubularSegments + 1 ) * j + i - 1;
			var b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( this.tubularSegments + 1 ) * j + i;

			var face = new THREE.Face4( a, b, c, d, [ normals[ a ], normals[ b ], normals[ c ], normals[ d ] ] );
			face.normal.add( normals[ a ] );
			face.normal.add( normals[ b ] );
			face.normal.add( normals[ c ] );
			face.normal.add( normals[ d ] );
			face.normal.normalize();

			this.faces.push( face );

			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );
		}

	}

	this.computeCentroids();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.radialSegments = radialSegments || 64;
	this.tubularSegments = tubularSegments || 8;
	this.p = p || 2;
	this.q = q || 3;
	this.heightScale = heightScale || 1;
	this.grid = new Array( this.radialSegments );

	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < this.radialSegments; ++ i ) {

		this.grid[ i ] = new Array( this.tubularSegments );

		for ( var j = 0; j < this.tubularSegments; ++ j ) {

			var u = i / this.radialSegments * 2 * this.p * Math.PI;
			var v = j / this.tubularSegments * 2 * Math.PI;
			var p1 = getPos( u, v, this.q, this.p, this.radius, this.heightScale );
			var p2 = getPos( u + 0.01, v, this.q, this.p, this.radius, this.heightScale );
			var cx, cy;

			tang.subVectors( p2, p1 );
			n.addVectors( p2, p1 );

			bitan.crossVectors( tang, n );
			n.crossVectors( bitan, tang );
			bitan.normalize();
			n.normalize();

			cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = this.tube * Math.sin( v );

			p1.x += cx * n.x + cy * bitan.x;
			p1.y += cx * n.y + cy * bitan.y;
			p1.z += cx * n.z + cy * bitan.z;

			this.grid[ i ][ j ] = vert( p1.x, p1.y, p1.z );

		}

	}

	for ( var i = 0; i < this.radialSegments; ++ i ) {

		for ( var j = 0; j < this.tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % this.radialSegments;
			var jp = ( j + 1 ) % this.tubularSegments;

			var a = this.grid[ i ][ j ];
			var b = this.grid[ ip ][ j ];
			var c = this.grid[ ip ][ jp ];
			var d = this.grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );
			var uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );

			this.faces.push( new THREE.Face4( a, b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva,uvb,uvc, uvd ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}

	function getPos( u, v, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var cv = Math.cos( v );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function( path, segments, radius, radiusSegments, closed, debug ) {

	THREE.Geometry.call( this );

	this.path = path;
	this.segments = segments || 64;
	this.radius = radius || 1;
	this.radiusSegments = radiusSegments || 8;
	this.closed = closed || false;

	if ( debug ) this.debug = new THREE.Object3D();

	this.grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = this.segments + 1,

		x, y, z,
		tx, ty, tz,
		u, v,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}


	// consruct the grid

	for ( i = 0; i < numpoints; i++ ) {

		this.grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		if ( this.debug ) {

			this.debug.add( new THREE.ArrowHelper(tangent, pos, radius, 0x0000ff ) );
			this.debug.add( new THREE.ArrowHelper(normal, pos, radius, 0xff0000 ) );
			this.debug.add( new THREE.ArrowHelper(binormal, pos, radius, 0x00ff00 ) );

		}

		for ( j = 0; j < this.radiusSegments; j++ ) {

			v = j / this.radiusSegments * 2 * Math.PI;

			cx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = this.radius * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			this.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}
	}


	// construct the mesh

	for ( i = 0; i < this.segments; i++ ) {

		for ( j = 0; j < this.radiusSegments; j++ ) {

			ip = ( this.closed ) ? (i + 1) % this.segments : i + 1;
			jp = (j + 1) % this.radiusSegments;

			a = this.grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = this.grid[ ip ][ j ];
			c = this.grid[ ip ][ jp ];
			d = this.grid[ i ][ jp ];

			uva = new THREE.Vector2( i / this.segments, j / this.radiusSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radiusSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radiusSegments );
			uvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radiusSegments );

			this.faces.push( new THREE.Face4( a, b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvc, uvd ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );


// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {

	var	tangent = new THREE.Vector3(),
		normal = new THREE.Vector3(),
		binormal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		epsilon = 0.0001,
		smallest,

		tx, ty, tz,
		i, u, v;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}

	function initialNormal3() {
		// select an initial normal vector perpenicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {
			smallest = tx;
			normal.set( 1, 0, 0 );
		}

		if ( ty <= smallest ) {
			smallest = ty;
			normal.set( 0, 1, 0 );
		}

		if ( tz <= smallest ) {
			normal.set( 0, 0, 1 );
		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i++ ) {

		normals[ i ] = normals[ i-1 ].clone();

		binormals[ i ] = binormals[ i-1 ].clone();

		vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

		if ( vec.length() > epsilon ) {

			vec.normalize();

			theta = Math.acos( tangents[ i-1 ].dot( tangents[ i ] ) );

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( normals[ 0 ].dot( normals[ numpoints-1 ] ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

			theta = -theta;

		}

		for ( i = 1; i < numpoints; i++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}
};
/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {

	THREE.Geometry.call( this );

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i ++ ) {

		prepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );

	}

	var midpoints = [], p = this.vertices;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		make( p[ faces[ i ][ 0 ] ], p[ faces[ i ][ 1 ] ], p[ faces[ i ][ 2 ] ], detail );

	}

	this.mergeVertices();

	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3, detail ) {

		if ( detail < 1 ) {

			var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
			face.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
			face.normal = face.centroid.clone().normalize();
			that.faces.push( face );

			var azi = azimuth( face.centroid );
			that.faceVertexUvs[ 0 ].push( [
				correctUV( v1.uv, v1, azi ),
				correctUV( v2.uv, v2, azi ),
				correctUV( v3.uv, v3, azi )
			] );

		} else {

			detail -= 1;

			// split triangle into 4 smaller triangles

			make( v1, midpoint( v1, v2 ), midpoint( v1, v3 ), detail ); // top quadrant
			make( midpoint( v1, v2 ), v2, midpoint( v2, v3 ), detail ); // left quadrant
			make( midpoint( v1, v3 ), midpoint( v2, v3 ), v3, detail ); // right quadrant
			make( midpoint( v1, v2 ), midpoint( v2, v3 ), midpoint( v1, v3 ), detail ); // center quadrant

		}

	}

	function midpoint( v1, v2 ) {

		if ( !midpoints[ v1.index ] ) midpoints[ v1.index ] = [];
		if ( !midpoints[ v2.index ] ) midpoints[ v2.index ] = [];

		var mid = midpoints[ v1.index ][ v2.index ];

		if ( mid === undefined ) {

			// generate mean point and project to surface with prepare()

			midpoints[ v1.index ][ v2.index ] = midpoints[ v2.index ][ v1.index ] = mid = prepare(
				new THREE.Vector3().addVectors( v1, v2 ).divideScalar( 2 )
			);
		}

		return mid;

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, -vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv;

	}

	this.computeCentroids();

    this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],
		[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],
		[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]
	];

	var faces = [
		[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],
		[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],
		[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],
		[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	var vertices = [
		[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]
	];

	var faces = [
		[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]
	];

	var faces = [
		[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements, useTris );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks, useTris ) {

	THREE.Geometry.call( this );

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	useTris = (useTris === undefined) ? false : useTris;

	var i, il, j, p;
	var u, v;

	var stackCount = stacks + 1;
	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}
	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = (i + 1) * sliceCount + j;
			d = (i + 1) * sliceCount + j + 1;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );

			if ( useTris ) {

				faces.push( new THREE.Face3( a, b, c ) );
				faces.push( new THREE.Face3( b, d, c ) );

				uvs.push( [ uva, uvb, uvc ] );
				uvs.push( [ uvb, uvd, uvc ] );

			} else {

				faces.push( new THREE.Face4( a, b, d, c ) );
				uvs.push( [ uva, uvb, uvd, uvc ] );

			}

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author qiao / https://github.com/qiao
 * @fileoverview This is a convex hull generator using the incremental method. 
 * The complexity is O(n^2) where n is the number of vertices.
 * O(nlogn) algorithms do exist, but they are much more complicated.
 *
 * Benchmark: 
 *
 *  Platform: CPU: P7350 @2.00GHz Engine: V8
 *
 *  Num Vertices	Time(ms)
 *
 *     10           1
 *     20           3
 *     30           19
 *     40           48
 *     50           107
 */

THREE.ConvexGeometry = function( vertices ) {

	THREE.Geometry.call( this );

	var faces = [ [ 0, 1, 2 ], [ 0, 2, 1 ] ]; 

	for ( var i = 3; i < vertices.length; i++ ) {

		addPoint( i );

	}


	function addPoint( vertexId ) {

		var vertex = vertices[ vertexId ].clone();

		var mag = vertex.length();
		vertex.x += mag * randomOffset();
		vertex.y += mag * randomOffset();
		vertex.z += mag * randomOffset();

		var hole = [];

		for ( var f = 0; f < faces.length; ) {

			var face = faces[ f ];

			// for each face, if the vertex can see it,
			// then we try to add the face's edges into the hole.
			if ( visible( face, vertex ) ) {

				for ( var e = 0; e < 3; e++ ) {

					var edge = [ face[ e ], face[ ( e + 1 ) % 3 ] ];
					var boundary = true;

					// remove duplicated edges.
					for ( var h = 0; h < hole.length; h++ ) {

						if ( equalEdge( hole[ h ], edge ) ) {

							hole[ h ] = hole[ hole.length - 1 ];
							hole.pop();
							boundary = false;
							break;

						}

					}

					if ( boundary ) {

						hole.push( edge );

					}

				}

				// remove faces[ f ]
				faces[ f ] = faces[ faces.length - 1 ];
				faces.pop();

			} else { // not visible

				f++;

			}
		}

		// construct the new faces formed by the edges of the hole and the vertex
		for ( var h = 0; h < hole.length; h++ ) {

			faces.push( [ 
				hole[ h ][ 0 ],
				hole[ h ][ 1 ],
				vertexId
			] );

		}
	}

	/**
	 * Whether the face is visible from the vertex
	 */
	function visible( face, vertex ) {

		var va = vertices[ face[ 0 ] ];
		var vb = vertices[ face[ 1 ] ];
		var vc = vertices[ face[ 2 ] ];

		var n = normal( va, vb, vc );

		// distance from face to origin
		var dist = n.dot( va );

		return n.dot( vertex ) >= dist; 

	}

	/**
	 * Face normal
	 */
	function normal( va, vb, vc ) {

		var cb = new THREE.Vector3();
		var ab = new THREE.Vector3();

		cb.subVectors( vc, vb );
		ab.subVectors( va, vb );
		cb.cross( ab );

		cb.normalize();

		return cb;

	}

	/**
	 * Detect whether two edges are equal.
	 * Note that when constructing the convex hull, two same edges can only
	 * be of the negative direction.
	 */
	function equalEdge( ea, eb ) {

		return ea[ 0 ] === eb[ 1 ] && ea[ 1 ] === eb[ 0 ]; 

	}

	/**
	 * Create a random offset between -1e-6 and 1e-6.
	 */
	function randomOffset() {

		return ( Math.random() - 0.5 ) * 2 * 1e-6;

	}


	/**
	 * XXX: Not sure if this is the correct approach. Need someone to review.
	 */
	function vertexUv( vertex ) {

		var mag = vertex.length();
		return new THREE.Vector2( vertex.x / mag, vertex.y / mag );

	}

	// Push vertices into `this.vertices`, skipping those inside the hull
	var id = 0;
	var newId = new Array( vertices.length ); // map from old vertex id to new id

	for ( var i = 0; i < faces.length; i++ ) {

		 var face = faces[ i ];

		 for ( var j = 0; j < 3; j++ ) {

				if ( newId[ face[ j ] ] === undefined ) {

						newId[ face[ j ] ] = id++;
						this.vertices.push( vertices[ face[ j ] ] );

				}

				face[ j ] = newId[ face[ j ] ];

		 }

	}

	// Convert faces into instances of THREE.Face3
	for ( var i = 0; i < faces.length; i++ ) {

		this.faces.push( new THREE.Face3( 
				faces[ i ][ 0 ],
				faces[ i ][ 1 ],
				faces[ i ][ 2 ]
		) );

	}

	// Compute UVs
	for ( var i = 0; i < this.faces.length; i++ ) {

		var face = this.faces[ i ];

		this.faceVertexUvs[ 0 ].push( [
			vertexUv( this.vertices[ face.a ] ),
			vertexUv( this.vertices[ face.b ] ),
			vertexUv( this.vertices[ face.c ])
		] );

	}


	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ConvexGeometry.prototype = Object.create( THREE.Geometry.prototype );
/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	var geometry = new THREE.Geometry();

	geometry.vertices.push(
		new THREE.Vector3(), new THREE.Vector3( size || 1, 0, 0 ),
		new THREE.Vector3(), new THREE.Vector3( 0, size || 1, 0 ),
		new THREE.Vector3(), new THREE.Vector3( 0, 0, size || 1 )
	);

	geometry.colors.push(
		new THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),
		new THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),
		new THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )
	);

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );
/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author bhouston / https://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  hex - color in hex value
 */

THREE.ArrowHelper = function ( dir, origin, length, hex ) {

	THREE.Object3D.call( this );

	if ( length === undefined ) length = 20;
	if ( hex === undefined ) hex = 0xffff00;

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
	lineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );

	this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );
	this.add( this.line );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.05, 0.25, 5, 1 );

	this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );
	this.cone.position.set( 0, 1, 0 );
	this.add( this.cone );

	if ( origin instanceof THREE.Vector3 ) this.position = origin;

	this.setDirection( dir );
	this.setLength( length );

};

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.ArrowHelper.prototype.setDirection = function ( dir ) {

    var d = THREE.ArrowHelper.__v1.copy( dir ).normalize();

    if ( d.y > 0.999 ) {

        this.rotation.set( 0, 0, 0 );
 
    } else if ( d.y < - 0.999 ) {

        this.rotation.set( Math.PI, 0, 0 );

    } else {

	    var axis = THREE.ArrowHelper.__v2.set( d.z, 0, - d.x ).normalize();
	    var radians = Math.acos( d.y );
	    var quaternion = THREE.ArrowHelper.__q1.setFromAxisAngle( axis, radians );

	    this.rotation.setEulerFromQuaternion( quaternion, this.eulerOrder );

	}

};

THREE.ArrowHelper.prototype.setLength = function ( length ) {

	this.scale.set( length, length, length );

};

THREE.ArrowHelper.prototype.setColor = function ( hex ) {

	this.line.material.color.setHex( hex );
	this.cone.material.color.setHex( hex );

};

THREE.ArrowHelper.__v1 = new THREE.Vector3();
THREE.ArrowHelper.__v2 = new THREE.Vector3();
THREE.ArrowHelper.__q1 = new THREE.Quaternion();
/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	THREE.Line.call( this );

	var scope = this;

	this.geometry = new THREE.Geometry();
	this.material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );
	this.type = THREE.LinePieces;

	this.matrixWorld = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	this.camera = camera;

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		scope.geometry.vertices.push( new THREE.Vector3() );
		scope.geometry.colors.push( new THREE.Color( hex ) );

		if ( scope.pointMap[ id ] === undefined ) scope.pointMap[ id ] = [];

		scope.pointMap[ id ].push( scope.geometry.vertices.length - 1 );

	}

	this.update( camera );

};

THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );

THREE.CameraHelper.prototype.update = function () {

	var scope = this;

	var w = 1, h = 1;

	// we need just camera projection matrix
	// world matrix must be identity

	THREE.CameraHelper.__c.projectionMatrix.copy( this.camera.projectionMatrix );

	// center / target

	setPoint( "c", 0, 0, -1 );
	setPoint( "t", 0, 0,  1 );

	// near

	setPoint( "n1", -w, -h, -1 );
	setPoint( "n2",  w, -h, -1 );
	setPoint( "n3", -w,  h, -1 );
	setPoint( "n4",  w,  h, -1 );

	// far

	setPoint( "f1", -w, -h, 1 );
	setPoint( "f2",  w, -h, 1 );
	setPoint( "f3", -w,  h, 1 );
	setPoint( "f4",  w,  h, 1 );

	// up

	setPoint( "u1",  w * 0.7, h * 1.1, -1 );
	setPoint( "u2", -w * 0.7, h * 1.1, -1 );
	setPoint( "u3",        0, h * 2,   -1 );

	// cross

	setPoint( "cf1", -w,  0, 1 );
	setPoint( "cf2",  w,  0, 1 );
	setPoint( "cf3",  0, -h, 1 );
	setPoint( "cf4",  0,  h, 1 );

	setPoint( "cn1", -w,  0, -1 );
	setPoint( "cn2",  w,  0, -1 );
	setPoint( "cn3",  0, -h, -1 );
	setPoint( "cn4",  0,  h, -1 );

	function setPoint( point, x, y, z ) {

		THREE.CameraHelper.__v.set( x, y, z );
		THREE.CameraHelper.__projector.unprojectVector( THREE.CameraHelper.__v, THREE.CameraHelper.__c );

		var points = scope.pointMap[ point ];

		if ( points !== undefined ) {

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				scope.geometry.vertices[ points[ i ] ].copy( THREE.CameraHelper.__v );

			}

		}

	}

	this.geometry.verticesNeedUpdate = true;

};

THREE.CameraHelper.__projector = new THREE.Projector();
THREE.CameraHelper.__v = new THREE.Vector3();
THREE.CameraHelper.__c = new THREE.Camera();

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows directional light color, intensity, position, orientation and target
 */

THREE.DirectionalLightHelper = function ( light, sphereSize ) {

	THREE.Object3D.call( this );

	this.light = light;

	// position

	this.position = light.position;

	// direction

	this.direction = new THREE.Vector3();
	this.direction.subVectors( light.target.position, light.position );

	// color

	var intensity = THREE.Math.clamp( light.intensity, 0, 1 );

	this.color = light.color.clone();
	this.color.multiplyScalar( intensity );

	var hexColor = this.color.getHex();

	// light helper

	var bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );
	var raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );

	var bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );
	var raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );

	this.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );

	this.add( this.lightSphere );
	this.add( this.lightRays );

	this.lightSphere.properties.isGizmo = true;
	this.lightSphere.properties.gizmoSubject = light;
	this.lightSphere.properties.gizmoRoot = this;

	// light target helper

	this.targetSphere = null;

	if ( light.target.properties.targetInverse !== undefined ) {

		var targetGeo = new THREE.SphereGeometry( sphereSize, 8, 4 );
		var targetMaterial = new THREE.MeshBasicMaterial( { color: hexColor, wireframe: true, fog: false } );

		this.targetSphere = new THREE.Mesh( targetGeo, targetMaterial );
		this.targetSphere.position = light.target.position;

		this.targetSphere.properties.isGizmo = true;
		this.targetSphere.properties.gizmoSubject = light.target;
		this.targetSphere.properties.gizmoRoot = this.targetSphere;

		var lineMaterial = new THREE.LineDashedMaterial( { color: hexColor, dashSize: 4, gapSize: 4, opacity: 0.75, transparent: true, fog: false } );
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( this.position.clone() );
		lineGeometry.vertices.push( this.targetSphere.position.clone() );
		lineGeometry.computeLineDistances();

		this.targetLine = new THREE.Line( lineGeometry, lineMaterial );
		this.targetLine.properties.isGizmo = true;

	}

	//

	this.properties.isGizmo = true;

}

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.DirectionalLightHelper.prototype.update = function () {

	// update arrow orientation
	// pointing from light to target

	this.direction.subVectors( this.light.target.position, this.light.position );

	// update arrow, spheres, rays and line colors to light color * light intensity

	var intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );

	this.color.copy( this.light.color );
	this.color.multiplyScalar( intensity );

	this.lightSphere.material.color.copy( this.color );
	this.lightRays.material.color.copy( this.color );

	// Only update targetSphere and targetLine if available
	if ( this.targetSphere !== null ) {

		this.targetSphere.material.color.copy( this.color );
		this.targetLine.material.color.copy( this.color );

		// update target line vertices

		this.targetLine.geometry.vertices[ 0 ].copy( this.light.position );
		this.targetLine.geometry.vertices[ 1 ].copy( this.light.target.position );

		this.targetLine.geometry.computeLineDistances();
		this.targetLine.geometry.verticesNeedUpdate = true;

	}

}

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows hemisphere light intensity, sky and ground colors and directions
 */

THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

	THREE.Object3D.call( this );

	this.light = light;

	// position

	this.position = light.position;

	//

	var intensity = THREE.Math.clamp( light.intensity, 0, 1 );

	// sky color

	this.color = light.color.clone();
	this.color.multiplyScalar( intensity );

	var hexColor = this.color.getHex();

	// ground color

	this.groundColor = light.groundColor.clone();
	this.groundColor.multiplyScalar( intensity );

	var hexColorGround = this.groundColor.getHex();

	// double colored light bulb

	var bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8, 0, Math.PI * 2, 0, Math.PI * 0.5 );
	var bulbGroundGeometry = new THREE.SphereGeometry( sphereSize, 16, 8, 0, Math.PI * 2, Math.PI * 0.5, Math.PI );

	var bulbSkyMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );
	var bulbGroundMaterial = new THREE.MeshBasicMaterial( { color: hexColorGround, fog: false } );

	for ( var i = 0, il = bulbGeometry.faces.length; i < il; i ++ ) {

		bulbGeometry.faces[ i ].materialIndex = 0;

	}

	for ( var i = 0, il = bulbGroundGeometry.faces.length; i < il; i ++ ) {

		bulbGroundGeometry.faces[ i ].materialIndex = 1;

	}

	THREE.GeometryUtils.merge( bulbGeometry, bulbGroundGeometry );

	this.lightSphere = new THREE.Mesh( bulbGeometry, new THREE.MeshFaceMaterial( [ bulbSkyMaterial, bulbGroundMaterial ] ) );

	// arrows for sky and ground light directions

	this.lightArrow = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, ( sphereSize + arrowLength ) * 1.1, 0 ), arrowLength, hexColor );
	this.lightArrow.rotation.x = Math.PI;

	this.lightArrowGround = new THREE.ArrowHelper( new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, ( sphereSize + arrowLength ) * -1.1, 0 ), arrowLength, hexColorGround );

	var joint = new THREE.Object3D();
	joint.rotation.x = -Math.PI * 0.5;

	joint.add( this.lightSphere );
	joint.add( this.lightArrow );
	joint.add( this.lightArrowGround );

	this.add( joint );

	//

	this.lightSphere.properties.isGizmo = true;
	this.lightSphere.properties.gizmoSubject = light;
	this.lightSphere.properties.gizmoRoot = this;

	//

	this.properties.isGizmo = true;

	//

	this.target = new THREE.Vector3();
	this.lookAt( this.target );

}

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.HemisphereLightHelper.prototype.update = function () {

	// update sphere sky and ground colors to light color * light intensity

	var intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );

	this.color.copy( this.light.color );
	this.color.multiplyScalar( intensity );

	this.groundColor.copy( this.light.groundColor );
	this.groundColor.multiplyScalar( intensity );

	this.lightSphere.material.materials[ 0 ].color.copy( this.color );
	this.lightSphere.material.materials[ 1 ].color.copy( this.groundColor );

	this.lightArrow.setColor( this.color.getHex() );
	this.lightArrowGround.setColor( this.groundColor.getHex() );

	this.lookAt( this.target );

}

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows point light color, intensity, position and distance
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	THREE.Object3D.call( this );

	this.light = light;

	// position

	this.position = light.position;

	// color

	var intensity = THREE.Math.clamp( light.intensity, 0, 1 );

	this.color = light.color.clone();
	this.color.multiplyScalar( intensity );

	var hexColor = this.color.getHex();

	// light helper

	var bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );
	var raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );

	var bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );
	var raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightSphere );
	this.add( this.lightRays );
	this.add( this.lightDistance );

	//

	this.lightSphere.properties.isGizmo = true;
	this.lightSphere.properties.gizmoSubject = light;
	this.lightSphere.properties.gizmoRoot = this;

	//

	this.properties.isGizmo = true;

}

THREE.PointLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.PointLightHelper.prototype.update = function () {

	// update sphere and rays colors to light color * light intensity

	var intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );

	this.color.copy( this.light.color );
	this.color.multiplyScalar( intensity );

	this.lightSphere.material.color.copy( this.color );
	this.lightRays.material.color.copy( this.color );
	this.lightDistance.material.color.copy( this.color );

	//

	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}

}

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows spot light color, intensity, position, orientation, light cone and target
 */

THREE.SpotLightHelper = function ( light, sphereSize ) {

	THREE.Object3D.call( this );

	this.light = light;

	// position

	this.position = light.position;

	// direction

	this.direction = new THREE.Vector3();
	this.direction.subVectors( light.target.position, light.position );

	// color

	var intensity = THREE.Math.clamp( light.intensity, 0, 1 );

	this.color = light.color.clone();
	this.color.multiplyScalar( intensity );

	var hexColor = this.color.getHex();

	// light helper

	var bulbGeometry = new THREE.SphereGeometry( sphereSize, 16, 8 );
	var raysGeometry = new THREE.AsteriskGeometry( sphereSize * 1.25, sphereSize * 2.25 );
	var coneGeometry = new THREE.CylinderGeometry( 0.0001, 1, 1, 8, 1, true );

	var coneMatrix = new THREE.Matrix4();
	coneMatrix.rotateX( -Math.PI/2 );
	coneMatrix.translate( new THREE.Vector3( 0, -0.5, 0 ) );
	coneGeometry.applyMatrix( coneMatrix );

	var bulbMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false } );
	var raysMaterial = new THREE.LineBasicMaterial( { color: hexColor, fog: false } );
	var coneMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.3, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightCone = new THREE.Mesh( coneGeometry, coneMaterial );

	var coneLength = light.distance ? light.distance : 10000;
	var coneWidth = coneLength * Math.tan( light.angle * 0.5 ) * 2;
	this.lightCone.scale.set( coneWidth, coneWidth, coneLength );

	this.lightRays = new THREE.Line( raysGeometry, raysMaterial, THREE.LinePieces );

	this.gyroscope = new THREE.Gyroscope();

	this.gyroscope.add( this.lightSphere );
	this.gyroscope.add( this.lightRays );

	this.add( this.gyroscope );
	this.add( this.lightCone );

	this.lookAt( light.target.position );

	this.lightSphere.properties.isGizmo = true;
	this.lightSphere.properties.gizmoSubject = light;
	this.lightSphere.properties.gizmoRoot = this;

	// light target helper

	this.targetSphere = null;

	if ( light.target.properties.targetInverse !== undefined ) {

		var targetGeo = new THREE.SphereGeometry( sphereSize, 8, 4 );
		var targetMaterial = new THREE.MeshBasicMaterial( { color: hexColor, wireframe: true, fog: false } );

		this.targetSphere = new THREE.Mesh( targetGeo, targetMaterial );
		this.targetSphere.position = light.target.position;

		this.targetSphere.properties.isGizmo = true;
		this.targetSphere.properties.gizmoSubject = light.target;
		this.targetSphere.properties.gizmoRoot = this.targetSphere;

		var lineMaterial = new THREE.LineDashedMaterial( { color: hexColor, dashSize: 4, gapSize: 4, opacity: 0.75, transparent: true, fog: false } );
		var lineGeometry = new THREE.Geometry();
		lineGeometry.vertices.push( this.position.clone() );
		lineGeometry.vertices.push( this.targetSphere.position.clone() );
		lineGeometry.computeLineDistances();

		this.targetLine = new THREE.Line( lineGeometry, lineMaterial );
		this.targetLine.properties.isGizmo = true;

	}

	//

	this.properties.isGizmo = true;

}

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.SpotLightHelper.prototype.update = function () {

	// update arrow orientation
	// pointing from light to target

	this.direction.subVectors( this.light.target.position, this.light.position );

	// update light cone orientation and size

	this.lookAt( this.light.target.position );

	var coneLength = this.light.distance ? this.light.distance : 10000;
	var coneWidth = coneLength * Math.tan( this.light.angle * 0.5 ) * 2;
	this.lightCone.scale.set( coneWidth, coneWidth, coneLength );

	// update arrow, spheres, rays and line colors to light color * light intensity

	var intensity = THREE.Math.clamp( this.light.intensity, 0, 1 );

	this.color.copy( this.light.color );
	this.color.multiplyScalar( intensity );

	this.lightSphere.material.color.copy( this.color );
	this.lightRays.material.color.copy( this.color );
	this.lightCone.material.color.copy( this.color );

	// Only update targetSphere and targetLine if available
	if ( this.targetSphere !== null ) {

		this.targetSphere.material.color.copy( this.color );
		this.targetLine.material.color.copy( this.color );

		// update target line vertices

		this.targetLine.geometry.vertices[ 0 ].copy( this.light.position );
		this.targetLine.geometry.vertices[ 1 ].copy( this.light.target.position );

		this.targetLine.geometry.computeLineDistances();
		this.targetLine.geometry.verticesNeedUpdate = true;

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

	THREE.Object3D.call( this );

	this.render = function ( renderCallback ) { };

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if( size === undefined ) size = -1;
	if( distance === undefined ) distance = 0;
	if( opacity === undefined ) opacity = 1;
	if( color === undefined ) color = new THREE.Color( 0xffffff );
	if( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( { texture: texture, 			// THREE.Texture
		                    size: size, 				// size in pixels (-1 = use texture.width)
		                    distance: distance, 		// distance (0-1) from light source (0=at light source)
		                    x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
		                    scale: 1, 					// scale
		                    rotation: 1, 				// rotation
		                    opacity: opacity,			// opacity
							color: color,				// color
		                    blending: blending } );		// blending

};


/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = -this.positionScreen.x * 2;
	var vecY = -this.positionScreen.y * 2;

	for( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};












/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		startFrame: start,
		endFrame: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];
			var num = chunks[ 2 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = -1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = -1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "animation[" + name + "] undefined" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= -1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
		this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

	}

};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function () {

	var _gl, _renderer, _precision, _lensFlare = {};

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		_precision = renderer.getPrecision();

		_lensFlare.vertices = new Float32Array( 8 + 8 );
		_lensFlare.faces = new Uint16Array( 6 );

		var i = 0;
		_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;	// vertex
		_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;	// uv... etc.

		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;
		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;

		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;
		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;

		_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;
		_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;

		i = 0;
		_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;
		_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;

		// buffers

		_lensFlare.vertexBuffer     = _gl.createBuffer();
		_lensFlare.elementBuffer    = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );

		// textures

		_lensFlare.tempTexture      = _gl.createTexture();
		_lensFlare.occlusionTexture = _gl.createTexture();

		_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
		_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );

		_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
		_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );

		if ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {

			_lensFlare.hasVertexTexture = false;
			_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlare" ], _precision );

		} else {

			_lensFlare.hasVertexTexture = true;
			_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlareVertexTexture" ], _precision );

		}

		_lensFlare.attributes = {};
		_lensFlare.uniforms = {};

		_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, "position" );
		_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, "uv" );

		_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, "renderType" );
		_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, "map" );
		_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, "occlusionMap" );
		_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, "opacity" );
		_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, "color" );
		_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, "scale" );
		_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, "rotation" );
		_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, "screenPosition" );

	};


	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 *         Then _lensFlare.update_lensFlares() is called to re-position and
	 *         update transparency of flares. Then they are rendered.
	 *
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		var flares = scene.__webglFlares,
			nFlares = flares.length;

		if ( ! nFlares ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		var uniforms = _lensFlare.uniforms,
			attributes = _lensFlare.attributes;

		// set _lensFlare program and reset blending

		_gl.useProgram( _lensFlare.program );

		_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );
		_gl.enableVertexAttribArray( _lensFlare.attributes.uv );

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/unforms

		_gl.uniform1i( uniforms.occlusionMap, 0 );
		_gl.uniform1i( uniforms.map, 1 );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
		_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );

		_gl.disable( _gl.CULL_FACE );
		_gl.depthMask( false );

		var i, j, jl, flare, sprite;

		for ( i = 0; i < nFlares; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition )

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( _lensFlare.hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				_gl.activeTexture( _gl.TEXTURE1 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
				_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				_gl.uniform1i( uniforms.renderType, 0 );
				_gl.uniform2f( uniforms.scale, scale.x, scale.y );
				_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				_gl.disable( _gl.BLEND );
				_gl.enable( _gl.DEPTH_TEST );

				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				_gl.activeTexture( _gl.TEXTURE0 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
				_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				_gl.uniform1i( uniforms.renderType, 1 );
				_gl.disable( _gl.DEPTH_TEST );

				_gl.activeTexture( _gl.TEXTURE1 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition )

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				_gl.uniform1i( uniforms.renderType, 2 );
				_gl.enable( _gl.BLEND );

				for ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						_gl.uniform2f( uniforms.scale, scale.x, scale.y );
						_gl.uniform1f( uniforms.rotation, sprite.rotation );

						_gl.uniform1f( uniforms.opacity, sprite.opacity );
						_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						_renderer.setTexture( sprite.texture, 1 );

						_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		_gl.enable( _gl.CULL_FACE );
		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthMask( true );

	};

	function createProgram ( shader, precision ) {

		var program = _gl.createProgram();

		var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
		var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );

		var prefix = "precision " + precision + " float;\n";

		_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		_gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		_gl.compileShader( fragmentShader );
		_gl.compileShader( vertexShader );

		_gl.attachShader( program, fragmentShader );
		_gl.attachShader( program, vertexShader );

		_gl.linkProgram( program );

		return program;

	};

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShadowMapPlugin = function () {

	var _gl,
	_renderer,
	_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_matrixPosition = new THREE.Vector3();

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
		_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

	};

	this.render = function ( scene, camera ) {

		if ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;

		this.update( scene, camera );

	};

	this.update = function ( scene, camera ) {

		var i, il, j, jl, n,

		shadowMap, shadowMatrix, shadowCamera,
		program, buffer, material,
		webglObject, object, light,
		renderList,

		lights = [],
		k = 0,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_gl.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.FRONT );

		} else {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.setDepthTest( true );

		// preprocess lights
		// 	- skip lights that are not casting shadows
		//	- create virtual lights for cascaded shadow maps

		for ( i = 0, il = scene.__lights.length; i < il; i ++ ) {

			light = scene.__lights[ i ];

			if ( ! light.castShadow ) continue;

			if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

				for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

					var virtualLight;

					if ( ! light.shadowCascadeArray[ n ] ) {

						virtualLight = createVirtualLight( light, n );
						virtualLight.originalCamera = camera;

						var gyro = new THREE.Gyroscope();
						gyro.position = light.shadowCascadeOffset;

						gyro.add( virtualLight );
						gyro.add( virtualLight.target );

						camera.add( gyro );

						light.shadowCascadeArray[ n ] = virtualLight;

						console.log( "Created virtualLight", virtualLight );

					} else {

						virtualLight = light.shadowCascadeArray[ n ];

					}

					updateVirtualLight( light, n );

					lights[ k ] = virtualLight;
					k ++;

				}

			} else {

				lights[ k ] = light;
				k ++;

			}

		}

		// render depth map

		for ( i = 0, il = lights.length; i < il; i ++ ) {

			light = lights[ i ];

			if ( ! light.shadowMap ) {

				var shadowFilter = THREE.LinearFilter;

				if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

					shadowFilter = THREE.NearestFilter;

				}

				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

				light.shadowMatrix = new THREE.Matrix4();

			}

			if ( ! light.shadowCamera ) {

				if ( light instanceof THREE.SpotLight ) {

					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

				} else if ( light instanceof THREE.DirectionalLight ) {

					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

				} else {

					console.error( "Unsupported light type for shadow" );
					continue;

				}

				scene.add( light.shadowCamera );

				if ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();

			}

			if ( light.shadowCameraVisible && ! light.cameraHelper ) {

				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
				light.shadowCamera.add( light.cameraHelper );

			}

			if ( light.isVirtual && virtualLight.originalCamera == camera ) {

				updateShadowCamera( camera, light );

			}

			shadowMap = light.shadowMap;
			shadowMatrix = light.shadowMatrix;
			shadowCamera = light.shadowCamera;

			shadowCamera.position.getPositionFromMatrix( light.matrixWorld );
			_matrixPosition.getPositionFromMatrix( light.target.matrixWorld );
			shadowCamera.lookAt( _matrixPosition );
			shadowCamera.updateMatrixWorld();

			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
			if ( light.shadowCameraVisible ) light.cameraHelper.update();

			// compute shadow matrix

			shadowMatrix.set( 0.5, 0.0, 0.0, 0.5,
							  0.0, 0.5, 0.0, 0.5,
							  0.0, 0.0, 0.5, 0.5,
							  0.0, 0.0, 0.0, 1.0 );

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			// update camera matrices and frustum

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			// render shadow map

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// set object matrices & frustum culling

			renderList = scene.__webglObjects;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];
				object = webglObject.object;

				webglObject.render = false;

				if ( object.visible && object.castShadow ) {

					if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

						webglObject.render = true;

					}

				}

			}

			// render regular objects

			var objectMaterial, useMorphing, useSkinning;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];

				if ( webglObject.render ) {

					object = webglObject.object;
					buffer = webglObject.buffer;

					// culling is overriden globally for all objects
					// while rendering depth map

					// need to deal with MeshFaceMaterial somehow
					// in that case just use the first of material.materials for now
					// (proper solution would require to break objects by materials
					//  similarly to regular rendering and then set corresponding
					//  depth materials per each chunk instead of just once per object)

					objectMaterial = getObjectMaterial( object );

					useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

					if ( object.customDepthMaterial ) {

						material = object.customDepthMaterial;

					} else if ( useSkinning ) {

						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

					} else if ( useMorphing ) {

						material = _depthMaterialMorph;

					} else {

						material = _depthMaterial;

					}

					if ( buffer instanceof THREE.BufferGeometry ) {

						_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );

					} else {

						_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );

					}

				}

			}

			// set matrices and render immediate objects

			renderList = scene.__webglObjectsImmediate;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];
				object = webglObject.object;

				if ( object.visible && object.castShadow ) {

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );

				}

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

	};

	function createVirtualLight( light, cascade ) {

		var virtualLight = new THREE.DirectionalLight();

		virtualLight.isVirtual = true;

		virtualLight.onlyShadow = true;
		virtualLight.castShadow = true;

		virtualLight.shadowCameraNear = light.shadowCameraNear;
		virtualLight.shadowCameraFar = light.shadowCameraFar;

		virtualLight.shadowCameraLeft = light.shadowCameraLeft;
		virtualLight.shadowCameraRight = light.shadowCameraRight;
		virtualLight.shadowCameraBottom = light.shadowCameraBottom;
		virtualLight.shadowCameraTop = light.shadowCameraTop;

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;

		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
		virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
		virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

		virtualLight.pointsWorld = [];
		virtualLight.pointsFrustum = [];

		var pointsWorld = virtualLight.pointsWorld,
			pointsFrustum = virtualLight.pointsFrustum;

		for ( var i = 0; i < 8; i ++ ) {

			pointsWorld[ i ] = new THREE.Vector3();
			pointsFrustum[ i ] = new THREE.Vector3();

		}

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		pointsFrustum[ 0 ].set( -1, -1, nearZ );
		pointsFrustum[ 1 ].set(  1, -1, nearZ );
		pointsFrustum[ 2 ].set( -1,  1, nearZ );
		pointsFrustum[ 3 ].set(  1,  1, nearZ );

		pointsFrustum[ 4 ].set( -1, -1, farZ );
		pointsFrustum[ 5 ].set(  1, -1, farZ );
		pointsFrustum[ 6 ].set( -1,  1, farZ );
		pointsFrustum[ 7 ].set(  1,  1, farZ );

		return virtualLight;

	}

	// Synchronize virtual light with the original light

	function updateVirtualLight( light, cascade ) {

		var virtualLight = light.shadowCascadeArray[ cascade ];

		virtualLight.position.copy( light.position );
		virtualLight.target.position.copy( light.target.position );
		virtualLight.lookAt( virtualLight.target );

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;
		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		var pointsFrustum = virtualLight.pointsFrustum;

		pointsFrustum[ 0 ].z = nearZ;
		pointsFrustum[ 1 ].z = nearZ;
		pointsFrustum[ 2 ].z = nearZ;
		pointsFrustum[ 3 ].z = nearZ;

		pointsFrustum[ 4 ].z = farZ;
		pointsFrustum[ 5 ].z = farZ;
		pointsFrustum[ 6 ].z = farZ;
		pointsFrustum[ 7 ].z = farZ;

	}

	// Fit shadow camera's ortho frustum to camera frustum

	function updateShadowCamera( camera, light ) {

		var shadowCamera = light.shadowCamera,
			pointsFrustum = light.pointsFrustum,
			pointsWorld = light.pointsWorld;

		_min.set( Infinity, Infinity, Infinity );
		_max.set( -Infinity, -Infinity, -Infinity );

		for ( var i = 0; i < 8; i ++ ) {

			var p = pointsWorld[ i ];

			p.copy( pointsFrustum[ i ] );
			THREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );

			p.applyMatrix4( shadowCamera.matrixWorldInverse );

			if ( p.x < _min.x ) _min.x = p.x;
			if ( p.x > _max.x ) _max.x = p.x;

			if ( p.y < _min.y ) _min.y = p.y;
			if ( p.y > _max.y ) _max.y = p.y;

			if ( p.z < _min.z ) _min.z = p.z;
			if ( p.z > _max.z ) _max.z = p.z;

		}

		shadowCamera.left = _min.x;
		shadowCamera.right = _max.x;
		shadowCamera.top = _max.y;
		shadowCamera.bottom = _min.y;

		// can't really fit near/far
		//shadowCamera.near = _min.z;
		//shadowCamera.far = _max.z;

		shadowCamera.updateProjectionMatrix();

	}

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use for shadow maps

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};

THREE.ShadowMapPlugin.__projector = new THREE.Projector();
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function () {

	var _gl, _renderer, _precision, _sprite = {};

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		_precision = renderer.getPrecision();

		_sprite.vertices = new Float32Array( 8 + 8 );
		_sprite.faces    = new Uint16Array( 6 );

		var i = 0;

		_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = -1;	// vertex 0
		_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 0;	// uv 0

		_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = -1;	// vertex 1
		_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 0;	// uv 1

		_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;	// vertex 2
		_sprite.vertices[ i++ ] = 1;  _sprite.vertices[ i++ ] = 1;	// uv 2

		_sprite.vertices[ i++ ] = -1; _sprite.vertices[ i++ ] = 1;	// vertex 3
		_sprite.vertices[ i++ ] = 0;  _sprite.vertices[ i++ ] = 1;	// uv 3

		i = 0;

		_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 1; _sprite.faces[ i++ ] = 2;
		_sprite.faces[ i++ ] = 0; _sprite.faces[ i++ ] = 2; _sprite.faces[ i++ ] = 3;

		_sprite.vertexBuffer  = _gl.createBuffer();
		_sprite.elementBuffer = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, _sprite.vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _sprite.faces, _gl.STATIC_DRAW );

		_sprite.program = createProgram( THREE.ShaderSprite[ "sprite" ], _precision );

		_sprite.attributes = {};
		_sprite.uniforms = {};

		_sprite.attributes.position           = _gl.getAttribLocation ( _sprite.program, "position" );
		_sprite.attributes.uv                 = _gl.getAttribLocation ( _sprite.program, "uv" );

		_sprite.uniforms.uvOffset             = _gl.getUniformLocation( _sprite.program, "uvOffset" );
		_sprite.uniforms.uvScale              = _gl.getUniformLocation( _sprite.program, "uvScale" );

		_sprite.uniforms.rotation             = _gl.getUniformLocation( _sprite.program, "rotation" );
		_sprite.uniforms.scale                = _gl.getUniformLocation( _sprite.program, "scale" );
		_sprite.uniforms.alignment            = _gl.getUniformLocation( _sprite.program, "alignment" );

		_sprite.uniforms.color                = _gl.getUniformLocation( _sprite.program, "color" );
		_sprite.uniforms.map                  = _gl.getUniformLocation( _sprite.program, "map" );
		_sprite.uniforms.opacity              = _gl.getUniformLocation( _sprite.program, "opacity" );

		_sprite.uniforms.useScreenCoordinates = _gl.getUniformLocation( _sprite.program, "useScreenCoordinates" );
		_sprite.uniforms.sizeAttenuation   	  = _gl.getUniformLocation( _sprite.program, "sizeAttenuation" );
		_sprite.uniforms.screenPosition    	  = _gl.getUniformLocation( _sprite.program, "screenPosition" );
		_sprite.uniforms.modelViewMatrix      = _gl.getUniformLocation( _sprite.program, "modelViewMatrix" );
		_sprite.uniforms.projectionMatrix     = _gl.getUniformLocation( _sprite.program, "projectionMatrix" );

		_sprite.uniforms.fogType 		  	  = _gl.getUniformLocation( _sprite.program, "fogType" );
		_sprite.uniforms.fogDensity 		  = _gl.getUniformLocation( _sprite.program, "fogDensity" );
		_sprite.uniforms.fogNear 		  	  = _gl.getUniformLocation( _sprite.program, "fogNear" );
		_sprite.uniforms.fogFar 		  	  = _gl.getUniformLocation( _sprite.program, "fogFar" );
		_sprite.uniforms.fogColor 		  	  = _gl.getUniformLocation( _sprite.program, "fogColor" );

		_sprite.uniforms.alphaTest 		  	  = _gl.getUniformLocation( _sprite.program, "alphaTest" );

	};

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		var sprites = scene.__webglSprites,
			nSprites = sprites.length;

		if ( ! nSprites ) return;

		var attributes = _sprite.attributes,
			uniforms = _sprite.uniforms;

		var invAspect = viewportHeight / viewportWidth;

		var halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		// setup gl

		_gl.useProgram( _sprite.program );

		_gl.enableVertexAttribArray( attributes.position );
		_gl.enableVertexAttribArray( attributes.uv );

		_gl.disable( _gl.CULL_FACE );
		_gl.enable( _gl.BLEND );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _sprite.vertexBuffer );
		_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _sprite.elementBuffer );

		_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		_gl.activeTexture( _gl.TEXTURE0 );
		_gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				_gl.uniform1f( uniforms.fogNear, fog.near );
				_gl.uniform1f( uniforms.fogFar, fog.far );

				_gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				_gl.uniform1f( uniforms.fogDensity, fog.density );

				_gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			_gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		var i, sprite, material, screenPosition, size, fogType, scale = [];

		for( i = 0; i < nSprites; i ++ ) {

			sprite = sprites[ i ];
			material = sprite.material;

			if ( ! sprite.visible || material.opacity === 0 ) continue;

			if ( ! material.useScreenCoordinates ) {

				sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
				sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

			} else {

				sprite.z = - sprite.position.z;

			}

		}

		sprites.sort( painterSortStable );

		// render all sprites

		for( i = 0; i < nSprites; i ++ ) {

			sprite = sprites[ i ];
			material = sprite.material;

			if ( ! sprite.visible || material.opacity === 0 ) continue;

			if ( material.map && material.map.image && material.map.image.width ) {

				_gl.uniform1f( uniforms.alphaTest, material.alphaTest );

				if ( material.useScreenCoordinates === true ) {

					_gl.uniform1i( uniforms.useScreenCoordinates, 1 );
					_gl.uniform3f(
						uniforms.screenPosition,
						( ( sprite.position.x * _renderer.devicePixelRatio ) - halfViewportWidth  ) / halfViewportWidth,
						( halfViewportHeight - ( sprite.position.y * _renderer.devicePixelRatio ) ) / halfViewportHeight,
						Math.max( 0, Math.min( 1, sprite.position.z ) )
					);

					scale[ 0 ] = _renderer.devicePixelRatio;
					scale[ 1 ] = _renderer.devicePixelRatio;

				} else {

					_gl.uniform1i( uniforms.useScreenCoordinates, 0 );
					_gl.uniform1i( uniforms.sizeAttenuation, material.sizeAttenuation ? 1 : 0 );
					_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

					scale[ 0 ] = 1;
					scale[ 1 ] = 1;

				}

				if ( scene.fog && material.fog ) {

					fogType = sceneFogType;

				} else {

					fogType = 0;

				}

				if ( oldFogType !== fogType ) {

					_gl.uniform1i( uniforms.fogType, fogType );
					oldFogType = fogType;

				}

				size = 1 / ( material.scaleByViewport ? viewportHeight : 1 );

				scale[ 0 ] *= size * invAspect * sprite.scale.x
				scale[ 1 ] *= size * sprite.scale.y;

				_gl.uniform2f( uniforms.uvScale, material.uvScale.x, material.uvScale.y );
				_gl.uniform2f( uniforms.uvOffset, material.uvOffset.x, material.uvOffset.y );
				_gl.uniform2f( uniforms.alignment, material.alignment.x, material.alignment.y );

				_gl.uniform1f( uniforms.opacity, material.opacity );
				_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

				_gl.uniform1f( uniforms.rotation, sprite.rotation );
				_gl.uniform2fv( uniforms.scale, scale );

				_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
				_renderer.setDepthTest( material.depthTest );
				_renderer.setDepthWrite( material.depthWrite );
				_renderer.setTexture( material.map, 0 );

				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

			}

		}

		// restore gl

		_gl.enable( _gl.CULL_FACE );

	};

	function createProgram ( shader, precision ) {

		var program = _gl.createProgram();

		var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
		var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );

		var prefix = "precision " + precision + " float;\n";

		_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		_gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		_gl.compileShader( fragmentShader );
		_gl.compileShader( vertexShader );

		_gl.attachShader( program, fragmentShader );
		_gl.attachShader( program, vertexShader );

		_gl.linkProgram( program );

		return program;

	};

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	};

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DepthPassPlugin = function () {

	this.enabled = false;
	this.renderTarget = null;

	var _gl,
	_renderer,
	_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4();

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
		_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

	};

	this.render = function ( scene, camera ) {

		if ( ! this.enabled ) return;

		this.update( scene, camera );

	};

	this.update = function ( scene, camera ) {

		var i, il, j, jl, n,

		program, buffer, material,
		webglObject, object, light,
		renderList,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_renderer.setDepthTest( true );

		// update scene

		if ( _renderer.autoUpdateScene ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// render depth map

		_renderer.setRenderTarget( this.renderTarget );
		_renderer.clear();

		// set object matrices & frustum culling

		renderList = scene.__webglObjects;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];
			object = webglObject.object;

			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

					object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

					webglObject.render = true;

				}

			}

		}

		// render regular objects

		var objectMaterial, useMorphing, useSkinning;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				// todo: create proper depth material for particles

				if ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;

				objectMaterial = getObjectMaterial( object );

				if ( objectMaterial ) _renderer.setMaterialFaces( object.material );

				useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
				useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

				if ( object.customDepthMaterial ) {

					material = object.customDepthMaterial;

				} else if ( useSkinning ) {

					material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

				} else if ( useMorphing ) {

					material = _depthMaterialMorph;

				} else {

					material = _depthMaterial;

				}

				if ( buffer instanceof THREE.BufferGeometry ) {

					_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );

				} else {

					_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );

				}

			}

		}

		// set matrices and render immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];
			object = webglObject.object;

			if ( object.visible ) {

				object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

				_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

	};

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};

/**
 * @author mikael emtinger / http://gomo.se/
 *
 */

THREE.ShaderFlares = {

	'lensFlareVertexTexture': {

		vertexShader: [

			"uniform lowp int renderType;",

			"uniform vec3 screenPosition;",
			"uniform vec2 scale;",
			"uniform float rotation;",

			"uniform sampler2D occlusionMap;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",
			"varying float vVisibility;",

			"void main() {",

				"vUV = uv;",

				"vec2 pos = position;",

				"if( renderType == 2 ) {",

					"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) ) +",
									  "texture2D( occlusionMap, vec2( 0.5, 0.1 ) ) +",
									  "texture2D( occlusionMap, vec2( 0.9, 0.1 ) ) +",
									  "texture2D( occlusionMap, vec2( 0.9, 0.5 ) ) +",
									  "texture2D( occlusionMap, vec2( 0.9, 0.9 ) ) +",
									  "texture2D( occlusionMap, vec2( 0.5, 0.9 ) ) +",
									  "texture2D( occlusionMap, vec2( 0.1, 0.9 ) ) +",
									  "texture2D( occlusionMap, vec2( 0.1, 0.5 ) ) +",
									  "texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

					"vVisibility = (       visibility.r / 9.0 ) *",
								  "( 1.0 - visibility.g / 9.0 ) *",
								  "(       visibility.b / 9.0 ) *",
								  "( 1.0 - visibility.a / 9.0 );",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

				"}",

				"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform lowp int renderType;",

			"uniform sampler2D map;",
			"uniform float opacity;",
			"uniform vec3 color;",

			"varying vec2 vUV;",
			"varying float vVisibility;",

			"void main() {",

				// pink square

				"if( renderType == 0 ) {",

					"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

				// restore

				"} else if( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

				// flare

				"} else {",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * vVisibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

				"}",

			"}"
		].join( "\n" )

	},


	'lensFlare': {

		vertexShader: [

			"uniform lowp int renderType;",

			"uniform vec3 screenPosition;",
			"uniform vec2 scale;",
			"uniform float rotation;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",

			"void main() {",

				"vUV = uv;",

				"vec2 pos = position;",

				"if( renderType == 2 ) {",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

				"}",

				"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"precision mediump float;",

			"uniform lowp int renderType;",

			"uniform sampler2D map;",
			"uniform sampler2D occlusionMap;",
			"uniform float opacity;",
			"uniform vec3 color;",

			"varying vec2 vUV;",

			"void main() {",

				// pink square

				"if( renderType == 0 ) {",

					"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

				// restore

				"} else if( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

				// flare

				"} else {",

					"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a +",
									   "texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a +",
									   "texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a +",
									   "texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",

					"visibility = ( 1.0 - visibility / 4.0 );",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * visibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

				"}",

			"}"

		].join( "\n" )

	}

};
/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 *
 */

THREE.ShaderSprite = {

	'sprite': {

		vertexShader: [

			"uniform int useScreenCoordinates;",
			"uniform int sizeAttenuation;",
			"uniform vec3 screenPosition;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform float rotation;",
			"uniform vec2 scale;",
			"uniform vec2 alignment;",
			"uniform vec2 uvOffset;",
			"uniform vec2 uvScale;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",

			"void main() {",

				"vUV = uvOffset + uv * uvScale;",

				"vec2 alignedPosition = position + alignment;",

				"vec2 rotatedPosition;",
				"rotatedPosition.x = ( cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y ) * scale.x;",
				"rotatedPosition.y = ( sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y ) * scale.y;",

				"vec4 finalPosition;",

				"if( useScreenCoordinates != 0 ) {",

					"finalPosition = vec4( screenPosition.xy + rotatedPosition, screenPosition.z, 1.0 );",

				"} else {",

					"finalPosition = projectionMatrix * modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );",
					"finalPosition.xy += rotatedPosition * ( sizeAttenuation == 1 ? 1.0 : finalPosition.z );",

				"}",

				"gl_Position = finalPosition;",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform vec3 color;",
			"uniform sampler2D map;",
			"uniform float opacity;",

			"uniform int fogType;",
			"uniform vec3 fogColor;",
			"uniform float fogDensity;",
			"uniform float fogNear;",
			"uniform float fogFar;",
			"uniform float alphaTest;",

			"varying vec2 vUV;",

			"void main() {",

				"vec4 texture = texture2D( map, vUV );",

				"if ( texture.a < alphaTest ) discard;",

				"gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );",

				"if ( fogType > 0 ) {",

					"float depth = gl_FragCoord.z / gl_FragCoord.w;",
					"float fogFactor = 0.0;",

					"if ( fogType == 1 ) {",

						"fogFactor = smoothstep( fogNear, fogFar, depth );",

					"} else {",

						"const float LOG2 = 1.442695;",
						"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
						"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",

					"}",

					"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

				"}",

			"}"

		].join( "\n" )

	}

};

// Export the THREE object for **Node.js**, with
// backwards-compatibility for the old `require()` API. If we're in
// the browser, add `_` as a global object via a string identifier,
// for Closure Compiler "advanced" mode.
if (typeof exports !== 'undefined') {
  if (typeof module !== 'undefined' && module.exports) {
    exports = module.exports = THREE;
  }
  exports.THREE = THREE;
} else {
  this['THREE'] = THREE;
}

}).call(this,require('_process'))

},{"_process":10}],59:[function(require,module,exports){
/*
 * tic
 * https://github.com/shama/tic
 *
 * Copyright (c) 2013 Kyle Robinson Young
 * Licensed under the MIT license.
 */

function Tic() { this._things = []; }
module.exports = function() { return new Tic(); };

Tic.prototype._stack = function(thing) {
  var self = this;
  self._things.push(thing);
  var i = self._things.length - 1;
  return function() { delete self._things[i]; }
};

Tic.prototype.interval = Tic.prototype.setInterval = function(fn, at) {
  return this._stack({
    fn: fn, at: at, args: Array.prototype.slice.call(arguments, 2),
    elapsed: 0, once: false
  });
};

Tic.prototype.timeout = Tic.prototype.setTimeout = function(fn, at) {
  return this._stack({
    fn: fn, at: at, args: Array.prototype.slice.call(arguments, 2),
    elapsed: 0, once: true
  });
};

Tic.prototype.tick = function(dt) {
  var self = this;
  self._things.forEach(function(thing, i) {
    thing.elapsed += dt;
    if (thing.elapsed > thing.at) {
      thing.elapsed -= thing.at;
      thing.fn.apply(thing.fn, thing.args || []);
      if (thing.once) {
        delete self._things[i];
      }
    }
  });
};

},{}],60:[function(require,module,exports){
module.exports = control

var Stream = require('stream').Stream

function control(control_state, opts) {
  return new Control(control_state, opts)
}

function Control(state, opts) {
  Stream.call(this)

  opts = opts || {}

  this.state = state
  this._pitch_target = 
  this._yaw_target =
  this._roll_target =
  this._target = null
  this.speed = opts.speed || 0.0032
  this.max_speed = opts.maxSpeed || 0.0112
  this.jump_max_speed = opts.jumpMaxSpeed || 0.016
  this.jump_max_timer = opts.jumpTimer || 200
  this.jump_speed = opts.jumpSpeed || 0.004
  this.jump_timer = this.jump_timer_max
  this.jumping = false
  this.acceleration = opts.accelerationCurve || this.acceleration

  this.fire_rate = opts.fireRate || 0
  this.needs_discrete_fire = opts.discreteFire || false
  this.onfire = opts.onfire || this.onfire
  this.firing = 0

  this.x_rotation_per_ms = opts.rotationXMax || opts.rotationMax || 33
  this.y_rotation_per_ms = opts.rotationYMax || opts.rotationMax || 33
  this.z_rotation_per_ms = opts.rotationZMax || opts.rotationMax || 33

  this.x_rotation_clamp = opts.rotationXClamp || Math.PI / 2
  this.y_rotation_clamp = opts.rotationYClamp || Infinity
  this.z_rotation_clamp = opts.rotationZClamp || 0

  this.rotation_scale = opts.rotationScale || 0.002

  this.air_control = 'airControl' in opts ? opts.airControl : true

  this.state.x_rotation_accum =
  this.state.y_rotation_accum = 
  this.state.z_rotation_accum = 0.0

  this.accel_max_timer = opts.accelTimer || 200
  this.x_accel_timer = this.accel_max_timer+0
  this.z_accel_timer = this.accel_max_timer+0

  this.readable =
  this.writable = true

  this.buffer = []
  this.paused = false
}

var cons = Control
  , proto = cons.prototype = new Stream

proto.constructor = cons

var max = Math.max
  , min = Math.min
  , sin = Math.sin
  , abs = Math.abs
  , floor = Math.floor
  , PI = Math.PI

proto.tick = function(dt) {
  if(!this._target) {
    return
  }
  var state = this.state
    , target = this._target
    , speed = this.speed
    , jump_speed = this.jump_speed
    , okay_z = abs(target.velocity.z) < this.max_speed
    , okay_x = abs(target.velocity.x) < this.max_speed
    , at_rest = target.atRestY()

  if(!this._target) return

  if(state.forward || state.backward) {
    this.z_accel_timer = max(0, this.z_accel_timer - dt)
  }
  if(state.backward) {
    if(target.velocity.z < this.max_speed)
      target.velocity.z = max(min(this.max_speed, speed * dt * this.acceleration(this.z_accel_timer, this.accel_max_timer)), target.velocity.z)
  } else if(state.forward) {
    if(target.velocity.z > -this.max_speed)
      target.velocity.z = min(max(-this.max_speed, -speed * dt * this.acceleration(this.z_accel_timer, this.accel_max_timer)), target.velocity.z)
  } else {
    this.z_accel_timer = this.accel_max_timer

  }
 

  if(state.left || state.right) {
    this.x_accel_timer = max(0, this.x_accel_timer - dt)
  }

  if(state.right) {
    if(target.velocity.x < this.max_speed)
      target.velocity.x = max(min(this.max_speed, speed * dt * this.acceleration(this.x_accel_timer, this.accel_max_timer)), target.velocity.x)
  } else if(state.left) {
    if(target.velocity.x > -this.max_speed)
      target.velocity.x = min(max(-this.max_speed, -speed * dt * this.acceleration(this.x_accel_timer, this.accel_max_timer)), target.velocity.x)
  } else {
    this.x_accel_timer = this.accel_max_timer
  }

  if(state.jump) {
    if(!this.jumping && !at_rest) {
      // we're falling, we can't jump
    } else if(at_rest > 0) {
      // we hit our head
      this.jumping = false
    } else {
      this.jumping = true
      if(this.jump_timer > 0) {
        target.velocity.y = min(target.velocity.y + jump_speed * min(dt, this.jump_timer), this.jump_max_speed)
      }
      this.jump_timer = max(this.jump_timer - dt, 0)
    }
  } else {
    this.jumping = false
  }
  this.jump_timer = at_rest < 0 ? this.jump_max_timer : this.jump_timer

  var can_fire = true

  if(state.fire || state.firealt) {
    if(this.firing && this.needs_discrete_fire) {
      this.firing += dt
    } else {
      if(!this.fire_rate || floor(this.firing / this.fire_rate) !== floor((this.firing + dt) / this.fire_rate)) {
        this.onfire(state)
      }
      this.firing += dt
    }
  } else {
    this.firing = 0
  }

  var x_rotation = this.state.x_rotation_accum * this.rotation_scale
    , y_rotation = this.state.y_rotation_accum * this.rotation_scale
    , z_rotation = this.state.z_rotation_accum * this.rotation_scale
    , pitch_target = this._pitch_target
    , yaw_target = this._yaw_target
    , roll_target = this._roll_target

  pitch_target.rotation.x = clamp(pitch_target.rotation.x + clamp(x_rotation, this.x_rotation_per_ms), this.x_rotation_clamp)
  yaw_target.rotation.y = clamp(yaw_target.rotation.y + clamp(y_rotation, this.y_rotation_per_ms), this.y_rotation_clamp)
  roll_target.rotation.z = clamp(roll_target.rotation.z + clamp(z_rotation, this.z_rotation_per_ms), this.z_rotation_clamp)

  if(this.listeners('data').length) {
    this.emitUpdate()
  }

  this.state.x_rotation_accum =
  this.state.y_rotation_accum =
  this.state.z_rotation_accum = 0
}

proto.write = function(changes) {
  for(var key in changes) {
    this.state[key] = changes[key]
  }
}

proto.end = function(deltas) {
  if(deltas) {
    this.write(deltas)
  }
}

proto.createWriteRotationStream = function() {
  var state = this.state
    , stream = new Stream

  state.x_rotation_accum =
  state.y_rotation_accum =
  state.z_rotation_accum = 0

  stream.writable = true
  stream.write = write
  stream.end = end

  return stream

  function write(changes) {
    state.x_rotation_accum -= changes.dy || 0
    state.y_rotation_accum -= changes.dx || 0
    state.z_rotation_accum += changes.dz || 0
  }

  function end(deltas) {
    if(deltas) {
      stream.write(deltas)
    }
  }
}

proto.emitUpdate = function() {
  return this.queue({
      x_rotation_accum: this.state.x_rotation_accum
    , y_rotation_accum: this.state.y_rotation_accum
    , z_rotation_accum: this.state.z_rotation_accum
    , forward: this.state.forward
    , backward: this.state.backward
    , left: this.state.left
    , right: this.state.right
    , fire: this.state.fire
    , firealt: this.state.firealt
    , jump: this.state.jump
  })
}

proto.drain = function() {
  var buf = this.buffer
    , data

  while(buf.length && !this.paused) {
    data = buf.shift()
    if(null === data) {
      return this.emit('end')
    }
    this.emit('data', data)
  }
}

proto.resume = function() {
  this.paused = false
  this.drain()

  if(!this.paused) {
    this.emit('drain')
  }
  return this
}

proto.pause = function() {
  if(this.paused) return

  this.paused = true
  this.emit('pause')
  return this
}

proto.queue = function(data) {
  this.buffer.push(data)
  this.drain()
  return this
}

proto.acceleration = function(current, max) {
  // max -> 0
  var pct = (max - current) / max
  return sin(PI/2*pct)
}

proto.target = function(target) {
  if(target) {
    this._target = target
    this._yaw_target = target.yaw || target
    this._pitch_target = target.pitch || target
    this._roll_target = target.roll || target
  }
  return this._target
}

proto.onfire = function(_) {

}

function clamp(value, to) {
  return isFinite(to) ? max(min(value, to), -to) : value
}

},{"stream":24}],61:[function(require,module,exports){
var THREE = require('three')

module.exports = function(data, mesher, scaleFactor, three) {
  return new Mesh(data, mesher, scaleFactor, three)
}

module.exports.Mesh = Mesh

function Mesh(data, mesher, scaleFactor, three) {
  this.THREE = three || THREE
  this.data = data
  var geometry = this.geometry = new this.THREE.Geometry()
  this.scale = scaleFactor || new this.THREE.Vector3(10, 10, 10)
  
  var result = mesher( data.voxels, data.dims )
  this.meshed = result

  geometry.vertices.length = 0
  geometry.faces.length = 0

  for (var i = 0; i < result.vertices.length; ++i) {
    var q = result.vertices[i]
    geometry.vertices.push(new this.THREE.Vector3(q[0], q[1], q[2]))
  } 
  
  for (var i = 0; i < result.faces.length; ++i) {
    geometry.faceVertexUvs[0].push(this.faceVertexUv(i))
    
    var q = result.faces[i]
    if (q.length === 5) {
      var f = new this.THREE.Face4(q[0], q[1], q[2], q[3])
      f.color = new this.THREE.Color(q[4])
      geometry.faces.push(f)
    } else if (q.length == 4) {
      var f = new this.THREE.Face3(q[0], q[1], q[2])
      f.color = new this.THREE.Color(q[3])
      geometry.faces.push(f)
    }
  }
  
  geometry.computeFaceNormals()

  // compute vertex colors for ambient occlusion
  var light = new THREE.Color(0xffffff)
  var shadow = new THREE.Color(0x505050)
  for (var i = 0; i < geometry.faces.length; ++i) {
    var face = geometry.faces[i]
    // facing up
    if (face.normal.y === 1)       face.vertexColors = [light, light, light, light]
    // facing down
    else if (face.normal.y === -1) face.vertexColors = [shadow, shadow, shadow, shadow]
    // facing right
    else if (face.normal.x === 1)  face.vertexColors = [shadow, light, light, shadow]
    // facing left
    else if (face.normal.x === -1) face.vertexColors = [shadow, shadow, light, light]
    // facing backward
    else if (face.normal.z === 1)  face.vertexColors = [shadow, shadow, light, light]
    // facing forward
    else                           face.vertexColors = [shadow, light, light, shadow]
  }

  geometry.verticesNeedUpdate = true
  geometry.elementsNeedUpdate = true
  geometry.normalsNeedUpdate = true

  geometry.computeBoundingBox()
  geometry.computeBoundingSphere()

}

Mesh.prototype.createWireMesh = function(hexColor) {    
  var wireMaterial = new this.THREE.MeshBasicMaterial({
    color : hexColor || 0xffffff,
    wireframe : true
  })
  wireMesh = new THREE.Mesh(this.geometry, wireMaterial)
  wireMesh.scale = this.scale
  wireMesh.doubleSided = true
  this.wireMesh = wireMesh
  return wireMesh
}

Mesh.prototype.createSurfaceMesh = function(material) {
  material = material || new this.THREE.MeshNormalMaterial()
  var surfaceMesh  = new this.THREE.Mesh( this.geometry, material )
  surfaceMesh.scale = this.scale
  surfaceMesh.doubleSided = false
  this.surfaceMesh = surfaceMesh
  return surfaceMesh
}

Mesh.prototype.addToScene = function(scene) {
  if (this.wireMesh) scene.add( this.wireMesh )
  if (this.surfaceMesh) scene.add( this.surfaceMesh )
}

Mesh.prototype.setPosition = function(x, y, z) {
  if (this.wireMesh) this.wireMesh.position = new this.THREE.Vector3(x, y, z)
  if (this.surfaceMesh) this.surfaceMesh.position = new this.THREE.Vector3(x, y, z)
}

Mesh.prototype.faceVertexUv = function(i) {
  var vs = [
    this.meshed.vertices[i*4+0],
    this.meshed.vertices[i*4+1],
    this.meshed.vertices[i*4+2],
    this.meshed.vertices[i*4+3]
  ]
  var spans = {
    x0: vs[0][0] - vs[1][0],
    x1: vs[1][0] - vs[2][0],
    y0: vs[0][1] - vs[1][1],
    y1: vs[1][1] - vs[2][1],
    z0: vs[0][2] - vs[1][2],
    z1: vs[1][2] - vs[2][2]
  }
  var size = {
    x: Math.max(Math.abs(spans.x0), Math.abs(spans.x1)),
    y: Math.max(Math.abs(spans.y0), Math.abs(spans.y1)),
    z: Math.max(Math.abs(spans.z0), Math.abs(spans.z1))
  }
  if (size.x === 0) {
    if (spans.y0 > spans.y1) {
      var width = size.y
      var height = size.z
    }
    else {
      var width = size.z
      var height = size.y
    }
  }
  if (size.y === 0) {
    if (spans.x0 > spans.x1) {
      var width = size.x
      var height = size.z
    }
    else {
      var width = size.z
      var height = size.x
    }
  }
  if (size.z === 0) {
    if (spans.x0 > spans.x1) {
      var width = size.x
      var height = size.y
    }
    else {
      var width = size.y
      var height = size.x
    }
  }
  if ((size.z === 0 && spans.x0 < spans.x1) || (size.x === 0 && spans.y0 > spans.y1)) {
    return [
      new this.THREE.Vector2(height, 0),
      new this.THREE.Vector2(0, 0),
      new this.THREE.Vector2(0, width),
      new this.THREE.Vector2(height, width)
    ]
  } else {
    return [
      new this.THREE.Vector2(0, 0),
      new this.THREE.Vector2(0, height),
      new this.THREE.Vector2(width, height),
      new this.THREE.Vector2(width, 0)
    ]
  }
}
;

},{"three":58}],62:[function(require,module,exports){
module.exports = physical

var aabb = require('aabb-3d')
  , THREE = require('three')

function physical(avatar, collidables, dimensions, terminal) {
  return new Physical(avatar, collidables, dimensions, terminal)
}

function Physical(avatar, collidables, dimensions, terminal) {
  this.avatar = avatar
  this.terminal = terminal || new THREE.Vector3(0.9, 0.1, 0.9)
  this.dimensions = dimensions = dimensions || [1, 1, 1]
  this._aabb = aabb([0, 0, 0], dimensions)
  this.resting = {x: false, y: false, z: false}
  this.collidables = collidables
  this.friction = new THREE.Vector3(1, 1, 1)

  this.rotation = this.avatar.rotation
  this.default_friction = 1

  // default yaw/pitch/roll controls to the avatar
  this.yaw =
  this.pitch =
  this.roll = avatar

  this.forces = new THREE.Vector3(0, 0, 0)
  this.attractors = []
  this.acceleration = new THREE.Vector3(0, 0, 0)
  this.velocity = new THREE.Vector3(0, 0, 0)
}

var cons = Physical
  , proto = cons.prototype
  , axes = ['x', 'y', 'z']
  , abs = Math.abs

// make these *once*, so we're not generating
// garbage for every object in the game.
var WORLD_DESIRED = new THREE.Vector3(0, 0, 0)
  , DESIRED = new THREE.Vector3(0, 0, 0)
  , START = new THREE.Vector3(0, 0, 0)
  , END = new THREE.Vector3(0, 0, 0)
  , DIRECTION = new THREE.Vector3()
  , LOCAL_ATTRACTOR = new THREE.Vector3()
  , TOTAL_FORCES = new THREE.Vector3()

proto.applyWorldAcceleration = applyTo('acceleration')
proto.applyWorldVelocity = applyTo('velocity')

function applyTo(which) {
  return function(world) {
    var local = this.avatar.worldToLocal(world)
    this[which].x += local.x
    this[which].y += local.y
    this[which].z += local.z
  }
}

proto.tick = function(dt) {
  var forces = this.forces
    , acceleration = this.acceleration
    , velocity = this.velocity
    , terminal = this.terminal
    , friction = this.friction
    , desired = DESIRED
    , world_desired = WORLD_DESIRED
    , bbox
    , pcs
  TOTAL_FORCES.multiplyScalar(0)

  desired.x =
  desired.y =
  desired.z =
  world_desired.x =
  world_desired.y =
  world_desired.z = 0

  for(var i = 0; i < this.attractors.length; i++) {
    var distance_factor = this.avatar.position.distanceToSquared(this.attractors[i])
    LOCAL_ATTRACTOR.copy(this.attractors[i])
    LOCAL_ATTRACTOR = this.avatar.worldToLocal(LOCAL_ATTRACTOR)

    DIRECTION.sub(LOCAL_ATTRACTOR, this.avatar.position)

    DIRECTION.divideScalar(DIRECTION.length() * distance_factor)
    DIRECTION.multiplyScalar(this.attractors[i].mass)

    TOTAL_FORCES.addSelf(DIRECTION)
  }
  
  if(!this.resting.x) {
    acceleration.x /= 8 * dt
    acceleration.x += TOTAL_FORCES.x * dt
    acceleration.x += forces.x * dt

    velocity.x += acceleration.x * dt
    velocity.x *= friction.x

    if(abs(velocity.x) < terminal.x) {
      desired.x = (velocity.x * dt)
    } else if(velocity.x !== 0) {
      desired.x = (velocity.x / abs(velocity.x)) * terminal.x
    }
  } else {
    acceleration.x = velocity.x = 0
  }
  if(!this.resting.y) {
    acceleration.y /= 8 * dt
    acceleration.y += TOTAL_FORCES.y * dt
    acceleration.y += forces.y * dt

    velocity.y += acceleration.y * dt
    velocity.y *= friction.y

    if(abs(velocity.y) < terminal.y) {
      desired.y = (velocity.y * dt)
    } else if(velocity.y !== 0) {
      desired.y = (velocity.y / abs(velocity.y)) * terminal.y
    }
  } else {
    acceleration.y = velocity.y = 0
  }
  if(!this.resting.z) {
    acceleration.z /= 8 * dt
    acceleration.z += TOTAL_FORCES.z * dt
    acceleration.z += forces.z * dt

    velocity.z += acceleration.z * dt
    velocity.z *= friction.z

    if(abs(velocity.z) < terminal.z) {
      desired.z = (velocity.z * dt)
    } else if(velocity.z !== 0) {
      desired.z = (velocity.z / abs(velocity.z)) * terminal.z
    }
  } else {
    acceleration.z = velocity.z = 0
  }
  
  START.copy(this.avatar.position)
  this.avatar.translateX(desired.x)
  this.avatar.translateY(desired.y)
  this.avatar.translateZ(desired.z)
  END.copy(this.avatar.position)
  this.avatar.position.copy(START)
  world_desired.x = END.x - START.x
  world_desired.y = END.y - START.y
  world_desired.z = END.z - START.z
  this.friction.x =
  this.friction.y =
  this.friction.z = this.default_friction

  // run collisions
  this.resting.x =
  this.resting.y =
  this.resting.z = false

  bbox = this.aabb()
  pcs = this.collidables

  for(var i = 0, len = pcs.length; i < len; ++i) {
    if(pcs[i] !== this) {
      pcs[i].collide(this, bbox, world_desired, this.resting)
    }
  }

  // apply translation
  this.avatar.position.x += world_desired.x
  this.avatar.position.y += world_desired.y
  this.avatar.position.z += world_desired.z
}

proto.subjectTo = function(force) {
  this.forces.x += force[0]
  this.forces.y += force[1]
  this.forces.z += force[2]
  return this
}

proto.removeForce = function(force) {
  this.forces.x -= force[0]
  this.forces.y -= force[1]
  this.forces.z -= force[2]
  return this
}

proto.attractTo = function(vector, mass) {
  vector.mass = mass
  this.attractors.push(vector)
}

proto.aabb = function() {
  var pos = this.avatar.position
  var d = this.dimensions
  return aabb(
    [pos.x - (d[0]/2), pos.y, pos.z - (d[2]/2)],
    this.dimensions
  )
}

// no object -> object collisions for now, thanks
proto.collide = function(other, bbox, world_vec, resting) {
  return
}

proto.atRestX = function() {
  return this.resting.x
}

proto.atRestY = function() {
  return this.resting.y
}

proto.atRestZ = function() {
  return this.resting.z
}

},{"aabb-3d":36,"three":58}],63:[function(require,module,exports){
"use strict"

function traceRay_impl(
  voxels,
  px, py, pz,
  dx, dy, dz,
  max_d,
  hit_pos,
  hit_norm,
  EPSILON) {
  var t = 0.0
    , nx=0, ny=0, nz=0
    , ix, iy, iz
    , fx, fy, fz
    , ox, oy, oz
    , ex, ey, ez
    , b, step, min_step
    , floor = Math.floor
  //Step block-by-block along ray
  while(t <= max_d) {
    ox = px + t * dx
    oy = py + t * dy
    oz = pz + t * dz
    ix = floor(ox)|0
    iy = floor(oy)|0
    iz = floor(oz)|0
    fx = ox - ix
    fy = oy - iy
    fz = oz - iz
    b = voxels.getBlock(ix, iy, iz)
    if(b) {
      if(hit_pos) {
        //Clamp to face on hit
        hit_pos[0] = fx < EPSILON ? +ix : (fx > 1.0-EPSILON ? ix+1.0-EPSILON : ox)
        hit_pos[1] = fy < EPSILON ? +iy : (fy > 1.0-EPSILON ? iy+1.0-EPSILON : oy)
        hit_pos[2] = fz < EPSILON ? +iz : (fz > 1.0-EPSILON ? iz+1.0-EPSILON : oz)
      }
      if(hit_norm) {
        hit_norm[0] = nx
        hit_norm[1] = ny
        hit_norm[2] = nz
      }
      return b
    }
    //Check edge cases
    min_step = +(EPSILON * (1.0 + t))
    if(t > min_step) {
      ex = nx < 0 ? fx <= min_step : fx >= 1.0 - min_step
      ey = ny < 0 ? fy <= min_step : fy >= 1.0 - min_step
      ez = nz < 0 ? fz <= min_step : fz >= 1.0 - min_step
      if(ex && ey && ez) {
        b = voxels.getBlock(ix+nx, iy+ny, iz) ||
            voxels.getBlock(ix, iy+ny, iz+nz) ||
            voxels.getBlock(ix+nx, iy, iz+nz)
        if(b) {
          if(hit_pos) {
            hit_pos[0] = nx < 0 ? ix-EPSILON : ix + 1.0-EPSILON
            hit_pos[1] = ny < 0 ? iy-EPSILON : iy + 1.0-EPSILON
            hit_pos[2] = nz < 0 ? iz-EPSILON : iz + 1.0-EPSILON
          }
          if(hit_norm) {
            hit_norm[0] = nx
            hit_norm[1] = ny
            hit_norm[2] = nz
          }
          return b
        }
      }
      if(ex && (ey || ez)) {
        b = voxels.getBlock(ix+nx, iy, iz)
        if(b) {
          if(hit_pos) {
            hit_pos[0] = nx < 0 ? ix-EPSILON : ix + 1.0-EPSILON
            hit_pos[1] = fy < EPSILON ? +iy : oy
            hit_pos[2] = fz < EPSILON ? +iz : oz
          }
          if(hit_norm) {
            hit_norm[0] = nx
            hit_norm[1] = ny
            hit_norm[2] = nz
          }
          return b
        }
      }
      if(ey && (ex || ez)) {
        b = voxels.getBlock(ix, iy+ny, iz)
        if(b) {
          if(hit_pos) {
            hit_pos[0] = fx < EPSILON ? +ix : ox
            hit_pos[1] = ny < 0 ? iy-EPSILON : iy + 1.0-EPSILON
            hit_pos[2] = fz < EPSILON ? +iz : oz
          }
          if(hit_norm) {
            hit_norm[0] = nx
            hit_norm[1] = ny
            hit_norm[2] = nz
          }
          return b
        }
      }
      if(ez && (ex || ey)) {
        b = voxels.getBlock(ix, iy, iz+nz)
        if(b) {
          if(hit_pos) {
            hit_pos[0] = fx < EPSILON ? +ix : ox
            hit_pos[1] = fy < EPSILON ? +iy : oy
            hit_pos[2] = nz < 0 ? iz-EPSILON : iz + 1.0-EPSILON
          }
          if(hit_norm) {
            hit_norm[0] = nx
            hit_norm[1] = ny
            hit_norm[2] = nz
          }
          return b
        }
      }
    }
    //Walk to next face of cube along ray
    nx = ny = nz = 0
    step = 2.0
    if(dx < -EPSILON) {
      var s = -fx/dx
      nx = 1
      step = s
    }
    if(dx > EPSILON) {
      var s = (1.0-fx)/dx
      nx = -1
      step = s
    }
    if(dy < -EPSILON) {
      var s = -fy/dy
      if(s < step-min_step) {
        nx = 0
        ny = 1
        step = s
      } else if(s < step+min_step) {
        ny = 1
      }
    }
    if(dy > EPSILON) {
      var s = (1.0-fy)/dy
      if(s < step-min_step) {
        nx = 0
        ny = -1
        step = s
      } else if(s < step+min_step) {
        ny = -1
      }
    }
    if(dz < -EPSILON) {
      var s = -fz/dz
      if(s < step-min_step) {
        nx = ny = 0
        nz = 1
        step = s
      } else if(s < step+min_step) {
        nz = 1
      }
    }
    if(dz > EPSILON) {
      var s = (1.0-fz)/dz
      if(s < step-min_step) {
        nx = ny = 0
        nz = -1
        step = s
      } else if(s < step+min_step) {
        nz = -1
      }
    }
    if(step > max_d - t) {
      step = max_d - t - min_step
    }
    if(step < min_step) {
      step = min_step
    }
    t += step
  }
  if(hit_pos) {
    hit_pos[0] = ox;
    hit_pos[1] = oy;
    hit_pos[2] = oz;
  }
  if(hit_norm) {
    hit_norm[0] = hit_norm[1] = hit_norm[2] = 0;
  }
  return 0
}

function traceRay(voxels, origin, direction, max_d, hit_pos, hit_norm, EPSILON) {
  var px = +origin[0]
    , py = +origin[1]
    , pz = +origin[2]
    , dx = +direction[0]
    , dy = +direction[1]
    , dz = +direction[2]
    , ds = Math.sqrt(dx*dx + dy*dy + dz*dz)
  if(typeof(EPSILON) === "undefined") {
    EPSILON = 1e-8
  }
  if(ds < EPSILON) {
    if(hit_pos) {
      hit_pos[0] = hit_pos[1] = hit_pos[2]
    }
    if(hit_norm) {
      hit_norm[0] = hit_norm[1] = hit_norm[2]
    }
    return 0;
  }
  dx /= ds
  dy /= ds
  dz /= ds
  if(typeof(max_d) === "undefined") {
    max_d = 64.0
  } else {
    max_d = +max_d
  }
  return traceRay_impl(voxels, px, py, pz, dx, dy, dz, max_d, hit_pos, hit_norm, EPSILON)
}

module.exports = traceRay
},{}],64:[function(require,module,exports){
module.exports = coordinates

var aabb = require('aabb-3d')
var events = require('events')

function coordinates(spatial, box, regionWidth) {
  var emitter = new events.EventEmitter()
  var lastRegion = [NaN, NaN, NaN]
  var thisRegion

  if (arguments.length === 2) {
    regionWidth = box
    box = aabb([-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity])
  }

  spatial.on('position', box, updateRegion)
  
  function updateRegion(pos) {
    thisRegion = [Math.floor(pos[0] / regionWidth), Math.floor(pos[1] / regionWidth), Math.floor(pos[2] / regionWidth)]
    if (thisRegion[0] !== lastRegion[0] || thisRegion[1] !== lastRegion[1] || thisRegion[2] !== lastRegion[2]) {
      emitter.emit('change', thisRegion)
    }
    lastRegion = thisRegion
  }
 
  return emitter
}
},{"aabb-3d":36,"events":6}],65:[function(require,module,exports){
var tic = require('tic')();
var createAtlas = require('atlaspack');

function Texture(opts) {
  if (!(this instanceof Texture)) return new Texture(opts || {});
  var self = this;
  this.game = opts.game; delete opts.game;
  this.THREE = this.game.THREE;
  this.materials = [];
  this.texturePath = opts.texturePath || '/textures/';
  this.loading = 0;

  var useFlatColors = opts.materialFlatColor === true;
  delete opts.materialFlatColor;

  this.options = defaults(opts || {}, {
    crossOrigin: 'Anonymous',
    materialParams: defaults(opts.materialParams || {}, {
      ambient: 0xbbbbbb
    }),
    materialType: this.THREE.MeshLambertMaterial,
    applyTextureParams: function(map) {
      map.magFilter = self.THREE.NearestFilter;
      map.minFilter = self.THREE.LinearMipMapLinearFilter;
    }
  });

  // create a canvas for the texture atlas
  this.canvas = (typeof document !== 'undefined') ? document.createElement('canvas') : {};
  this.canvas.width = opts.atlasWidth || 512;
  this.canvas.height = opts.atlasHeight || 512;

  // create core atlas and texture
  this.atlas = createAtlas(this.canvas);
  this.atlas.tilepad = true;
  this._atlasuv = false;
  this._atlaskey = false;
  this.texture = new this.THREE.Texture(this.canvas);
  this.options.applyTextureParams(this.texture);

  if (useFlatColors) {
    // If were using simple colors
    this.material = new this.THREE.MeshBasicMaterial({
      vertexColors: this.THREE.VertexColors
    });
  } else {
    // load a first material for easy application to meshes
    this.material = new this.options.materialType(this.options.materialParams);
    this.material.map = this.texture;
    this.material.transparent = true;
  }

  // a place for meshes to wait while textures are loading
  this._meshQueue = [];
}
module.exports = Texture;

Texture.prototype.load = function(names, done) {
  var self = this;
  if (!Array.isArray(names)) names = [names];
  done = done || function() {};
  this.loading++;

  var materialSlice = names.map(self._expandName);
  self.materials = self.materials.concat(materialSlice);

  // load onto the texture atlas
  var load = Object.create(null);
  materialSlice.forEach(function(mats) {
    mats.forEach(function(mat) {
      if (mat.slice(0, 1) === '#') return;
      // todo: check if texture already exists
      load[mat] = true;
    });
  });
  if (Object.keys(load).length > 0) {
    each(Object.keys(load), self.pack.bind(self), function() {
      self._afterLoading();
      done(materialSlice);
    });
  } else {
    self._afterLoading();
  }
};

Texture.prototype.pack = function(name, done) {
  var self = this;
  function pack(img) {
    var node = self.atlas.pack(img);
    if (node === false) {
      self.atlas = self.atlas.expand(img);
      self.atlas.tilepad = true;
    }
    done();
  }
  if (typeof name === 'string') {
    var img = new Image();
    img.id = name;
    img.crossOrigin = self.options.crossOrigin;
    img.src = self.texturePath + ext(name);
    img.onload = function() {
      pack(img);
    };
    img.onerror = function() {
      console.error('Couldn\'t load URL [' + img.src + ']');
      done();
    };
  } else {
    pack(name);
  }
  return self;
};

Texture.prototype.find = function(name) {
  var self = this;
  var type = 0;
  self.materials.forEach(function(mats, i) {
    mats.forEach(function(mat) {
      if (mat === name) {
        type = i + 1;
        return false;
      }
    });
    if (type !== 0) return false;
  });
  return type;
};

Texture.prototype._expandName = function(name) {
  if (name === null) return Array(6);
  if (name.top) return [name.back, name.front, name.top, name.bottom, name.left, name.right];
  if (!Array.isArray(name)) name = [name];
  // load the 0 texture to all
  if (name.length === 1) name = [name[0],name[0],name[0],name[0],name[0],name[0]];
  // 0 is top/bottom, 1 is sides
  if (name.length === 2) name = [name[1],name[1],name[0],name[0],name[1],name[1]];
  // 0 is top, 1 is bottom, 2 is sides
  if (name.length === 3) name = [name[2],name[2],name[0],name[1],name[2],name[2]];
  // 0 is top, 1 is bottom, 2 is front/back, 3 is left/right
  if (name.length === 4) name = [name[2],name[2],name[0],name[1],name[3],name[3]];
  return name;
};

Texture.prototype._afterLoading = function() {
  var self = this;
  function alldone() {
    self.loading--;
    self._atlasuv = self.atlas.uv(self.canvas.width, self.canvas.height);
    self._atlaskey = Object.create(null);
    self.atlas.index().forEach(function(key) {
      self._atlaskey[key.name] = key;
    });
    self.texture.needsUpdate = true;
    self.material.needsUpdate = true;
    //window.open(self.canvas.toDataURL());
    if (self._meshQueue.length > 0) {
      self._meshQueue.forEach(function(queue, i) {
        self.paint.apply(queue.self, queue.args);
        delete self._meshQueue[i];
      });
    }
  }
  self._powerof2(function() {
    setTimeout(alldone, 100);
  });
};

// Ensure the texture stays at a power of 2 for mipmaps
// this is cheating :D
Texture.prototype._powerof2 = function(done) {
  var w = this.canvas.width;
  var h = this.canvas.height;
  function pow2(x) {
    x--;
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x++;
    return x;
  }
  if (h > w) w = h;
  var old = this.canvas.getContext('2d').getImageData(0, 0, this.canvas.width, this.canvas.height);
  this.canvas.width = this.canvas.height = pow2(w);
  this.canvas.getContext('2d').putImageData(old, 0, 0);
  done();
};

Texture.prototype.paint = function(mesh, materials) {
  var self = this;

  // if were loading put into queue
  if (self.loading > 0) {
    self._meshQueue.push({self: self, args: arguments});
    return false;
  }

  var isVoxelMesh = (materials) ? false : true;
  if (!isVoxelMesh) materials = self._expandName(materials);

  mesh.geometry.faces.forEach(function(face, i) {
    if (mesh.geometry.faceVertexUvs[0].length < 1) return;

    if (isVoxelMesh) {
      var index = Math.floor(face.color.b*255 + face.color.g*255*255 + face.color.r*255*255*255);
      materials = self.materials[index - 1];
      if (!materials) materials = self.materials[0];
    }

    // BACK, FRONT, TOP, BOTTOM, LEFT, RIGHT
    var name = materials[0] || '';
    if      (face.normal.z === 1)  name = materials[1] || '';
    else if (face.normal.y === 1)  name = materials[2] || '';
    else if (face.normal.y === -1) name = materials[3] || '';
    else if (face.normal.x === -1) name = materials[4] || '';
    else if (face.normal.x === 1)  name = materials[5] || '';

    // if just a simple color
    if (name.slice(0, 1) === '#') {
      self.setColor(mesh.geometry.faces[i], name);
      return;
    }

    var atlasuv = self._atlasuv[name];
    if (!atlasuv) return;

    // 0 -- 1
    // |    |
    // 3 -- 2
    // faces on these meshes are flipped vertically, so we map in reverse
    // TODO: tops need rotate
    if (isVoxelMesh) {
      if (face.normal.z === -1 || face.normal.x === 1) {
        atlasuv = uvrot(atlasuv, 90);
      }
      atlasuv = uvinvert(atlasuv);
    } else {
      atlasuv = uvrot(atlasuv, -90);
    }
    for (var j = 0; j < 4; j++) {
      mesh.geometry.faceVertexUvs[0][i][j].set(atlasuv[j][0], 1 - atlasuv[j][1]);
    }
  });

  mesh.geometry.uvsNeedUpdate = true;
};

Texture.prototype.sprite = function(name, w, h, cb) {
  var self = this;
  if (typeof w === 'function') { cb = w; w = null; }
  if (typeof h === 'function') { cb = h; h = null; }
  w = w || 16; h = h || w;
  self.loading++;
  var img = new Image();
  img.src = self.texturePath + ext(name);
  img.onerror = cb;
  img.onload = function() {
    var canvases = [];
    for (var x = 0; x < img.width; x += w) {
      for (var y = 0; y < img.height; y += h) {
        var canvas = document.createElement('canvas');
        canvas.width = w; canvas.height = h;
        canvas.name = name + '_' + x + '_' + y;
        canvas.getContext('2d').drawImage(img, x, y, w, h, 0, 0, w, h);
        canvases.push(canvas);
      }
    }
    var textures = [];
    each(canvases, function(canvas, next) {
      var tex = new Image();
      tex.name = canvas.name;
      tex.src = canvas.toDataURL();
      tex.onload = function() {
        self.pack(tex, next);
      };
      tex.onerror = next;
      textures.push([
        tex.name, tex.name, tex.name,
        tex.name, tex.name, tex.name
      ]);
    }, function() {
      self._afterLoading();
      delete canvases;
      self.materials = self.materials.concat(textures);
      cb(textures);
    });
  };
  return self;
};

Texture.prototype.animate = function(mesh, names, delay) {
  var self = this;
  delay = delay || 1000;
  if (!Array.isArray(names) || names.length < 2) return false;
  var i = 0;
  var mat = new this.options.materialType(this.options.materialParams);
  mat.map = this.texture;
  mat.transparent = true;
  mat.needsUpdate = true;
  tic.interval(function() {
    self.paint(mesh, names[i % names.length]);
    i++;
  }, delay);
  return mat;
};

Texture.prototype.tick = function(dt) {
  tic.tick(dt);
};

Texture.prototype.setColor = function(face, color) {
  var rgb = hex2rgb(color);
  face.color.setRGB(rgb[0], rgb[1], rgb[2]);
  var ld = this._lightDark(color);

  // TODO: AO should be figured better than this
  if (face.normal.y === 1)       face.vertexColors = [ld[0], ld[0], ld[0], ld[0]];
  else if (face.normal.y === -1) face.vertexColors = [ld[1], ld[1], ld[1], ld[1]];
  else if (face.normal.x === 1)  face.vertexColors = [ld[1], ld[0], ld[0], ld[1]];
  else if (face.normal.x === -1) face.vertexColors = [ld[1], ld[1], ld[0], ld[0]];
  else if (face.normal.z === 1)  face.vertexColors = [ld[1], ld[1], ld[0], ld[0]];
  else                           face.vertexColors = [ld[1], ld[0], ld[0], ld[1]];
};

Texture.prototype._lightDark = memoize(function(color) {
  var light = new this.THREE.Color(color);
  var hsl = light.getHSL();
  var dark = light.clone();
  dark.setHSL(hsl.h, hsl.s, hsl.l - 0.1);
  return [light, dark];
});

function uvrot(coords, deg) {
  if (deg === 0) return coords;
  var c = [];
  var i = (4 - Math.ceil(deg / 90)) % 4;
  for (var j = 0; j < 4; j++) {
    c.push(coords[i]);
    if (i === 3) i = 0; else i++;
  }
  return c;
}

function uvinvert(coords) {
  var c = coords.slice(0);
  return [c[3], c[2], c[1], c[0]];
}

function ext(name) {
  return (String(name).indexOf('.') !== -1) ? name : name + '.png';
}

function defaults(obj) {
  [].slice.call(arguments, 1).forEach(function(from) {
    if (from) for (var k in from) if (obj[k] == null) obj[k] = from[k];
  });
  return obj;
}

function each(arr, it, done) {
  var count = 0;
  arr.forEach(function(a) {
    it(a, function() {
      count++;
      if (count >= arr.length) done();
    });
  });
}

function hex2rgb(hex) {
  if (hex[0] === '#') hex = hex.substr(1);
  return [parseInt(hex.substr(0,2), 16)/255, parseInt(hex.substr(2,2), 16)/255, parseInt(hex.substr(4,2), 16)/255];
}

function memoize(func) {
  function memoized() {
    var cache = memoized.cache, key = arguments[0];
    return hasOwnProperty.call(cache, key)
      ? cache[key]
      : (cache[key] = func.apply(this, arguments));
  }
  memoized.cache = {};
  return memoized;
}

},{"atlaspack":66,"tic":59}],66:[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.atlaspack=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/*
 * atlaspack
 * https://github.com/shama/atlaspack
 *
 * Copyright (c) 2014 Kyle Robinson Young
 * Licensed under the MIT license.
 *
 * Based on Nick Welch's binpack: https://github.com/mackstann/binpack
 */

function Rect(x, y, w, h) {
  this.x = x; this.y = y;
  this.w = w; this.h = h;
}

Rect.prototype.fitsIn = function(outer) {
  return outer.w >= this.w && outer.h >= this.h;
};

Rect.prototype.sameSizeAs = function(other) {
  return this.w === other.w && this.h === other.h;
};

function Atlas(x, y, w, h) {
  if (arguments.length === 1) {
    this.canvas = x;
    x = y = 0;
    w = this.canvas.width;
    h = this.canvas.height;
  }
  if (arguments.length === 2) {
    w = x; h = y; x = y = 0;
  }
  this.left = this.right = null;
  this.rect = new Rect(x, y, w, h);
  this.filled = false;
  this.tilepad = false;
  this._cache = [];
  this._uvcache = Object.create(null);
}
module.exports = function() {
  if (arguments.length === 1) { return new Atlas(arguments[0]); }
  if (arguments.length === 2) { return new Atlas(arguments[0], arguments[1]); }
  return new Atlas(arguments[0], arguments[1], arguments[2], arguments[3]);
};
module.exports.Atlas = Atlas;
module.exports.Rect = Rect;

// pack image/rect to the atlas
Atlas.prototype.pack = function(rect) {
  this._cache = [];
  this._uvcache = Object.create(null);
  rect = this._toRect(rect);

  if (this.img && this.tilepad) {
    rect = this._tilepad(rect);
  }

  if (this.left !== null) {
    return this._ontoCanvas(this.left.pack(rect) || this.right.pack(rect));
  }
  // if atlas filled or wont fit
  if (this.filled || !rect.fitsIn(this.rect)) {
    return false;
  }
  // if this atlas has been filled
  if (rect.sameSizeAs(this.rect)) {
    this.filled = true;
    return this._ontoCanvas(this);
  }
  if ((this.rect.w - rect.w) > (this.rect.h - rect.h)) {
    this.left = new Atlas(this.rect.x, this.rect.y, rect.w, this.rect.h);
    this.right = new Atlas(this.rect.x + rect.w, this.rect.y, this.rect.w - rect.w, this.rect.h);
  } else {
    this.left = new Atlas(this.rect.x, this.rect.y, this.rect.w, rect.h);
    this.right = new Atlas(this.rect.x, this.rect.y + rect.h, this.rect.w, this.rect.h - rect.h);
  }
  return this._ontoCanvas(this.left.pack(rect));
};

Atlas.prototype.expand = function(rect) {
  var self = this;
  rect = this._toRect(rect);

  if (this.img && this.tilepad) {
    rect = this._tilepad(rect);
  }

  var atlas;
  if (this.rect.w < this.rect.h) {
    atlas = new Atlas(0, 0, this.rect.w + rect.w, this.rect.h);
    atlas.right = new Atlas(this.rect.w, 0, rect.w, this.rect.h);
    atlas.left = this;
  } else {
    atlas = new Atlas(0, 0, this.rect.w, this.rect.h + rect.h);
    atlas.right = new Atlas(0, this.rect.h, this.rect.w, rect.h);
    atlas.left = this;
  }

  ['canvas', 'context', 'img'].forEach(function(p) {
    if (self[p]) {
      atlas[p] = self[p];
      self[p] = null;
    }
  });

  // resize canvas
  if (atlas.canvas) {
    if (!atlas.context) {
      atlas.context = atlas.canvas.getContext('2d');
    }
    var old = atlas.context.getImageData(0, 0, atlas.canvas.width, atlas.canvas.height);
    atlas.canvas.width = atlas.rect.w;
    atlas.canvas.height = atlas.rect.h;
    atlas.context.putImageData(old, 0, 0);
  }

  return (atlas.pack(rect) === false) ? atlas.expand(rect) : atlas;
};

Atlas.prototype.index = function() {
  var self = this;
  if (self._cache.length > 0) {
    return self._cache;
  }
  (function loop(atlas) {
    if (atlas.left !== null) {
      loop(atlas.left);
      loop(atlas.right);
    } else if (atlas.rect.name) {
      self._cache.push(atlas.rect);
    }
  }(self));
  return self._cache;
};

Atlas.prototype.uv = function(w, h) {
  var self = this;
  w = w || self.rect.w;
  h = h || self.rect.h;
  var isPad = this.tilepad;
  (function loop(atlas) {
    if (atlas.left !== null) {
      loop(atlas.left);
      loop(atlas.right);
    } else if (typeof atlas.rect.name !== 'undefined') {
      var p = (isPad) ? atlas.rect.w / 4 : 0;
      self._uvcache[atlas.rect.name] = [
        [atlas.rect.x + p, atlas.rect.y + p],
        [(atlas.rect.x + p) + (atlas.rect.w - (p * 2)), atlas.rect.y + p],
        [(atlas.rect.x + p) + (atlas.rect.w - (p * 2)), (atlas.rect.y + p) + (atlas.rect.h - (p * 2))],
        [(atlas.rect.x + p), (atlas.rect.y + p) + (atlas.rect.h - (p * 2))],
      ].map(function(uv) {
        if (uv[0] !== 0) {
          uv[0] = uv[0] / w;
        }
        if (uv[1] !== 0) {
          uv[1] = uv[1] / h;
        }
        return uv;
      });
    }
  }(self));
  return self._uvcache;
};

Atlas.prototype.json = function(input) {
  var self = this;
  if (input) {
    if (typeof input === 'string') input = JSON.parse(input);
    return (function loop(obj) {
      if (!obj || !obj.rect) return;
      var atlas = new Atlas(obj.rect.x, obj.rect.y, obj.rect.w, obj.rect.h);
      if (obj.left) atlas.left = loop(obj.left);
      if (obj.right) atlas.right = loop(obj.right);
      return atlas;
    }(input));
  } else {
    return JSON.stringify(function loop(atlas) {
      var obj = {
        left: null, right: null,
        rect: atlas.rect, filled: atlas.filled
      };
      if (atlas.left !== null) {
        obj.left = loop(atlas.left);
        obj.right = loop(atlas.right);
      }
      return obj;
    }(self), null, 2);
  }
};

// Pads the image by tiling itself around itself
Atlas.prototype._tilepad = function(rect) {
  var img = this.img;
  if (!img) return rect;

  var p = img.width / 2;

  var canvas = document.createElement('canvas');
  canvas.name = img.name || img.src;
  canvas.id = img.id || '';
  canvas.width = img.width + img.width;
  canvas.height = img.height + img.height;
  var ctx = canvas.getContext('2d');

  var pattern = ctx.createPattern(img, 'repeat');
  ctx.fillStyle = pattern;
  ctx.translate(p, p);
  ctx.fillRect(-p, -p, canvas.width + p, canvas.height + p);
  ctx.translate(-p, -p);

  this.img = canvas;

  return new Rect(rect.x, rect.y, this.img.width, this.img.height);
};

// if has an image and canvas, draw to the canvas as we go
Atlas.prototype._ontoCanvas = function(node) {
  if (node && this.img && this.canvas) {
    if (!this.context) {
      this.context = this.canvas.getContext('2d');
    }
    this.context.clearRect(node.rect.x, node.rect.y, node.rect.w, node.rect.h);
    this.context.drawImage(this.img, node.rect.x, node.rect.y, node.rect.w, node.rect.h);
    node.rect.name = this.img.id || this.img.name || this.img.src || null;
  }
  return node;
};

// make sure we're always working with rects
Atlas.prototype._toRect = function(rect) {
  // if rect is an image
  if (rect.nodeName && rect.nodeName === 'IMG') {
    this.img = rect;
    rect = new Rect(rect.x, rect.y, rect.width, rect.height);
  }
  // if rect is an object
  if (!(rect instanceof Rect)) {
    rect = new Rect(rect.x || 0, rect.y || 0, rect.w || rect.width, rect.h || rect.height);
  }
  return rect;
};

Atlas.prototype._debug = function() {
  if (!this.canvas) { return; }
  var context = this.canvas.getContext('2d');
  this.index().forEach(function(rect) {
    context.lineWidth = 1;
    context.strokeStyle = 'red';
    context.strokeRect(rect.x, rect.y, rect.w, rect.h);
  });
};

},{}]},{},[1])
(1)
});;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],67:[function(require,module,exports){
(function (process){
var THREE, temporaryPosition, temporaryVector

module.exports = function(three, opts) {
  temporaryPosition = new three.Vector3
  temporaryVector = new three.Vector3
  
  return new View(three, opts)
}

function View(three, opts) {
  THREE = three // three.js doesn't support multiple instances on a single page
  this.fov = opts.fov || 60
  this.width = opts.width || 512
  this.height = opts.height || 512
  this.aspectRatio = opts.aspectRatio || this.width/this.height
  this.nearPlane = opts.nearPlane || 1
  this.farPlane = opts.farPlane || 10000
  this.skyColor = opts.skyColor || 0xBFD1E5
  this.ortho = opts.ortho
  this.camera = this.ortho?(new THREE.OrthographicCamera(this.width/-2, this.width/2, this.height/2, this.height/-2, this.nearPlane, this.farPlane)):(new THREE.PerspectiveCamera(this.fov, this.aspectRatio, this.nearPlane, this.farPlane))
  this.camera.lookAt(new THREE.Vector3(0, 0, 0))

  if (!process.browser) return

  this.createRenderer()
  this.element = this.renderer.domElement
}

View.prototype.createRenderer = function() {
  this.renderer = new THREE.WebGLRenderer({
    antialias: true
  })
  this.renderer.setSize(this.width, this.height)
  this.renderer.setClearColorHex(this.skyColor, 1.0)
  this.renderer.clear()
}

View.prototype.bindToScene = function(scene) {
  scene.add(this.camera)
}

View.prototype.getCamera = function() {
  return this.camera
}

View.prototype.cameraPosition = function() {
  temporaryPosition.multiplyScalar(0)
  temporaryPosition.applyMatrix4(this.camera.matrixWorld)
  return [temporaryPosition.x, temporaryPosition.y, temporaryPosition.z]
}

View.prototype.cameraVector = function() {
  temporaryVector.multiplyScalar(0)
  temporaryVector.z = -1
  this.camera.matrixWorld.rotateAxis(temporaryVector)
  return [temporaryVector.x, temporaryVector.y, temporaryVector.z]
}

View.prototype.resizeWindow = function(width, height) {
  if (this.element.parentElement) {
    width = width || this.element.parentElement.clientWidth
    height = height || this.element.parentElement.clientHeight
  }

  this.camera.aspect = this.aspectRatio = width/height
  this.width = width
  this.height = height

  this.camera.updateProjectionMatrix()

  this.renderer.setSize( width, height )
}

View.prototype.render = function(scene) {
  this.renderer.render(scene, this.camera)
}

View.prototype.appendTo = function(element) {
  if (typeof element === 'object') {
    element.appendChild(this.element)
  }
  else {
    document.querySelector(element).appendChild(this.element)
  }

  this.resizeWindow(this.width,this.height)
}
}).call(this,require('_process'))

},{"_process":10}],68:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26,"events":6,"ever":69,"vkey":72}],69:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"./init.json":70,"./types.json":71,"dup":27,"events":6}],70:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],71:[function(require,module,exports){
arguments[4][29][0].apply(exports,arguments)
},{"dup":29}],72:[function(require,module,exports){
arguments[4][30][0].apply(exports,arguments)
},{"dup":30}],73:[function(require,module,exports){
var inherits = require('inherits')
var events = require('events')
var _ = require('underscore')

module.exports = Highlighter

function Highlighter(game, opts) {
  if (!(this instanceof Highlighter)) return new Highlighter(game, opts)
  this.game = game
  opts = opts || {}
  var geometry = this.geometry = opts.geometry || new game.THREE.CubeGeometry(1, 1, 1)
  var material = opts.material || new game.THREE.MeshBasicMaterial({
    color: opts.color || 0x000000,
    wireframe: true,
    wireframeLinewidth: opts.wireframeLinewidth || 3,
    transparent: true,
    opacity: opts.wireframeOpacity || 0.5
  })
  this.mesh = new game.THREE.Mesh(geometry, material)
  this.distance = opts.distance || 10
  this.currVoxelPos // undefined when no voxel selected for highlight
  this.currVoxelAdj // undefined when no adjacent voxel selected for highlight
  this.targetPosition // desired position of highlight cube center
  
  // the adjacent highlight will be active when the following returns true
  this.adjacentActive = opts.adjacentActive || function () { return game.controls.state.alt }
  
  // the selection highlight will be active when the following returns true
  this.selectActive = opts.selectActive || function () { return game.controls.state.select }
  
  // animate highlight transitions?
  this.animate = opts.animate
  this.animateFunction = opts.animateFunction || function (position, targetPosition, deltaTime) {
    if (!position || !targetPosition || !deltaTime) return;
    var rate = 10
    if (Math.abs(targetPosition[0] - position[0]) < 0.05
     && Math.abs(targetPosition[1] - position[1]) < 0.05
     && Math.abs(targetPosition[2] - position[2]) < 0.05) {
      return targetPosition // close enough to snap and be done
    }
    deltaTime = deltaTime / 1000 // usually around .016 seconds (60 FPS)
    position[0] += rate * deltaTime * (targetPosition[0] - position[0])
    position[1] += rate * deltaTime * (targetPosition[1] - position[1])
    position[2] += rate * deltaTime * (targetPosition[2] - position[2])
    return position
  }

  // highlight 'easing' animation, called every tick if enabled
  var self = this
  if (this.animate) game.on('tick', function (dt) {
    var position = [self.mesh.position.x, self.mesh.position.y, self.mesh.position.z]
    position = self.animateFunction(position, self.targetPosition, dt)
    if (position) self.mesh.position.set(position[0], position[1], position[2])
  })

  game.on('tick', _.throttle(this.highlight.bind(this), opts.frequency || 100))
  
  // anchors for multi-voxel selection
  this.selectStart
  this.selectEnd
}

inherits(Highlighter, events.EventEmitter)

Highlighter.prototype.highlight = function () {

  var cp = this.game.cameraPosition()
  var cv = this.game.cameraVector()
  var hit = this.game.raycastVoxels(cp, cv, this.distance)
  var targetPositionCandidate

  var removeAdjacent = function (self) { // remove adjacent highlight if any
    if (!self.currVoxelAdj) return;
    self.emit('remove-adjacent', self.currVoxelAdj)
    self.currVoxelAdj = undefined
  }

  // remove existing highlight if any
  if (!hit) {
    if (!this.currVoxelPos) return; // already removed
    this.game.scene.remove(this.mesh)
    this.emit('remove', this.currVoxelPos.slice())
    this.currVoxelPos = undefined
    removeAdjacent(this)
    return;
  }

  var newVoxelPos = hit.voxel
  if (!this.currVoxelPos
    || newVoxelPos[0] !== this.currVoxelPos[0]
    || newVoxelPos[1] !== this.currVoxelPos[1]
    || newVoxelPos[2] !== this.currVoxelPos[2]) { // no current highlight or it moved

    if (this.currVoxelPos) {
      this.emit('remove', this.currVoxelPos.slice()) // moved highlight
    }
    else {
      this.game.scene.add(this.mesh) // fresh highlight
    }
    this.emit('highlight', newVoxelPos.slice())
    this.currVoxelPos = newVoxelPos.slice()
  }
  // try to set the position every time, it may be overridden below
  targetPositionCandidate = [this.currVoxelPos[0] + 0.5, this.currVoxelPos[1] + 0.5, this.currVoxelPos[2] + 0.5]

  // if in "adjacent" mode, highlight adjacent voxel instead
  if (this.adjacentActive()) {
    // since we got here, we know we have a selected non-empty voxel
    // and with an empty adjacent voxel that we can work with
    var newVoxelAdj = hit.adjacent
    if (!this.currVoxelAdj
      || newVoxelAdj[0] !== this.currVoxelAdj[0]
      || newVoxelAdj[1] !== this.currVoxelAdj[1]
      || newVoxelAdj[2] !== this.currVoxelAdj[2]) { // no current adj highlight or it has moved
  
      if (this.currVoxelAdj) {
        this.emit('remove-adjacent', this.currVoxelAdj.slice()) // moved adjacent highlight
      }
      this.emit('highlight-adjacent', newVoxelAdj.slice())
      
      this.currVoxelAdj = newVoxelAdj.slice()
    }
    targetPositionCandidate = [this.currVoxelAdj[0] + 0.5, this.currVoxelAdj[1] + 0.5, this.currVoxelAdj[2] + 0.5]
  }
  else removeAdjacent(this)

  // if in "select" mode, track start and end voxel bounds
  if (this.selectActive()) {
    if (!this.selectStart) { // start a new selection
      this.selectStart = this.selectEnd = this.currVoxelAdj || this.currVoxelPos
    }
    else {
      var endCandidate = this.currVoxelAdj || this.currVoxelPos
      if (endCandidate[0] !== this.selectEnd[0]
       || endCandidate[1] !== this.selectEnd[1]
       || endCandidate[2] !== this.selectEnd[2]) { 
         
        this.selectEnd = endCandidate // selection end has changed
        
        this.emit('highlight-select', { start: this.selectStart.slice(), end: this.selectEnd.slice() })
        
        var scale = []
        scale[0] = Math.abs(this.selectEnd[0] - this.selectStart[0]) + 1
        scale[1] = Math.abs(this.selectEnd[1] - this.selectStart[1]) + 1
        scale[2] = Math.abs(this.selectEnd[2] - this.selectStart[2]) + 1
        this.mesh.scale.set(scale[0], scale[1], scale[2])
        
        var pos = []
        pos[0] = this.selectStart[0] + 0.5 + (this.selectEnd[0] - this.selectStart[0]) / 2
        pos[1] = this.selectStart[1] + 0.5 + (this.selectEnd[1] - this.selectStart[1]) / 2
        pos[2] = this.selectStart[2] + 0.5 + (this.selectEnd[2] - this.selectStart[2]) / 2
        this.targetPosition = pos
      }
    }
  }
  else {
    if (this.selectStart) {
      this.emit('highlight-deselect', { start: this.selectStart.slice(), end: this.selectEnd.slice() })
      this.selectStart = null
      this.mesh.scale.set(1, 1, 1)
    }
    this.targetPosition = targetPositionCandidate // highlighted voxel or adjacent
  }
  if (!this.animate) this.mesh.position.set(this.targetPosition[0], this.targetPosition[1], this.targetPosition[2])
}

},{"events":6,"inherits":74,"underscore":75}],74:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],75:[function(require,module,exports){
//     Underscore.js 1.4.4
//     http://underscorejs.org
//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.4.4';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs, first) {
    if (_.isEmpty(attrs)) return first ? null : [];
    return _[first ? 'find' : 'filter'](obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.where(obj, attrs, true);
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity, value: -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity, value: Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value || _.identity);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function() {
      return func.apply(context, args.concat(slice.call(arguments)));
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context.
  _.partial = function(func) {
    var args = slice.call(arguments, 1);
    return function() {
      return func.apply(this, args.concat(slice.call(arguments)));
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] == null) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(n);
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

},{}],76:[function(require,module,exports){
var skin = require('minecraft-skin');

module.exports = function (game) {
    var mountPoint;
    var possessed;
    
    return function (img, skinOpts) {
        if (!skinOpts) {
          skinOpts = {};
        }
        skinOpts.scale = skinOpts.scale || new game.THREE.Vector3(0.04, 0.04, 0.04);
        var playerSkin = skin(game.THREE, img, skinOpts);
        var player = playerSkin.mesh;
        var physics = game.makePhysical(player);
        physics.playerSkin = playerSkin;
        
        player.position.set(0, 562, -20);
        game.scene.add(player);
        game.addItem(physics);
        
        physics.yaw = player;
        physics.pitch = player.head;
        physics.subjectTo(game.gravity);
        physics.blocksCreation = true;
        
        game.control(physics);
        
        physics.move = function (x, y, z) {
            var xyz = parseXYZ(x, y, z);
            physics.yaw.position.x += xyz.x;
            physics.yaw.position.y += xyz.y;
            physics.yaw.position.z += xyz.z;
        };
        
        physics.moveTo = function (x, y, z) {
            var xyz = parseXYZ(x, y, z);
            physics.yaw.position.x = xyz.x;
            physics.yaw.position.y = xyz.y;
            physics.yaw.position.z = xyz.z;
        };
        
        var pov = 1;
        physics.pov = function (type) {
            if (type === 'first' || type === 1) {
                pov = 1;
            }
            else if (type === 'third' || type === 3) {
                pov = 3;
            }
            physics.possess();
        };
        
        physics.toggle = function () {
            physics.pov(pov === 1 ? 3 : 1);
        };
        
        physics.possess = function () {
            if (possessed) possessed.remove(game.camera);
            var key = pov === 1 ? 'cameraInside' : 'cameraOutside';
            player[key].add(game.camera);
            possessed = player[key];
        };
        
        physics.position = physics.yaw.position;
        
        return physics;
    }
};

function parseXYZ (x, y, z) {
    if (typeof x === 'object' && Array.isArray(x)) {
        return { x: x[0], y: x[1], z: x[2] };
    }
    else if (typeof x === 'object') {
        return { x: x.x || 0, y: x.y || 0, z: x.z || 0 };
    }
    return { x: Number(x), y: Number(y), z: Number(z) };
}

},{"minecraft-skin":77}],77:[function(require,module,exports){
var THREE

module.exports = function(three, image, sizeRatio) {
  return new Skin(three, image, sizeRatio)
}

function Skin(three, image, opts) {
  if (opts) opts.image = opts.image || image
  else opts = { image: image }
  if (typeof image === 'object' && !(image instanceof HTMLElement)) opts = image
  THREE = three // hack until three.js fixes multiple instantiation
  this.sizeRatio = opts.sizeRatio || 8
  this.scale = opts.scale || new three.Vector3(1, 1, 1)
  this.fallbackImage = opts.fallbackImage || 'skin.png'
  this.createCanvases()
  this.charMaterial = this.getMaterial(this.skin, false)
	this.charMaterialTrans = this.getMaterial(this.skin, true)
  if (typeof opts.image === "string") this.fetchImage(opts.image)
  if (opts.image instanceof HTMLElement) this.setImage(opts.image)
  this.mesh = this.createPlayerObject()
}

Skin.prototype.createCanvases = function() {
  this.skinBig = document.createElement('canvas')
  this.skinBigContext = this.skinBig.getContext('2d')
  this.skinBig.width = 64 * this.sizeRatio
  this.skinBig.height = 32 * this.sizeRatio
  
  this.skin = document.createElement('canvas')
  this.skinContext = this.skin.getContext('2d')
  this.skin.width = 64
  this.skin.height = 32
}

Skin.prototype.fetchImage = function(imageURL) {
  var self = this
  this.image = new Image()
  this.image.crossOrigin = 'anonymous'
  this.image.src = imageURL
  this.image.onload = function() {
    self.setImage(self.image)
  }
}

Skin.prototype.setImage = function (skin) {
  this.image = skin
  this.skinContext.clearRect(0, 0, 64, 32);
  
  this.skinContext.drawImage(skin, 0, 0);
  
  var imgdata = this.skinContext.getImageData(0, 0, 64, 32);
  var pixels = imgdata.data;

  this.skinBigContext.clearRect(0, 0, this.skinBig.width, this.skinBig.height);
  this.skinBigContext.save();
  
  var isOnecolor = true;
  
  var colorCheckAgainst = [40, 0];
  var colorIndex = (colorCheckAgainst[0]+colorCheckAgainst[1]*64)*4;
  
  var isPixelDifferent = function (x, y) {
    if(pixels[(x+y*64)*4+0] !== pixels[colorIndex+0] || pixels[(x+y*64)*4+1] !== pixels[colorIndex+1] || pixels[(x+y*64)*4+2] !== pixels[colorIndex+2] || pixels[(x+y*64)*4+3] !== pixels[colorIndex+3]) {
      return true;
    }
    return false;
  };
  
  // Check if helmet/hat is a solid color
  // Bottom row
  for(var i=32; i < 64; i+=1) {
    for(var j=8; j < 16; j+=1) {
      if(isPixelDifferent(i, j)) {
        isOnecolor = false;
        break;
      }
    }
    if(!isOnecolor) {
      break;
    }
  }
  if(!isOnecolor) {
    // Top row
    for(var i=40; i < 56; i+=1) {
      for(var j=0; j < 8; j+=1) {
        if(isPixelDifferent(i, j)) {
          isOnecolor = false;
          break;
        }
      }
      if(!isOnecolor) {
        break;
      }
      
    }
  }
  
  for(var i=0; i < 64; i+=1) {
    for(var j=0; j < 32; j+=1) {
      if(isOnecolor && ((i >= 32 && i < 64 && j >= 8 && j < 16) || (i >= 40 && i < 56 && j >= 0 && j < 8))) {
        pixels[(i+j*64)*4+3] = 0
      }
      this.skinBigContext.fillStyle = 'rgba('+pixels[(i+j*64)*4+0]+', '+pixels[(i+j*64)*4+1]+', '+pixels[(i+j*64)*4+2]+', '+pixels[(i+j*64)*4+3]/255+')';
      this.skinBigContext.fillRect(i * this.sizeRatio, j * this.sizeRatio, this.sizeRatio, this.sizeRatio);
    }
  }
  
  this.skinBigContext.restore();
  
  this.skinContext.putImageData(imgdata, 0, 0);
  
  this.charMaterial.map.needsUpdate = true;
  this.charMaterialTrans.map.needsUpdate = true;
  
};

Skin.prototype.getMaterial = function(img, transparent) {
  var texture    = new THREE.Texture(img);
  texture.magFilter  = THREE.NearestFilter;
  texture.minFilter  = THREE.NearestFilter;
  texture.format    = transparent ? THREE.RGBAFormat : THREE.RGBFormat;
  texture.needsUpdate  = true;
  var material  = new THREE.MeshBasicMaterial({
    map    : texture,
    transparent  : transparent ? true : false
  });
  return material;
}

Skin.prototype.UVMap = function(mesh, face, x, y, w, h, rotateBy) {
  if (!rotateBy) rotateBy = 0;
  var uvs = mesh.geometry.faceVertexUvs[0][face];
  var tileU = x;
  var tileV = y;
  var tileUvWidth = 1/64;
  var tileUvHeight = 1/32;
  uvs[ (0 + rotateBy) % 4 ].x = (tileU * tileUvWidth)
  uvs[ (0 + rotateBy) % 4 ].y = 1 - (tileV * tileUvHeight)
  uvs[ (1 + rotateBy) % 4 ].x = (tileU * tileUvWidth)
  uvs[ (1 + rotateBy) % 4 ].y = 1 - (tileV * tileUvHeight + h * tileUvHeight)
  uvs[ (2 + rotateBy) % 4 ].x = (tileU * tileUvWidth + w * tileUvWidth)
  uvs[ (2 + rotateBy) % 4 ].y = 1 - (tileV * tileUvHeight + h * tileUvHeight)
  uvs[ (3 + rotateBy) % 4 ].x = (tileU * tileUvWidth + w * tileUvWidth)
  uvs[ (3 + rotateBy) % 4 ].y = 1 - (tileV * tileUvHeight)
}

Skin.prototype.cubeFromPlanes = function (size, mat) {
  var cube = new THREE.Object3D();
  var meshes = [];
  for(var i=0; i < 6; i++) {
    var mesh = new THREE.Mesh(new THREE.PlaneGeometry(size, size), mat);
    mesh.doubleSided = true;
    cube.add(mesh);
    meshes.push(mesh);
  }
  // Front
  meshes[0].rotation.x = Math.PI/2;
  meshes[0].rotation.z = -Math.PI/2;
  meshes[0].position.x = size/2;
  
  // Back
  meshes[1].rotation.x = Math.PI/2;
  meshes[1].rotation.z = Math.PI/2;
  meshes[1].position.x = -size/2;
  
  // Top
  meshes[2].position.y = size/2;
  
  // Bottom
  meshes[3].rotation.y = Math.PI;
  meshes[3].rotation.z = Math.PI;
  meshes[3].position.y = -size/2;
  
  // Left
  meshes[4].rotation.x = Math.PI/2;
  meshes[4].position.z = size/2;
  
  // Right
  meshes[5].rotation.x = -Math.PI/2;
  meshes[5].rotation.y = Math.PI;
  meshes[5].position.z = -size/2;
  
  return cube;
}

//exporting these meshes for manipulation:
//leftLeg
//rightLeg
//leftArm
//rightArm
//body
//head

Skin.prototype.createPlayerObject = function(scene) {
  var headgroup = new THREE.Object3D();
  var upperbody = this.upperbody = new THREE.Object3D();
  
  // Left leg
  var leftleggeo = new THREE.CubeGeometry(4, 12, 4);
  for(var i=0; i < 8; i+=1) {
    leftleggeo.vertices[i].y -= 6;
  }
  var leftleg = this.leftLeg = new THREE.Mesh(leftleggeo, this.charMaterial);
  leftleg.position.z = -2;
  leftleg.position.y = -6;
  this.UVMap(leftleg, 0, 8, 20, -4, 12);
  this.UVMap(leftleg, 1, 16, 20, -4, 12);
  this.UVMap(leftleg, 2, 4, 16, 4, 4, 3);
  this.UVMap(leftleg, 3, 8, 20, 4, -4, 1);
  this.UVMap(leftleg, 4, 12, 20, -4, 12);
  this.UVMap(leftleg, 5, 4, 20, -4, 12);

  // Right leg
  var rightleggeo = new THREE.CubeGeometry(4, 12, 4);
  for(var i=0; i < 8; i+=1) {
    rightleggeo.vertices[i].y -= 6;
  }
  var rightleg = this.rightLeg =new THREE.Mesh(rightleggeo, this.charMaterial);
  rightleg.position.z = 2;
  rightleg.position.y = -6;
  this.UVMap(rightleg, 0, 4, 20, 4, 12);
  this.UVMap(rightleg, 1, 12, 20, 4, 12);
  this.UVMap(rightleg, 2, 8, 16, -4, 4, 3);
  this.UVMap(rightleg, 3, 12, 20, -4, -4, 1);
  this.UVMap(rightleg, 4, 0, 20, 4, 12);
  this.UVMap(rightleg, 5, 8, 20, 4, 12);
  
  // Body
  var bodygeo = new THREE.CubeGeometry(4, 12, 8);
  var bodymesh = this.body = new THREE.Mesh(bodygeo, this.charMaterial);
  this.UVMap(bodymesh, 0, 20, 20, 8, 12);
  this.UVMap(bodymesh, 1, 32, 20, 8, 12);
  this.UVMap(bodymesh, 2, 20, 16, 8, 4, 1);
  this.UVMap(bodymesh, 3, 28, 16, 8, 4, 3);
  this.UVMap(bodymesh, 4, 16, 20, 4, 12);
  this.UVMap(bodymesh, 5, 28, 20, 4, 12);
  upperbody.add(bodymesh);
  
  
  // Left arm
  var leftarmgeo = new THREE.CubeGeometry(4, 12, 4);
  for(var i=0; i < 8; i+=1) {
    leftarmgeo.vertices[i].y -= 4;
  }
  var leftarm = this.leftArm = new THREE.Mesh(leftarmgeo, this.charMaterial);
  leftarm.position.z = -6;
  leftarm.position.y = 4;
  leftarm.rotation.x = Math.PI/32;
  this.UVMap(leftarm, 0, 48, 20, -4, 12);
  this.UVMap(leftarm, 1, 56, 20, -4, 12);
  this.UVMap(leftarm, 2, 48, 16, -4, 4, 1);
  this.UVMap(leftarm, 3, 52, 16, -4, 4, 3);
  this.UVMap(leftarm, 4, 52, 20, -4, 12);
  this.UVMap(leftarm, 5, 44, 20, -4, 12);
  upperbody.add(leftarm);
  
  // Right arm
  var rightarmgeo = new THREE.CubeGeometry(4, 12, 4);
  for(var i=0; i < 8; i+=1) {
    rightarmgeo.vertices[i].y -= 4;
  }
  var rightarm =this.rightArm = new THREE.Mesh(rightarmgeo, this.charMaterial);
  rightarm.position.z = 6;
  rightarm.position.y = 4;
  rightarm.rotation.x = -Math.PI/32;
  this.UVMap(rightarm, 0, 44, 20, 4, 12);
  this.UVMap(rightarm, 1, 52, 20, 4, 12);
  this.UVMap(rightarm, 2, 44, 16, 4, 4, 1);
  this.UVMap(rightarm, 3, 48, 16, 4, 4, 3);
  this.UVMap(rightarm, 4, 40, 20, 4, 12);
  this.UVMap(rightarm, 5, 48, 20, 4, 12);
  upperbody.add(rightarm);
  
  //Head
  var headgeo = new THREE.CubeGeometry(8, 8, 8);
  var headmesh = this.head = new THREE.Mesh(headgeo, this.charMaterial);
  headmesh.position.y = 2;
  this.UVMap(headmesh, 0, 8, 8, 8, 8);
  this.UVMap(headmesh, 1, 24, 8, 8, 8);
  
  this.UVMap(headmesh, 2, 8, 0, 8, 8, 1);
  this.UVMap(headmesh, 3, 16, 0, 8, 8, 3);
  
  this.UVMap(headmesh, 4, 0, 8, 8, 8);
  this.UVMap(headmesh, 5, 16, 8, 8, 8);

  var unrotatedHeadMesh = new THREE.Object3D();
  unrotatedHeadMesh.rotation.y = Math.PI / 2;
  unrotatedHeadMesh.add(headmesh);

  headgroup.add(unrotatedHeadMesh);

  var helmet = this.cubeFromPlanes(9, this.charMaterialTrans);
  helmet.position.y = 2;
  this.UVMap(helmet.children[0], 0, 32+8, 8, 8, 8);
  this.UVMap(helmet.children[1], 0, 32+24, 8, 8, 8);
  this.UVMap(helmet.children[2], 0, 32+8, 0, 8, 8, 1);
  this.UVMap(helmet.children[3], 0, 32+16, 0, 8, 8, 3);
  this.UVMap(helmet.children[4], 0, 32+0, 8, 8, 8);
  this.UVMap(helmet.children[5], 0, 32+16, 8, 8, 8);
  
  headgroup.add(helmet);
  
  var ears = new THREE.Object3D();
  
  var eargeo = new THREE.CubeGeometry(1, (9/8)*6, (9/8)*6);
  var leftear = new THREE.Mesh(eargeo, this.charMaterial);
  var rightear = new THREE.Mesh(eargeo, this.charMaterial);
  
  leftear.position.y = 2+(9/8)*5;
  rightear.position.y = 2+(9/8)*5;
  leftear.position.z = -(9/8)*5;
  rightear.position.z = (9/8)*5;
  
  // Right ear share same geometry, same uv-maps
  
  this.UVMap(leftear, 0, 25, 1, 6, 6); // Front side
  this.UVMap(leftear, 1, 32, 1, 6, 6); // Back side
  
  this.UVMap(leftear, 2, 25, 0, 6, 1, 1); // Top edge
  this.UVMap(leftear, 3, 31, 0, 6, 1, 1); // Bottom edge
  
  this.UVMap(leftear, 4, 24, 1, 1, 6); // Left edge
  this.UVMap(leftear, 5, 31, 1, 1, 6); // Right edge
  
  ears.add(leftear);
  ears.add(rightear);
  
  leftear.visible = rightear.visible = false;
  
  headgroup.add(ears);
  headgroup.position.y = 8;
  
  var playerModel = this.playerModel = new THREE.Object3D();
  
  playerModel.add(leftleg);
  playerModel.add(rightleg);
  
  playerModel.add(upperbody);
  
  var playerRotation = new THREE.Object3D();
  playerRotation.rotation.y = Math.PI / 2
  playerRotation.position.y = 12
  playerRotation.add(playerModel)

  var rotatedHead = new THREE.Object3D();
  rotatedHead.rotation.y = -Math.PI/2;
  rotatedHead.add(headgroup);

  playerModel.add(rotatedHead);
  playerModel.position.y = 6;
  
  var playerGroup = new THREE.Object3D();
  playerGroup.cameraInside = new THREE.Object3D()
  playerGroup.cameraOutside = new THREE.Object3D()

  playerGroup.cameraInside.position.x = 0;
  playerGroup.cameraInside.position.y = 2;
  playerGroup.cameraInside.position.z = 0; 

  playerGroup.head = headgroup
  headgroup.add(playerGroup.cameraInside)
  playerGroup.cameraInside.add(playerGroup.cameraOutside)

  playerGroup.cameraOutside.position.z = 100

  
  playerGroup.add(playerRotation);
  playerGroup.scale = this.scale
  return playerGroup
}
},{}],78:[function(require,module,exports){
var walkSpeed = 1.0
var startedWalking = 0.0
var stoppedWalking = 0.0
var walking = false
var acceleration = 1.0

exports.render = function(skin){
  var time = Date.now() / 1000
  if (walking && time < startedWalking + acceleration){
    walkSpeed = (time - startedWalking) / acceleration
  }
  if (!walking && time < stoppedWalking + acceleration){
    walkSpeed = -1 / acceleration * (time - stoppedWalking) + 1
  }

  skin.head.rotation.y = Math.sin(time * 1.5) / 3 * walkSpeed
  skin.head.rotation.z = Math.sin(time) / 2 * walkSpeed
  
  skin.rightArm.rotation.z = 2 * Math.cos(0.6662 * time * 10 + Math.PI) * walkSpeed
  skin.rightArm.rotation.x = 1 * (Math.cos(0.2812 * time * 10) - 1) * walkSpeed
  skin.leftArm.rotation.z = 2 * Math.cos(0.6662 * time * 10) * walkSpeed
  skin.leftArm.rotation.x = 1 * (Math.cos(0.2312 * time * 10) + 1) * walkSpeed
  
  skin.rightLeg.rotation.z = 1.4 * Math.cos(0.6662 * time * 10) * walkSpeed
  skin.leftLeg.rotation.z = 1.4 * Math.cos(0.6662 * time * 10 + Math.PI) * walkSpeed
}

exports.startWalking = function(){
  var now = Date.now() / 1000
  walking = true
  if (stoppedWalking + acceleration>now){
    var progress = now - stoppedWalking;
    startedWalking = now - (stoppedWalking + acceleration - now)
  } else {
    startedWalking = Date.now() / 1000
  }
}
exports.stopWalking = function() {
  var now = Date.now() / 1000
  walking = false
  if (startedWalking + acceleration > now){
    stoppedWalking = now - (startedWalking + acceleration - now)
  } else {
    stoppedWalking = Date.now() / 1000
  }
}
exports.isWalking = function(){
  return walking
}

exports.setAcceleration = function(newA){
  acceleration = newA
}
},{}],79:[function(require,module,exports){
var events = require('events')
var inherits = require('inherits')

module.exports = function(opts) {
  return new Chunker(opts)
}

module.exports.Chunker = Chunker

function Chunker(opts) {
  this.distance = opts.chunkDistance || 2
  this.chunkSize = opts.chunkSize || 32
  this.cubeSize = opts.cubeSize || 25
  this.generateVoxelChunk = opts.generateVoxelChunk
  this.chunks = {}
  this.meshes = {}

  if (this.chunkSize & this.chunkSize-1 !== 0)
    throw new Error('chunkSize must be a power of 2')
  var bits = 0;
  for (var size = this.chunkSize; size > 0; size >>= 1) bits++;
  this.chunkBits = bits - 1;
}

inherits(Chunker, events.EventEmitter)

Chunker.prototype.nearbyChunks = function(position, distance) {
  var current = this.chunkAtPosition(position)
  var x = current[0]
  var y = current[1]
  var z = current[2]
  var dist = distance || this.distance
  var nearby = []
  for (var cx = (x - dist); cx !== (x + dist); ++cx) {
    for (var cy = (y - dist); cy !== (y + dist); ++cy) {
      for (var cz = (z - dist); cz !== (z + dist); ++cz) {
        nearby.push([cx, cy, cz])
      }
    }
  }
  return nearby
}

Chunker.prototype.requestMissingChunks = function(position) {
  var self = this
  this.nearbyChunks(position).map(function(chunk) {
    if (!self.chunks[chunk.join('|')]) {
      self.emit('missingChunk', chunk)
    }
  })
}

Chunker.prototype.getBounds = function(x, y, z) {
  var bits = this.chunkBits
  var low = [x << bits, y << bits, z << bits]
  var high = [(x+1) << bits, (y+1) << bits, (z+1) << bits]
  return [low, high]
}

Chunker.prototype.generateChunk = function(x, y, z) {
  var self = this
  var bounds = this.getBounds(x, y, z)
  var chunk = this.generateVoxelChunk(bounds[0], bounds[1], x, y, z)
  var position = [x, y, z]
  chunk.position = position
  this.chunks[position.join('|')] = chunk
  return chunk
}

Chunker.prototype.chunkAtCoordinates = function(x, y, z) {
  var bits = this.chunkBits;
  var cx = x >> bits;
  var cy = y >> bits;
  var cz = z >> bits;
  var chunkPos = [cx, cy, cz];
  return chunkPos;
}

Chunker.prototype.chunkAtPosition = function(position) {
  var cubeSize = this.cubeSize;
  var x = Math.floor(position[0] / cubeSize)
  var y = Math.floor(position[1] / cubeSize)
  var z = Math.floor(position[2] / cubeSize)
  var chunkPos = this.chunkAtCoordinates(x, y, z)
  return chunkPos
};

Chunker.prototype.voxelIndexFromCoordinates = function(x, y, z) {
  var bits = this.chunkBits
  var mask = (1 << bits) - 1
  var vidx = (x & mask) + ((y & mask) << bits) + ((z & mask) << bits * 2)
  return vidx
}

Chunker.prototype.voxelIndexFromPosition = function(pos) {
  var v = this.voxelVector(pos)
  return this.voxelIndex(v)
}

Chunker.prototype.voxelAtCoordinates = function(x, y, z, val) {
  var ckey = this.chunkAtCoordinates(x, y, z).join('|')
  var chunk = this.chunks[ckey]
  if (!chunk) return false
  var vidx = this.voxelIndexFromCoordinates(x, y, z)
  var v = chunk.voxels[vidx]
  if (typeof val !== 'undefined') {
    chunk.voxels[vidx] = val
  }
  return v
}

Chunker.prototype.voxelAtPosition = function(pos, val) {
  var cubeSize = this.cubeSize;
  var x = Math.floor(pos[0] / cubeSize)
  var y = Math.floor(pos[1] / cubeSize)
  var z = Math.floor(pos[2] / cubeSize)
  var v = this.voxelAtCoordinates(x, y, z, val)
  return v;
}

// deprecated
Chunker.prototype.voxelIndex = function(voxelVector) {
  var vidx = this.voxelIndexFromCoordinates(voxelVector[0], voxelVector[1], voxelVector[2])
  return vidx
}

// deprecated
Chunker.prototype.voxelVector = function(pos) {
  var cubeSize = this.cubeSize
  var mask = (1 << this.chunkBits) - 1
  var vx = (Math.floor(pos[0] / cubeSize)) & mask
  var vy = (Math.floor(pos[1] / cubeSize)) & mask
  var vz = (Math.floor(pos[2] / cubeSize)) & mask
  return [vx, vy, vz]
};

},{"events":6,"inherits":85}],80:[function(require,module,exports){
var chunker = require('./chunker')

module.exports = function(opts) {
  if (!opts.generateVoxelChunk) opts.generateVoxelChunk = function(low, high) {
    return generate(low, high, module.exports.generator['Valley'])
  }
  return chunker(opts)
}

module.exports.meshers = {
  culled: require('./meshers/culled').mesher,
  greedy: require('./meshers/greedy').mesher,
  monotone: require('./meshers/monotone').mesher,
  stupid: require('./meshers/stupid').mesher
}

module.exports.Chunker = chunker.Chunker
module.exports.geometry = {}
module.exports.generator = {}
module.exports.generate = generate

// from https://github.com/mikolalysenko/mikolalysenko.github.com/blob/master/MinecraftMeshes2/js/testdata.js#L4
function generate(l, h, f, game) {
  var d = [ h[0]-l[0], h[1]-l[1], h[2]-l[2] ]
  var v = new Int8Array(d[0]*d[1]*d[2])
  var n = 0
  for(var k=l[2]; k<h[2]; ++k)
  for(var j=l[1]; j<h[1]; ++j)
  for(var i=l[0]; i<h[0]; ++i, ++n) {
    v[n] = f(i,j,k,n,game)
  }
  return {voxels:v, dims:d}
}

// shape and terrain generator functions
module.exports.generator['Sphere'] = function(i,j,k) {
  return i*i+j*j+k*k <= 16*16 ? 1 : 0
}

module.exports.generator['Noise'] = function(i,j,k) {
  return Math.random() < 0.1 ? Math.random() * 0xffffff : 0;
}

module.exports.generator['Dense Noise'] = function(i,j,k) {
  return Math.round(Math.random() * 0xffffff);
}

module.exports.generator['Checker'] = function(i,j,k) {
  return !!((i+j+k)&1) ? (((i^j^k)&2) ? 1 : 0xffffff) : 0;
}

module.exports.generator['Hill'] = function(i,j,k) {
  return j <= 16 * Math.exp(-(i*i + k*k) / 64) ? 1 : 0;
}

module.exports.generator['Valley'] = function(i,j,k) {
  return j <= (i*i + k*k) * 31 / (32*32*2) + 1 ? 1 : 0;
}

module.exports.generator['Hilly Terrain'] = function(i,j,k) {
  var h0 = 3.0 * Math.sin(Math.PI * i / 12.0 - Math.PI * k * 0.1) + 27;    
  if(j > h0+1) {
    return 0;
  }
  if(h0 <= j) {
    return 1;
  }
  var h1 = 2.0 * Math.sin(Math.PI * i * 0.25 - Math.PI * k * 0.3) + 20;
  if(h1 <= j) {
    return 2;
  }
  if(2 < j) {
    return Math.random() < 0.1 ? 0x222222 : 0xaaaaaa;
  }
  return 3;
}

module.exports.scale = function ( x, fromLow, fromHigh, toLow, toHigh ) {
  return ( x - fromLow ) * ( toHigh - toLow ) / ( fromHigh - fromLow ) + toLow
}

// convenience function that uses the above functions to prebake some simple voxel geometries
module.exports.generateExamples = function() {
  return {
    'Sphere': generate([-16,-16,-16], [16,16,16], module.exports.generator['Sphere']),
    'Noise': generate([0,0,0], [16,16,16], module.exports.generator['Noise']),
    'Dense Noise': generate([0,0,0], [16,16,16], module.exports.generator['Dense Noise']),
    'Checker': generate([0,0,0], [8,8,8], module.exports.generator['Checker']),
    'Hill': generate([-16, 0, -16], [16,16,16], module.exports.generator['Hill']),
    'Valley': generate([0,0,0], [32,32,32], module.exports.generator['Valley']),
    'Hilly Terrain': generate([0, 0, 0], [32,32,32], module.exports.generator['Hilly Terrain'])
  }
}


},{"./chunker":79,"./meshers/culled":81,"./meshers/greedy":82,"./meshers/monotone":83,"./meshers/stupid":84}],81:[function(require,module,exports){
//Naive meshing (with face culling)
function CulledMesh(volume, dims) {
  //Precalculate direction vectors for convenience
  var dir = new Array(3);
  for(var i=0; i<3; ++i) {
    dir[i] = [[0,0,0], [0,0,0]];
    dir[i][0][(i+1)%3] = 1;
    dir[i][1][(i+2)%3] = 1;
  }
  //March over the volume
  var vertices = []
    , faces = []
    , x = [0,0,0]
    , B = [[false,true]    //Incrementally update bounds (this is a bit ugly)
          ,[false,true]
          ,[false,true]]
    , n = -dims[0]*dims[1];
  for(           B[2]=[false,true],x[2]=-1; x[2]<dims[2]; B[2]=[true,(++x[2]<dims[2]-1)])
  for(n-=dims[0],B[1]=[false,true],x[1]=-1; x[1]<dims[1]; B[1]=[true,(++x[1]<dims[1]-1)])
  for(n-=1,      B[0]=[false,true],x[0]=-1; x[0]<dims[0]; B[0]=[true,(++x[0]<dims[0]-1)], ++n) {
    //Read current voxel and 3 neighboring voxels using bounds check results
    var p =   (B[0][0] && B[1][0] && B[2][0]) ? volume[n]                 : 0
      , b = [ (B[0][1] && B[1][0] && B[2][0]) ? volume[n+1]               : 0
            , (B[0][0] && B[1][1] && B[2][0]) ? volume[n+dims[0]]         : 0
            , (B[0][0] && B[1][0] && B[2][1]) ? volume[n+dims[0]*dims[1]] : 0
          ];
    //Generate faces
    for(var d=0; d<3; ++d)
    if((!!p) !== (!!b[d])) {
      var s = !p ? 1 : 0;
      var t = [x[0],x[1],x[2]]
        , u = dir[d][s]
        , v = dir[d][s^1];
      ++t[d];
      
      var vertex_count = vertices.length;
      vertices.push([t[0],           t[1],           t[2]          ]);
      vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);
      vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);
      vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);
      faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, s ? b[d] : p]);
    }
  }
  return { vertices:vertices, faces:faces };
}


if(exports) {
  exports.mesher = CulledMesh;
}

},{}],82:[function(require,module,exports){
var GreedyMesh = (function() {
//Cache buffer internally
var mask = new Int32Array(4096);

return function(volume, dims) {
  var vertices = [], faces = []
    , dimsX = dims[0]
    , dimsY = dims[1]
    , dimsXY = dimsX * dimsY;

  //Sweep over 3-axes
  for(var d=0; d<3; ++d) {
    var i, j, k, l, w, W, h, n, c
      , u = (d+1)%3
      , v = (d+2)%3
      , x = [0,0,0]
      , q = [0,0,0]
      , du = [0,0,0]
      , dv = [0,0,0]
      , dimsD = dims[d]
      , dimsU = dims[u]
      , dimsV = dims[v]
      , qdimsX, qdimsXY
      , xd

    if (mask.length < dimsU * dimsV) {
      mask = new Int32Array(dimsU * dimsV);
    }

    q[d] =  1;
    x[d] = -1;

    qdimsX  = dimsX  * q[1]
    qdimsXY = dimsXY * q[2]

    // Compute mask
    while (x[d] < dimsD) {
      xd = x[d]
      n = 0;

      for(x[v] = 0; x[v] < dimsV; ++x[v]) {
        for(x[u] = 0; x[u] < dimsU; ++x[u], ++n) {
          var a = xd >= 0      && volume[x[0]      + dimsX * x[1]          + dimsXY * x[2]          ]
            , b = xd < dimsD-1 && volume[x[0]+q[0] + dimsX * x[1] + qdimsX + dimsXY * x[2] + qdimsXY]
          if (a ? b : !b) {
            mask[n] = 0; continue;
          }
          mask[n] = a ? a : -b;
        }
      }

      ++x[d];

      // Generate mesh for mask using lexicographic ordering
      n = 0;
      for (j=0; j < dimsV; ++j) {
        for (i=0; i < dimsU; ) {
          c = mask[n];
          if (!c) {
            i++;  n++; continue;
          }

          //Compute width
          w = 1;
          while (c === mask[n+w] && i+w < dimsU) w++;

          //Compute height (this is slightly awkward)
          for (h=1; j+h < dimsV; ++h) {
            k = 0;
            while (k < w && c === mask[n+k+h*dimsU]) k++
            if (k < w) break;
          }

          // Add quad
          // The du/dv arrays are reused/reset
          // for each iteration.
          du[d] = 0; dv[d] = 0;
          x[u]  = i;  x[v] = j;

          if (c > 0) {
            dv[v] = h; dv[u] = 0;
            du[u] = w; du[v] = 0;
          } else {
            c = -c;
            du[v] = h; du[u] = 0;
            dv[u] = w; dv[v] = 0;
          }
          var vertex_count = vertices.length;
          vertices.push([x[0],             x[1],             x[2]            ]);
          vertices.push([x[0]+du[0],       x[1]+du[1],       x[2]+du[2]      ]);
          vertices.push([x[0]+du[0]+dv[0], x[1]+du[1]+dv[1], x[2]+du[2]+dv[2]]);
          vertices.push([x[0]      +dv[0], x[1]      +dv[1], x[2]      +dv[2]]);
          faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, c]);

          //Zero-out mask
          W = n + w;
          for(l=0; l<h; ++l) {
            for(k=n; k<W; ++k) {
              mask[k+l*dimsU] = 0;
            }
          }

          //Increment counters and continue
          i += w; n += w;
        }
      }
    }
  }
  return { vertices:vertices, faces:faces };
}
})();

if(exports) {
  exports.mesher = GreedyMesh;
}

},{}],83:[function(require,module,exports){
"use strict";

var MonotoneMesh = (function(){

function MonotonePolygon(c, v, ul, ur) {
  this.color  = c;
  this.left   = [[ul, v]];
  this.right  = [[ur, v]];
};

MonotonePolygon.prototype.close_off = function(v) {
  this.left.push([ this.left[this.left.length-1][0], v ]);
  this.right.push([ this.right[this.right.length-1][0], v ]);
};

MonotonePolygon.prototype.merge_run = function(v, u_l, u_r) {
  var l = this.left[this.left.length-1][0]
    , r = this.right[this.right.length-1][0]; 
  if(l !== u_l) {
    this.left.push([ l, v ]);
    this.left.push([ u_l, v ]);
  }
  if(r !== u_r) {
    this.right.push([ r, v ]);
    this.right.push([ u_r, v ]);
  }
};


return function(volume, dims) {
  function f(i,j,k) {
    return volume[i + dims[0] * (j + dims[1] * k)];
  }
  //Sweep over 3-axes
  var vertices = [], faces = [];
  for(var d=0; d<3; ++d) {
    var i, j, k
      , u = (d+1)%3   //u and v are orthogonal directions to d
      , v = (d+2)%3
      , x = new Int32Array(3)
      , q = new Int32Array(3)
      , runs = new Int32Array(2 * (dims[u]+1))
      , frontier = new Int32Array(dims[u])  //Frontier is list of pointers to polygons
      , next_frontier = new Int32Array(dims[u])
      , left_index = new Int32Array(2 * dims[v])
      , right_index = new Int32Array(2 * dims[v])
      , stack = new Int32Array(24 * dims[v])
      , delta = [[0,0], [0,0]];
    //q points along d-direction
    q[d] = 1;
    //Initialize sentinel
    for(x[d]=-1; x[d]<dims[d]; ) {
      // --- Perform monotone polygon subdivision ---
      var n = 0
        , polygons = []
        , nf = 0;
      for(x[v]=0; x[v]<dims[v]; ++x[v]) {
        //Make one pass over the u-scan line of the volume to run-length encode polygon
        var nr = 0, p = 0, c = 0;
        for(x[u]=0; x[u]<dims[u]; ++x[u], p = c) {
          //Compute the type for this face
          var a = (0    <= x[d]      ? f(x[0],      x[1],      x[2])      : 0)
            , b = (x[d] <  dims[d]-1 ? f(x[0]+q[0], x[1]+q[1], x[2]+q[2]) : 0);
          c = a;
          if((!a) === (!b)) {
            c = 0;
          } else if(!a) {
            c = -b;
          }
          //If cell type doesn't match, start a new run
          if(p !== c) {
            runs[nr++] = x[u];
            runs[nr++] = c;
          }
        }
        //Add sentinel run
        runs[nr++] = dims[u];
        runs[nr++] = 0;
        //Update frontier by merging runs
        var fp = 0;
        for(var i=0, j=0; i<nf && j<nr-2; ) {
          var p    = polygons[frontier[i]]
            , p_l  = p.left[p.left.length-1][0]
            , p_r  = p.right[p.right.length-1][0]
            , p_c  = p.color
            , r_l  = runs[j]    //Start of run
            , r_r  = runs[j+2]  //End of run
            , r_c  = runs[j+1]; //Color of run
          //Check if we can merge run with polygon
          if(r_r > p_l && p_r > r_l && r_c === p_c) {
            //Merge run
            p.merge_run(x[v], r_l, r_r);
            //Insert polygon into frontier
            next_frontier[fp++] = frontier[i];
            ++i;
            j += 2;
          } else {
            //Check if we need to advance the run pointer
            if(r_r <= p_r) {
              if(!!r_c) {
                var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);
                next_frontier[fp++] = polygons.length;
                polygons.push(n_poly);
              }
              j += 2;
            }
            //Check if we need to advance the frontier pointer
            if(p_r <= r_r) {
              p.close_off(x[v]);
              ++i;
            }
          }
        }
        //Close off any residual polygons
        for(; i<nf; ++i) {
          polygons[frontier[i]].close_off(x[v]);
        }
        //Add any extra runs to frontier
        for(; j<nr-2; j+=2) {
          var r_l  = runs[j]
            , r_r  = runs[j+2]
            , r_c  = runs[j+1];
          if(!!r_c) {
            var n_poly = new MonotonePolygon(r_c, x[v], r_l, r_r);
            next_frontier[fp++] = polygons.length;
            polygons.push(n_poly);
          }
        }
        //Swap frontiers
        var tmp = next_frontier;
        next_frontier = frontier;
        frontier = tmp;
        nf = fp;
      }
      //Close off frontier
      for(var i=0; i<nf; ++i) {
        var p = polygons[frontier[i]];
        p.close_off(dims[v]);
      }
      // --- Monotone subdivision of polygon is complete at this point ---
      
      x[d]++;
      
      //Now we just need to triangulate each monotone polygon
      for(var i=0; i<polygons.length; ++i) {
        var p = polygons[i]
          , c = p.color
          , flipped = false;
        if(c < 0) {
          flipped = true;
          c = -c;
        }
        for(var j=0; j<p.left.length; ++j) {
          left_index[j] = vertices.length;
          var y = [0.0,0.0,0.0]
            , z = p.left[j];
          y[d] = x[d];
          y[u] = z[0];
          y[v] = z[1];
          vertices.push(y);
        }
        for(var j=0; j<p.right.length; ++j) {
          right_index[j] = vertices.length;
          var y = [0.0,0.0,0.0]
            , z = p.right[j];
          y[d] = x[d];
          y[u] = z[0];
          y[v] = z[1];
          vertices.push(y);
        }
        //Triangulate the monotone polygon
        var bottom = 0
          , top = 0
          , l_i = 1
          , r_i = 1
          , side = true;  //true = right, false = left
        
        stack[top++] = left_index[0];
        stack[top++] = p.left[0][0];
        stack[top++] = p.left[0][1];
        
        stack[top++] = right_index[0];
        stack[top++] = p.right[0][0];
        stack[top++] = p.right[0][1];
        
        while(l_i < p.left.length || r_i < p.right.length) {
          //Compute next side
          var n_side = false;
          if(l_i === p.left.length) {
            n_side = true;
          } else if(r_i !== p.right.length) {
            var l = p.left[l_i]
              , r = p.right[r_i];
            n_side = l[1] > r[1];
          }
          var idx = n_side ? right_index[r_i] : left_index[l_i]
            , vert = n_side ? p.right[r_i] : p.left[l_i];
          if(n_side !== side) {
            //Opposite side
            while(bottom+3 < top) {
              if(flipped === n_side) {
                faces.push([ stack[bottom], stack[bottom+3], idx, c]);
              } else {
                faces.push([ stack[bottom+3], stack[bottom], idx, c]);              
              }
              bottom += 3;
            }
          } else {
            //Same side
            while(bottom+3 < top) {
              //Compute convexity
              for(var j=0; j<2; ++j)
              for(var k=0; k<2; ++k) {
                delta[j][k] = stack[top-3*(j+1)+k+1] - vert[k];
              }
              var det = delta[0][0] * delta[1][1] - delta[1][0] * delta[0][1];
              if(n_side === (det > 0)) {
                break;
              }
              if(det !== 0) {
                if(flipped === n_side) {
                  faces.push([ stack[top-3], stack[top-6], idx, c ]);
                } else {
                  faces.push([ stack[top-6], stack[top-3], idx, c ]);
                }
              }
              top -= 3;
            }
          }
          //Push vertex
          stack[top++] = idx;
          stack[top++] = vert[0];
          stack[top++] = vert[1];
          //Update loop index
          if(n_side) {
            ++r_i;
          } else {
            ++l_i;
          }
          side = n_side;
        }
      }
    }
  }
  return { vertices:vertices, faces:faces };
}
})();

if(exports) {
  exports.mesher = MonotoneMesh;
}

},{}],84:[function(require,module,exports){
//The stupidest possible way to generate a Minecraft mesh (I think)
function StupidMesh(volume, dims) {
  var vertices = [], faces = [], x = [0,0,0], n = 0;
  for(x[2]=0; x[2]<dims[2]; ++x[2])
  for(x[1]=0; x[1]<dims[1]; ++x[1])
  for(x[0]=0; x[0]<dims[0]; ++x[0], ++n)
  if(!!volume[n]) {
    for(var d=0; d<3; ++d) {
      var t = [x[0], x[1], x[2]]
        , u = [0,0,0]
        , v = [0,0,0];
      u[(d+1)%3] = 1;
      v[(d+2)%3] = 1;
      for(var s=0; s<2; ++s) {
        t[d] = x[d] + s;
        var tmp = u;
        u = v;
        v = tmp;
        var vertex_count = vertices.length;
        vertices.push([t[0],           t[1],           t[2]          ]);
        vertices.push([t[0]+u[0],      t[1]+u[1],      t[2]+u[2]     ]);
        vertices.push([t[0]+u[0]+v[0], t[1]+u[1]+v[1], t[2]+u[2]+v[2]]);
        vertices.push([t[0]     +v[0], t[1]     +v[1], t[2]     +v[2]]);
        faces.push([vertex_count, vertex_count+1, vertex_count+2, vertex_count+3, volume[n]]);
      }
    }
  }
  return { vertices:vertices, faces:faces };
}


if(exports) {
  exports.mesher = StupidMesh;
}

},{}],85:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],86:[function(require,module,exports){
var inherits = require('inherits')
var events = require('events')
var _ = require('underscore')

module.exports = Highlighter

function Highlighter(game, opts) {
  if (!(this instanceof Highlighter)) return new Highlighter(game, opts)
  this.game = game
  opts = opts || {}
  this.enabled = opts.enabled || function () { return true }
  var geometry = this.geometry = opts.geometry || new game.THREE.CubeGeometry(1, 1, 1)
  var material = opts.material || new game.THREE.MeshBasicMaterial({
    color: opts.color || 0x000000,
    wireframe: true,
    wireframeLinewidth: opts.wireframeLinewidth || 3,
    transparent: true,
    opacity: opts.wireframeOpacity || 0.5
  })
  this.mesh = new game.THREE.Mesh(geometry, material)
  this.distance = opts.distance || 10
  this.currVoxelPos // undefined when no voxel selected for highlight
  this.currVoxelAdj // undefined when no adjacent voxel selected for highlight
  this.targetPosition // desired position of highlight cube center
  
  // the adjacent highlight will be active when the following returns true
  this.adjacentActive = opts.adjacentActive || function () { return game.controls.state.alt }
  
  // the selection highlight will be active when the following returns true
  this.selectActive = opts.selectActive || function () { return game.controls.state.select }
  
  // animate highlight transitions?
  this.animate = opts.animate
  this.animateFunction = opts.animateFunction || function (position, targetPosition, deltaTime) {
    if (!position || !targetPosition || !deltaTime) return;
    var rate = 10
    if (Math.abs(targetPosition[0] - position[0]) < 0.05
     && Math.abs(targetPosition[1] - position[1]) < 0.05
     && Math.abs(targetPosition[2] - position[2]) < 0.05) {
      return targetPosition // close enough to snap and be done
    }
    deltaTime = deltaTime / 1000 // usually around .016 seconds (60 FPS)
    position[0] += rate * deltaTime * (targetPosition[0] - position[0])
    position[1] += rate * deltaTime * (targetPosition[1] - position[1])
    position[2] += rate * deltaTime * (targetPosition[2] - position[2])
    return position
  }

  // highlight 'easing' animation, called every tick if enabled
  var self = this
  if (this.animate) game.on('tick', function (dt) {
    var position = [self.mesh.position.x, self.mesh.position.y, self.mesh.position.z]
    position = self.animateFunction(position, self.targetPosition, dt)
    if (position) self.mesh.position.set(position[0], position[1], position[2])
  })

  game.on('tick', _.throttle(this.highlight.bind(this), opts.frequency || 100))
  
  // anchors for multi-voxel selection
  this.selectStart
  this.selectEnd
}

inherits(Highlighter, events.EventEmitter)

Highlighter.prototype.highlight = function () {

  if (!this.enabled()) {
    if (this.mesh.parent !== null) {
      this.game.scene.remove(this.mesh)
    }
    return;
  }

  var cp = this.game.cameraPosition()
  var cv = this.game.cameraVector()
  var hit = this.game.raycastVoxels(cp, cv, this.distance)
  var targetPositionCandidate

  var removeAdjacent = function (self) { // remove adjacent highlight if any
    if (!self.currVoxelAdj) return;
    self.emit('remove-adjacent', self.currVoxelAdj)
    self.currVoxelAdj = undefined
  }

  // remove existing highlight if any
  if (!hit) {
    if (!this.currVoxelPos) return; // already removed
    this.game.scene.remove(this.mesh)
    this.emit('remove', this.currVoxelPos.slice())
    this.currVoxelPos = undefined
    removeAdjacent(this)
    return;
  }

  var newVoxelPos = hit.voxel
  if (!this.currVoxelPos
    || newVoxelPos[0] !== this.currVoxelPos[0]
    || newVoxelPos[1] !== this.currVoxelPos[1]
    || newVoxelPos[2] !== this.currVoxelPos[2]) { // no current highlight or it moved

    if (this.currVoxelPos) {
      this.emit('remove', this.currVoxelPos.slice()) // moved highlight
    }
    else {
      this.game.scene.add(this.mesh) // fresh highlight
    }
    this.emit('highlight', newVoxelPos.slice())
    this.currVoxelPos = newVoxelPos.slice()
  }
  // try to set the position every time, it may be overridden below
  targetPositionCandidate = [this.currVoxelPos[0] + 0.5, this.currVoxelPos[1] + 0.5, this.currVoxelPos[2] + 0.5]

  // if in "adjacent" mode, highlight adjacent voxel instead
  if (this.adjacentActive()) {
    // since we got here, we know we have a selected non-empty voxel
    // and with an empty adjacent voxel that we can work with
    var newVoxelAdj = hit.adjacent
    if (!this.currVoxelAdj
      || newVoxelAdj[0] !== this.currVoxelAdj[0]
      || newVoxelAdj[1] !== this.currVoxelAdj[1]
      || newVoxelAdj[2] !== this.currVoxelAdj[2]) { // no current adj highlight or it has moved
  
      if (this.currVoxelAdj) {
        this.emit('remove-adjacent', this.currVoxelAdj.slice()) // moved adjacent highlight
      }
      this.emit('highlight-adjacent', newVoxelAdj.slice())
      
      this.currVoxelAdj = newVoxelAdj.slice()
    }
    targetPositionCandidate = [this.currVoxelAdj[0] + 0.5, this.currVoxelAdj[1] + 0.5, this.currVoxelAdj[2] + 0.5]
  }
  else removeAdjacent(this)

  // if in "select" mode, track start and end voxel bounds
  if (this.selectActive()) {
    if (!this.selectStart) { // start a new selection
      this.selectStart = this.selectEnd = this.currVoxelAdj || this.currVoxelPos
    }
    else {
      var endCandidate = this.currVoxelAdj || this.currVoxelPos
      if (endCandidate[0] !== this.selectEnd[0]
       || endCandidate[1] !== this.selectEnd[1]
       || endCandidate[2] !== this.selectEnd[2]) { 
         
        this.selectEnd = endCandidate // selection end has changed
        
        this.emit('highlight-select', { start: this.selectStart.slice(), end: this.selectEnd.slice() })
        
        var scale = []
        scale[0] = Math.abs(this.selectEnd[0] - this.selectStart[0]) + 1
        scale[1] = Math.abs(this.selectEnd[1] - this.selectStart[1]) + 1
        scale[2] = Math.abs(this.selectEnd[2] - this.selectStart[2]) + 1
        this.mesh.scale.set(scale[0], scale[1], scale[2])
        
        var pos = []
        pos[0] = this.selectStart[0] + 0.5 + (this.selectEnd[0] - this.selectStart[0]) / 2
        pos[1] = this.selectStart[1] + 0.5 + (this.selectEnd[1] - this.selectStart[1]) / 2
        pos[2] = this.selectStart[2] + 0.5 + (this.selectEnd[2] - this.selectStart[2]) / 2
        this.targetPosition = pos
      }
    }
  }
  else {
    if (this.selectStart) {
      this.emit('highlight-deselect', { start: this.selectStart.slice(), end: this.selectEnd.slice() })
      this.selectStart = null
      this.mesh.scale.set(1, 1, 1)
    }
    this.targetPosition = targetPositionCandidate // highlighted voxel or adjacent
  }
  if (!this.animate) this.mesh.position.set(this.targetPosition[0], this.targetPosition[1], this.targetPosition[2])
}

},{"events":6,"inherits":87,"underscore":88}],87:[function(require,module,exports){
arguments[4][39][0].apply(exports,arguments)
},{"dup":39}],88:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"dup":75}],89:[function(require,module,exports){
var noise = require('perlin').noise

module.exports = function(seed, floor, ceiling, divisor) {
  floor = floor || 0
  ceiling = ceiling || 20 // minecraft's limit
  divisor = divisor || 50
  noise.seed(seed)
  return function generateChunk(position, width) {
    var startX = position[0] * width
    var startY = position[1] * width
    var startZ = position[2] * width
    var chunk = new Int8Array(width * width * width)
    pointsInside(startX, startZ, width, function(x, z) {
      var n = noise.simplex2(x / divisor , z / divisor)
      var y = ~~scale(n, -1, 1, floor, ceiling)
      if (y === floor || startY < y && y < startY + width) {
        var xidx = Math.abs((width + x % width) % width)
        var yidx = Math.abs((width + y % width) % width)
        var zidx = Math.abs((width + z % width) % width)
        var idx = xidx + yidx * width + zidx * width * width
        chunk[idx] = 1
      }
    })
    return chunk
  }
}

function pointsInside(startX, startY, width, func) {
  for (var x = startX; x < startX + width; x++)
    for (var y = startY; y < startY + width; y++)
      func(x, y)
}

function scale( x, fromLow, fromHigh, toLow, toHigh ) {
  return ( x - fromLow ) * ( toHigh - toLow ) / ( fromHigh - fromLow ) + toLow
}
;
},{"perlin":90}],90:[function(require,module,exports){
/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */

(function(global){
  var module = global.noise = {};

  function Grad(x, y, z) {
    this.x = x; this.y = y; this.z = z;
  }
  
  Grad.prototype.dot2 = function(x, y) {
    return this.x*x + this.y*y;
  };

  Grad.prototype.dot3 = function(x, y, z) {
    return this.x*x + this.y*y + this.z*z;
  };

  var grad3 = [new Grad(1,1,0),new Grad(-1,1,0),new Grad(1,-1,0),new Grad(-1,-1,0),
               new Grad(1,0,1),new Grad(-1,0,1),new Grad(1,0,-1),new Grad(-1,0,-1),
               new Grad(0,1,1),new Grad(0,-1,1),new Grad(0,1,-1),new Grad(0,-1,-1)];

  var p = [151,160,137,91,90,15,
  131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
  190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
  88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
  77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
  102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
  135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
  5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
  223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
  129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
  251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
  49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
  138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
  // To remove the need for index wrapping, double the permutation table length
  var perm = new Array(512);
  var gradP = new Array(512);

  // This isn't a very good seeding function, but it works ok. It supports 2^16
  // different seed values. Write something better if you need more seeds.
  module.seed = function(seed) {
    if(seed > 0 && seed < 1) {
      // Scale the seed out
      seed *= 65536;
    }

    seed = Math.floor(seed);
    if(seed < 256) {
      seed |= seed << 8;
    }

    for(var i = 0; i < 256; i++) {
      var v;
      if (i & 1) {
        v = p[i] ^ (seed & 255);
      } else {
        v = p[i] ^ ((seed>>8) & 255);
      }

      perm[i] = perm[i + 256] = v;
      gradP[i] = gradP[i + 256] = grad3[v % 12];
    }
  };

  module.seed(0);

  /*
  for(var i=0; i<256; i++) {
    perm[i] = perm[i + 256] = p[i];
    gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
  }*/

  // Skewing and unskewing factors for 2, 3, and 4 dimensions
  var F2 = 0.5*(Math.sqrt(3)-1);
  var G2 = (3-Math.sqrt(3))/6;

  var F3 = 1/3;
  var G3 = 1/6;

  // 2D simplex noise
  module.simplex2 = function(xin, yin) {
    var n0, n1, n2; // Noise contributions from the three corners
    // Skew the input space to determine which simplex cell we're in
    var s = (xin+yin)*F2; // Hairy factor for 2D
    var i = Math.floor(xin+s);
    var j = Math.floor(yin+s);
    var t = (i+j)*G2;
    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
    var y0 = yin-j+t;
    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if(x0>y0) { // lower triangle, XY order: (0,0)->(1,0)->(1,1)
      i1=1; j1=0;
    } else {    // upper triangle, YX order: (0,0)->(0,1)->(1,1)
      i1=0; j1=1;
    }
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    var y1 = y0 - j1 + G2;
    var x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
    var y2 = y0 - 1 + 2 * G2;
    // Work out the hashed gradient indices of the three simplex corners
    i &= 255;
    j &= 255;
    var gi0 = gradP[i+perm[j]];
    var gi1 = gradP[i+i1+perm[j+j1]];
    var gi2 = gradP[i+1+perm[j+1]];
    // Calculate the contribution from the three corners
    var t0 = 0.5 - x0*x0-y0*y0;
    if(t0<0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot2(x0, y0);  // (x,y) of grad3 used for 2D gradient
    }
    var t1 = 0.5 - x1*x1-y1*y1;
    if(t1<0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot2(x1, y1);
    }
    var t2 = 0.5 - x2*x2-y2*y2;
    if(t2<0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot2(x2, y2);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70 * (n0 + n1 + n2);
  };

  // 3D simplex noise
  module.simplex3 = function(xin, yin, zin) {
    var n0, n1, n2, n3; // Noise contributions from the four corners

    // Skew the input space to determine which simplex cell we're in
    var s = (xin+yin+zin)*F3; // Hairy factor for 2D
    var i = Math.floor(xin+s);
    var j = Math.floor(yin+s);
    var k = Math.floor(zin+s);

    var t = (i+j+k)*G3;
    var x0 = xin-i+t; // The x,y distances from the cell origin, unskewed.
    var y0 = yin-j+t;
    var z0 = zin-k+t;

    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
    // Determine which simplex we are in.
    var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
    var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
    if(x0 >= y0) {
      if(y0 >= z0)      { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
      else if(x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
      else              { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
    } else {
      if(y0 < z0)      { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
      else if(x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
      else             { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
    }
    // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
    // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
    // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
    // c = 1/6.
    var x1 = x0 - i1 + G3; // Offsets for second corner
    var y1 = y0 - j1 + G3;
    var z1 = z0 - k1 + G3;

    var x2 = x0 - i2 + 2 * G3; // Offsets for third corner
    var y2 = y0 - j2 + 2 * G3;
    var z2 = z0 - k2 + 2 * G3;

    var x3 = x0 - 1 + 3 * G3; // Offsets for fourth corner
    var y3 = y0 - 1 + 3 * G3;
    var z3 = z0 - 1 + 3 * G3;

    // Work out the hashed gradient indices of the four simplex corners
    i &= 255;
    j &= 255;
    k &= 255;
    var gi0 = gradP[i+   perm[j+   perm[k   ]]];
    var gi1 = gradP[i+i1+perm[j+j1+perm[k+k1]]];
    var gi2 = gradP[i+i2+perm[j+j2+perm[k+k2]]];
    var gi3 = gradP[i+ 1+perm[j+ 1+perm[k+ 1]]];

    // Calculate the contribution from the four corners
    var t0 = 0.5 - x0*x0-y0*y0-z0*z0;
    if(t0<0) {
      n0 = 0;
    } else {
      t0 *= t0;
      n0 = t0 * t0 * gi0.dot3(x0, y0, z0);  // (x,y) of grad3 used for 2D gradient
    }
    var t1 = 0.5 - x1*x1-y1*y1-z1*z1;
    if(t1<0) {
      n1 = 0;
    } else {
      t1 *= t1;
      n1 = t1 * t1 * gi1.dot3(x1, y1, z1);
    }
    var t2 = 0.5 - x2*x2-y2*y2-z2*z2;
    if(t2<0) {
      n2 = 0;
    } else {
      t2 *= t2;
      n2 = t2 * t2 * gi2.dot3(x2, y2, z2);
    }
    var t3 = 0.5 - x3*x3-y3*y3-z3*z3;
    if(t3<0) {
      n3 = 0;
    } else {
      t3 *= t3;
      n3 = t3 * t3 * gi3.dot3(x3, y3, z3);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 32 * (n0 + n1 + n2 + n3);

  };

  // ##### Perlin noise stuff

  function fade(t) {
    return t*t*t*(t*(t*6-15)+10);
  }

  function lerp(a, b, t) {
    return (1-t)*a + t*b;
  }

  // 2D Perlin Noise
  module.perlin2 = function(x, y) {
    // Find unit grid cell containing point
    var X = Math.floor(x), Y = Math.floor(y);
    // Get relative xy coordinates of point within that cell
    x = x - X; y = y - Y;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255; Y = Y & 255;

    // Calculate noise contributions from each of the four corners
    var n00 = gradP[X+perm[Y]].dot2(x, y);
    var n01 = gradP[X+perm[Y+1]].dot2(x, y-1);
    var n10 = gradP[X+1+perm[Y]].dot2(x-1, y);
    var n11 = gradP[X+1+perm[Y+1]].dot2(x-1, y-1);

    // Compute the fade curve value for x
    var u = fade(x);

    // Interpolate the four results
    return lerp(
        lerp(n00, n10, u),
        lerp(n01, n11, u),
       fade(y));
  };

  // 3D Perlin Noise
  module.perlin3 = function(x, y, z) {
    // Find unit grid cell containing point
    var X = Math.floor(x), Y = Math.floor(y), Z = Math.floor(z);
    // Get relative xyz coordinates of point within that cell
    x = x - X; y = y - Y; z = z - Z;
    // Wrap the integer cells at 255 (smaller integer period can be introduced here)
    X = X & 255; Y = Y & 255; Z = Z & 255;

    // Calculate noise contributions from each of the eight corners
    var n000 = gradP[X+  perm[Y+  perm[Z  ]]].dot3(x,   y,     z);
    var n001 = gradP[X+  perm[Y+  perm[Z+1]]].dot3(x,   y,   z-1);
    var n010 = gradP[X+  perm[Y+1+perm[Z  ]]].dot3(x,   y-1,   z);
    var n011 = gradP[X+  perm[Y+1+perm[Z+1]]].dot3(x,   y-1, z-1);
    var n100 = gradP[X+1+perm[Y+  perm[Z  ]]].dot3(x-1,   y,   z);
    var n101 = gradP[X+1+perm[Y+  perm[Z+1]]].dot3(x-1,   y, z-1);
    var n110 = gradP[X+1+perm[Y+1+perm[Z  ]]].dot3(x-1, y-1,   z);
    var n111 = gradP[X+1+perm[Y+1+perm[Z+1]]].dot3(x-1, y-1, z-1);

    // Compute the fade curve value for x, y, z
    var u = fade(x);
    var v = fade(y);
    var w = fade(z);

    // Interpolate
    return lerp(
        lerp(
          lerp(n000, n100, u),
          lerp(n001, n101, u), w),
        lerp(
          lerp(n010, n110, u),
          lerp(n011, n111, u), w),
       v);
  };

})(typeof module === "undefined" ? this : module.exports);
},{}],91:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76,"minecraft-skin":92}],92:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"dup":77}],93:[function(require,module,exports){
var traj = require('voxel-trajectory');
var tic = require('tic')();

function Sky(opts) {
  var self = this;
  if (opts.THREE) opts = {game:opts};
  this.game   = opts.game;
  this.time   = opts.time  || 0;
  this.size   = opts.size  || this.game.worldWidth() * 3;
  this._color = opts.color || new this.game.THREE.Color(0, 0, 0);
  this._speed = opts.speed || 0.1;
}

module.exports = function(opts) {
  var sky = new Sky(opts || {});
  sky.createBox();
  sky.createLights();
  return function(fn) {
    if (typeof fn === 'function') sky.fn = fn;
    else if (typeof fn === 'number') {
      // move to the specific time of day
      sky.time = fn;
      for (var i = 0; i <= 2400; i += sky._speed) sky.tick.call(sky);
    }
    return sky.tick.bind(sky);
  }
};
module.exports.Sky = Sky;

Sky.prototype.tick = function(dt) {
  tic.tick(dt);
  this.fn.call(this, this.time);
  var pos = this.game.cameraPosition();
  var vec = new this.game.THREE.Vector3(pos[0], pos[1], pos[2]);
  this.outer.position.copy(vec);
  this.inner.position.copy(vec);
  this.ambient.position.copy(vec);
  this.time += this._speed;
  if (this.time > 2400) this.time = 0;
  return this;
};

Sky.prototype.createBox = function() {
  var game = this.game;
  var size = this.size;

  var mat = new game.THREE.MeshBasicMaterial({
    side: game.THREE.BackSide,
    fog: false,
  });
  this.outer = new game.THREE.Mesh(
    new game.THREE.CubeGeometry(size, size, size),
    new game.THREE.MeshFaceMaterial([
      mat, mat, mat, mat, mat, mat
    ])
  );
  game.scene.add(this.outer);

  var materials = [];
  for (var i = 0; i < 6; i++) {
    materials.push(this.createCanvas());
  }
  this.inner = new game.THREE.Mesh(
    new game.THREE.CubeGeometry(size-10, size-10, size-10),
    new game.THREE.MeshFaceMaterial(materials)
  );
  game.scene.add(this.inner);
};

Sky.prototype.createLights = function() {
  var game = this.game;
  this.ambient = new game.THREE.HemisphereLight(0x408CFF, 0xFFC880, 0.6);
  game.scene.add(this.ambient);
  this.sunlight = new game.THREE.DirectionalLight(0xffffff, 0.5);
  game.scene.add(this.sunlight);
};

Sky.prototype.color = function(end, time) {
  var self = this;
  if (self._colorInterval) self._colorInterval();
  var i = 0;
  var start = self._color.clone().getHSL();
  var color = self._color.clone().getHSL();
  self._colorInterval = tic.interval(function() {
    var dt = i / time;
    for (var p in color) color[p] = start[p] + (end[p] - start[p]) * dt;
    self._color.setHSL(color.h, color.s, color.l);
    self.outer.material.materials.forEach(function(mat) {
      mat.color.setHSL(color.h, color.s, color.l);
    });
    self.ambient.color.setHSL(color.h, color.s, color.l);
    if (self.game.scene.fog) self.game.scene.fog.color.setHSL(color.h, color.s, color.l);
    if (dt === 1) self._colorInterval();
    i += self._speed;
  }, self._speed);
};

Sky.prototype.speed = function(speed) {
  if (speed != null) this._speed = speed;
  return this._speed;
};

Sky.prototype.paint = function(faces, fn) {
  var self = this;
  var args = Array.prototype.slice.call(arguments, 2);
  var index = ['back', 'front', 'top', 'bottom', 'left', 'right'];
  if (faces === 'all') faces = index;
  if (faces === 'sides') faces = ['back', 'front', 'left', 'right'];
  if (!isArray(faces)) faces = [faces];
  faces.forEach(function(face) {
    if (typeof face === 'string') {
      face = index.indexOf(String(face).toLowerCase());
      if (face === -1) return;
    }
    self.material = self.inner.material.materials[face];
    self.canvas = self.material.map.image;
    self.context = self.canvas.getContext('2d');
    fn.apply(self, args);
    self.inner.material.materials[face].map.needsUpdate = true;
  });
  self.material = self.canvas = self.context = false;
};

Sky.prototype.sun   = require('./lib/sun.js');
Sky.prototype.moon  = require('./lib/moon.js');
Sky.prototype.stars = require('./lib/stars.js');

Sky.prototype.createCanvas = function() {
  var game = this.game;

  var canvas = document.createElement('canvas');
  canvas.height = canvas.width = 512;
  var context = canvas.getContext('2d');

  var material = new game.THREE.MeshBasicMaterial({
    side: game.THREE.BackSide,
    map: new game.THREE.Texture(canvas),
    transparent: true,
    fog: false,
  });
  material.magFilter = game.THREE.NearestFilter;
  material.minFilter = game.THREE.LinearMipMapLinearFilter;
  material.wrapS = material.wrapT = game.THREE.RepeatWrapping;
  material.map.needsUpdate = true;

  return material;
};

Sky.prototype.spin = function(r, axis) {
  axis = axis || 'z';
  this.inner.rotation[axis] = this.outer.rotation[axis] = r;
  this.ambient.rotation[axis] = r + Math.PI;
  var t = traj(this.size/2, this.ambient.rotation);
  this.sunlight.position.set(t[0], t[1], t[2]);
  this.sunlight.lookAt(0, 0, 0);
};

Sky.prototype.clear = function() {
  if (!this.canvas) return false;
  this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
};

// default sky
Sky.prototype._default = {
  hours: {
       0: {color: {h: 230/360, s: 0.3, l: 0}},
     300: {color: {h: 26/360, s: 0.3, l: 0.5}},
     500: {color: {h: 230/360, s: 0.3, l: 0.7}},
    1400: {color: {h: 26/360, s: 0.3, l: 0.5}},
    1600: {color: {h: 230/360, s: 0.3, l: 0}}
  },
  init: function() {
    // add a sun on the bottom
    this.paint('bottom', this.sun);
    // add some stars
    this.paint(['top', 'left', 'right', 'front', 'back'], this.stars, 500);
    // add full moon to the top
    this.paint('top', this.moon, 0);
    // no sunlight at startup
    this.sunlight.intensity = 0;
  },
  day: 0,
  moonCycle: 29.5305882,
  until: false,
  last: 0
};

// default sky fn
Sky.prototype.fn = function(time) {
  var my = this._default;
  var hour = Math.round(time / 100) * 100;
  var speed = Math.abs(my.last - time);
  my.last = time;

  // run initialization once
  if (my.init) { my.init.call(this); delete my.init; }

  // switch color based on time of day
  // maybe make this next part into a helper function
  if (my.hours[hour]) {
    if (!my.until) {
      this.color(my.hours[hour].color, speed > 9 ? 100 : 1000);
      my.until = hour + 100;
    }
  }
  if (my.until === hour) my.until = false;

  // change moon phase
  if (time === 1200) {
    this.paint('top', this.clear);
    this.paint('top', this.moon, Math.floor(my.day % my.moonCycle) / my.moonCycle);
    this.paint('top', this.stars, 500);
  }

  // fade stars in and out
  if (time === 500) {
    this.paint(['top', 'left', 'right', 'front', 'back'], function() {
      this.material.transparent = true;
      var i = tic.interval(function(mat) {
        mat.opacity -= 0.1;
        if (mat.opacity <= 0) i();
      }, 100, this.material);
    });
  }
  if (time === 1800) {
    this.paint(['top', 'left', 'right', 'front', 'back'], function() {
      this.material.transparent = true;
      var i = tic.interval(function(mat) {
        mat.opacity += 0.1;
        if (mat.opacity >= 1) i();
      }, 100, this.material);
    });
  }

  // turn on sunlight
  if (time === 400) {
    (function(sunlight) {
      var i = tic.interval(function() {
        sunlight.intensity += 0.1;
        if (sunlight.intensity <= 1) i();
      }, 100);
    }(this.sunlight));
  }

  // turn off sunlight
  if (time === 1800) {
    (function(sunlight) {
      var i = tic.interval(function() {
        sunlight.intensity -= 0.1;
        if (sunlight.intensity <= 0) i();
      }, 100);
    }(this.sunlight));
  }

  // spin the sky 1 revolution per day
  this.spin(Math.PI * 2 * (time / 2400));

  // keep track of days
  if (time === 2400) my.day++;
};

Sky.prototype.rgba = function(c, o) {
  if (arguments.length === 4) {
    c = {r: arguments[0], g: arguments[1], b: arguments[2]};
    o = arguments[3];
  }
  return 'rgba(' + (c.r*255) + ', ' + (c.g*255) + ', ' + (c.b*255) + ', ' + o + ')';
};

function isArray(ar) {
  return Array.isArray(ar)
    || (typeof ar === 'object' && Object.prototype.toString.call(ar) === '[object Array]');
}

},{"./lib/moon.js":94,"./lib/stars.js":95,"./lib/sun.js":96,"tic":97,"voxel-trajectory":98}],94:[function(require,module,exports){
module.exports = function(phase, r, color) {
  if (!this.canvas) return false;
  r = r || 20;
  color = color || new this.game.THREE.Color(0xE6E2D1);
  var x = this.canvas.width / 2;
  var y = this.canvas.height / 2;

  // bg glow
  this.context.beginPath();
  var grd = this.context.createRadialGradient(x+r/2, y+r/2, 1, x+r/2, y+r/2, r * 2);
  grd.addColorStop(0, this.rgba(1, 1, 1, 0.3));
  grd.addColorStop(1, this.rgba(1, 1, 1, 0));
  this.context.arc(x+r/2, y+r/2, r * 2, 0, 2 * Math.PI, false);
  this.context.fillStyle = grd;
  this.context.fill();
  this.context.closePath();

  // clipping region
  this.context.save();
  this.context.beginPath();
  this.context.rect(x, y, r, r);
  this.context.clip();
  
  // moon bg
  this.context.beginPath();
  this.context.rect(x, y, r, r);
  this.context.fillStyle = this.rgba(color, 1);
  this.context.fill();

  this.context.translate(x, y);

  // lighter inside
  this.context.beginPath();
  this.context.rect(4, 4, r-8, r-8);
  this.context.fillStyle = this.rgba(1, 1, 1, 0.8);
  this.context.fill();

  // moon phase
  var px = (phase * r * 2) - r;
  this.context.beginPath();
  this.context.rect(px, 0, r, r);
  this.context.fillStyle = this.rgba(0, 0, 0, 0.8);
  this.context.fill();
  this.context.beginPath();
  this.context.rect(2 + px, 2, r-4, r-4);
  this.context.fillStyle = this.rgba(0, 0, 0, 0.9);
  this.context.fill();

  this.context.restore();
};

},{}],95:[function(require,module,exports){
module.exports = function(amt) {
  if (!this.canvas) return false;
  var colors = [
    '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF',
    '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF', '#FFFFFF',
    '#8589FF', '#FF8585'
  ];
  var alpha = this.context.globalAlpha;
  for (var i = 0; i < amt; i++) {
    this.context.globalAlpha = Math.random() * 1 + 0.5;
    this.context.beginPath();
    this.context.arc(
      Math.random() * this.canvas.width,
      Math.random() * this.canvas.height,
      Math.random() * 0.5,
      0, 2 * Math.PI, false
    );
    this.context.fillStyle = colors[Math.floor(Math.random() * colors.length)];
    this.context.fill();
  }
  this.context.globalAlpha = alpha;
};
},{}],96:[function(require,module,exports){
module.exports = function(r, color) {
  if (!this.canvas) return false;
  r = r || 50;
  color = color || new this.game.THREE.Color(0xF8FFB5);

  this.context.save();

  // bg glow
  this.context.beginPath();
  x = (this.canvas.width/2);
  y = (this.canvas.height/2);
  var grd = this.context.createRadialGradient(x, y, 1, x, y, r * 2);
  grd.addColorStop(0, this.rgba(1, 1, 1, 0.3));
  grd.addColorStop(1, this.rgba(1, 1, 1, 0));
  this.context.arc(x, y, r * 2, 0, 2 * Math.PI, false);
  this.context.fillStyle = grd;
  this.context.fill();
  this.context.closePath();

  // outer sun
  this.context.beginPath();
  x = (this.canvas.width / 2) - (r / 2);
  y = (this.canvas.height / 2) - (r / 2);
  this.context.rect(x, y, r, r);
  this.context.fillStyle = this.rgba(color, 1);
  this.context.fill();
  this.context.closePath();

  // inner sun
  this.context.beginPath();
  r /= 1.6;
  x = (this.canvas.width / 2) - (r / 2);
  y = (this.canvas.height / 2) - (r / 2);
  this.context.rect(x, y, r, r);
  this.context.fillStyle = this.rgba(1, 1, 1, 0.5);
  this.context.fill();
  this.context.closePath();

  this.context.restore();
};
},{}],97:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"dup":59}],98:[function(require,module,exports){
module.exports = function(velocity, rotation, origin) {
  if (typeof velocity === 'object') {
    origin   = velocity.origin;
    rotation = velocity.rotation;
    velocity = velocity.velocity;
  }
  velocity   = velocity || 1;
  rotation   = rotation || [0, 0, 0];
  origin     = origin   || [0, 0, 0];
  if (!Array.isArray(rotation)) rotation = [rotation.x, rotation.y, rotation.z];
  if (!Array.isArray(origin)) origin = [origin.x, origin.y, origin.z];
  return [
    (velocity * Math.sin(rotation[0]) * Math.sin(rotation[1])) + origin[0],
    (velocity * Math.cos(rotation[0])) + origin[1],
    (velocity * Math.sin(rotation[0]) * Math.cos(rotation[1])) + origin[2]
  ];
};

},{}],99:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"dup":78}],100:[function(require,module,exports){
/// Copyright 2014-2015 Red Hat, Inc. and/or its affiliates
/// and other contributors as indicated by the @author tags.
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///   http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
/// Copyright 2014-2015 Red Hat, Inc. and/or its affiliates
/// and other contributors as indicated by the @author tags.
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///
///   http://www.apache.org/licenses/LICENSE-2.0
///
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
/// <reference path="../libs/hawtio-utilities/defs.d.ts"/>
/// <reference path="../libs/hawtio-kubernetes/defs.d.ts"/>

/// <reference path="../../includes.ts"/>
var Kube3d;
(function (Kube3d) {
    Kube3d.W = 1;
    Kube3d.S = 0;
    Kube3d.WALL = Kube3d.W;
    Kube3d.SPACE = Kube3d.S;
    Kube3d.CELL_SIZE = 100;
    Kube3d.FLOOR_LEVEL = -Kube3d.CELL_SIZE;
    ;
})(Kube3d || (Kube3d = {}));

/// <reference path="../../includes.ts"/>
/// <reference path="kube3dInterfaces.ts"/>
var createGame = require('voxel-hello-world');
var terrain = require('voxel-perlin-terrain');
var fly = require('voxel-fly');
var walk = require('voxel-walk');
var highlight = require('voxel-highlight');
var player = require('voxel-player');
var createSky = require('voxel-sky');
var Kube3d;
(function (Kube3d) {
    Kube3d.pluginName = 'Kube3d';
    Kube3d.log = Logger.get(Kube3d.pluginName);
    Kube3d.templatePath = 'plugins/kube3d/html';
    Kube3d.havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;
    Kube3d.HalfPI = Math.PI / 2;
    function rgbToHex(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    Kube3d.rgbToHex = rgbToHex;
    function randomGrey() {
        var rgbVal = Math.random() * 128 + 128;
        return rgbToHex(rgbVal, rgbVal, rgbVal);
    }
    Kube3d.randomGrey = randomGrey;
    function webglAvailable() {
        try {
            var canvas = document.createElement('canvas');
            return !!(window.WebGLRenderingContext && (canvas.getContext('webgl') ||
                canvas.getContext('experimental-webgl')));
        }
        catch (e) {
            return false;
        }
    }
    Kube3d.webglAvailable = webglAvailable;
    function placeObject(cellX, cellY, isFloor) {
        if (isFloor === void 0) { isFloor = false; }
        var x = cellX * Kube3d.CELL_SIZE;
        var z = cellY * Kube3d.CELL_SIZE;
        var y = isFloor ? Kube3d.FLOOR_LEVEL : 0;
        return [x, y, z];
    }
    Kube3d.placeObject = placeObject;
})(Kube3d || (Kube3d = {}));

/// <reference path="kube3dHelpers.ts"/>
var Kube3d;
(function (Kube3d) {
    Kube3d._module = angular.module(Kube3d.pluginName, []);
    Kube3d.controller = PluginHelpers.createControllerFunction(Kube3d._module, Kube3d.pluginName);
    var tab = undefined;
    Kube3d._module.config(['$routeProvider', "HawtioNavBuilderProvider", function ($routeProvider, builder) {
            tab = builder.create()
                .id(Kube3d.pluginName)
                .title(function () { return '3D View'; })
                .href(function () { return '/kubernetes/3d'; })
                .page(function () { return builder.join(Kube3d.templatePath, 'view.html'); })
                .build();
            builder.configureRouting($routeProvider, tab);
        }]);
    Kube3d._module.run(['HawtioNav', function (nav) {
            nav.on(HawtioMainNav.Actions.ADD, Kube3d.pluginName, function (item) {
                if (item.id !== 'kubernetes') {
                    return;
                }
                if (!_.any(item.tabs, function (tab) { return tab.id === Kube3d.pluginName; })) {
                    item.tabs.push(tab);
                }
            });
        }]);
    hawtioPluginLoader.addModule(Kube3d.pluginName);
})(Kube3d || (Kube3d = {}));

/// <reference path="kube3dPlugin.ts"/>
var Kube3d;
(function (Kube3d) {
    Kube3d._module.directive('requestLock', ['$document', function ($document) {
            return {
                restrict: 'A',
                scope: {
                    'onLock': '&requestLock'
                },
                link: function (scope, element, attr) {
                    var el = element[0] || element;
                    if (Kube3d.havePointerLock) {
                        Kube3d.log.debug("here!");
                        var doc = $document[0];
                        var body = doc.body;
                        var pointerlockchange = function (event) {
                            if (doc.pointerLockElement === body ||
                                doc.mozPointerLockElement === body ||
                                doc.webkitPointerLockElement === body) {
                                el.style.display = 'none';
                                scope.onLock({ lock: true });
                            }
                            else {
                                el.style.display = '';
                                scope.onLock({ lock: false });
                            }
                            Core.$apply(scope);
                        };
                        var pointerlockerror = function (event) {
                            el.style.display = '';
                        };
                        doc.addEventListener('pointerlockchange', pointerlockchange, false);
                        doc.addEventListener('mozpointerlockchange', pointerlockchange, false);
                        doc.addEventListener('webkitpointerlockchange', pointerlockchange, false);
                        doc.addEventListener('pointerlockerror', pointerlockerror, false);
                        doc.addEventListener('mozpointerlockerror', pointerlockerror, false);
                        doc.addEventListener('webkitpointerlockerror', pointerlockerror, false);
                        el.addEventListener('click', function (event) {
                            el.style.display = 'none';
                            body.requestPointerLock = body.requestPointerLock || body.mozRequestPointerLock || body.webkitRequestPointerLock;
                            body.requestPointerLock();
                        });
                    }
                    else {
                        el.style.display = 'none';
                    }
                }
            };
        }]);
})(Kube3d || (Kube3d = {}));

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
/// <reference path="kube3dInterfaces.ts"/>
var Kube3d;
(function (Kube3d) {
    var log = Logger.get('Kube3d');
    var SceneObjectBase = (function () {
        function SceneObjectBase(scene, geometry) {
            this.scene = scene;
            this.geometry = geometry;
            this.boundingBox = null;
            this.scene.add(geometry);
            this.boundingBox = new THREE.BoundingBoxHelper(this.geometry, 0x00ff00);
            this.scene.add(this.boundingBox);
        }
        SceneObjectBase.prototype.destroy = function () {
            this.scene.remove(this.geometry);
            this.geometry.dispose();
            delete this.geometry;
        };
        SceneObjectBase.prototype.debug = function (enable) {
            this.boundingBox.visible = enable;
        };
        SceneObjectBase.prototype.move = function (x, y, z) {
            this.geometry.position.x += x;
            this.geometry.position.y += y;
            this.geometry.position.z += z;
            this.boundingBox.position.x += x;
            this.boundingBox.position.y += y;
            this.boundingBox.position.z += z;
        };
        SceneObjectBase.prototype.rotate = function (rx, ry, rz) {
            this.geometry.rotation.x += rx;
            this.geometry.rotation.y += ry;
            this.geometry.rotation.z += rz;
            this.boundingBox.rotation.x += rx;
            this.boundingBox.rotation.y += ry;
            this.boundingBox.rotation.z += rz;
        };
        SceneObjectBase.prototype.getPosition = function () {
            this.boundingBox.update();
            return this.boundingBox.object.position;
        };
        SceneObjectBase.prototype.setPosition = function (x, y, z) {
            this.geometry.position.x = x;
            this.geometry.position.y = y;
            this.geometry.position.z = z;
            this.boundingBox.position.x = x;
            this.boundingBox.position.y = y;
            this.boundingBox.position.z = z;
        };
        SceneObjectBase.prototype.setRotation = function (rx, ry, rz) {
            this.geometry.rotation.x = rx;
            this.geometry.rotation.y = ry;
            this.geometry.rotation.z = rz;
            this.geometry.rotation.x = rx;
            this.geometry.rotation.y = ry;
            this.geometry.rotation.z = rz;
        };
        SceneObjectBase.prototype.render = function () {
            this.boundingBox.update();
        };
        return SceneObjectBase;
    })();
    Kube3d.SceneObjectBase = SceneObjectBase;
    var PodObject = (function (_super) {
        __extends(PodObject, _super);
        function PodObject(scene, hostObject, id, obj) {
            _super.call(this, scene, new THREE.Object3D());
            this.scene = scene;
            this.hostObject = hostObject;
            this.id = id;
            this.obj = obj;
            this.angle = undefined;
            this.circle = undefined;
            this.rotation = {
                x: Math.random() * Math.PI / 1000,
                y: Math.random() * Math.PI / 100,
                z: Math.random() * Math.PI / 1000
            };
            var texture = THREE.ImageUtils.loadTexture(obj.$iconUrl);
            texture.minFilter = THREE.NearestFilter;
            this.geometry.add(new THREE.Mesh(new THREE.BoxGeometry(50, 50, 50), new THREE.MeshPhongMaterial({
                color: 0xffffff,
                map: texture,
                bumpMap: texture,
                castShadow: true,
                receiveShadow: true,
                shading: THREE.SmoothShading
            })));
            log.debug("Created pod object ", id);
        }
        PodObject.prototype.update = function (model, pod) {
            this.obj = pod;
        };
        PodObject.prototype.destroy = function () {
            _super.prototype.destroy.call(this);
            this.hostObject.geometry.remove(this.circle);
            log.debug("Destroyed pod object ", this.id);
        };
        PodObject.prototype.distance = function () {
            var hostPosition = this.hostObject.getPosition();
            var myPosition = this.getPosition();
            var distX = Math.abs(hostPosition.x - myPosition.x);
            var distY = Math.abs(hostPosition.y - myPosition.y);
            return Math.sqrt(distX * distX + distY * distY);
        };
        PodObject.prototype.angleOfVelocity = function () {
            if (!this.angle) {
                var dist = this.distance();
                log.debug("pod id: ", this.id, " distance: ", dist);
                this.angle = (1 / dist) * 10;
                log.debug("pod id: ", this.id, " angle: ", this.angle);
                var materialArray = [];
                var face = new THREE.MeshPhongMaterial({
                    color: 0x555555,
                    castShadow: true,
                    receiveShadow: true,
                    wireframe: true
                });
                materialArray.push(face.clone());
                materialArray.push(face.clone());
                this.circle = new THREE.Mesh(new THREE.RingGeometry(dist - 1, dist + 1, 128), new THREE.MeshFaceMaterial(materialArray));
                this.hostObject.geometry.add(this.circle);
            }
            return this.angle;
        };
        PodObject.prototype.render = function () {
            var myPosition = this.getPosition();
            var hostPosition = this.hostObject.getPosition();
            var x = myPosition.x;
            var y = myPosition.y;
            var centerX = hostPosition.x;
            var centerY = hostPosition.y;
            var offsetX = x - centerX;
            var offsetY = y - centerY;
            var angle = this.angleOfVelocity();
            var newX = centerX + offsetX * Math.cos(angle) - offsetY * Math.sin(angle);
            var newY = centerY + offsetX * Math.sin(angle) + offsetY * Math.cos(angle);
            this.setPosition(newX, newY, 0);
            this.rotate(this.rotation.x, this.rotation.y, this.rotation.z);
            _super.prototype.render.call(this);
        };
        return PodObject;
    })(SceneObjectBase);
    Kube3d.PodObject = PodObject;
    var HostObject = (function (_super) {
        __extends(HostObject, _super);
        function HostObject(scene, id, obj) {
            _super.call(this, scene, new THREE.Object3D());
            this.id = id;
            this.obj = obj;
            this.offsetX = 200;
            this.offsetY = 200;
            this.pods = {};
            this.rotation = {
                x: 0,
                y: 0,
                z: Math.random() * Math.PI / 1000
            };
            this.step = 0;
            var texture = THREE.ImageUtils.loadTexture('img/sun-texture.jpg');
            texture.minFilter = THREE.NearestFilter;
            this.geometry.add(new THREE.PointLight(0xffd700, 1, 5000), new THREE.Mesh(new THREE.SphereGeometry(100, 32, 16), new THREE.MeshPhongMaterial({
                color: 0xffd700,
                map: texture,
                bumpMap: texture,
                specular: 0x00ff00,
                shading: THREE.SmoothShading
            })));
            log.debug("Created host object ", id);
        }
        HostObject.prototype.update = function (model, host) {
            var _this = this;
            this.obj = host;
            var podsToRemove = [];
            _.forIn(this.pods, function (pod, key) {
                if (!(key in model.podsByKey)) {
                    podsToRemove.push(key);
                }
            });
            _.forEach(podsToRemove, function (id) { return _this.removePod(id); });
            _.forEach(this.obj.pods, function (pod) {
                var name = pod._key;
                if (!_this.hasPod(name)) {
                    _this.addPod(name, pod);
                }
                else {
                    var podObj = _this.pods[name];
                    podObj.update(model, pod);
                }
            });
        };
        HostObject.prototype.debug = function (enable) {
            var _this = this;
            var ids = _.keys(this.pods);
            _.forEach(ids, function (id) { return _this.pods[id].debug(enable); });
            _super.prototype.debug.call(this, enable);
        };
        HostObject.prototype.destroy = function () {
            var _this = this;
            if (this.pods) {
                var podIds = _.keys(this.pods);
                _.forEach(podIds, function (id) { return _this.removePod(id); });
            }
            _super.prototype.destroy.call(this);
            log.debug("Destroying host object ", this.id);
        };
        HostObject.prototype.removePod = function (id) {
            var pod = this.pods[id];
            if (pod) {
                pod.destroy();
                delete this.pods[id];
            }
        };
        HostObject.prototype.addPod = function (key, p) {
            if (this.hasPod(key)) {
                return;
            }
            var myPosition = this.getPosition();
            var podOffsetX = this.offsetX - myPosition.x;
            var podOffsetY = myPosition.y;
            var pod = new PodObject(this.scene, this, key, p);
            pod.setPosition(myPosition.x, myPosition.y, myPosition.z);
            pod.move(this.offsetX, 0, 0);
            this.offsetX = this.offsetX + Math.random() * 50 + 100;
            this.offsetY = this.offsetY + Math.random() * 50 + 100;
            this.pods[key] = pod;
        };
        HostObject.prototype.hasPod = function (id) {
            return (id in this.pods);
        };
        HostObject.prototype.render = function () {
            this.rotate(this.rotation.x, this.rotation.y, this.rotation.z);
            _.forIn(this.pods, function (podObject, id) {
                podObject.render();
            });
            this.step = this.step + 1;
            _super.prototype.render.call(this);
        };
        return HostObject;
    })(SceneObjectBase);
    Kube3d.HostObject = HostObject;
})(Kube3d || (Kube3d = {}));

/// <reference path="kube3dHelpers.ts"/>
var Kube3d;
(function (Kube3d) {
    var levelData = [
        [Kube3d.W, Kube3d.W, Kube3d.W, Kube3d.W, Kube3d.W, Kube3d.W, Kube3d.W, Kube3d.W],
        [Kube3d.W, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.W],
        [Kube3d.W, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.W],
        [Kube3d.W, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.W],
        [Kube3d.W, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.W],
        [Kube3d.W, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.W],
        [Kube3d.W, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.S, Kube3d.W],
        [Kube3d.W, Kube3d.W, Kube3d.W, Kube3d.W, Kube3d.W, Kube3d.W, Kube3d.W, Kube3d.W]
    ];
    var levelWidth = levelData[0].length;
    var levelHeight = levelData.length;
    function makeBox(cellX, cellY, isFloor) {
        if (isFloor === void 0) { isFloor = false; }
        return undefined;
    }
    var World = (function () {
        function World(scene) {
            this.scene = scene;
            this.ambient = new THREE.AmbientLight(0xffffff);
            this.light = new THREE.DirectionalLight(0x888888);
            this.ambient.color.setHSL(0.1, 0.3, 0.2);
            this.light.position.set(1, 1, 0);
            scene.add(this.ambient);
            scene.add(this.light);
            var materialArray = [];
            for (var i = 0; i < 6; i++)
                materialArray.push(new THREE.MeshBasicMaterial({
                    map: THREE.ImageUtils.loadTexture('img/space-seamless.png'),
                    side: THREE.BackSide
                }));
            var skyMaterial = new THREE.MeshFaceMaterial(materialArray);
            scene.add(new THREE.Mesh(new THREE.BoxGeometry(10000, 10000, 10000), skyMaterial));
            _.forEach(levelData, function (row, y) {
                _.forEach(row, function (cell, x) {
                    switch (cell) {
                        case Kube3d.WALL:
                            scene.add(makeBox(x, y, false));
                            break;
                    }
                    scene.add(makeBox(x, y, true));
                });
            });
        }
        World.prototype.placePlayer = function (object) {
            this.placeObject(object);
        };
        World.prototype.placeObject = function (object) {
            if (!object || !object.position) {
                return;
            }
            var x, y;
            do {
                x = Math.floor(Math.random() * (levelWidth - 2) + 1);
                y = Math.floor(Math.random() * (levelHeight - 2) + 1);
                Kube3d.log.debug("x:", x, "y:", y, "val:", levelData[y][x]);
            } while (levelData[y][x] !== Kube3d.SPACE);
            object.position.fromArray(Kube3d.placeObject(x, y));
        };
        World.prototype.render = function () {
        };
        World.prototype.destroy = function () {
        };
        return World;
    })();
    Kube3d.World = World;
})(Kube3d || (Kube3d = {}));

/// <reference path="kube3dHelpers.ts"/>
/// <reference path="world.ts"/>
var Kube3d;
(function (Kube3d) {
    var Player = (function () {
        function Player(scene, camera, d, world) {
            this.scene = scene;
            this.camera = camera;
            this.d = d;
            this.world = world;
            this.log = Logger.get('kube3d-player');
            this.domElement = null;
            this._lookAt = null;
            this.pitch = new THREE.Object3D();
            this.yaw = new THREE.Object3D();
            this._enabled = false;
            this._document = undefined;
            this.getWorldObjects = function () { return []; };
            this.raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, -1, 0), 0, 10);
            this.forward = false;
            this.backward = false;
            this.left = false;
            this.right = false;
            this.canJump = true;
            this.running = false;
            this.velocity = new THREE.Vector3();
            this.prevTime = performance.now();
            this.handlers = null;
            this.walkingModifier = 500;
            this.runningModifier = 200;
            camera.rotation.set(0, 0, 0);
            camera.position.set(0, 0, 0);
            this.pitch.add(camera);
            this.yaw.add(this.pitch);
            scene.add(this.yaw);
            this.yaw.position.set(0, 0, -5);
            var domElement = this.domElement = $(d);
            if (!Kube3d.havePointerLock) {
                this.enabled = true;
            }
            var self = this;
            self.handlers = {
                'keydown': function (event) {
                    switch (event.keyCode) {
                        case 38:
                        case 87:
                            self.forward = true;
                            break;
                        case 37:
                        case 65:
                            self.left = true;
                            break;
                        case 40:
                        case 83:
                            self.backward = true;
                            break;
                        case 39:
                        case 68:
                            self.right = true;
                            break;
                        case 16:
                            self.running = true;
                            break;
                        case 32:
                            if (self.canJump === true) {
                                self.velocity.y += 350;
                                self.canJump = false;
                            }
                            break;
                    }
                },
                'keyup': function (event) {
                    switch (event.keyCode) {
                        case 38:
                        case 87:
                            self.forward = false;
                            break;
                        case 37:
                        case 65:
                            self.left = false;
                            break;
                        case 40:
                        case 83:
                            self.backward = false;
                            break;
                        case 39:
                        case 68:
                            self.right = false;
                            break;
                        case 16:
                            self.running = false;
                            break;
                    }
                },
                'mousemove': function (event) {
                    if (!self._enabled || !Kube3d.havePointerLock) {
                        return;
                    }
                    var yaw = self.yaw;
                    var pitch = self.pitch;
                    var deltaX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                    var deltaY = event.movementY || event.mozMovementX || event.webkitMovementX || 0;
                    yaw.rotation.y -= deltaX * 0.002;
                    pitch.rotation.x -= deltaY * 0.002;
                    pitch.rotation.x = Math.max(-Kube3d.HalfPI, Math.min(Kube3d.HalfPI, pitch.rotation.x));
                }
            };
            _.forIn(this.handlers, function (handler, evt) { return document.addEventListener(evt, handler, false); });
        }
        Object.defineProperty(Player.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (enabled) {
                this._enabled = enabled;
                if (enabled) {
                    this.camera.position.set(0, 0, 0);
                    this.camera.rotation.set(0, 0, 0);
                    this.object.position.set(0, 0, 0);
                    var angle = THREE.Math.degToRad(THREE.Math.random16() * 360);
                    this.yaw.rotation.set(0, angle, 0);
                    this.world.placePlayer(this.object);
                }
                else {
                    this.yaw.position.set(0, 0, 0);
                    this.yaw.rotation.set(0, 0, 0);
                    this.pitch.rotation.set(0, 0, 0);
                }
            },
            enumerable: true,
            configurable: true
        });
        Player.prototype.setWorldObjectsCallback = function (func) {
            this.getWorldObjects = func;
        };
        Object.defineProperty(Player.prototype, "object", {
            get: function () {
                return this.yaw;
            },
            enumerable: true,
            configurable: true
        });
        Player.prototype.lookAt = function (box) {
            this._lookAt = box;
        };
        Player.prototype.destroy = function () {
            this.scene.remove(this.yaw);
            this.yaw.dispose();
            this.pitch.dispose();
            _.forIn(this.handlers, function (handler, evt) { return document.removeEventListener(evt, handler); });
        };
        Player.prototype.render = function () {
            if (!this.enabled || !Kube3d.havePointerLock) {
                if (this._lookAt) {
                    var angle = Date.now() * 0.0001;
                    this.camera.focus(this._lookAt, angle);
                }
                return;
            }
            var raycaster = this.raycaster;
            var velocity = this.velocity;
            var me = this.object;
            raycaster.ray.origin.copy(this.yaw.position);
            raycaster.ray.origin.y -= 10;
            var objects = this.getWorldObjects();
            var intersections = raycaster.intersectObjects(objects);
            var isOnObject = intersections.length > 0;
            var time = performance.now();
            var interval = time - this.prevTime;
            var modifier = this.running ? this.runningModifier : this.walkingModifier;
            var delta = interval / modifier;
            var deltaY = interval / this.walkingModifier;
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 9.8 * 100.0 * deltaY;
            if (this.forward)
                velocity.z -= 400.0 * delta;
            if (this.backward)
                velocity.z += 400.0 * delta;
            if (this.left)
                velocity.x -= 400.0 * delta;
            if (this.right)
                velocity.x += 400.0 * delta;
            if (isOnObject === true) {
                velocity.y = Math.max(0, velocity.y);
                this.canJump = true;
            }
            me.translateX(velocity.x * delta);
            me.translateY(velocity.y * deltaY);
            me.translateZ(velocity.z * delta);
            if (me.position.y < 10) {
                velocity.y = 0;
                me.position.y = 10;
                this.canJump = true;
            }
            this.prevTime = time;
        };
        return Player;
    })();
    Kube3d.Player = Player;
})(Kube3d || (Kube3d = {}));

/// <reference path="kube3dPlugin.ts"/>
var Kube3d;
(function (Kube3d) {
    var directiveName = 'threejs';
    Kube3d._module.directive(directiveName, [function () {
            THREE.ImageUtils.crossOrigin = '';
            return {
                restrict: 'A',
                replace: true,
                scope: {
                    config: '=?' + directiveName
                },
                link: function (scope, element, attrs) {
                    var scene = null;
                    var camera = null;
                    var renderer = null;
                    var keepRendering = true;
                    var resizeHandle = null;
                    function stop() {
                        keepRendering = false;
                    }
                    function cleanup() {
                        $(window).off('resize', resizeFunc);
                        delete renderer;
                        delete camera;
                        delete scene;
                        element.empty();
                    }
                    var resizeFunc = function () {
                        Kube3d.log.debug("resizing");
                        element.find('canvas').width(element.width()).height(element.height());
                        camera.aspect = element.width() / element.height();
                        camera.updateProjectionMatrix();
                        renderer.setSize(element.width(), element.height());
                    };
                    element.on('$destroy', function () {
                        stop();
                        Kube3d.log.debug("scene destroyed");
                    });
                    scope.$watch('config', _.debounce(function (config) {
                        stop();
                        if (!config || !config.initialize) {
                            Kube3d.log.debug("no config, returning");
                            return;
                        }
                        Kube3d.log.debug("creating scene");
                        scene = new THREE.Scene();
                        camera = new THREE.PerspectiveCamera(60, element.width() / element.height(), 0.1, 20000);
                        camera.focus = function (box3, angle, c) {
                            if (c === void 0) { c = camera; }
                            var height = box3.size().y;
                            var width = box3.size().x / (camera.aspect / 2);
                            if (width < 0 || height < 0) {
                                return;
                            }
                            var distY = Math.round(height * Math.tan((camera.fov / 2) * (Math.PI / 180)));
                            var distX = Math.round(width * Math.tan((camera.fov / 2) * (Math.PI / 180)));
                            var distZ = (distY + distX);
                            var z = Math.round(c.position.z);
                            var period = 5.0;
                            c.position.x = distX * Math.cos(angle);
                            c.position.y = distY * Math.sin(angle);
                            if (z !== distZ) {
                                if (z > distZ) {
                                    var v = (z - distZ) / period;
                                    c.position.z = z - v;
                                }
                                if (z < distZ) {
                                    var v = (distZ - z) / period;
                                    c.position.z = z + v;
                                }
                            }
                            c.lookAt(box3.center());
                        };
                        if (Kube3d.webglAvailable()) {
                            renderer = new THREE.WebGLRenderer();
                        }
                        else {
                            renderer = new THREE.CanvasRenderer();
                        }
                        renderer.setPixelRatio(window.devicePixelRatio);
                        renderer.setSize(element.width(), element.height());
                        var domElement = renderer.domElement;
                        config.initialize(renderer, scene, camera, domElement);
                        element.append(domElement);
                        $(window).on('resize', resizeFunc);
                        var render = function () {
                            if (!keepRendering) {
                                cleanup();
                                return;
                            }
                            if (config.render) {
                                config.render(renderer, scene, camera);
                            }
                            renderer.render(scene, camera);
                            requestAnimationFrame(render);
                        };
                        keepRendering = true;
                        render();
                    }, 500, { trailing: true }));
                }
            };
        }]);
})(Kube3d || (Kube3d = {}));

/// <reference path="kube3dPlugin.ts"/>
/// <reference path="player.ts"/>
/// <reference path="world.ts"/>
/// <reference path="objects.ts"/>
var Kube3d;
(function (Kube3d) {
    Kube3d.ViewController = Kube3d.controller('ViewController', ['$scope', 'KubernetesModel', 'KubernetesState', '$element', function ($scope, model, state, $element) {
            var debugScene = false;
            var renderer = undefined;
            var scene = undefined;
            var camera = undefined;
            var domElement = undefined;
            var sceneGeometry = new THREE.Object3D();
            var sceneBounds = new THREE.BoundingBoxHelper(sceneGeometry, 0xff0000);
            var hostObjects = {};
            var updating = false;
            var hasMouse = false;
            var player = null;
            var world = null;
            $scope.onLock = function (lock) {
                if (!player) {
                    return;
                }
                player.enabled = lock;
            };
            $scope.config = {
                initialize: function (r, s, c, d) {
                    Kube3d.log.debug("init called");
                    renderer = r;
                    scene = s;
                    camera = c;
                    domElement = d;
                    world = new Kube3d.World(scene);
                    player = new Kube3d.Player(scene, camera, d, world);
                    scene.add(sceneGeometry);
                    if (debugScene) {
                        scene.add(sceneBounds);
                    }
                    var axis = new THREE.AxisHelper(1000);
                    scene.add(axis);
                    sceneGeometry.rotation.x = 90;
                    sceneGeometry.rotation.z = 90;
                    sceneGeometry.position.x = 0;
                    sceneGeometry.position.y = 0;
                    sceneGeometry.position.z = 0;
                    buildScene();
                },
                render: function (renderer, scene, camera) {
                    if (updating) {
                        return;
                    }
                    world.render();
                    var angle = Date.now() * 0.0001;
                    sceneGeometry.position.x = 1000 * Math.cos(angle);
                    sceneGeometry.position.z = 1000 * Math.sin(angle);
                    _.forIn(hostObjects, function (hostObject, key) {
                        hostObject.render();
                    });
                    sceneBounds.update();
                    player.lookAt(sceneBounds.box);
                    player.render();
                }
            };
            function buildScene() {
                if (!scene) {
                    return;
                }
                updating = true;
                var originX = 0;
                var originY = 0;
                var hostsToRemove = [];
                _.forIn(hostObjects, function (hostObject, key) {
                    if (_.any(model.hosts, function (host) { return host.elementId === key; })) {
                        Kube3d.log.debug("Keeping host: ", key);
                    }
                    else {
                        hostsToRemove.push(key);
                    }
                });
                _.forEach(hostsToRemove, function (key) {
                    var hostObject = hostObjects[key];
                    if (hostObject) {
                        hostObject.destroy();
                        delete hostObjects[key];
                    }
                });
                _.forEach(model.hosts, function (host) {
                    var id = host.elementId;
                    Kube3d.log.debug("host: ", host);
                    var hostObject = hostObjects[id] || new Kube3d.HostObject(sceneGeometry, id, host);
                    if (!(id in hostObjects)) {
                        hostObject.setPosition(originX, originY, 0);
                        originX = originX + 500;
                        originY = originY + 500;
                        hostObjects[id] = hostObject;
                    }
                    hostObject.update(model, host);
                    hostObject.debug(debugScene);
                });
                Kube3d.log.debug("model updated");
                updating = false;
            }
            $scope.$on('kubernetesModelUpdated', buildScene);
        }]);
})(Kube3d || (Kube3d = {}));

/// <reference path="kube3dPlugin.ts"/>
var Kube3d;
(function (Kube3d) {
    var chunkSize = 32;
    var generateChunk = terrain('hawtio', 0, 20, 50);
    Kube3d.VoxelController = Kube3d.controller('VoxelController', ['$scope', '$element', 'KubernetesModel', function ($scope, $element, model) {
            var creatures = {};
            var bullets = [];
            var el = $element.find('.kube3d-control')[0];
            var game = createGame({
                lightsDisabled: true,
                fogDisabled: false,
                generateChunks: false,
                texturePath: './img/textures/',
                materials: [['grass', 'dirt', 'grass_dirt'], 'brick', 'dirt'],
                materialFlatColor: false,
                container: el
            }, function (game, avatar) {
                var bullet = new game.THREE.Mesh(new game.THREE.SphereGeometry(0.25, 32, 32), new game.THREE.MeshPhongMaterial({
                    color: 0x888888,
                }));
                function newCreature(texture) {
                    var THREE = game.THREE;
                    var boxTexture = THREE.ImageUtils.loadTexture(texture);
                    boxTexture.minFilter = THREE.NearestFilter;
                    var boxMaterial = new THREE.MeshPhongMaterial({
                        map: boxTexture,
                        alphaMap: boxTexture
                    });
                    var box = new THREE.Mesh(new THREE.CubeGeometry(game.cubeSize, game.cubeSize, game.cubeSize), boxMaterial);
                    return box;
                }
                var makeFly = fly(game);
                var target = game.controls.target();
                game.flyer = makeFly(target);
                var sky = createSky({
                    game: game,
                    time: 800,
                    speed: 0.1,
                    color: new game.THREE.Color(game.skyColor)
                });
                window.addEventListener('keydown', function (ev) {
                    if (ev.keyCode === 'R'.charCodeAt(0))
                        avatar.toggle();
                });
                var currentMaterial = 1;
                game.on('fire', function (target, state) {
                    Kube3d.log.debug("fire, target: ", target, " state: ", state);
                    if (bullets.length > 10) {
                        return;
                    }
                    var b = bullet.clone();
                    b.position.set(target.position.x, target.position.y + 1, target.position.z);
                    var direction = game.cameraVector();
                    var velocity = new game.THREE.Vector3(direction[0], direction[1], direction[2]);
                    velocity.multiplyScalar(0.05);
                    var item = {
                        mesh: b,
                        size: 0.8,
                        velocity: velocity
                    };
                    item = game.addItem(item);
                    Kube3d.log.debug("item: ", item);
                    bullets.push(item);
                });
                game.on('tick', function (delta) {
                    walk.render(target.playerSkin);
                    var vx = Math.abs(target.velocity.x);
                    var vz = Math.abs(target.velocity.z);
                    if (vx > 0.001 || vz > 0.001) {
                        walk.stopWalking();
                    }
                    else {
                        walk.startWalking();
                    }
                    var toRemove = [];
                    _.forEach(bullets, function (bullet) {
                        if (bullet.lastPosition) {
                            var pos = bullet.mesh.position;
                            var last = bullet.lastPosition;
                            if (pos.x === last.x && pos.y === last.y && pos.z === last.z) {
                                game.removeItem(bullet);
                                toRemove.push(bullet);
                            }
                        }
                        bullet.lastPosition = {
                            x: bullet.mesh.position.x,
                            y: bullet.mesh.position.y,
                            z: bullet.mesh.position.z
                        };
                        var bulletAABB = bullet.aabb();
                        var hit = false;
                        _.forIn(creatures, function (creature, key) {
                            if (!creature.entity || hit) {
                                return;
                            }
                            if (bulletAABB.intersects(creature.entity.aabb())) {
                                hit = true;
                                game.removeItem(bullet);
                                toRemove.push(bullet);
                                creature.hit = true;
                            }
                        });
                    });
                    _.forEach(toRemove, function (bullet) {
                        _.remove(bullets, bullet);
                    });
                    sky()(delta);
                    if (game.pendingChunks.length) {
                        Kube3d.log.debug("Pending chunks, skipping entity creation");
                        return;
                    }
                    var creaturesToRemove = [];
                    _.forIn(creatures, function (creature, key) {
                        if (creature.hit && !creature.deleted) {
                            model['podsResource'].delete({ id: Kubernetes.getName(creature.pod) });
                            creature.deleted = true;
                            if (creature.clearInterval) {
                                creature.clearInterval();
                                delete creature.clearInterval;
                            }
                            creature.entity.velocity.y = 2;
                            creature.entity.resting = false;
                            Kube3d.log.debug("Creature hit: ", creature);
                        }
                        if (creature.hit && creature.entity) {
                            creature.entity.mesh.scale.x = creature.entity.mesh.scale.x + 0.05;
                            creature.entity.mesh.scale.z = creature.entity.mesh.scale.z + 0.05;
                        }
                        if (!(key in model.podsByKey)) {
                            Kube3d.log.debug("need to delete creature ", key);
                            creaturesToRemove.push(key);
                        }
                        if (!('entity' in creature)) {
                            Kube3d.log.debug("need to create creature ", key);
                            var mesh = newCreature(creature.pod.$iconUrl);
                            mesh.name = key;
                            mesh.position.set(Math.random() * 20 - 10, 30, Math.random() * 20 - 10);
                            var item = {
                                mesh: mesh,
                                size: 1,
                                velocity: { x: 0, y: 0, z: 0 }
                            };
                            creature.entity = game.addItem(item);
                            creature.clearInterval = game.setInterval(function () {
                                if (creature.deleted) {
                                    return;
                                }
                                creature.entity.velocity.x = (Math.random() * 10 - 5) * 0.005;
                                creature.entity.velocity.z = (Math.random() * 10 - 5) * 0.005;
                                creature.entity.velocity.y = (Math.random() * 10 - 5) * 0.005;
                                creature.entity.resting = false;
                            }, Math.random() * 5000 + 500);
                        }
                    });
                    _.forEach(creaturesToRemove, function (key) {
                        var creature = creatures[key];
                        if (!creature) {
                            return;
                        }
                        if (creature.entity) {
                            game.removeItem(creature.entity);
                            if (creature.clearInterval) {
                                creature.clearInterval();
                            }
                        }
                        delete creatures[key];
                    });
                });
            });
            game.voxels.on('missingChunk', function (p) {
                var voxels = generateChunk(p, chunkSize);
                var chunk = {
                    position: p,
                    dims: [chunkSize, chunkSize, chunkSize],
                    voxels: voxels
                };
                game.showChunk(chunk);
            });
            $scope.$on('kubernetesModelUpdated', function (e, model) {
                Kube3d.log.debug("model updated: ", model);
                _.forIn(model.podsByKey, function (pod, key) {
                    var creature = creatures[key];
                    if (!creature) {
                        creature = creatures[key] = {
                            name: key,
                            pod: pod
                        };
                    }
                });
                Kube3d.log.debug("Creatures:", creatures);
            });
        }]);
})(Kube3d || (Kube3d = {}));

angular.module("hawtio-kube3d-templates", []).run(["$templateCache", function($templateCache) {$templateCache.put("plugins/kube3d/html/view.html","<!--\n<div class=\"kube3d-viewport\" ng-controller=\"Kube3d.ViewController\">\n  <div class=\"kube3d-control\" threejs=\"config\"></div>\n  <div class=\"kube3d-instructions\" request-lock=\'onLock(lock)\'>\n    <div class=\"kube3d-instructions-wrapper\">\n      <span class=\"kube3d-start-title\">Click to play</span>\n    </div>\n  </div>\n</div>\n-->\n\n<div class=\"kube3d-viewport\" ng-controller=\"Kube3d.VoxelController\">\n  <div class=\"kube3d-control\"></div>\n</div>\n");}]); hawtioPluginLoader.addModule("hawtio-kube3d-templates");
},{"voxel-fly":26,"voxel-hello-world":31,"voxel-highlight":86,"voxel-perlin-terrain":89,"voxel-player":91,"voxel-sky":93,"voxel-walk":99}]},{},[100])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9saWIvYjY0LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvbm9kZV9tb2R1bGVzL2lzLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1mbHkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtZmx5L25vZGVfbW9kdWxlcy9ldmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWZseS9ub2RlX21vZHVsZXMvZXZlci9pbml0Lmpzb24iLCJub2RlX21vZHVsZXMvdm94ZWwtZmx5L25vZGVfbW9kdWxlcy9ldmVyL3R5cGVzLmpzb24iLCJub2RlX21vZHVsZXMvdm94ZWwtZmx5L25vZGVfbW9kdWxlcy92a2V5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy9leHRlbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwtZW5naW5lL2xpYi9kZXRlY3Rvci5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwtZW5naW5lL2xpYi9zdGF0cy5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwtZW5naW5lL25vZGVfbW9kdWxlcy9hYWJiLTNkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1lbmdpbmUvbm9kZV9tb2R1bGVzL2NvbGxpZGUtM2QtdGlsZW1hcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwtZW5naW5lL25vZGVfbW9kdWxlcy9nbC1tYXRyaXgvZGlzdC9nbC1tYXRyaXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHMuanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvaW50ZXJhY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvaW50ZXJhY3Qvbm9kZV9tb2R1bGVzL2RyYWctc3RyZWFtL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1lbmdpbmUvbm9kZV9tb2R1bGVzL2ludGVyYWN0L25vZGVfbW9kdWxlcy9kcmFnLXN0cmVhbS9ub2RlX21vZHVsZXMvZG9tbm9kZS1kb20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvaW50ZXJhY3Qvbm9kZV9tb2R1bGVzL2RyYWctc3RyZWFtL25vZGVfbW9kdWxlcy9kb21ub2RlLWRvbS9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvaW50ZXJhY3Qvbm9kZV9tb2R1bGVzL2RyYWctc3RyZWFtL25vZGVfbW9kdWxlcy9kb21ub2RlLWRvbS9saWIvcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvaW50ZXJhY3Qvbm9kZV9tb2R1bGVzL2RyYWctc3RyZWFtL25vZGVfbW9kdWxlcy9kb21ub2RlLWRvbS9saWIvd3JpdGFibGUuanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvaW50ZXJhY3Qvbm9kZV9tb2R1bGVzL2RyYWctc3RyZWFtL25vZGVfbW9kdWxlcy90aHJvdWdoL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1lbmdpbmUvbm9kZV9tb2R1bGVzL2ludGVyYWN0L25vZGVfbW9kdWxlcy9mdWxsc2NyZWVuL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1lbmdpbmUvbm9kZV9tb2R1bGVzL2ludGVyYWN0L25vZGVfbW9kdWxlcy9wb2ludGVyLWxvY2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMva2ItY29udHJvbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMva2ItY29udHJvbHMvbm9kZV9tb2R1bGVzL3ZrZXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvcGluLWl0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1lbmdpbmUvbm9kZV9tb2R1bGVzL3JhZi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwtZW5naW5lL25vZGVfbW9kdWxlcy9zcGF0aWFsLWV2ZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwtZW5naW5lL25vZGVfbW9kdWxlcy9zcGF0aWFsLWV2ZW50cy90cmVlLmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1lbmdpbmUvbm9kZV9tb2R1bGVzL3RocmVlL3RocmVlLmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1lbmdpbmUvbm9kZV9tb2R1bGVzL3RpYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwtZW5naW5lL25vZGVfbW9kdWxlcy92b3hlbC1jb250cm9sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1lbmdpbmUvbm9kZV9tb2R1bGVzL3ZveGVsLW1lc2gvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvdm94ZWwtcGh5c2ljYWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvdm94ZWwtcmF5Y2FzdC9yYXljYXN0LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1lbmdpbmUvbm9kZV9tb2R1bGVzL3ZveGVsLXJlZ2lvbi1jaGFuZ2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvdm94ZWwtdGV4dHVyZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwtZW5naW5lL25vZGVfbW9kdWxlcy92b3hlbC10ZXh0dXJlL25vZGVfbW9kdWxlcy9hdGxhc3BhY2svaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsLWVuZ2luZS9ub2RlX21vZHVsZXMvdm94ZWwtdmlldy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwtaGlnaGxpZ2h0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1oaWdobGlnaHQvbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwtcGxheWVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC1wbGF5ZXIvbm9kZV9tb2R1bGVzL21pbmVjcmFmdC1za2luL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC13YWxrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC9jaHVua2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oZWxsby13b3JsZC9ub2RlX21vZHVsZXMvdm94ZWwvbWVzaGVycy9jdWxsZWQuanMiLCJub2RlX21vZHVsZXMvdm94ZWwtaGVsbG8td29ybGQvbm9kZV9tb2R1bGVzL3ZveGVsL21lc2hlcnMvZ3JlZWR5LmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC9tZXNoZXJzL21vbm90b25lLmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLWhlbGxvLXdvcmxkL25vZGVfbW9kdWxlcy92b3hlbC9tZXNoZXJzL3N0dXBpZC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1oaWdobGlnaHQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtcGVybGluLXRlcnJhaW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtcGVybGluLXRlcnJhaW4vbm9kZV9tb2R1bGVzL3Blcmxpbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92b3hlbC1za3kvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdm94ZWwtc2t5L2xpYi9tb29uLmpzIiwibm9kZV9tb2R1bGVzL3ZveGVsLXNreS9saWIvc3RhcnMuanMiLCJub2RlX21vZHVsZXMvdm94ZWwtc2t5L2xpYi9zdW4uanMiLCJub2RlX21vZHVsZXMvdm94ZWwtc2t5L25vZGVfbW9kdWxlcy92b3hlbC10cmFqZWN0b3J5L2luZGV4LmpzIiwiL3NvdXJjZS9pbmNsdWRlcy50cyIsIi9zb3VyY2Uva3ViZTNkL3RzL2t1YmUzZEludGVyZmFjZXMudHMiLCIvc291cmNlL2t1YmUzZC90cy9rdWJlM2RIZWxwZXJzLnRzIiwiL3NvdXJjZS9rdWJlM2QvdHMva3ViZTNkUGx1Z2luLnRzIiwiL3NvdXJjZS9rdWJlM2QvdHMvbG9ja1JlcXVlc3QudHMiLCIvc291cmNlL2t1YmUzZC90cy9vYmplY3RzLnRzIiwiL3NvdXJjZS9rdWJlM2QvdHMvd29ybGQudHMiLCIvc291cmNlL2t1YmUzZC90cy9wbGF5ZXIudHMiLCIvc291cmNlL2t1YmUzZC90cy90aHJlZUpTRGlyZWN0aXZlLnRzIiwiL3NvdXJjZS9rdWJlM2QvdHMvdmlldy50cyIsIi9zb3VyY2Uva3ViZTNkL3RzL3ZveGVsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy83QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4Z0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOURBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMXNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy8vRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlybUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2pZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3RGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMXNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDclRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqQkEsMkRBQTJEO0FBQzNELDREQUE0RDtBQUM1RCxHQUFHO0FBQ0gsbUVBQW1FO0FBQ25FLG9FQUFvRTtBQUNwRSwyQ0FBMkM7QUFDM0MsR0FBRztBQUNILGdEQUFnRDtBQUNoRCxHQUFHO0FBQ0gsdUVBQXVFO0FBQ3ZFLHFFQUFxRTtBQUNyRSw0RUFBNEU7QUFDNUUsdUVBQXVFO0FBQ3ZFLGtDQUFrQztBQUVsQywwREFBMEQ7QUFDMUQsMkRBQTJEOztBQ2hCM0QsQUFDQSx5Q0FEeUM7QUFDekMsSUFBTyxNQUFNLENBb0JaO0FBcEJELFdBQU8sTUFBTSxFQUFDLENBQUM7SUFFRixRQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ04sUUFBQyxHQUFHLENBQUMsQ0FBQztJQUNOLFdBQUksR0FBRyxRQUFDLENBQUM7SUFDVCxZQUFLLEdBQUcsUUFBQyxDQUFDO0lBRVYsZ0JBQVMsR0FBRyxHQUFHLENBQUM7SUFDaEIsa0JBQVcsR0FBRyxDQUFDLGdCQUFTLENBQUM7SUFXbkMsQ0FBQztBQUNKLENBQUMsRUFwQk0sTUFBTSxLQUFOLE1BQU0sUUFvQlo7O0FDckJELHlDQUF5QztBQUN6QywyQ0FBMkM7QUFHM0MsSUFBSSxVQUFVLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7QUFDOUMsSUFBSSxPQUFPLEdBQUcsT0FBTyxDQUFDLHNCQUFzQixDQUFDLENBQUM7QUFDOUMsSUFBSSxHQUFHLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBQy9CLElBQUksSUFBSSxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUNqQyxJQUFJLFNBQVMsR0FBRyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQztBQUMzQyxJQUFJLE1BQU0sR0FBRyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUM7QUFDckMsSUFBSSxTQUFTLEdBQUcsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBRXJDLElBQU8sTUFBTSxDQXVDWjtBQXZDRCxXQUFPLE1BQU0sRUFBQyxDQUFDO0lBQ0YsaUJBQVUsR0FBRyxRQUFRLENBQUM7SUFDdEIsVUFBRyxHQUFrQixNQUFNLENBQUMsR0FBRyxDQUFDLGlCQUFVLENBQUMsQ0FBQztJQUM1QyxtQkFBWSxHQUFHLHFCQUFxQixDQUFDO0lBQ3JDLHNCQUFlLEdBQUcsb0JBQW9CLElBQUksUUFBUSxJQUFJLHVCQUF1QixJQUFJLFFBQVEsSUFBSSwwQkFBMEIsSUFBSSxRQUFRLENBQUM7SUFHcEksYUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBRWhDLGtCQUF5QixDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7UUFDOUIsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUUsQ0FBQztJQUZlLGVBQVEsV0FFdkIsQ0FBQTtJQUVEO1FBQ0UsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFDdkMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQzFDLENBQUM7SUFIZSxpQkFBVSxhQUd6QixDQUFBO0lBRUQ7UUFDRSxJQUFJLENBQUM7WUFDSCxJQUFJLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFFLFFBQVEsQ0FBRSxDQUFDO1lBQ2hELE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBUSxNQUFPLENBQUMscUJBQXFCLElBQUksQ0FDNUMsTUFBTSxDQUFDLFVBQVUsQ0FBRSxPQUFPLENBQUU7Z0JBQzVCLE1BQU0sQ0FBQyxVQUFVLENBQUUsb0JBQW9CLENBQUUsQ0FBRSxDQUM1QyxDQUFDO1FBQ1IsQ0FBRTtRQUFBLEtBQUssQ0FBQyxDQUFFLENBQUUsQ0FBQyxDQUFDLENBQUM7WUFDYixNQUFNLENBQUMsS0FBSyxDQUFDO1FBQ2YsQ0FBQztJQUNILENBQUM7SUFWZSxxQkFBYyxpQkFVN0IsQ0FBQTtJQUVELHFCQUE0QixLQUFLLEVBQUUsS0FBSyxFQUFFLE9BQWU7UUFBZix1QkFBZSxHQUFmLGVBQWU7UUFDdkQsSUFBSSxDQUFDLEdBQUcsS0FBSyxHQUFHLGdCQUFTLENBQUM7UUFDMUIsSUFBSSxDQUFDLEdBQUcsS0FBSyxHQUFHLGdCQUFTLENBQUM7UUFDMUIsSUFBSSxDQUFDLEdBQUcsT0FBTyxHQUFHLGtCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBQ2xDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbkIsQ0FBQztJQUxlLGtCQUFXLGNBSzFCLENBQUE7QUFJSCxDQUFDLEVBdkNNLE1BQU0sS0FBTixNQUFNLFFBdUNaOztBQ25ERCx3Q0FBd0M7QUFFeEMsSUFBTyxNQUFNLENBZ0NaO0FBaENELFdBQU8sTUFBTSxFQUFDLENBQUM7SUFFRixjQUFPLEdBQUcsT0FBTyxDQUFDLE1BQU0sQ0FBQyxpQkFBVSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3pDLGlCQUFVLEdBQUcsYUFBYSxDQUFDLHdCQUF3QixDQUFDLGNBQU8sRUFBRSxpQkFBVSxDQUFDLENBQUM7SUFFcEYsSUFBSSxHQUFHLEdBQUcsU0FBUyxDQUFDO0lBRXBCLGNBQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxnQkFBZ0IsRUFBRSwwQkFBMEIsRUFBRSxVQUFDLGNBQXVDLEVBQUUsT0FBcUM7WUFDM0ksR0FBRyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUU7aUJBQ25CLEVBQUUsQ0FBQyxpQkFBVSxDQUFDO2lCQUNkLEtBQUssQ0FBQyxjQUFNLE9BQUEsU0FBUyxFQUFULENBQVMsQ0FBQztpQkFDdEIsSUFBSSxDQUFDLGNBQU0sT0FBQSxnQkFBZ0IsRUFBaEIsQ0FBZ0IsQ0FBQztpQkFDNUIsSUFBSSxDQUFDLGNBQU0sT0FBQSxPQUFPLENBQUMsSUFBSSxDQUFDLG1CQUFZLEVBQUUsV0FBVyxDQUFDLEVBQXZDLENBQXVDLENBQUM7aUJBQ25ELEtBQUssRUFBRSxDQUFDO1lBQ1gsT0FBTyxDQUFDLGdCQUFnQixDQUFDLGNBQWMsRUFBRSxHQUFHLENBQUMsQ0FBQztRQUVoRCxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRUosY0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLFdBQVcsRUFBRSxVQUFDLEdBQUc7WUFDNUIsR0FBRyxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxpQkFBVSxFQUFFLFVBQUMsSUFBSTtnQkFDakQsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsS0FBSyxZQUFZLENBQUMsQ0FBQyxDQUFDO29CQUM3QixNQUFNLENBQUM7Z0JBQ1QsQ0FBQztnQkFDRCxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxVQUFDLEdBQU8sSUFBSyxPQUFBLEdBQUcsQ0FBQyxFQUFFLEtBQUssaUJBQVUsRUFBckIsQ0FBcUIsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDMUQsSUFBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ3RCLENBQUM7WUFDSCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFHSixrQkFBa0IsQ0FBQyxTQUFTLENBQUMsaUJBQVUsQ0FBQyxDQUFDO0FBRTNDLENBQUMsRUFoQ00sTUFBTSxLQUFOLE1BQU0sUUFnQ1o7O0FDbENELHVDQUF1QztBQUV2QyxJQUFPLE1BQU0sQ0FvRFo7QUFwREQsV0FBTyxNQUFNLEVBQUMsQ0FBQztJQUViLGNBQU8sQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLENBQUMsV0FBVyxFQUFFLFVBQUMsU0FBUztZQUN2RCxNQUFNLENBQUM7Z0JBQ0wsUUFBUSxFQUFFLEdBQUc7Z0JBQ2IsS0FBSyxFQUFFO29CQUNMLFFBQVEsRUFBRSxjQUFjO2lCQUN6QjtnQkFDRCxJQUFJLEVBQUUsVUFBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLElBQUk7b0JBQ3pCLElBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxPQUFPLENBQUM7b0JBQy9CLEVBQUUsQ0FBQyxDQUFDLHNCQUFlLENBQUMsQ0FBQyxDQUFDO3dCQUNwQixVQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO3dCQUNuQixJQUFJLEdBQUcsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3ZCLElBQUksSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUM7d0JBRXBCLElBQUksaUJBQWlCLEdBQUcsVUFBQyxLQUFLOzRCQUM1QixFQUFFLENBQUMsQ0FBRSxHQUFHLENBQUMsa0JBQWtCLEtBQUssSUFBSTtnQ0FDL0IsR0FBRyxDQUFDLHFCQUFxQixLQUFLLElBQUk7Z0NBQ2xDLEdBQUcsQ0FBQyx3QkFBd0IsS0FBSyxJQUFLLENBQUMsQ0FBQyxDQUFDO2dDQUM1QyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7Z0NBQzFCLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQzs0QkFDL0IsQ0FBQzs0QkFBQyxJQUFJLENBQUMsQ0FBQztnQ0FDTixFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7Z0NBQ3RCLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQzs0QkFDaEMsQ0FBQzs0QkFDRCxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO3dCQUNyQixDQUFDLENBQUM7d0JBRUYsSUFBSSxnQkFBZ0IsR0FBRyxVQUFDLEtBQUs7NEJBQzNCLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQzt3QkFDeEIsQ0FBQyxDQUFDO3dCQUVGLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBRSxtQkFBbUIsRUFBRSxpQkFBaUIsRUFBRSxLQUFLLENBQUUsQ0FBQzt3QkFDdEUsR0FBRyxDQUFDLGdCQUFnQixDQUFFLHNCQUFzQixFQUFFLGlCQUFpQixFQUFFLEtBQUssQ0FBRSxDQUFDO3dCQUN6RSxHQUFHLENBQUMsZ0JBQWdCLENBQUUseUJBQXlCLEVBQUUsaUJBQWlCLEVBQUUsS0FBSyxDQUFFLENBQUM7d0JBRTVFLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBRSxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSxLQUFLLENBQUUsQ0FBQzt3QkFDcEUsR0FBRyxDQUFDLGdCQUFnQixDQUFFLHFCQUFxQixFQUFFLGdCQUFnQixFQUFFLEtBQUssQ0FBRSxDQUFDO3dCQUN2RSxHQUFHLENBQUMsZ0JBQWdCLENBQUUsd0JBQXdCLEVBQUUsZ0JBQWdCLEVBQUUsS0FBSyxDQUFFLENBQUM7d0JBRTFFLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBQyxLQUFLOzRCQUNqQyxFQUFFLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7NEJBQzFCLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsa0JBQWtCLElBQUksSUFBSSxDQUFDLHFCQUFxQixJQUFJLElBQUksQ0FBQyx3QkFBd0IsQ0FBQzs0QkFDakgsSUFBSSxDQUFDLGtCQUFrQixFQUFFLENBQUM7d0JBQzVCLENBQUMsQ0FBQyxDQUFDO29CQUNMLENBQUM7b0JBQUMsSUFBSSxDQUFDLENBQUM7d0JBQ04sRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO29CQUM1QixDQUFDO2dCQUNILENBQUM7YUFDRixDQUFBO1FBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUVOLENBQUMsRUFwRE0sTUFBTSxLQUFOLE1BQU0sUUFvRFo7Ozs7Ozs7O0FDdERELEFBQ0EsMkNBRDJDO0FBQzNDLElBQU8sTUFBTSxDQTJRWjtBQTNRRCxXQUFPLE1BQU0sRUFBQyxDQUFDO0lBRWIsSUFBSSxHQUFHLEdBQWtCLE1BQU0sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7SUFFOUM7UUFJRSx5QkFBbUIsS0FBUyxFQUFTLFFBQVk7WUFBOUIsVUFBSyxHQUFMLEtBQUssQ0FBSTtZQUFTLGFBQVEsR0FBUixRQUFRLENBQUk7WUFGekMsZ0JBQVcsR0FBTyxJQUFJLENBQUM7WUFHN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDekIsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBQ3hFLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBRU0saUNBQU8sR0FBZDtZQUNFLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNqQyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3hCLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztRQUN2QixDQUFDO1FBRU0sK0JBQUssR0FBWixVQUFhLE1BQU07WUFDakIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDO1FBQ3BDLENBQUM7UUFFTSw4QkFBSSxHQUFYLFVBQVksQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ2pCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDOUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM5QixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzlCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDakMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUNqQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25DLENBQUM7UUFFTSxnQ0FBTSxHQUFiLFVBQWMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDL0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUMvQixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1lBQy9CLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDbEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztZQUNsQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3BDLENBQUM7UUFFTSxxQ0FBVyxHQUFsQjtZQUNFLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDMUIsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQztRQUMxQyxDQUFDO1FBRU0scUNBQVcsR0FBbEIsVUFBbUIsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDN0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM3QixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBQzdCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDaEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNoQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBRWxDLENBQUM7UUFFTSxxQ0FBVyxHQUFsQixVQUFtQixFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUU7WUFDM0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUM5QixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQzlCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDOUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUM5QixJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQzlCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDaEMsQ0FBQztRQUVNLGdDQUFNLEdBQWI7WUFDRSxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzVCLENBQUM7UUFFSCxzQkFBQztJQUFELENBbEVBLEFBa0VDLElBQUE7SUFsRVksc0JBQWUsa0JBa0UzQixDQUFBO0lBRUQ7UUFBK0IsNkJBQWU7UUFRNUMsbUJBQW1CLEtBQVUsRUFBUyxVQUFxQixFQUFTLEVBQVMsRUFBUyxHQUFPO1lBQzNGLGtCQUFNLEtBQUssRUFBRSxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1lBRGxCLFVBQUssR0FBTCxLQUFLLENBQUs7WUFBUyxlQUFVLEdBQVYsVUFBVSxDQUFXO1lBQVMsT0FBRSxHQUFGLEVBQUUsQ0FBTztZQUFTLFFBQUcsR0FBSCxHQUFHLENBQUk7WUFQckYsVUFBSyxHQUFVLFNBQVMsQ0FBQztZQUN6QixXQUFNLEdBQU8sU0FBUyxDQUFDO1lBQ3ZCLGFBQVEsR0FBRztnQkFDakIsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLElBQUk7Z0JBQ2pDLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHO2dCQUNoQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSTthQUNsQyxDQUFDO1lBR0EsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3pELE9BQU8sQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQztZQUN4QyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FDYixJQUFJLEtBQUssQ0FBQyxJQUFJLENBQ1osSUFBSSxLQUFLLENBQUMsV0FBVyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQ2pDLElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDO2dCQUMxQixLQUFLLEVBQUUsUUFBUTtnQkFDZixHQUFHLEVBQUUsT0FBTztnQkFDWixPQUFPLEVBQUUsT0FBTztnQkFDaEIsVUFBVSxFQUFFLElBQUk7Z0JBQ2hCLGFBQWEsRUFBRSxJQUFJO2dCQUNuQixPQUFPLEVBQUUsS0FBSyxDQUFDLGFBQWE7YUFDN0IsQ0FBQyxDQUNELENBQUMsQ0FBQztZQUNULEdBQUcsQ0FBQyxLQUFLLENBQUMscUJBQXFCLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDdkMsQ0FBQztRQUVNLDBCQUFNLEdBQWIsVUFBYyxLQUFLLEVBQUUsR0FBRztZQUN0QixJQUFJLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztRQUNqQixDQUFDO1FBRU0sMkJBQU8sR0FBZDtZQUNFLGdCQUFLLENBQUMsT0FBTyxXQUFFLENBQUM7WUFDaEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM3QyxHQUFHLENBQUMsS0FBSyxDQUFDLHVCQUF1QixFQUFFLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUM5QyxDQUFDO1FBRU8sNEJBQVEsR0FBaEI7WUFDRSxJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ2pELElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNwQyxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BELElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDcEQsTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUM7UUFDbEQsQ0FBQztRQUVPLG1DQUFlLEdBQXZCO1lBQ0UsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztnQkFDaEIsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO2dCQUMzQixHQUFHLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFLGFBQWEsRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDcEQsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7Z0JBQzdCLEdBQUcsQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUUsVUFBVSxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDdkQsSUFBSSxhQUFhLEdBQUcsRUFBRSxDQUFDO2dCQUN2QixJQUFJLElBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQztvQkFDckMsS0FBSyxFQUFFLFFBQVE7b0JBQ2YsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLGFBQWEsRUFBRSxJQUFJO29CQUNuQixTQUFTLEVBQUUsSUFBSTtpQkFDaEIsQ0FBQyxDQUFDO2dCQUNILGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Z0JBQ2pDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7Z0JBQ2pDLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLEVBQUUsSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztnQkFDekgsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUM1QyxDQUFDO1lBQ0QsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDcEIsQ0FBQztRQUVNLDBCQUFNLEdBQWI7WUFDRSxJQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDcEMsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNqRCxJQUFJLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDckIsSUFBSSxPQUFPLEdBQUcsWUFBWSxDQUFDLENBQUMsQ0FBQztZQUM3QixJQUFJLE9BQU8sR0FBRyxZQUFZLENBQUMsQ0FBQyxDQUFDO1lBQzdCLElBQUksT0FBTyxHQUFHLENBQUMsR0FBRyxPQUFPLENBQUM7WUFDMUIsSUFBSSxPQUFPLEdBQUcsQ0FBQyxHQUFHLE9BQU8sQ0FBQztZQUMxQixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsZUFBZSxFQUFFLENBQUM7WUFDbkMsSUFBSSxJQUFJLEdBQUcsT0FBTyxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzNFLElBQUksSUFBSSxHQUFHLE9BQU8sR0FBRyxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUMzRSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDaEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQy9ELGdCQUFLLENBQUMsTUFBTSxXQUFFLENBQUM7UUFDakIsQ0FBQztRQUNILGdCQUFDO0lBQUQsQ0FsRkEsQUFrRkMsRUFsRjhCLGVBQWUsRUFrRjdDO0lBbEZZLGdCQUFTLFlBa0ZyQixDQUFBO0lBRUQ7UUFBZ0MsOEJBQWU7UUFVN0Msb0JBQVksS0FBVSxFQUFTLEVBQVMsRUFBUyxHQUFPO1lBQ3RELGtCQUFNLEtBQUssRUFBRSxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFBO1lBREwsT0FBRSxHQUFGLEVBQUUsQ0FBTztZQUFTLFFBQUcsR0FBSCxHQUFHLENBQUk7WUFUaEQsWUFBTyxHQUFHLEdBQUcsQ0FBQztZQUNkLFlBQU8sR0FBRyxHQUFHLENBQUM7WUFDZixTQUFJLEdBQUcsRUFBRSxDQUFDO1lBQ1YsYUFBUSxHQUFHO2dCQUNoQixDQUFDLEVBQUUsQ0FBQztnQkFDSixDQUFDLEVBQUUsQ0FBQztnQkFDSixDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSTthQUNsQyxDQUFBO1lBeUZPLFNBQUksR0FBRyxDQUFDLENBQUM7WUFyRmYsSUFBSSxPQUFPLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMscUJBQXFCLENBQUMsQ0FBQztZQUNsRSxPQUFPLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQyxhQUFhLENBQUM7WUFDeEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQ2IsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQ3ZDLElBQUksS0FBSyxDQUFDLElBQUksQ0FDWixJQUFJLEtBQUssQ0FBQyxjQUFjLENBQUMsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFDckMsSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUM7Z0JBQzFCLEtBQUssRUFBRSxRQUFRO2dCQUNmLEdBQUcsRUFBRSxPQUFPO2dCQUNaLE9BQU8sRUFBRSxPQUFPO2dCQUNoQixRQUFRLEVBQUUsUUFBUTtnQkFDbEIsT0FBTyxFQUFFLEtBQUssQ0FBQyxhQUFhO2FBQzdCLENBQUMsQ0FDSCxDQUNGLENBQUM7WUFDSixHQUFHLENBQUMsS0FBSyxDQUFDLHNCQUFzQixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3hDLENBQUM7UUFFTSwyQkFBTSxHQUFiLFVBQWMsS0FBSyxFQUFFLElBQUk7WUFBekIsaUJBa0JDO1lBakJDLElBQUksQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDO1lBQ2hCLElBQUksWUFBWSxHQUFHLEVBQUUsQ0FBQztZQUN0QixDQUFDLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsVUFBQyxHQUFHLEVBQUUsR0FBRztnQkFDMUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUM5QixZQUFZLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUN6QixDQUFDO1lBQ0gsQ0FBQyxDQUFDLENBQUM7WUFDSCxDQUFDLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxVQUFDLEVBQUUsSUFBSyxPQUFBLEtBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEVBQWxCLENBQWtCLENBQUMsQ0FBQztZQUNwRCxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLFVBQUMsR0FBTztnQkFDL0IsSUFBSSxJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQztnQkFDcEIsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDdkIsS0FBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ3pCLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ04sSUFBSSxNQUFNLEdBQUcsS0FBSSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDN0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQzVCLENBQUM7WUFDSCxDQUFDLENBQUMsQ0FBQztRQUNMLENBQUM7UUFFTSwwQkFBSyxHQUFaLFVBQWEsTUFBTTtZQUFuQixpQkFJQztZQUhDLElBQUksR0FBRyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFBO1lBQzNCLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLFVBQUMsRUFBRSxJQUFLLE9BQUEsS0FBSSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQTNCLENBQTJCLENBQUMsQ0FBQztZQUNwRCxnQkFBSyxDQUFDLEtBQUssWUFBQyxNQUFNLENBQUMsQ0FBQztRQUN0QixDQUFDO1FBRU0sNEJBQU8sR0FBZDtZQUFBLGlCQU9DO1lBTkMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7Z0JBQ2QsSUFBSSxNQUFNLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQy9CLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLFVBQUMsRUFBRSxJQUFLLE9BQUEsS0FBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLENBQUMsRUFBbEIsQ0FBa0IsQ0FBQyxDQUFDO1lBQ2hELENBQUM7WUFDRCxnQkFBSyxDQUFDLE9BQU8sV0FBRSxDQUFDO1lBQ2hCLEdBQUcsQ0FBQyxLQUFLLENBQUMseUJBQXlCLEVBQUUsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2hELENBQUM7UUFFTSw4QkFBUyxHQUFoQixVQUFpQixFQUFFO1lBQ2pCLElBQUksR0FBRyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDeEIsRUFBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDUixHQUFHLENBQUMsT0FBTyxFQUFFLENBQUM7Z0JBQ2QsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1lBQ3ZCLENBQUM7UUFDSCxDQUFDO1FBRU0sMkJBQU0sR0FBYixVQUFjLEdBQUcsRUFBRSxDQUFLO1lBQ3RCLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyQixNQUFNLENBQUM7WUFDVCxDQUFDO1lBQ0QsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsRUFBRSxDQUFDO1lBQ3BDLElBQUksVUFBVSxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQztZQUM3QyxJQUFJLFVBQVUsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBTTlCLElBQUksR0FBRyxHQUFHLElBQUksU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNsRCxHQUFHLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLEVBQUUsVUFBVSxDQUFDLENBQUMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDMUQsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM3QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxHQUFHLENBQUM7WUFDdkQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsR0FBRyxDQUFDO1lBQ3ZELElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsR0FBRyxDQUFDO1FBQ3ZCLENBQUM7UUFFTSwyQkFBTSxHQUFiLFVBQWMsRUFBRTtZQUNkLE1BQU0sQ0FBQyxDQUFDLEVBQUUsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0IsQ0FBQztRQUlNLDJCQUFNLEdBQWI7WUFDRSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDL0QsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLFVBQUMsU0FBUyxFQUFFLEVBQUU7Z0JBQy9CLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNyQixDQUFDLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLENBQUM7WUFDMUIsZ0JBQUssQ0FBQyxNQUFNLFdBQUUsQ0FBQztRQUNqQixDQUFDO1FBR0gsaUJBQUM7SUFBRCxDQTdHQSxBQTZHQyxFQTdHK0IsZUFBZSxFQTZHOUM7SUE3R1ksaUJBQVUsYUE2R3RCLENBQUE7QUFFSCxDQUFDLEVBM1FNLE1BQU0sS0FBTixNQUFNLFFBMlFaOztBQzVRRCx3Q0FBd0M7QUFFeEMsSUFBTyxNQUFNLENBNkhaO0FBN0hELFdBQU8sTUFBTSxFQUFDLENBQUM7SUFFYixJQUFJLFNBQVMsR0FDWDtRQUNFLENBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsQ0FBRTtRQUMxQixDQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLENBQUU7UUFDMUIsQ0FBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxDQUFFO1FBQzFCLENBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsQ0FBRTtRQUMxQixDQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLENBQUU7UUFDMUIsQ0FBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxDQUFFO1FBQzFCLENBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsQ0FBRTtRQUMxQixDQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLEVBQUUsUUFBQyxFQUFFLFFBQUMsRUFBRSxRQUFDLENBQUU7S0FDM0IsQ0FBQztJQUVKLElBQUksVUFBVSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7SUFDckMsSUFBSSxXQUFXLEdBQUcsU0FBUyxDQUFDLE1BQU0sQ0FBQztJQTBCbkMsaUJBQWlCLEtBQUssRUFBRSxLQUFLLEVBQUUsT0FBZTtRQUFmLHVCQUFlLEdBQWYsZUFBZTtRQU01QyxNQUFNLENBQUMsU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFFRDtRQUlFLGVBQTJCLEtBQUs7WUFBTCxVQUFLLEdBQUwsS0FBSyxDQUFBO1lBSHhCLFlBQU8sR0FBRyxJQUFJLEtBQUssQ0FBQyxZQUFZLENBQUUsUUFBUSxDQUFFLENBQUM7WUFDN0MsVUFBSyxHQUFHLElBQUksS0FBSyxDQUFDLGdCQUFnQixDQUFFLFFBQVEsQ0FBRSxDQUFDO1lBR3JELElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBRSxDQUFDO1lBQzNDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBRWxDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3hCLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBR3RCLElBQUksYUFBYSxHQUFHLEVBQUUsQ0FBQztZQUN2QixHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRTtnQkFDeEIsYUFBYSxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQztvQkFDN0MsR0FBRyxFQUFFLEtBQUssQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLHdCQUF3QixDQUFDO29CQUMzRCxJQUFJLEVBQUUsS0FBSyxDQUFDLFFBQVE7aUJBQ3JCLENBQUMsQ0FBQyxDQUFDO1lBQ04sSUFBSSxXQUFXLEdBQUcsSUFBSSxLQUFLLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDNUQsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLEVBQUUsV0FBVyxDQUFDLENBQUMsQ0FBQztZQUduRixDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxVQUFDLEdBQUcsRUFBRSxDQUFDO2dCQUMxQixDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxVQUFDLElBQUksRUFBRSxDQUFDO29CQUNyQixNQUFNLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO3dCQUNiLEtBQUssV0FBSTs0QkFDUCxLQUFLLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7NEJBQ2hDLEtBQUssQ0FBQztvQkFDVixDQUFDO29CQUNELEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFDakMsQ0FBQyxDQUFDLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztRQWVMLENBQUM7UUFFTSwyQkFBVyxHQUFsQixVQUFtQixNQUFNO1lBQ3ZCLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDM0IsQ0FBQztRQUVNLDJCQUFXLEdBQWxCLFVBQW1CLE1BQU07WUFDdkIsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztnQkFDaEMsTUFBTSxDQUFDO1lBQ1QsQ0FBQztZQUNELElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUNULEdBQUcsQ0FBQztnQkFDRixDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JELENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLFdBQVcsR0FBRSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztnQkFDckQsVUFBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUMsQ0FBQyxFQUFDLElBQUksRUFBQyxDQUFDLEVBQUMsTUFBTSxFQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2xELENBQUMsUUFBUSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssWUFBSyxFQUFDO1lBQ25DLE1BQU0sQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLGtCQUFXLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDL0MsQ0FBQztRQUVNLHNCQUFNLEdBQWI7UUFFQSxDQUFDO1FBRU0sdUJBQU8sR0FBZDtRQUVBLENBQUM7UUFFSCxZQUFDO0lBQUQsQ0F6RUEsQUF5RUMsSUFBQTtJQXpFWSxZQUFLLFFBeUVqQixDQUFBO0FBRUgsQ0FBQyxFQTdITSxNQUFNLEtBQU4sTUFBTSxRQTZIWjs7QUMvSEQsd0NBQXdDO0FBQ3hDLGdDQUFnQztBQUVoQyxJQUFPLE1BQU0sQ0FtTlo7QUFuTkQsV0FBTyxNQUFNLEVBQUMsQ0FBQztJQUViO1FBNkJFLGdCQUEyQixLQUFLLEVBQVUsTUFBTSxFQUFVLENBQUMsRUFBVSxLQUFXO1lBQXJELFVBQUssR0FBTCxLQUFLLENBQUE7WUFBVSxXQUFNLEdBQU4sTUFBTSxDQUFBO1lBQVUsTUFBQyxHQUFELENBQUMsQ0FBQTtZQUFVLFVBQUssR0FBTCxLQUFLLENBQU07WUE1QnhFLFFBQUcsR0FBa0IsTUFBTSxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUMsQ0FBQztZQUNqRCxlQUFVLEdBQU8sSUFBSSxDQUFDO1lBQ3RCLFlBQU8sR0FBTyxJQUFJLENBQUM7WUFDbkIsVUFBSyxHQUFHLElBQUksS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO1lBQzdCLFFBQUcsR0FBRyxJQUFJLEtBQUssQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUUzQixhQUFRLEdBQUcsS0FBSyxDQUFDO1lBQ2pCLGNBQVMsR0FBRyxTQUFTLENBQUM7WUFFdEIsb0JBQWUsR0FBTyxjQUFNLE9BQUEsRUFBRSxFQUFGLENBQUUsQ0FBQztZQUUvQixjQUFTLEdBQUcsSUFBSSxLQUFLLENBQUMsU0FBUyxDQUFDLElBQUksS0FBSyxDQUFDLE9BQU8sRUFBRSxFQUFFLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBR3pGLFlBQU8sR0FBRyxLQUFLLENBQUM7WUFDaEIsYUFBUSxHQUFHLEtBQUssQ0FBQztZQUNqQixTQUFJLEdBQUcsS0FBSyxDQUFDO1lBQ2IsVUFBSyxHQUFHLEtBQUssQ0FBQztZQUNkLFlBQU8sR0FBRyxJQUFJLENBQUM7WUFDZixZQUFPLEdBQUcsS0FBSyxDQUFDO1lBR2hCLGFBQVEsR0FBRyxJQUFJLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUMvQixhQUFRLEdBQUcsV0FBVyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBRzdCLGFBQVEsR0FBTyxJQUFJLENBQUM7WUFpSXBCLG9CQUFlLEdBQUcsR0FBRyxDQUFDO1lBQ3RCLG9CQUFlLEdBQUcsR0FBRyxDQUFDO1lBOUg1QixNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQzdCLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDN0IsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3pCLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRXBCLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFaEMsSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFeEMsRUFBRSxDQUFDLENBQUMsQ0FBQyxzQkFBZSxDQUFDLENBQUMsQ0FBQztnQkFDckIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFDdEIsQ0FBQztZQUVELElBQUksSUFBSSxHQUFHLElBQUksQ0FBQztZQUVoQixJQUFJLENBQUMsUUFBUSxHQUFHO2dCQUNkLFNBQVMsRUFBRSxVQUFDLEtBQVM7b0JBQ25CLE1BQU0sQ0FBQyxDQUFFLEtBQUssQ0FBQyxPQUFRLENBQUMsQ0FBQyxDQUFDO3dCQUN4QixLQUFLLEVBQUUsQ0FBQzt3QkFDUixLQUFLLEVBQUU7NEJBQ0wsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7NEJBQ3BCLEtBQUssQ0FBQzt3QkFDUixLQUFLLEVBQUUsQ0FBQzt3QkFDUixLQUFLLEVBQUU7NEJBQ0wsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUM7NEJBQ2pCLEtBQUssQ0FBQzt3QkFDUixLQUFLLEVBQUUsQ0FBQzt3QkFDUixLQUFLLEVBQUU7NEJBQ0wsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7NEJBQ3JCLEtBQUssQ0FBQzt3QkFDUixLQUFLLEVBQUUsQ0FBQzt3QkFDUixLQUFLLEVBQUU7NEJBQ0wsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7NEJBQ2xCLEtBQUssQ0FBQzt3QkFDUixLQUFLLEVBQUU7NEJBQ0wsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7NEJBQ3BCLEtBQUssQ0FBQzt3QkFDUixLQUFLLEVBQUU7NEJBQ0wsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO2dDQUMxQixJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUM7Z0NBQ3ZCLElBQUksQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDOzRCQUN2QixDQUFDOzRCQUNELEtBQUssQ0FBQztvQkFDVixDQUFDO2dCQUNILENBQUM7Z0JBQ0QsT0FBTyxFQUFFLFVBQUMsS0FBUztvQkFDakIsTUFBTSxDQUFDLENBQUUsS0FBSyxDQUFDLE9BQVEsQ0FBQyxDQUFDLENBQUM7d0JBQ3hCLEtBQUssRUFBRSxDQUFDO3dCQUNSLEtBQUssRUFBRTs0QkFDTCxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzs0QkFDckIsS0FBSyxDQUFDO3dCQUNSLEtBQUssRUFBRSxDQUFDO3dCQUNSLEtBQUssRUFBRTs0QkFDTCxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQzs0QkFDbEIsS0FBSyxDQUFDO3dCQUNSLEtBQUssRUFBRSxDQUFDO3dCQUNSLEtBQUssRUFBRTs0QkFDTCxJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQzs0QkFDdEIsS0FBSyxDQUFDO3dCQUNSLEtBQUssRUFBRSxDQUFDO3dCQUNSLEtBQUssRUFBRTs0QkFDTCxJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQzs0QkFDbkIsS0FBSyxDQUFDO3dCQUNSLEtBQUssRUFBRTs0QkFDTCxJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzs0QkFDckIsS0FBSyxDQUFDO29CQUNWLENBQUM7Z0JBQ0gsQ0FBQztnQkFDRCxXQUFXLEVBQUUsVUFBQyxLQUFTO29CQUNyQixFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLElBQUksQ0FBQyxzQkFBZSxDQUFDLENBQUMsQ0FBQzt3QkFDdkMsTUFBTSxDQUFDO29CQUNULENBQUM7b0JBQ0QsSUFBSSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQztvQkFDbkIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztvQkFDdkIsSUFBSSxNQUFNLEdBQUcsS0FBSyxDQUFDLFNBQVMsSUFBSSxLQUFLLENBQUMsWUFBWSxJQUFJLEtBQUssQ0FBQyxlQUFlLElBQUksQ0FBQyxDQUFDO29CQUNqRixJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUMsU0FBUyxJQUFJLEtBQUssQ0FBQyxZQUFZLElBQUksS0FBSyxDQUFDLGVBQWUsSUFBSSxDQUFDLENBQUM7b0JBQ2pGLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUM7b0JBQ2pDLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLE1BQU0sR0FBRyxLQUFLLENBQUM7b0JBQ25DLEtBQUssQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxhQUFNLEVBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFNLEVBQUUsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUMzRSxDQUFDO2FBQ0YsQ0FBQztZQUNGLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxVQUFDLE9BQU8sRUFBRSxHQUFHLElBQUssT0FBQSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsR0FBRyxFQUFFLE9BQU8sRUFBRSxLQUFLLENBQUMsRUFBOUMsQ0FBOEMsQ0FBQyxDQUFDO1FBQzNGLENBQUM7UUFFRCxzQkFBVywyQkFBTztpQkFxQmxCO2dCQUNFLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO1lBQ3ZCLENBQUM7aUJBdkJELFVBQW1CLE9BQU87Z0JBQ3hCLElBQUksQ0FBQyxRQUFRLEdBQUcsT0FBTyxDQUFDO2dCQUN4QixFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDO29CQUNaLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUNsQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDbEMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQ2xDLElBQUksS0FBSyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxDQUFDLENBQUM7b0JBQzdELElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUNuQyxJQUFJLENBQUMsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3RDLENBQUM7Z0JBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ04sSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7b0JBQy9CLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUMvQixJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDbkMsQ0FBQztZQUVILENBQUM7OztXQUFBO1FBRU0sd0NBQXVCLEdBQTlCLFVBQStCLElBQUk7WUFDakMsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7UUFDOUIsQ0FBQztRQU1ELHNCQUFXLDBCQUFNO2lCQUFqQjtnQkFDRSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztZQUNsQixDQUFDOzs7V0FBQTtRQUVNLHVCQUFNLEdBQWIsVUFBYyxHQUFHO1lBQ2YsSUFBSSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7UUFDckIsQ0FBQztRQUVNLHdCQUFPLEdBQWQ7WUFDRSxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDNUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNuQixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ3JCLENBQUMsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxVQUFDLE9BQU8sRUFBRSxHQUFHLElBQUssT0FBQSxRQUFRLENBQUMsbUJBQW1CLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxFQUExQyxDQUEwQyxDQUFDLENBQUM7UUFDdkYsQ0FBQztRQUtNLHVCQUFNLEdBQWI7WUFDRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxzQkFBZSxDQUFDLENBQUMsQ0FBQztnQkFDdEMsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7b0JBQ2pCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxNQUFNLENBQUM7b0JBQ2hDLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7Z0JBQ3pDLENBQUM7Z0JBQ0QsTUFBTSxDQUFDO1lBQ1QsQ0FBQztZQUNELElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7WUFDL0IsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQztZQUM3QixJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1lBQ3JCLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBRSxJQUFJLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBRSxDQUFDO1lBQy9DLFNBQVMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUM7WUFDN0IsSUFBSSxPQUFPLEdBQUcsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1lBQ3JDLElBQUksYUFBYSxHQUFHLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUN4RCxJQUFJLFVBQVUsR0FBRyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztZQUMxQyxJQUFJLElBQUksR0FBRyxXQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7WUFDN0IsSUFBSSxRQUFRLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7WUFDcEMsSUFBSSxRQUFRLEdBQUcsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDMUUsSUFBSSxLQUFLLEdBQUcsUUFBUSxHQUFHLFFBQVEsQ0FBQztZQUNoQyxJQUFJLE1BQU0sR0FBRyxRQUFRLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztZQUU3QyxRQUFRLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLEtBQUssQ0FBQztZQUN4QyxRQUFRLENBQUMsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLEtBQUssQ0FBQztZQUN4QyxRQUFRLENBQUMsQ0FBQyxJQUFJLEdBQUcsR0FBRyxLQUFLLEdBQUcsTUFBTSxDQUFDO1lBRW5DLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7Z0JBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQzlDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7Z0JBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQy9DLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUM7Z0JBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBQzNDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7Z0JBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxLQUFLLEdBQUcsS0FBSyxDQUFDO1lBRTVDLEVBQUUsQ0FBQyxDQUFFLFVBQVUsS0FBSyxJQUFLLENBQUMsQ0FBQyxDQUFDO2dCQUMxQixRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUUsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUUsQ0FBQztnQkFDdkMsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFDdEIsQ0FBQztZQUVELEVBQUUsQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQztZQUNsQyxFQUFFLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsTUFBTSxDQUFDLENBQUM7WUFDbkMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxDQUFDO1lBRWxDLEVBQUUsQ0FBQyxDQUFFLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUcsQ0FBQyxDQUFDLENBQUM7Z0JBRXpCLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNmLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztnQkFDbkIsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7WUFDdEIsQ0FBQztZQUVELElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBQ3ZCLENBQUM7UUFDSCxhQUFDO0lBQUQsQ0FoTkEsQUFnTkMsSUFBQTtJQWhOWSxhQUFNLFNBZ05sQixDQUFBO0FBQ0gsQ0FBQyxFQW5OTSxNQUFNLEtBQU4sTUFBTSxRQW1OWjs7QUN0TkQsdUNBQXVDO0FBRXZDLElBQU8sTUFBTSxDQXNIWjtBQXRIRCxXQUFPLE1BQU0sRUFBQyxDQUFDO0lBRWIsSUFBSSxhQUFhLEdBQUcsU0FBUyxDQUFDO0lBRTlCLGNBQU8sQ0FBQyxTQUFTLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDaEMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxXQUFXLEdBQUcsRUFBRSxDQUFDO1lBQ2xDLE1BQU0sQ0FBQztnQkFDTCxRQUFRLEVBQUUsR0FBRztnQkFDYixPQUFPLEVBQUUsSUFBSTtnQkFDYixLQUFLLEVBQUU7b0JBQ0wsTUFBTSxFQUFFLElBQUksR0FBRyxhQUFhO2lCQUM3QjtnQkFDRCxJQUFJLEVBQUUsVUFBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLEtBQUs7b0JBRTFCLElBQUksS0FBSyxHQUFPLElBQUksQ0FBQztvQkFDckIsSUFBSSxNQUFNLEdBQU8sSUFBSSxDQUFDO29CQUN0QixJQUFJLFFBQVEsR0FBTyxJQUFJLENBQUM7b0JBQ3hCLElBQUksYUFBYSxHQUFHLElBQUksQ0FBQztvQkFDekIsSUFBSSxZQUFZLEdBQU8sSUFBSSxDQUFDO29CQUU1Qjt3QkFDRSxhQUFhLEdBQUcsS0FBSyxDQUFDO29CQUN4QixDQUFDO29CQUVEO3dCQUNFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDO3dCQUNwQyxPQUFPLFFBQVEsQ0FBQzt3QkFDaEIsT0FBTyxNQUFNLENBQUM7d0JBQ2QsT0FBTyxLQUFLLENBQUM7d0JBQ2IsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO29CQUNsQixDQUFDO29CQUVELElBQUksVUFBVSxHQUFHO3dCQUNiLFVBQUcsQ0FBQyxLQUFLLENBQUMsVUFBVSxDQUFDLENBQUM7d0JBQ3RCLE9BQU8sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQzt3QkFDdkUsTUFBTSxDQUFDLE1BQU0sR0FBRyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDO3dCQUNuRCxNQUFNLENBQUMsc0JBQXNCLEVBQUUsQ0FBQzt3QkFDaEMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsT0FBTyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7b0JBQ3hELENBQUMsQ0FBQTtvQkFFRCxPQUFPLENBQUMsRUFBRSxDQUFDLFVBQVUsRUFBRTt3QkFDckIsSUFBSSxFQUFFLENBQUM7d0JBQ1AsVUFBRyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO29CQUMvQixDQUFDLENBQUMsQ0FBQztvQkFFSCxLQUFLLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLFVBQUMsTUFBTTt3QkFDdkMsSUFBSSxFQUFFLENBQUM7d0JBQ1AsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQzs0QkFDbEMsVUFBRyxDQUFDLEtBQUssQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDOzRCQUNsQyxNQUFNLENBQUM7d0JBQ1QsQ0FBQzt3QkFDRCxVQUFHLENBQUMsS0FBSyxDQUFDLGdCQUFnQixDQUFDLENBQUM7d0JBRTVCLEtBQUssR0FBRyxJQUFJLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQzt3QkFDMUIsTUFBTSxHQUFHLElBQUksS0FBSyxDQUFDLGlCQUFpQixDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsT0FBTyxDQUFDLE1BQU0sRUFBRSxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQzt3QkFFekYsTUFBTSxDQUFDLEtBQUssR0FBRyxVQUFDLElBQVEsRUFBRSxLQUFLLEVBQUUsQ0FBYzs0QkFBZCxpQkFBYyxHQUFkLFVBQWM7NEJBRzdDLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7NEJBQzNCLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDOzRCQUVoRCxFQUFFLENBQUMsQ0FBQyxLQUFLLEdBQUcsQ0FBQyxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dDQUM1QixNQUFNLENBQUM7NEJBQ1QsQ0FBQzs0QkFDRCxJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUUsR0FBRyxDQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFFLENBQUMsQ0FBQyxDQUFDOzRCQUNsRixJQUFJLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUUsR0FBRyxDQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFFLENBQUMsQ0FBQyxDQUFDOzRCQUNqRixJQUFJLEtBQUssR0FBRyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUMsQ0FBQzs0QkFFNUIsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUNqQyxJQUFJLE1BQU0sR0FBRyxHQUFHLENBQUM7NEJBQ2pCLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDOzRCQUN2QyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQzs0QkFDdkMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUM7Z0NBQ2hCLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO29DQUNkLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQztvQ0FDN0IsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztnQ0FDdkIsQ0FBQztnQ0FDRCxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztvQ0FDZCxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUM7b0NBQzdCLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7Z0NBQ3ZCLENBQUM7NEJBQ0gsQ0FBQzs0QkFDRCxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO3dCQUMxQixDQUFDLENBQUM7d0JBRUYsRUFBRSxDQUFDLENBQUUscUJBQWMsRUFBRyxDQUFDLENBQUMsQ0FBQzs0QkFDdkIsUUFBUSxHQUFHLElBQUksS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFDO3dCQUN2QyxDQUFDO3dCQUFDLElBQUksQ0FBQyxDQUFDOzRCQUNOLFFBQVEsR0FBRyxJQUFJLEtBQUssQ0FBQyxjQUFjLEVBQUUsQ0FBQzt3QkFDeEMsQ0FBQzt3QkFFRCxRQUFRLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO3dCQUNoRCxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxPQUFPLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQzt3QkFDcEQsSUFBSSxVQUFVLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQzt3QkFDckMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQzt3QkFFdkQsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQzt3QkFDM0IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7d0JBRW5DLElBQUksTUFBTSxHQUFHOzRCQUNYLEVBQUUsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQztnQ0FDbkIsT0FBTyxFQUFFLENBQUM7Z0NBQ1YsTUFBTSxDQUFDOzRCQUNULENBQUM7NEJBQ0QsRUFBRSxDQUFDLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7Z0NBQ2xCLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQzs0QkFDekMsQ0FBQzs0QkFDRCxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLENBQUMsQ0FBQzs0QkFDL0IscUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUM7d0JBQ2hDLENBQUMsQ0FBQTt3QkFDRCxhQUFhLEdBQUcsSUFBSSxDQUFDO3dCQUNyQixNQUFNLEVBQUUsQ0FBQztvQkFDWCxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDL0IsQ0FBQzthQUNGLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQyxDQUFDO0FBRU4sQ0FBQyxFQXRITSxNQUFNLEtBQU4sTUFBTSxRQXNIWjs7QUN4SEQsdUNBQXVDO0FBQ3ZDLGlDQUFpQztBQUNqQyxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBRWxDLElBQU8sTUFBTSxDQStIWjtBQS9IRCxXQUFPLE1BQU0sRUFBQyxDQUFDO0lBRUYscUJBQWMsR0FBRyxpQkFBVSxDQUFDLGdCQUFnQixFQUFFLENBQUMsUUFBUSxFQUFFLGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLFVBQVUsRUFBRSxVQUFDLE1BQU0sRUFBRSxLQUF1QyxFQUFFLEtBQUssRUFBRSxRQUFRO1lBRXJMLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQztZQUV2QixJQUFJLFFBQVEsR0FBTyxTQUFTLENBQUM7WUFDN0IsSUFBSSxLQUFLLEdBQU8sU0FBUyxDQUFDO1lBQzFCLElBQUksTUFBTSxHQUFPLFNBQVMsQ0FBQztZQUMzQixJQUFJLFVBQVUsR0FBTyxTQUFTLENBQUM7WUFFL0IsSUFBSSxhQUFhLEdBQUcsSUFBSSxLQUFLLENBQUMsUUFBUSxFQUFFLENBQUM7WUFDekMsSUFBSSxXQUFXLEdBQUcsSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUMsYUFBYSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1lBRXZFLElBQUksV0FBVyxHQUFHLEVBQUUsQ0FBQztZQUVyQixJQUFJLFFBQVEsR0FBRyxLQUFLLENBQUM7WUFDckIsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1lBRXJCLElBQUksTUFBTSxHQUFVLElBQUksQ0FBQztZQUN6QixJQUFJLEtBQUssR0FBUyxJQUFJLENBQUM7WUFFdkIsTUFBTSxDQUFDLE1BQU0sR0FBRyxVQUFDLElBQUk7Z0JBQ25CLEVBQUUsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztvQkFDWixNQUFNLENBQUM7Z0JBQ1QsQ0FBQztnQkFDRCxNQUFNLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztZQUN4QixDQUFDLENBQUE7WUFFRCxNQUFNLENBQUMsTUFBTSxHQUFHO2dCQUNkLFVBQVUsRUFBRSxVQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7b0JBQ3JCLFVBQUcsQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLENBQUM7b0JBQ3pCLFFBQVEsR0FBRyxDQUFDLENBQUM7b0JBQ2IsS0FBSyxHQUFHLENBQUMsQ0FBQztvQkFDVixNQUFNLEdBQUcsQ0FBQyxDQUFDO29CQUNYLFVBQVUsR0FBRyxDQUFDLENBQUM7b0JBRWYsS0FBSyxHQUFHLElBQUksWUFBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUN6QixNQUFNLEdBQUcsSUFBSSxhQUFNLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7b0JBRTdDLEtBQUssQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLENBQUM7b0JBRXpCLEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7d0JBR2YsS0FBSyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztvQkFFekIsQ0FBQztvQkFHRCxJQUFJLElBQUksR0FBRyxJQUFJLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ3RDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBRWhCLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQztvQkFDOUIsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUM5QixhQUFhLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQzdCLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDN0IsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUM3QixVQUFVLEVBQUUsQ0FBQztnQkFDZixDQUFDO2dCQUNELE1BQU0sRUFBRSxVQUFDLFFBQVEsRUFBRSxLQUFLLEVBQUUsTUFBTTtvQkFFOUIsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQzt3QkFDYixNQUFNLENBQUM7b0JBQ1QsQ0FBQztvQkFDRCxLQUFLLENBQUMsTUFBTSxFQUFFLENBQUM7b0JBQ2YsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLE1BQU0sQ0FBQztvQkFDaEMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBQ2xELGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUlsRCxDQUFDLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxVQUFDLFVBQVUsRUFBRSxHQUFHO3dCQUNuQyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUM7b0JBQ3RCLENBQUMsQ0FBQyxDQUFDO29CQUNILFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztvQkFDckIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLENBQUM7b0JBQy9CLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztnQkFDbEIsQ0FBQzthQUNGLENBQUE7WUFFRDtnQkFDRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7b0JBQ1gsTUFBTSxDQUFDO2dCQUNULENBQUM7Z0JBQ0QsUUFBUSxHQUFHLElBQUksQ0FBQztnQkFDaEIsSUFBSSxPQUFPLEdBQUcsQ0FBQyxDQUFDO2dCQUNoQixJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7Z0JBRWhCLElBQUksYUFBYSxHQUFHLEVBQUUsQ0FBQztnQkFFdkIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsVUFBQyxVQUFVLEVBQUUsR0FBRztvQkFDbkMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsS0FBSyxFQUFFLFVBQUMsSUFBSSxJQUFLLE9BQUEsSUFBSSxDQUFDLFNBQVMsS0FBSyxHQUFHLEVBQXRCLENBQXNCLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBQ3pELFVBQUcsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEVBQUUsR0FBRyxDQUFDLENBQUM7b0JBQ25DLENBQUM7b0JBQUMsSUFBSSxDQUFDLENBQUM7d0JBQ04sYUFBYSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDMUIsQ0FBQztnQkFDSCxDQUFDLENBQUMsQ0FBQztnQkFFSCxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxVQUFDLEdBQUc7b0JBQzNCLElBQUksVUFBVSxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDbEMsRUFBRSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQzt3QkFDZixVQUFVLENBQUMsT0FBTyxFQUFFLENBQUM7d0JBQ3JCLE9BQU8sV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUMxQixDQUFDO2dCQUNILENBQUMsQ0FBQyxDQUFDO2dCQUVILENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEtBQUssRUFBRSxVQUFDLElBQUk7b0JBQzFCLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUM7b0JBQ3hCLFVBQUcsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxDQUFDO29CQUMxQixJQUFJLFVBQVUsR0FBRyxXQUFXLENBQUMsRUFBRSxDQUFDLElBQUksSUFBSSxpQkFBVSxDQUFDLGFBQWEsRUFBRSxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUM7b0JBQzVFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO3dCQUN6QixVQUFVLENBQUMsV0FBVyxDQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUM7d0JBQzVDLE9BQU8sR0FBRyxPQUFPLEdBQUcsR0FBRyxDQUFDO3dCQUN4QixPQUFPLEdBQUcsT0FBTyxHQUFHLEdBQUcsQ0FBQzt3QkFDeEIsV0FBVyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQztvQkFDL0IsQ0FBQztvQkFDRCxVQUFVLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztvQkFDL0IsVUFBVSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDL0IsQ0FBQyxDQUFDLENBQUM7Z0JBRUgsVUFBRyxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDM0IsUUFBUSxHQUFHLEtBQUssQ0FBQztZQUNuQixDQUFDO1lBQ0QsTUFBTSxDQUFDLEdBQUcsQ0FBQyx3QkFBd0IsRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNuRCxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBRU4sQ0FBQyxFQS9ITSxNQUFNLEtBQU4sTUFBTSxRQStIWjs7QUNwSUQsdUNBQXVDO0FBRXZDLElBQU8sTUFBTSxDQWtPWjtBQWxPRCxXQUFPLE1BQU0sRUFBQyxDQUFDO0lBRWIsSUFBSSxTQUFTLEdBQUcsRUFBRSxDQUFDO0lBQ25CLElBQUksYUFBYSxHQUFHLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUV0QyxzQkFBZSxHQUFHLGlCQUFVLENBQUMsaUJBQWlCLEVBQUUsQ0FBQyxRQUFRLEVBQUUsVUFBVSxFQUFFLGlCQUFpQixFQUFFLFVBQUMsTUFBTSxFQUFFLFFBQVEsRUFBRSxLQUF1QztZQUU3SixJQUFJLFNBQVMsR0FBRyxFQUFFLENBQUM7WUFDbkIsSUFBSSxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBRWpCLElBQUksRUFBRSxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QyxJQUFJLElBQUksR0FBRyxVQUFVLENBQUM7Z0JBQ2xCLGNBQWMsRUFBRSxJQUFJO2dCQUNwQixXQUFXLEVBQUUsS0FBSztnQkFDbEIsY0FBYyxFQUFFLEtBQUs7Z0JBQ3JCLFdBQVcsRUFBRSxpQkFBaUI7Z0JBQzlCLFNBQVMsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxZQUFZLENBQUMsRUFBRSxPQUFPLEVBQUUsTUFBTSxDQUFDO2dCQUM3RCxpQkFBaUIsRUFBRSxLQUFLO2dCQUN4QixTQUFTLEVBQUUsRUFBRTthQUNkLEVBQUUsVUFBQyxJQUFJLEVBQUUsTUFBTTtnQkFFZCxJQUFJLE1BQU0sR0FBRyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsaUJBQWlCLENBQUM7b0JBQzdHLEtBQUssRUFBRSxRQUFRO2lCQUNoQixDQUFDLENBQUMsQ0FBQztnQkFFSixxQkFBcUIsT0FBTztvQkFDMUIsSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztvQkFDdkIsSUFBSSxVQUFVLEdBQUcsS0FBSyxDQUFDLFVBQVUsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7b0JBQ3ZELFVBQVUsQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLGFBQWEsQ0FBQztvQkFDM0MsSUFBSSxXQUFXLEdBQUcsSUFBSSxLQUFLLENBQUMsaUJBQWlCLENBQUM7d0JBQzVDLEdBQUcsRUFBRSxVQUFVO3dCQUNmLFFBQVEsRUFBRSxVQUFVO3FCQUNyQixDQUFDLENBQUM7b0JBQ0gsSUFBSSxHQUFHLEdBQUcsSUFBSSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO29CQUMzRyxNQUFNLENBQUMsR0FBRyxDQUFDO2dCQUNiLENBQUM7Z0JBRUQsSUFBSSxPQUFPLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUN4QixJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDO2dCQUNwQyxJQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFFN0IsSUFBSSxHQUFHLEdBQUcsU0FBUyxDQUFDO29CQUNsQixJQUFJLEVBQUUsSUFBSTtvQkFDVixJQUFJLEVBQUUsR0FBRztvQkFDVCxLQUFLLEVBQUUsR0FBRztvQkFDVixLQUFLLEVBQUUsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO2lCQUMzQyxDQUFDLENBQUM7Z0JBYUgsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUU7b0JBQzdDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEtBQUssR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3QkFBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3hELENBQUMsQ0FBQyxDQUFDO2dCQUdILElBQUksZUFBZSxHQUFHLENBQUMsQ0FBQztnQkFFeEIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsVUFBVSxNQUFNLEVBQUUsS0FBSztvQkFDckMsVUFBRyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO29CQUN2RCxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUM7d0JBQ3hCLE1BQU0sQ0FBQztvQkFDVCxDQUFDO29CQUNELElBQUksQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDdkIsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzVFLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztvQkFDcEMsSUFBSSxRQUFRLEdBQUcsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNoRixRQUFRLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUM5QixJQUFJLElBQUksR0FBTzt3QkFDYixJQUFJLEVBQUUsQ0FBQzt3QkFDUCxJQUFJLEVBQUUsR0FBRzt3QkFDVCxRQUFRLEVBQUUsUUFBUTtxQkFDbkIsQ0FBQztvQkFDRixJQUFJLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDMUIsVUFBRyxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUUsSUFBSSxDQUFDLENBQUM7b0JBQzFCLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3JCLENBQUMsQ0FBQyxDQUFDO2dCQUVILElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLFVBQVMsS0FBSztvQkFHNUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUM7b0JBQy9CLElBQUksRUFBRSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztvQkFDckMsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO29CQUNyQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEdBQUcsS0FBSyxJQUFJLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO3dCQUM3QixJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7b0JBQ3JCLENBQUM7b0JBQUMsSUFBSSxDQUFDLENBQUM7d0JBQ04sSUFBSSxDQUFDLFlBQVksRUFBRSxDQUFBO29CQUNyQixDQUFDO29CQUdELElBQUksUUFBUSxHQUFHLEVBQUUsQ0FBQztvQkFDbEIsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsVUFBQyxNQUFNO3dCQUN4QixFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQzs0QkFDeEIsSUFBSSxHQUFHLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7NEJBQy9CLElBQUksSUFBSSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUM7NEJBQy9CLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLElBQUksR0FBRyxDQUFDLENBQUMsS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQ0FDN0QsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQ0FDeEIsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzs0QkFDeEIsQ0FBQzt3QkFDSCxDQUFDO3dCQUNELE1BQU0sQ0FBQyxZQUFZLEdBQUc7NEJBQ3BCLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUN6QixDQUFDLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQzs0QkFDekIsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7eUJBQzFCLENBQUE7d0JBQ0QsSUFBSSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDO3dCQUMvQixJQUFJLEdBQUcsR0FBRyxLQUFLLENBQUM7d0JBQ2hCLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLFVBQUMsUUFBUSxFQUFFLEdBQUc7NEJBQy9CLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO2dDQUM1QixNQUFNLENBQUM7NEJBQ1QsQ0FBQzs0QkFDRCxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0NBQ2xELEdBQUcsR0FBRyxJQUFJLENBQUM7Z0NBQ1gsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztnQ0FDeEIsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQ0FDdEIsUUFBUSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUM7NEJBQ3RCLENBQUM7d0JBQ0gsQ0FBQyxDQUFDLENBQUM7b0JBQ0wsQ0FBQyxDQUFDLENBQUM7b0JBQ0gsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsVUFBQyxNQUFNO3dCQUN6QixDQUFDLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsQ0FBQztvQkFDNUIsQ0FBQyxDQUFDLENBQUM7b0JBRUgsR0FBRyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBRWIsRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO3dCQUM5QixVQUFHLENBQUMsS0FBSyxDQUFDLDBDQUEwQyxDQUFDLENBQUM7d0JBQ3RELE1BQU0sQ0FBQztvQkFDVCxDQUFDO29CQUdELElBQUksaUJBQWlCLEdBQUcsRUFBRSxDQUFDO29CQUMzQixDQUFDLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxVQUFDLFFBQVEsRUFBRSxHQUFHO3dCQUMvQixFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7NEJBQ3RDLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLEVBQUUsVUFBVSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDOzRCQUN2RSxRQUFRLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzs0QkFDeEIsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7Z0NBQzNCLFFBQVEsQ0FBQyxhQUFhLEVBQUUsQ0FBQztnQ0FDekIsT0FBTyxRQUFRLENBQUMsYUFBYSxDQUFDOzRCQUNoQyxDQUFDOzRCQUNELFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7NEJBQy9CLFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzs0QkFDaEMsVUFBRyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsRUFBRSxRQUFRLENBQUMsQ0FBQzt3QkFDeEMsQ0FBQzt3QkFDRCxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsR0FBRyxJQUFJLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDOzRCQUNwQyxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDOzRCQUNuRSxRQUFRLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDO3dCQUNyRSxDQUFDO3dCQUNELEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs0QkFDOUIsVUFBRyxDQUFDLEtBQUssQ0FBQywwQkFBMEIsRUFBRSxHQUFHLENBQUMsQ0FBQzs0QkFDM0MsaUJBQWlCLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO3dCQUM5QixDQUFDO3dCQUNELEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxRQUFRLElBQUksUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDOzRCQUM1QixVQUFHLENBQUMsS0FBSyxDQUFDLDBCQUEwQixFQUFFLEdBQUcsQ0FBQyxDQUFDOzRCQUMzQyxJQUFJLElBQUksR0FBRyxXQUFXLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQzs0QkFDOUMsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUM7NEJBQ2hCLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxDQUFDOzRCQUN4RSxJQUFJLElBQUksR0FBTztnQ0FDYixJQUFJLEVBQUUsSUFBSTtnQ0FDVixJQUFJLEVBQUUsQ0FBQztnQ0FDUCxRQUFRLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRTs2QkFDL0IsQ0FBQzs0QkFDRixRQUFRLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7NEJBQ3JDLFFBQVEsQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztnQ0FDeEMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7b0NBQ3JCLE1BQU0sQ0FBQztnQ0FDVCxDQUFDO2dDQUNELFFBQVEsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDO2dDQUM5RCxRQUFRLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEtBQUssQ0FBQztnQ0FDOUQsUUFBUSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7Z0NBQzlELFFBQVEsQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzs0QkFDbEMsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLEdBQUcsR0FBRyxDQUFDLENBQUM7d0JBQ2pDLENBQUM7b0JBQ0gsQ0FBQyxDQUFDLENBQUM7b0JBQ0gsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsRUFBRSxVQUFDLEdBQUc7d0JBQy9CLElBQUksUUFBUSxHQUFHLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQzt3QkFDOUIsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDOzRCQUNkLE1BQU0sQ0FBQzt3QkFDVCxDQUFDO3dCQUNELEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDOzRCQUNwQixJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQzs0QkFDakMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7Z0NBQzNCLFFBQVEsQ0FBQyxhQUFhLEVBQUUsQ0FBQzs0QkFDM0IsQ0FBQzt3QkFDSCxDQUFDO3dCQUNELE9BQU8sU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUN4QixDQUFDLENBQUMsQ0FBQztnQkFDTCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1lBR0wsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsY0FBYyxFQUFFLFVBQUMsQ0FBQztnQkFDL0IsSUFBSSxNQUFNLEdBQUcsYUFBYSxDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDekMsSUFBSSxLQUFLLEdBQUc7b0JBQ1YsUUFBUSxFQUFFLENBQUM7b0JBQ1gsSUFBSSxFQUFFLENBQUMsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLENBQUM7b0JBQ3ZDLE1BQU0sRUFBRSxNQUFNO2lCQUNmLENBQUM7Z0JBQ0YsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN4QixDQUFDLENBQUMsQ0FBQztZQUVILE1BQU0sQ0FBQyxHQUFHLENBQUMsd0JBQXdCLEVBQUUsVUFBQyxDQUFDLEVBQUUsS0FBSztnQkFDNUMsVUFBRyxDQUFDLEtBQUssQ0FBQyxpQkFBaUIsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDcEMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLFVBQUMsR0FBRyxFQUFFLEdBQUc7b0JBQ2hDLElBQUksUUFBUSxHQUFPLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztvQkFDbEMsRUFBRSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO3dCQUNkLFFBQVEsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLEdBQVM7NEJBQ2hDLElBQUksRUFBRSxHQUFHOzRCQUNULEdBQUcsRUFBRSxHQUFHO3lCQUNULENBQUM7b0JBQ0osQ0FBQztnQkFDSCxDQUFDLENBQUMsQ0FBQztnQkFDSCxVQUFHLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxTQUFTLENBQUMsQ0FBQztZQUNyQyxDQUFDLENBQUMsQ0FBQztRQUVMLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFFTixDQUFDLEVBbE9NLE1BQU0sS0FBTixNQUFNLFFBa09aIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsbnVsbCwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzLWFycmF5JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbnZhciByb290UGFyZW50ID0ge31cblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAtIEltcGxlbWVudGF0aW9uIG11c3Qgc3VwcG9ydCBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcy5cbiAqICAgRmlyZWZveCA0LTI5IGxhY2tlZCBzdXBwb3J0LCBmaXhlZCBpbiBGaXJlZm94IDMwKy5cbiAqICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cbiAqXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleSB3aWxsXG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCB3aWxsIHdvcmsgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZvbyAoKSB7fVxuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgYXJyLmNvbnN0cnVjdG9yID0gRm9vXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgYXJyLmNvbnN0cnVjdG9yID09PSBGb28gJiYgLy8gY29uc3RydWN0b3IgY2FuIGJlIHNldFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBuZXcgVWludDhBcnJheSgxKS5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKGFyZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIC8vIEF2b2lkIGdvaW5nIHRocm91Z2ggYW4gQXJndW1lbnRzQWRhcHRvclRyYW1wb2xpbmUgaW4gdGhlIGNvbW1vbiBjYXNlLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBhcmd1bWVudHNbMV0pXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnKVxuICB9XG5cbiAgdGhpcy5sZW5ndGggPSAwXG4gIHRoaXMucGFyZW50ID0gdW5kZWZpbmVkXG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBmcm9tTnVtYmVyKHRoaXMsIGFyZylcbiAgfVxuXG4gIC8vIFNsaWdodGx5IGxlc3MgY29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoaXMsIGFyZywgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiAndXRmOCcpXG4gIH1cblxuICAvLyBVbnVzdWFsLlxuICByZXR1cm4gZnJvbU9iamVjdCh0aGlzLCBhcmcpXG59XG5cbmZ1bmN0aW9uIGZyb21OdW1iZXIgKHRoYXQsIGxlbmd0aCkge1xuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGxlbmd0aCkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgLy8gQXNzdW1wdGlvbjogYnl0ZUxlbmd0aCgpIHJldHVybiB2YWx1ZSBpcyBhbHdheXMgPCBrTWF4TGVuZ3RoLlxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcblxuICB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iamVjdCkpIHJldHVybiBmcm9tQnVmZmVyKHRoYXQsIG9iamVjdClcblxuICBpZiAoaXNBcnJheShvYmplY3QpKSByZXR1cm4gZnJvbUFycmF5KHRoYXQsIG9iamVjdClcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtdXN0IHN0YXJ0IHdpdGggbnVtYmVyLCBidWZmZXIsIGFycmF5IG9yIHN0cmluZycpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiBvYmplY3QuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbVR5cGVkQXJyYXkodGhhdCwgb2JqZWN0KVxuICB9XG5cbiAgaWYgKG9iamVjdC5sZW5ndGgpIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iamVjdClcblxuICByZXR1cm4gZnJvbUpzb25PYmplY3QodGhhdCwgb2JqZWN0KVxufVxuXG5mdW5jdGlvbiBmcm9tQnVmZmVyICh0aGF0LCBidWZmZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYnVmZmVyLmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBhbGxvY2F0ZSh0aGF0LCBsZW5ndGgpXG4gIGJ1ZmZlci5jb3B5KHRoYXQsIDAsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5ICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLy8gRHVwbGljYXRlIG9mIGZyb21BcnJheSgpIHRvIGtlZXAgZnJvbUFycmF5KCkgbW9ub21vcnBoaWMuXG5mdW5jdGlvbiBmcm9tVHlwZWRBcnJheSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgLy8gVHJ1bmNhdGluZyB0aGUgZWxlbWVudHMgaXMgcHJvYmFibHkgbm90IHdoYXQgcGVvcGxlIGV4cGVjdCBmcm9tIHR5cGVkXG4gIC8vIGFycmF5cyB3aXRoIEJZVEVTX1BFUl9FTEVNRU5UID4gMSBidXQgaXQncyBjb21wYXRpYmxlIHdpdGggdGhlIGJlaGF2aW9yXG4gIC8vIG9mIHRoZSBvbGQgQnVmZmVyIGNvbnN0cnVjdG9yLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGFsbG9jYXRlKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8vIERlc2VyaWFsaXplIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsxLDIsMywuLi5dIH0gaW50byBhIEJ1ZmZlciBvYmplY3QuXG4vLyBSZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyIGZvciBpbnB1dHMgdGhhdCBkb24ndCBjb25mb3JtIHRvIHRoZSBzcGVjLlxuZnVuY3Rpb24gZnJvbUpzb25PYmplY3QgKHRoYXQsIG9iamVjdCkge1xuICB2YXIgYXJyYXlcbiAgdmFyIGxlbmd0aCA9IDBcblxuICBpZiAob2JqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqZWN0LmRhdGEpKSB7XG4gICAgYXJyYXkgPSBvYmplY3QuZGF0YVxuICAgIGxlbmd0aCA9IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgfVxuICB0aGF0ID0gYWxsb2NhdGUodGhhdCwgbGVuZ3RoKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBhbGxvY2F0ZSAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgICB0aGF0Ll9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBmcm9tUG9vbCA9IGxlbmd0aCAhPT0gMCAmJiBsZW5ndGggPD0gQnVmZmVyLnBvb2xTaXplID4+PiAxXG4gIGlmIChmcm9tUG9vbCkgdGhhdC5wYXJlbnQgPSByb290UGFyZW50XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2xvd0J1ZmZlcikpIHJldHVybiBuZXcgU2xvd0J1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZylcbiAgZGVsZXRlIGJ1Zi5wYXJlbnRcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgdmFyIGkgPSAwXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSBicmVha1xuXG4gICAgKytpXG4gIH1cblxuICBpZiAoaSAhPT0gbGVuKSB7XG4gICAgeCA9IGFbaV1cbiAgICB5ID0gYltpXVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycy4nKVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKDApXG4gIH0gZWxzZSBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbGlzdFswXVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHN0cmluZyA9ICcnICsgc3RyaW5nXG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAvLyBEZXByZWNhdGVkXG4gICAgICBjYXNlICdyYXcnOlxuICAgICAgY2FzZSAncmF3cyc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG4vLyBwcmUtc2V0IGZvciB2YWx1ZXMgdGhhdCBtYXkgZXhpc3QgaW4gdGhlIGZ1dHVyZVxuQnVmZmVyLnByb3RvdHlwZS5sZW5ndGggPSB1bmRlZmluZWRcbkJ1ZmZlci5wcm90b3R5cGUucGFyZW50ID0gdW5kZWZpbmVkXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICBzdGFydCA9IHN0YXJ0IHwgMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPT09IEluZmluaXR5ID8gdGhpcy5sZW5ndGggOiBlbmQgfCAwXG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcbiAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKGVuZCA8PSBzdGFydCkgcmV0dXJuICcnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiAwXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICBieXRlT2Zmc2V0ID4+PSAwXG5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVybiAtMVxuXG4gIC8vIE5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gTWF0aC5tYXgodGhpcy5sZW5ndGggKyBieXRlT2Zmc2V0LCAwKVxuXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSByZXR1cm4gLTEgLy8gc3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcgYWx3YXlzIGZhaWxzXG4gICAgcmV0dXJuIFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldClcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0aGlzLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YodGhpcywgWyB2YWwgXSwgYnl0ZU9mZnNldClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yICh2YXIgaSA9IDA7IGJ5dGVPZmZzZXQgKyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYXJyW2J5dGVPZmZzZXQgKyBpXSA9PT0gdmFsW2ZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbC5sZW5ndGgpIHJldHVybiBieXRlT2Zmc2V0ICsgZm91bmRJbmRleFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuLy8gYGdldGAgd2lsbCBiZSByZW1vdmVkIGluIE5vZGUgMC4xMytcbkJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdmFyIHN3YXAgPSBlbmNvZGluZ1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgb2Zmc2V0ID0gbGVuZ3RoIHwgMFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyBpKyspIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXdCdWYubGVuZ3RoKSBuZXdCdWYucGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdGhpc1xuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYnVmZmVyIG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCd2YWx1ZSBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSwgMClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IHZhbHVlIDwgMCA/IDEgOiAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gdmFsdWUgPCAwID8gMSA6IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gdmFsdWVcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9IHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmFsdWUgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdpbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0U3RhcnQpXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAoZW5kIDwgc3RhcnQpIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIHRvQXJyYXlCdWZmZXIgKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIF9hdWdtZW50IChhcnIpIHtcbiAgYXJyLmNvbnN0cnVjdG9yID0gQnVmZmVyXG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBzZXQgbWV0aG9kIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5pbmRleE9mID0gQlAuaW5kZXhPZlxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50TEUgPSBCUC5yZWFkVUludExFXG4gIGFyci5yZWFkVUludEJFID0gQlAucmVhZFVJbnRCRVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnRMRSA9IEJQLnJlYWRJbnRMRVxuICBhcnIucmVhZEludEJFID0gQlAucmVhZEludEJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludExFID0gQlAud3JpdGVVSW50TEVcbiAgYXJyLndyaXRlVUludEJFID0gQlAud3JpdGVVSW50QkVcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludExFID0gQlAud3JpdGVJbnRMRVxuICBhcnIud3JpdGVJbnRCRSA9IEJQLndyaXRlSW50QkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XFwtXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cbiAgdmFyIGkgPSAwXG5cbiAgZm9yICg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgICAgIGNvZGVQb2ludCA9IGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDAgfCAweDEwMDAwXG4gICAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcblxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICAgIH1cblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MjAwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGRlY29kZVV0ZjhDaGFyIChzdHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHN0cilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoMHhGRkZEKSAvLyBVVEYgOCBpbnZhbGlkIGNoYXJcbiAgfVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIlxuLyoqXG4gKiBpc0FycmF5XG4gKi9cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIHRvU3RyaW5nXG4gKi9cblxudmFyIHN0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIGB2YWxgXG4gKiBpcyBhbiBhcnJheS5cbiAqXG4gKiBleGFtcGxlOlxuICpcbiAqICAgICAgICBpc0FycmF5KFtdKTtcbiAqICAgICAgICAvLyA+IHRydWVcbiAqICAgICAgICBpc0FycmF5KGFyZ3VtZW50cyk7XG4gKiAgICAgICAgLy8gPiBmYWxzZVxuICogICAgICAgIGlzQXJyYXkoJycpO1xuICogICAgICAgIC8vID4gZmFsc2VcbiAqXG4gKiBAcGFyYW0ge21peGVkfSB2YWxcbiAqIEByZXR1cm4ge2Jvb2x9XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5IHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuICEhIHZhbCAmJiAnW29iamVjdCBBcnJheV0nID09IHN0ci5jYWxsKHZhbCk7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV9kdXBsZXguanNcIilcbiIsIi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgcmV0dXJuIGtleXM7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSlcbiAgICBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpXG4gICAgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSlcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpXG4gICAgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpXG4gICAgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHByb2Nlc3NOZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cbiIsIi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XG5cbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL19zdHJlYW1fdHJhbnNmb3JtJyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKVxuICAgIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuaWYgKCFFRS5saXN0ZW5lckNvdW50KSBFRS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCl7dHJ5e1xuICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xufWNhdGNoKF8pe31maW5hbGx5e1xuICBpZiAoIVN0cmVhbSlcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG59fSgpKVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWcgPSByZXF1aXJlKCd1dGlsJyk7XG5pZiAoZGVidWcgJiYgZGVidWcuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Zy5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICB2YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpXG4gICAgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5idWZmZXIgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB3aGVuIHBpcGluZywgd2Ugb25seSBjYXJlIGFib3V0ICdyZWFkYWJsZScgZXZlbnRzIHRoYXQgaGFwcGVuXG4gIC8vIGFmdGVyIHJlYWQoKWluZyBhbGwgdGhlIGJ5dGVzIGFuZCBub3QgZ2V0dGluZyBhbnkgcHVzaGJhY2suXG4gIHRoaXMucmFuT3V0ID0gZmFsc2U7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpXG4gICAgICBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIHZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSlcbiAgICByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJylcbiAgICB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgY2h1bmsgPSBuZXcgQnVmZmVyKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICBlbmNvZGluZyA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgJycsIHRydWUpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQpIHtcbiAgdmFyIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfSBlbHNlIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgIGlmIChzdGF0ZS5lbmRlZCAmJiAhYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZEVtaXR0ZWQgJiYgYWRkVG9Gcm9udCkge1xuICAgICAgdmFyIGUgPSBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWFkZFRvRnJvbnQgJiYgIWVuY29kaW5nKVxuICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgICBpZiAoIWFkZFRvRnJvbnQpXG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgLy8gaWYgd2Ugd2FudCB0aGUgZGF0YSBub3csIGp1c3QgZW1pdCBpdC5cbiAgICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChhZGRUb0Zyb250KVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgICAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKVxuICAgICAgICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICAgICAgfVxuXG4gICAgICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIChzdGF0ZS5uZWVkUmVhZGFibGUgfHxcbiAgICAgICAgICBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8XG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbihlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKVxuICAgIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxMjhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIHJvdW5kVXBUb05leHRQb3dlck9mMihuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyXG4gICAgbi0tO1xuICAgIGZvciAodmFyIHAgPSAxOyBwIDwgMzI7IHAgPDw9IDEpIG4gfD0gbiA+PiBwO1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKVxuICAgIHJldHVybiAwO1xuXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKVxuICAgIHJldHVybiBuID09PSAwID8gMCA6IDE7XG5cbiAgaWYgKG4gPT09IG51bGwgfHwgaXNOYU4obikpIHtcbiAgICAvLyBvbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5idWZmZXIubGVuZ3RoKVxuICAgICAgcmV0dXJuIHN0YXRlLmJ1ZmZlclswXS5sZW5ndGg7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChuIDw9IDApXG4gICAgcmV0dXJuIDA7XG5cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIHRhcmdldCBidWZmZXIgbGV2ZWwsXG4gIC8vIHRoZW4gcmFpc2UgdGhlIHdhdGVyIG1hcmsuICBCdW1wIHVwIHRvIHRoZSBuZXh0IGhpZ2hlc3RcbiAgLy8gcG93ZXIgb2YgMiwgdG8gcHJldmVudCBpbmNyZWFzaW5nIGl0IGV4Y2Vzc2l2ZWx5IGluIHRpbnlcbiAgLy8gYW1vdW50cy5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKVxuICAgIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSByb3VuZFVwVG9OZXh0UG93ZXJPZjIobik7XG5cbiAgLy8gZG9uJ3QgaGF2ZSB0aGF0IG11Y2guICByZXR1cm4gbnVsbCwgdW5sZXNzIHdlJ3ZlIGVuZGVkLlxuICBpZiAobiA+IHN0YXRlLmxlbmd0aCkge1xuICAgIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24obikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA+IDApXG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJlxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlICYmXG4gICAgICAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICBlbHNlXG4gICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApXG4gICAgICBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9XG5cbiAgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKVxuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gIH1cblxuICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gIGlmIChkb1JlYWQgJiYgIXN0YXRlLnJlYWRpbmcpXG4gICAgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApXG4gICAgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO1xuICBlbHNlXG4gICAgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfVxuXG4gIHN0YXRlLmxlbmd0aCAtPSBuO1xuXG4gIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLmVuZGVkKVxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoID09PSAwKVxuICAgIGVuZFJlYWRhYmxlKHRoaXMpO1xuXG4gIGlmIChyZXQgIT09IG51bGwpXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXIgPSBudWxsO1xuICBpZiAoIShCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSAmJlxuICAgICAgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJlxuICAgICAgY2h1bmsgIT09IG51bGwgJiZcbiAgICAgIGNodW5rICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYylcbiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICAgIGVsc2VcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiZcbiAgICAgICAgIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gICAgZWxzZVxuICAgICAgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiZcbiAgICAgICAgICAgICAgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IGNsZWFudXA7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKVxuICAgIHByb2Nlc3NOZXh0VGljayhlbmRGbik7XG4gIGVsc2VcbiAgICBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUpIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgY2xlYW51cCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmXG4gICAgICAgICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpXG4gICAgICBvbmRyYWluKCk7XG4gIH1cblxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0KSB7XG4gICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJyxcbiAgICAgICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMClcbiAgICAgIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cbiAgLy8gVGhpcyBpcyBhIGJydXRhbGx5IHVnbHkgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlclxuICAvLyBpcyBhdHRhY2hlZCBiZWZvcmUgYW55IHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLlxuICBpZiAoIWRlc3QuX2V2ZW50cyB8fCAhZGVzdC5fZXZlbnRzLmVycm9yKVxuICAgIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGVsc2UgaWYgKGlzQXJyYXkoZGVzdC5fZXZlbnRzLmVycm9yKSlcbiAgICBkZXN0Ll9ldmVudHMuZXJyb3IudW5zaGlmdChvbmVycm9yKTtcbiAgZWxzZVxuICAgIGRlc3QuX2V2ZW50cy5lcnJvciA9IFtvbmVycm9yLCBkZXN0Ll9ldmVudHMuZXJyb3JdO1xuXG5cblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pXG4gICAgICBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUUubGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24oZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpXG4gICAgICBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KVxuICAgICAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGkgPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGkgPT09IC0xKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpLCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSlcbiAgICBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICAvLyBJZiBsaXN0ZW5pbmcgdG8gZGF0YSwgYW5kIGl0IGhhcyBub3QgZXhwbGljaXRseSBiZWVuIHBhdXNlZCxcbiAgLy8gdGhlbiBjYWxsIHJlc3VtZSB0byBzdGFydCB0aGUgZmxvdyBvZiBkYXRhIG9uIHRoZSBuZXh0IHRpY2suXG4gIGlmIChldiA9PT0gJ2RhdGEnICYmIGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICB0aGlzLnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXMucmVhZGFibGUpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcywgc3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZylcbiAgICBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgY2h1bmsgPSBzdHJlYW0ucmVhZCgpO1xuICAgIH0gd2hpbGUgKG51bGwgIT09IGNodW5rICYmIHN0YXRlLmZsb3dpbmcpO1xuICB9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aClcbiAgICAgICAgc2VsZi5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBzZWxmLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKVxuICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSlcbiAgICAgIHJldHVybjtcbiAgICBlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24obWV0aG9kKSB7IHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgIH07IH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICB2YXIgZXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuICBmb3JFYWNoKGV2ZW50cywgZnVuY3Rpb24oZXYpIHtcbiAgICBzdHJlYW0ub24oZXYsIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGV2KSk7XG4gIH0pO1xuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbihuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG5cblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICB2YXIgbGlzdCA9IHN0YXRlLmJ1ZmZlcjtcbiAgdmFyIGxlbmd0aCA9IHN0YXRlLmxlbmd0aDtcbiAgdmFyIHN0cmluZ01vZGUgPSAhIXN0YXRlLmRlY29kZXI7XG4gIHZhciBvYmplY3RNb2RlID0gISFzdGF0ZS5vYmplY3RNb2RlO1xuICB2YXIgcmV0O1xuXG4gIC8vIG5vdGhpbmcgaW4gdGhlIGxpc3QsIGRlZmluaXRlbHkgZW1wdHkuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gbnVsbDtcblxuICBpZiAobGVuZ3RoID09PSAwKVxuICAgIHJldCA9IG51bGw7XG4gIGVsc2UgaWYgKG9iamVjdE1vZGUpXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICBlbHNlIGlmICghbiB8fCBuID49IGxlbmd0aCkge1xuICAgIC8vIHJlYWQgaXQgYWxsLCB0cnVuY2F0ZSB0aGUgYXJyYXkuXG4gICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICByZXQgPSBsaXN0LmpvaW4oJycpO1xuICAgIGVsc2VcbiAgICAgIHJldCA9IEJ1ZmZlci5jb25jYXQobGlzdCwgbGVuZ3RoKTtcbiAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBqdXN0IHNvbWUgb2YgaXQuXG4gICAgaWYgKG4gPCBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8ganVzdCB0YWtlIGEgcGFydCBvZiB0aGUgZmlyc3QgbGlzdCBpdGVtLlxuICAgICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3MuXG4gICAgICB2YXIgYnVmID0gbGlzdFswXTtcbiAgICAgIHJldCA9IGJ1Zi5zbGljZSgwLCBuKTtcbiAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgfSBlbHNlIGlmIChuID09PSBsaXN0WzBdLmxlbmd0aCkge1xuICAgICAgLy8gZmlyc3QgbGlzdCBpcyBhIHBlcmZlY3QgbWF0Y2hcbiAgICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29tcGxleCBjYXNlLlxuICAgICAgLy8gd2UgaGF2ZSBlbm91Z2ggdG8gY292ZXIgaXQsIGJ1dCBpdCBzcGFucyBwYXN0IHRoZSBmaXJzdCBidWZmZXIuXG4gICAgICBpZiAoc3RyaW5nTW9kZSlcbiAgICAgICAgcmV0ID0gJyc7XG4gICAgICBlbHNlXG4gICAgICAgIHJldCA9IG5ldyBCdWZmZXIobik7XG5cbiAgICAgIHZhciBjID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsICYmIGMgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIGJ1ZiA9IGxpc3RbMF07XG4gICAgICAgIHZhciBjcHkgPSBNYXRoLm1pbihuIC0gYywgYnVmLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHN0cmluZ01vZGUpXG4gICAgICAgICAgcmV0ICs9IGJ1Zi5zbGljZSgwLCBjcHkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnVmLmNvcHkocmV0LCBjLCAwLCBjcHkpO1xuXG4gICAgICAgIGlmIChjcHkgPCBidWYubGVuZ3RoKVxuICAgICAgICAgIGxpc3RbMF0gPSBidWYuc2xpY2UoY3B5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcblxuICAgICAgICBjICs9IGNweTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIC8vIElmIHdlIGdldCBoZXJlIGJlZm9yZSBjb25zdW1pbmcgYWxsIHRoZSBieXRlcywgdGhlbiB0aGF0IGlzIGFcbiAgLy8gYnVnIGluIG5vZGUuICBTaG91bGQgbmV2ZXIgaGFwcGVuLlxuICBpZiAoc3RhdGUubGVuZ3RoID4gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuZFJlYWRhYmxlIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCAoeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mICh4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuIiwiLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24oZXIsIGRhdGEpIHtcbiAgICByZXR1cm4gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XG4gIHRoaXMud3JpdGVjaHVuayA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMudHJhbnNmb3JtaW5nID0gZmFsc2U7XG5cbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoIWNiKVxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ25vIHdyaXRlY2IgaW4gVHJhbnNmb3JtIGNsYXNzJykpO1xuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgaWYgKGNiKVxuICAgIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpXG4gICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgLy8gd2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH1cblxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpXG4gICAgICB0aGlzLl9mbHVzaChmdW5jdGlvbihlcikge1xuICAgICAgICBkb25lKHN0cmVhbSwgZXIpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHxcbiAgICAgICAgcnMubmVlZFJlYWRhYmxlIHx8XG4gICAgICAgIHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspXG4gICAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24obikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlcikge1xuICBpZiAoZXIpXG4gICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gc3RpbGwgdHJhbnNmb3JtaW5nJyk7XG5cbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufVxuIiwiLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW07XG4oZnVuY3Rpb24gKCl7dHJ5e1xuICBTdHJlYW0gPSByZXF1aXJlKCdzdCcgKyAncmVhbScpO1xufWNhdGNoKF8pe31maW5hbGx5e1xuICBpZiAoIVN0cmVhbSlcbiAgICBTdHJlYW0gPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG59fSgpKVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KVxuICAgIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSAoaHdtIHx8IGh3bSA9PT0gMCkgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gfn50aGlzLmhpZ2hXYXRlck1hcms7XG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24oZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gd3JpdGFibGVTdGF0ZUdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKXt0cnkge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICBnZXQ6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJykoZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlICcgK1xuICAgICAgJ193cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpIGluc3RlYWQuJylcbn0pO1xufWNhdGNoKF8pe319KCkpO1xuXG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgdmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRob3VnaCB0aGV5J3JlIG5vdFxuICAvLyBpbnN0YW5jZW9mIFdyaXRhYmxlLCB0aGV5J3JlIGluc3RhbmNlb2YgUmVhZGFibGUuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcml0YWJsZSkgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSlcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKVxuICAgICAgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLiBOb3QgcmVhZGFibGUuJykpO1xufTtcblxuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gSWYgd2UgZ2V0IHNvbWV0aGluZyB0aGF0IGlzIG5vdCBhIGJ1ZmZlciwgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQsXG4vLyBhbmQgd2UncmUgbm90IGluIG9iamVjdE1vZGUsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuLy8gT3RoZXJ3aXNlIHN0cmVhbSBjaHVua3MgYXJlIGFsbCBjb25zaWRlcmVkIHRvIGJlIG9mIGxlbmd0aD0xLCBhbmQgdGhlXG4vLyB3YXRlcm1hcmtzIGRldGVybWluZSBob3cgbWFueSBvYmplY3RzIHRvIGtlZXAgaW4gdGhlIGJ1ZmZlciwgcmF0aGVyIHRoYW5cbi8vIGhvdyBtYW55IGJ5dGVzIG9yIGNoYXJhY3RlcnMuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuXG4gIGlmICghKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpICYmXG4gICAgICB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmXG4gICAgICBjaHVuayAhPT0gbnVsbCAmJlxuICAgICAgY2h1bmsgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICB2YXIgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICBlbHNlIGlmICghZW5jb2RpbmcpXG4gICAgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJylcbiAgICBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpXG4gICAgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7XG4gIGVsc2UgaWYgKHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJlxuICAgICAgICAhc3RhdGUuY29ya2VkICYmXG4gICAgICAgICFzdGF0ZS5maW5pc2hlZCAmJlxuICAgICAgICAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJlxuICAgICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpXG4gICAgICBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKVxuICAgIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0Jyxcbid1Y3MyJywgJ3Vjcy0yJywndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXVxuLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJlxuICAgICAgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiZcbiAgICAgIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IG5ldyBCdWZmZXIoY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSlcbiAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcblxuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG4gIGlmICghcmV0KVxuICAgIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBuZXcgV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgaWYgKGxhc3QpIHtcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldilcbiAgICBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7XG4gIGVsc2VcbiAgICBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcbiAgaWYgKHN5bmMpXG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gIGVsc2VcbiAgICBjYihlcik7XG5cbiAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpXG4gICAgb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYik7XG4gIGVsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmXG4gICAgICAgICFzdGF0ZS5jb3JrZWQgJiZcbiAgICAgICAgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiZcbiAgICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzc05leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZClcbiAgICBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgYnVmZmVyID0gW107XG4gICAgdmFyIGNicyA9IFtdO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgY2JzLnB1c2goZW50cnkuY2FsbGJhY2spO1xuICAgICAgYnVmZmVyLnB1c2goZW50cnkpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgIH1cblxuICAgIC8vIGNvdW50IHRoZSBvbmUgd2UgYXJlIGFkZGluZywgYXMgd2VsbC5cbiAgICAvLyBUT0RPKGlzYWFjcykgY2xlYW4gdGhpcyB1cFxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBmdW5jdGlvbihlcnIpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgICAgICBjYnNbaV0oZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENsZWFyIGJ1ZmZlclxuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpXG4gICAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpXG4gICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZClcbiAgICBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xufTtcblxuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiAoc3RhdGUuZW5kaW5nICYmXG4gICAgICAgICAgc3RhdGUubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmXG4gICAgICAgICAgIXN0YXRlLmZpbmlzaGVkICYmXG4gICAgICAgICAgIXN0YXRlLndyaXRpbmcpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnByZWZpbmlzaGVkKSB7XG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG4gIGlmIChuZWVkKSB7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKVxuICAgICAgcHJvY2Vzc05leHRUaWNrKGNiKTtcbiAgICBlbHNlXG4gICAgICBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIoYXJnKTtcbn1cbmV4cG9ydHMuaXNCdWZmZXIgPSBpc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufSIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gIH1cbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gIH0pO1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpXG4iLCJ2YXIgU3RyZWFtID0gKGZ1bmN0aW9uICgpe1xuICB0cnkge1xuICAgIHJldHVybiByZXF1aXJlKCdzdCcgKyAncmVhbScpOyAvLyBoYWNrIHRvIGZpeCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgaXNzdWUgd2hlbiB1c2VkIHdpdGggYnJvd3NlcmlmeVxuICB9IGNhdGNoKF8pe31cbn0oKSk7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzXCIpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXCIpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNCdWZmZXJFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nXG4gIHx8IGZ1bmN0aW9uKGVuY29kaW5nKSB7XG4gICAgICAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICBjYXNlICdoZXgnOiBjYXNlICd1dGY4JzogY2FzZSAndXRmLTgnOiBjYXNlICdhc2NpaSc6IGNhc2UgJ2JpbmFyeSc6IGNhc2UgJ2Jhc2U2NCc6IGNhc2UgJ3VjczInOiBjYXNlICd1Y3MtMic6IGNhc2UgJ3V0ZjE2bGUnOiBjYXNlICd1dGYtMTZsZSc6IGNhc2UgJ3Jhdyc6IHJldHVybiB0cnVlO1xuICAgICAgICAgZGVmYXVsdDogcmV0dXJuIGZhbHNlO1xuICAgICAgIH1cbiAgICAgfVxuXG5cbmZ1bmN0aW9uIGFzc2VydEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyAmJiAhaXNCdWZmZXJFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIH1cbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLiBDRVNVLTggaXMgaGFuZGxlZCBhcyBwYXJ0IG9mIHRoZSBVVEYtOCBlbmNvZGluZy5cbi8vXG4vLyBAVE9ETyBIYW5kbGluZyBhbGwgZW5jb2RpbmdzIGluc2lkZSBhIHNpbmdsZSBvYmplY3QgbWFrZXMgaXQgdmVyeSBkaWZmaWN1bHRcbi8vIHRvIHJlYXNvbiBhYm91dCB0aGlzIGNvZGUsIHNvIGl0IHNob3VsZCBiZSBzcGxpdCB1cCBpbiB0aGUgZnV0dXJlLlxuLy8gQFRPRE8gVGhlcmUgc2hvdWxkIGJlIGEgdXRmOC1zdHJpY3QgZW5jb2RpbmcgdGhhdCByZWplY3RzIGludmFsaWQgVVRGLTggY29kZVxuLy8gcG9pbnRzIGFzIHVzZWQgYnkgQ0VTVS04LlxudmFyIFN0cmluZ0RlY29kZXIgPSBleHBvcnRzLlN0cmluZ0RlY29kZXIgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bLV9dLywgJycpO1xuICBhc3NlcnRFbmNvZGluZyhlbmNvZGluZyk7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgLy8gQ0VTVS04IHJlcHJlc2VudHMgZWFjaCBvZiBTdXJyb2dhdGUgUGFpciBieSAzLWJ5dGVzXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICAvLyBVVEYtMTYgcmVwcmVzZW50cyBlYWNoIG9mIFN1cnJvZ2F0ZSBQYWlyIGJ5IDItYnl0ZXNcbiAgICAgIHRoaXMuc3Vycm9nYXRlU2l6ZSA9IDI7XG4gICAgICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyID0gdXRmMTZEZXRlY3RJbmNvbXBsZXRlQ2hhcjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAvLyBCYXNlLTY0IHN0b3JlcyAzIGJ5dGVzIGluIDQgY2hhcnMsIGFuZCBwYWRzIHRoZSByZW1haW5kZXIuXG4gICAgICB0aGlzLnN1cnJvZ2F0ZVNpemUgPSAzO1xuICAgICAgdGhpcy5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBwYXNzVGhyb3VnaFdyaXRlO1xuICAgICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRW5vdWdoIHNwYWNlIHRvIHN0b3JlIGFsbCBieXRlcyBvZiBhIHNpbmdsZSBjaGFyYWN0ZXIuIFVURi04IG5lZWRzIDRcbiAgLy8gYnl0ZXMsIGJ1dCBDRVNVLTggbWF5IHJlcXVpcmUgdXAgdG8gNiAoMyBieXRlcyBwZXIgc3Vycm9nYXRlKS5cbiAgdGhpcy5jaGFyQnVmZmVyID0gbmV3IEJ1ZmZlcig2KTtcbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHJlY2VpdmVkIGZvciB0aGUgY3VycmVudCBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgY2hhcmFjdGVyLlxuICB0aGlzLmNoYXJSZWNlaXZlZCA9IDA7XG4gIC8vIE51bWJlciBvZiBieXRlcyBleHBlY3RlZCBmb3IgdGhlIGN1cnJlbnQgaW5jb21wbGV0ZSBtdWx0aS1ieXRlIGNoYXJhY3Rlci5cbiAgdGhpcy5jaGFyTGVuZ3RoID0gMDtcbn07XG5cblxuLy8gd3JpdGUgZGVjb2RlcyB0aGUgZ2l2ZW4gYnVmZmVyIGFuZCByZXR1cm5zIGl0IGFzIEpTIHN0cmluZyB0aGF0IGlzXG4vLyBndWFyYW50ZWVkIHRvIG5vdCBjb250YWluIGFueSBwYXJ0aWFsIG11bHRpLWJ5dGUgY2hhcmFjdGVycy4gQW55IHBhcnRpYWxcbi8vIGNoYXJhY3RlciBmb3VuZCBhdCB0aGUgZW5kIG9mIHRoZSBidWZmZXIgaXMgYnVmZmVyZWQgdXAsIGFuZCB3aWxsIGJlXG4vLyByZXR1cm5lZCB3aGVuIGNhbGxpbmcgd3JpdGUgYWdhaW4gd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzLlxuLy9cbi8vIE5vdGU6IENvbnZlcnRpbmcgYSBCdWZmZXIgY29udGFpbmluZyBhbiBvcnBoYW4gc3Vycm9nYXRlIHRvIGEgU3RyaW5nXG4vLyBjdXJyZW50bHkgd29ya3MsIGJ1dCBjb252ZXJ0aW5nIGEgU3RyaW5nIHRvIGEgQnVmZmVyICh2aWEgYG5ldyBCdWZmZXJgLCBvclxuLy8gQnVmZmVyI3dyaXRlKSB3aWxsIHJlcGxhY2UgaW5jb21wbGV0ZSBzdXJyb2dhdGVzIHdpdGggdGhlIHVuaWNvZGVcbi8vIHJlcGxhY2VtZW50IGNoYXJhY3Rlci4gU2VlIGh0dHBzOi8vY29kZXJldmlldy5jaHJvbWl1bS5vcmcvMTIxMTczMDA5LyAuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgY2hhclN0ciA9ICcnO1xuICAvLyBpZiBvdXIgbGFzdCB3cml0ZSBlbmRlZCB3aXRoIGFuIGluY29tcGxldGUgbXVsdGlieXRlIGNoYXJhY3RlclxuICB3aGlsZSAodGhpcy5jaGFyTGVuZ3RoKSB7XG4gICAgLy8gZGV0ZXJtaW5lIGhvdyBtYW55IHJlbWFpbmluZyBieXRlcyB0aGlzIGJ1ZmZlciBoYXMgdG8gb2ZmZXIgZm9yIHRoaXMgY2hhclxuICAgIHZhciBhdmFpbGFibGUgPSAoYnVmZmVyLmxlbmd0aCA+PSB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCkgP1xuICAgICAgICB0aGlzLmNoYXJMZW5ndGggLSB0aGlzLmNoYXJSZWNlaXZlZCA6XG4gICAgICAgIGJ1ZmZlci5sZW5ndGg7XG5cbiAgICAvLyBhZGQgdGhlIG5ldyBieXRlcyB0byB0aGUgY2hhciBidWZmZXJcbiAgICBidWZmZXIuY29weSh0aGlzLmNoYXJCdWZmZXIsIHRoaXMuY2hhclJlY2VpdmVkLCAwLCBhdmFpbGFibGUpO1xuICAgIHRoaXMuY2hhclJlY2VpdmVkICs9IGF2YWlsYWJsZTtcblxuICAgIGlmICh0aGlzLmNoYXJSZWNlaXZlZCA8IHRoaXMuY2hhckxlbmd0aCkge1xuICAgICAgLy8gc3RpbGwgbm90IGVub3VnaCBjaGFycyBpbiB0aGlzIGJ1ZmZlcj8gd2FpdCBmb3IgbW9yZSAuLi5cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgYnl0ZXMgYmVsb25naW5nIHRvIHRoZSBjdXJyZW50IGNoYXJhY3RlciBmcm9tIHRoZSBidWZmZXJcbiAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoYXZhaWxhYmxlLCBidWZmZXIubGVuZ3RoKTtcblxuICAgIC8vIGdldCB0aGUgY2hhcmFjdGVyIHRoYXQgd2FzIHNwbGl0XG4gICAgY2hhclN0ciA9IHRoaXMuY2hhckJ1ZmZlci5zbGljZSgwLCB0aGlzLmNoYXJMZW5ndGgpLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xuXG4gICAgLy8gQ0VTVS04OiBsZWFkIHN1cnJvZ2F0ZSAoRDgwMC1EQkZGKSBpcyBhbHNvIHRoZSBpbmNvbXBsZXRlIGNoYXJhY3RlclxuICAgIHZhciBjaGFyQ29kZSA9IGNoYXJTdHIuY2hhckNvZGVBdChjaGFyU3RyLmxlbmd0aCAtIDEpO1xuICAgIGlmIChjaGFyQ29kZSA+PSAweEQ4MDAgJiYgY2hhckNvZGUgPD0gMHhEQkZGKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggKz0gdGhpcy5zdXJyb2dhdGVTaXplO1xuICAgICAgY2hhclN0ciA9ICcnO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHRoaXMuY2hhclJlY2VpdmVkID0gdGhpcy5jaGFyTGVuZ3RoID0gMDtcblxuICAgIC8vIGlmIHRoZXJlIGFyZSBubyBtb3JlIGJ5dGVzIGluIHRoaXMgYnVmZmVyLCBqdXN0IGVtaXQgb3VyIGNoYXJcbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNoYXJTdHI7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIGFuZCBzZXQgY2hhckxlbmd0aCAvIGNoYXJSZWNlaXZlZFxuICB0aGlzLmRldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcik7XG5cbiAgdmFyIGVuZCA9IGJ1ZmZlci5sZW5ndGg7XG4gIGlmICh0aGlzLmNoYXJMZW5ndGgpIHtcbiAgICAvLyBidWZmZXIgdGhlIGluY29tcGxldGUgY2hhcmFjdGVyIGJ5dGVzIHdlIGdvdFxuICAgIGJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgMCwgYnVmZmVyLmxlbmd0aCAtIHRoaXMuY2hhclJlY2VpdmVkLCBlbmQpO1xuICAgIGVuZCAtPSB0aGlzLmNoYXJSZWNlaXZlZDtcbiAgfVxuXG4gIGNoYXJTdHIgKz0gYnVmZmVyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIGVuZCk7XG5cbiAgdmFyIGVuZCA9IGNoYXJTdHIubGVuZ3RoIC0gMTtcbiAgdmFyIGNoYXJDb2RlID0gY2hhclN0ci5jaGFyQ29kZUF0KGVuZCk7XG4gIC8vIENFU1UtODogbGVhZCBzdXJyb2dhdGUgKEQ4MDAtREJGRikgaXMgYWxzbyB0aGUgaW5jb21wbGV0ZSBjaGFyYWN0ZXJcbiAgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuc3Vycm9nYXRlU2l6ZTtcbiAgICB0aGlzLmNoYXJMZW5ndGggKz0gc2l6ZTtcbiAgICB0aGlzLmNoYXJSZWNlaXZlZCArPSBzaXplO1xuICAgIHRoaXMuY2hhckJ1ZmZlci5jb3B5KHRoaXMuY2hhckJ1ZmZlciwgc2l6ZSwgMCwgc2l6ZSk7XG4gICAgYnVmZmVyLmNvcHkodGhpcy5jaGFyQnVmZmVyLCAwLCAwLCBzaXplKTtcbiAgICByZXR1cm4gY2hhclN0ci5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgfVxuXG4gIC8vIG9yIGp1c3QgZW1pdCB0aGUgY2hhclN0clxuICByZXR1cm4gY2hhclN0cjtcbn07XG5cbi8vIGRldGVjdEluY29tcGxldGVDaGFyIGRldGVybWluZXMgaWYgdGhlcmUgaXMgYW4gaW5jb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXIgYXRcbi8vIHRoZSBlbmQgb2YgdGhlIGdpdmVuIGJ1ZmZlci4gSWYgc28sIGl0IHNldHMgdGhpcy5jaGFyTGVuZ3RoIHRvIHRoZSBieXRlXG4vLyBsZW5ndGggdGhhdCBjaGFyYWN0ZXIsIGFuZCBzZXRzIHRoaXMuY2hhclJlY2VpdmVkIHRvIHRoZSBudW1iZXIgb2YgYnl0ZXNcbi8vIHRoYXQgYXJlIGF2YWlsYWJsZSBmb3IgdGhpcyBjaGFyYWN0ZXIuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5kZXRlY3RJbmNvbXBsZXRlQ2hhciA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAvLyBkZXRlcm1pbmUgaG93IG1hbnkgYnl0ZXMgd2UgaGF2ZSB0byBjaGVjayBhdCB0aGUgZW5kIG9mIHRoaXMgYnVmZmVyXG4gIHZhciBpID0gKGJ1ZmZlci5sZW5ndGggPj0gMykgPyAzIDogYnVmZmVyLmxlbmd0aDtcblxuICAvLyBGaWd1cmUgb3V0IGlmIG9uZSBvZiB0aGUgbGFzdCBpIGJ5dGVzIG9mIG91ciBidWZmZXIgYW5ub3VuY2VzIGFuXG4gIC8vIGluY29tcGxldGUgY2hhci5cbiAgZm9yICg7IGkgPiAwOyBpLS0pIHtcbiAgICB2YXIgYyA9IGJ1ZmZlcltidWZmZXIubGVuZ3RoIC0gaV07XG5cbiAgICAvLyBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9VVEYtOCNEZXNjcmlwdGlvblxuXG4gICAgLy8gMTEwWFhYWFhcbiAgICBpZiAoaSA9PSAxICYmIGMgPj4gNSA9PSAweDA2KSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAyO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMFhYWFhcbiAgICBpZiAoaSA8PSAyICYmIGMgPj4gNCA9PSAweDBFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSAzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gMTExMTBYWFhcbiAgICBpZiAoaSA8PSAzICYmIGMgPj4gMyA9PSAweDFFKSB7XG4gICAgICB0aGlzLmNoYXJMZW5ndGggPSA0O1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gaTtcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICB2YXIgcmVzID0gJyc7XG4gIGlmIChidWZmZXIgJiYgYnVmZmVyLmxlbmd0aClcbiAgICByZXMgPSB0aGlzLndyaXRlKGJ1ZmZlcik7XG5cbiAgaWYgKHRoaXMuY2hhclJlY2VpdmVkKSB7XG4gICAgdmFyIGNyID0gdGhpcy5jaGFyUmVjZWl2ZWQ7XG4gICAgdmFyIGJ1ZiA9IHRoaXMuY2hhckJ1ZmZlcjtcbiAgICB2YXIgZW5jID0gdGhpcy5lbmNvZGluZztcbiAgICByZXMgKz0gYnVmLnNsaWNlKDAsIGNyKS50b1N0cmluZyhlbmMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHBhc3NUaHJvdWdoV3JpdGUoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXIudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHV0ZjE2RGV0ZWN0SW5jb21wbGV0ZUNoYXIoYnVmZmVyKSB7XG4gIHRoaXMuY2hhclJlY2VpdmVkID0gYnVmZmVyLmxlbmd0aCAlIDI7XG4gIHRoaXMuY2hhckxlbmd0aCA9IHRoaXMuY2hhclJlY2VpdmVkID8gMiA6IDA7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NERldGVjdEluY29tcGxldGVDaGFyKGJ1ZmZlcikge1xuICB0aGlzLmNoYXJSZWNlaXZlZCA9IGJ1ZmZlci5sZW5ndGggJSAzO1xuICB0aGlzLmNoYXJMZW5ndGggPSB0aGlzLmNoYXJSZWNlaXZlZCA/IDMgOiAwO1xufVxuIiwidmFyIGV2ZXIgPSByZXF1aXJlKCdldmVyJylcbnZhciB2a2V5ID0gcmVxdWlyZSgndmtleScpXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcblxudmFyIGdhbWVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihnYW1lSW5zdGFuY2UpIHtcbiAgLy8gY2FjaGUgdGhlIGdhbWUgaW5zdGFuY2VcbiAgZ2FtZSA9IGdhbWVJbnN0YW5jZVxuICByZXR1cm4gZnVuY3Rpb24gbWFrZUZseShwaHlzaWNhbCwgbm9LZXlFdmVudHMpIHtcbiAgICByZXR1cm4gbmV3IEZseShwaHlzaWNhbCwgbm9LZXlFdmVudHMpXG4gIH1cbn1cblxuZnVuY3Rpb24gRmx5KHBoeXNpY2FsLCBub0tleUV2ZW50cykge1xuICB0aGlzLmZseVNwZWVkID0gMC44XG4gIHRoaXMucGh5c2ljYWwgPSBwaHlzaWNhbFxuICBpZiAoIW5vS2V5RXZlbnRzKSB0aGlzLmJpbmRLZXlFdmVudHMoKVxufVxuXG5GbHkucHJvdG90eXBlLmJpbmRLZXlFdmVudHMgPSBmdW5jdGlvbihlbCkge1xuICBpZiAoIWVsKSBlbCA9IGRvY3VtZW50LmJvZHlcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBjb3VudGVyID0gMFxuICB2YXIgc3BhY2VVcEFmdGVyRmlyc3REb3duID0gZmFsc2VcbiAgdmFyIGZpcnN0ID0gRGF0ZS5ub3coKVxuICBldmVyKGVsKVxuICAgIC5vbigna2V5ZG93bicsIG9uS2V5RG93bilcbiAgICAub24oJ2tleXVwJywgb25LZXlVcClcbiAgXG4gIGZ1bmN0aW9uIG9uS2V5RG93bihldikge1xuICAgIHZhciBrZXkgPSB2a2V5W2V2LmtleUNvZGVdIHx8IGV2LmNoYXJcbiAgICB2YXIgYmluZGluZyA9IGdhbWUua2V5YmluZGluZ3Nba2V5XVxuICAgIGlmIChiaW5kaW5nICE9PSBcImp1bXBcIikgcmV0dXJuXG4gICAgaWYgKGNvdW50ZXIgPT09IDEpIHtcbiAgICAgIGlmIChEYXRlLm5vdygpIC0gZmlyc3QgPiAzMDApIHtcbiAgICAgICAgc3BhY2VVcEFmdGVyRmlyc3REb3duID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIGZpcnN0ID0gRGF0ZS5ub3coKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFzZWxmLmZseWluZyAmJiBzcGFjZVVwQWZ0ZXJGaXJzdERvd24pIHtcbiAgICAgICAgICBzZWxmLnN0YXJ0Rmx5aW5nKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3BhY2VVcEFmdGVyRmlyc3REb3duID0gZmFsc2VcbiAgICAgIHJldHVybiBjb3VudGVyID0gMFxuICAgIH1cbiAgICBpZiAoY291bnRlciA9PT0gMCkge1xuICAgICAgZmlyc3QgPSBEYXRlLm5vdygpXG4gICAgICBjb3VudGVyICs9IDFcbiAgICB9XG4gIH1cbiAgXG4gIGZ1bmN0aW9uIG9uS2V5VXAoZXYpIHtcbiAgICB2YXIga2V5ID0gdmtleVtldi5rZXlDb2RlXSB8fCBldi5jaGFyXG4gICAgaWYgKGtleSA9PT0gJzxzcGFjZT4nICYmIGNvdW50ZXIgPT09IDEpIHtcbiAgICAgIHNwYWNlVXBBZnRlckZpcnN0RG93biA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuRmx5LnByb3RvdHlwZS5zdGFydEZseWluZyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgdGhpcy5mbHlpbmcgPSB0cnVlXG4gIHZhciBwaHlzaWNhbCA9IHRoaXMucGh5c2ljYWxcbiAgcGh5c2ljYWwucmVtb3ZlRm9yY2UoZ2FtZS5ncmF2aXR5KVxuICBwaHlzaWNhbC5vbkdhbWVUaWNrID0gZnVuY3Rpb24oZHQpIHtcbiAgICBpZiAocGh5c2ljYWwuYXRSZXN0WSgpID09PSAtMSkgcmV0dXJuIHNlbGYuc3RvcEZseWluZygpXG4gICAgcGh5c2ljYWwuZnJpY3Rpb24ueCA9IHNlbGYuZmx5U3BlZWRcbiAgICBwaHlzaWNhbC5mcmljdGlvbi56ID0gc2VsZi5mbHlTcGVlZFxuICAgIHZhciBwcmVzcyA9IGdhbWUuY29udHJvbHMuc3RhdGVcbiAgICBpZiAocHJlc3NbJ2Nyb3VjaCddKSByZXR1cm4gcGh5c2ljYWwudmVsb2NpdHkueSA9IC0wLjAxXG4gICAgaWYgKHByZXNzWydqdW1wJ10pIHJldHVybiBwaHlzaWNhbC52ZWxvY2l0eS55ID0gMC4wMVxuICAgIHBoeXNpY2FsLnZlbG9jaXR5LnkgPSAwXG4gIH1cbiAgZ2FtZS5vbigndGljaycsIHBoeXNpY2FsLm9uR2FtZVRpY2spXG59XG5cbkZseS5wcm90b3R5cGUuc3RvcEZseWluZyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmZseWluZyA9IGZhbHNlXG4gIHZhciBwaHlzaWNhbCA9IHRoaXMucGh5c2ljYWxcbiAgcGh5c2ljYWwuc3ViamVjdFRvKGdhbWUuZ3Jhdml0eSlcbiAgZ2FtZS5yZW1vdmVMaXN0ZW5lcigndGljaycsIHBoeXNpY2FsLm9uR2FtZVRpY2spXG59IiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHJldHVybiBuZXcgRXZlcihlbGVtKTtcbn07XG5cbmZ1bmN0aW9uIEV2ZXIgKGVsZW0pIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtO1xufVxuXG5FdmVyLnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXI7XG5cbkV2ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKG5hbWUsIGNiLCB1c2VDYXB0dXJlKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMpIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGlmICghdGhpcy5fZXZlbnRzW25hbWVdKSB0aGlzLl9ldmVudHNbbmFtZV0gPSBbXTtcbiAgICB0aGlzLl9ldmVudHNbbmFtZV0ucHVzaChjYik7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgY2IsIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuRXZlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVyLnByb3RvdHlwZS5vbjtcblxuRXZlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cykgdGhpcy5fZXZlbnRzID0ge307XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIHVzZUNhcHR1cmUgfHwgZmFsc2UpO1xuICAgIFxuICAgIHZhciB4cyA9IHRoaXMubGlzdGVuZXJzKHR5cGUpO1xuICAgIHZhciBpeCA9IHhzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpeCA+PSAwKSB4cy5zcGxpY2UoaXgsIDEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiByZW1vdmVBbGwgKHQpIHtcbiAgICAgICAgdmFyIHhzID0gc2VsZi5saXN0ZW5lcnModCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodCwgeHNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICh0eXBlKSB7XG4gICAgICAgIHJlbW92ZUFsbCh0eXBlKVxuICAgIH1cbiAgICBlbHNlIGlmIChzZWxmLl9ldmVudHMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNlbGYuX2V2ZW50cykge1xuICAgICAgICAgICAgaWYgKGtleSkgcmVtb3ZlQWxsKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHNlbGYsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBpbml0U2lnbmF0dXJlcyA9IHJlcXVpcmUoJy4vaW5pdC5qc29uJyk7XG5cbkV2ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAobmFtZSwgZXYpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGV2ID0gbmFtZTtcbiAgICAgICAgbmFtZSA9IGV2LnR5cGU7XG4gICAgfVxuICAgIFxuICAgIGlmICghaXNFdmVudChldikpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBFdmVyLnR5cGVPZihuYW1lKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBvcHRzID0gZXYgfHwge307XG4gICAgICAgIGlmIChvcHRzLnR5cGUgPT09IHVuZGVmaW5lZCkgb3B0cy50eXBlID0gbmFtZTtcbiAgICAgICAgXG4gICAgICAgIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQodHlwZSArICdzJyk7XG4gICAgICAgIHZhciBpbml0ID0gdHlwZW9mIGV2Wydpbml0JyArIHR5cGVdID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/ICdpbml0JyArIHR5cGUgOiAnaW5pdEV2ZW50J1xuICAgICAgICA7XG4gICAgICAgIFxuICAgICAgICB2YXIgc2lnID0gaW5pdFNpZ25hdHVyZXNbaW5pdF07XG4gICAgICAgIHZhciB1c2VkID0ge307XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IHNpZ1tpXTtcbiAgICAgICAgICAgIGFyZ3MucHVzaChvcHRzW2tleV0pO1xuICAgICAgICAgICAgdXNlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBldltpbml0XS5hcHBseShldiwgYXJncyk7XG4gICAgICAgIFxuICAgICAgICAvLyBhdHRhY2ggcmVtYWluaW5nIHVudXNlZCBvcHRpb25zIHRvIHRoZSBvYmplY3RcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9wdHMpIHtcbiAgICAgICAgICAgIGlmICghdXNlZFtrZXldKSBldltrZXldID0gb3B0c1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZGlzcGF0Y2hFdmVudChldik7XG59O1xuXG5mdW5jdGlvbiBpc0V2ZW50IChldikge1xuICAgIHZhciBzID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV2KTtcbiAgICByZXR1cm4gL1xcW29iamVjdCBcXFMrRXZlbnRcXF0vLnRlc3Qocyk7XG59XG5cbkV2ZXIudHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzLmpzb24nKTtcbkV2ZXIudHlwZU9mID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZXMgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gRXZlci50eXBlcykge1xuICAgICAgICB2YXIgdHMgPSBFdmVyLnR5cGVzW2tleV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHR5cGVzW3RzW2ldXSA9IGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVzW25hbWVdIHx8ICdFdmVudCc7XG4gICAgfTtcbn0pKCk7O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcImluaXRFdmVudFwiIDogW1xuICAgIFwidHlwZVwiLFxuICAgIFwiY2FuQnViYmxlXCIsIFxuICAgIFwiY2FuY2VsYWJsZVwiXG4gIF0sXG4gIFwiaW5pdFVJRXZlbnRcIiA6IFtcbiAgICBcInR5cGVcIixcbiAgICBcImNhbkJ1YmJsZVwiLCBcbiAgICBcImNhbmNlbGFibGVcIiwgXG4gICAgXCJ2aWV3XCIsIFxuICAgIFwiZGV0YWlsXCJcbiAgXSxcbiAgXCJpbml0TW91c2VFdmVudFwiIDogW1xuICAgIFwidHlwZVwiLFxuICAgIFwiY2FuQnViYmxlXCIsIFxuICAgIFwiY2FuY2VsYWJsZVwiLCBcbiAgICBcInZpZXdcIiwgXG4gICAgXCJkZXRhaWxcIiwgXG4gICAgXCJzY3JlZW5YXCIsIFxuICAgIFwic2NyZWVuWVwiLCBcbiAgICBcImNsaWVudFhcIiwgXG4gICAgXCJjbGllbnRZXCIsIFxuICAgIFwiY3RybEtleVwiLCBcbiAgICBcImFsdEtleVwiLCBcbiAgICBcInNoaWZ0S2V5XCIsIFxuICAgIFwibWV0YUtleVwiLCBcbiAgICBcImJ1dHRvblwiLFxuICAgIFwicmVsYXRlZFRhcmdldFwiXG4gIF0sXG4gIFwiaW5pdE11dGF0aW9uRXZlbnRcIiA6IFtcbiAgICBcInR5cGVcIixcbiAgICBcImNhbkJ1YmJsZVwiLCBcbiAgICBcImNhbmNlbGFibGVcIiwgXG4gICAgXCJyZWxhdGVkTm9kZVwiLCBcbiAgICBcInByZXZWYWx1ZVwiLCBcbiAgICBcIm5ld1ZhbHVlXCIsIFxuICAgIFwiYXR0ck5hbWVcIiwgXG4gICAgXCJhdHRyQ2hhbmdlXCJcbiAgXVxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1xuICBcIk1vdXNlRXZlbnRcIiA6IFtcbiAgICBcImNsaWNrXCIsXG4gICAgXCJtb3VzZWRvd25cIixcbiAgICBcIm1vdXNldXBcIixcbiAgICBcIm1vdXNlb3ZlclwiLFxuICAgIFwibW91c2Vtb3ZlXCIsXG4gICAgXCJtb3VzZW91dFwiXG4gIF0sXG4gIFwiS2V5Qm9hcmRFdmVudFwiIDogW1xuICAgIFwia2V5ZG93blwiLFxuICAgIFwia2V5dXBcIixcbiAgICBcImtleXByZXNzXCJcbiAgXSxcbiAgXCJNdXRhdGlvbkV2ZW50XCIgOiBbXG4gICAgXCJET01TdWJ0cmVlTW9kaWZpZWRcIixcbiAgICBcIkRPTU5vZGVJbnNlcnRlZFwiLFxuICAgIFwiRE9NTm9kZVJlbW92ZWRcIixcbiAgICBcIkRPTU5vZGVSZW1vdmVkRnJvbURvY3VtZW50XCIsXG4gICAgXCJET01Ob2RlSW5zZXJ0ZWRJbnRvRG9jdW1lbnRcIixcbiAgICBcIkRPTUF0dHJNb2RpZmllZFwiLFxuICAgIFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCJcbiAgXSxcbiAgXCJIVE1MRXZlbnRcIiA6IFtcbiAgICBcImxvYWRcIixcbiAgICBcInVubG9hZFwiLFxuICAgIFwiYWJvcnRcIixcbiAgICBcImVycm9yXCIsXG4gICAgXCJzZWxlY3RcIixcbiAgICBcImNoYW5nZVwiLFxuICAgIFwic3VibWl0XCIsXG4gICAgXCJyZXNldFwiLFxuICAgIFwiZm9jdXNcIixcbiAgICBcImJsdXJcIixcbiAgICBcInJlc2l6ZVwiLFxuICAgIFwic2Nyb2xsXCJcbiAgXSxcbiAgXCJVSUV2ZW50XCIgOiBbXG4gICAgXCJET01Gb2N1c0luXCIsXG4gICAgXCJET01Gb2N1c091dFwiLFxuICAgIFwiRE9NQWN0aXZhdGVcIlxuICBdXG59XG4iLCJ2YXIgdWEgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50IDogJydcbiAgLCBpc09TWCA9IC9PUyBYLy50ZXN0KHVhKVxuICAsIGlzT3BlcmEgPSAvT3BlcmEvLnRlc3QodWEpXG4gICwgbWF5YmVGaXJlZm94ID0gIS9saWtlIEdlY2tvLy50ZXN0KHVhKSAmJiAhaXNPcGVyYVxuXG52YXIgaSwgb3V0cHV0ID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIDA6ICBpc09TWCA/ICc8bWVudT4nIDogJzxVTks+J1xuLCAxOiAgJzxtb3VzZSAxPidcbiwgMjogICc8bW91c2UgMj4nXG4sIDM6ICAnPGJyZWFrPidcbiwgNDogICc8bW91c2UgMz4nXG4sIDU6ICAnPG1vdXNlIDQ+J1xuLCA2OiAgJzxtb3VzZSA1PidcbiwgODogICc8YmFja3NwYWNlPidcbiwgOTogICc8dGFiPidcbiwgMTI6ICc8Y2xlYXI+J1xuLCAxMzogJzxlbnRlcj4nXG4sIDE2OiAnPHNoaWZ0PidcbiwgMTc6ICc8Y29udHJvbD4nXG4sIDE4OiAnPGFsdD4nXG4sIDE5OiAnPHBhdXNlPidcbiwgMjA6ICc8Y2Fwcy1sb2NrPidcbiwgMjE6ICc8aW1lLWhhbmd1bD4nXG4sIDIzOiAnPGltZS1qdW5qYT4nXG4sIDI0OiAnPGltZS1maW5hbD4nXG4sIDI1OiAnPGltZS1rYW5qaT4nXG4sIDI3OiAnPGVzY2FwZT4nXG4sIDI4OiAnPGltZS1jb252ZXJ0PidcbiwgMjk6ICc8aW1lLW5vbmNvbnZlcnQ+J1xuLCAzMDogJzxpbWUtYWNjZXB0PidcbiwgMzE6ICc8aW1lLW1vZGUtY2hhbmdlPidcbiwgMjc6ICc8ZXNjYXBlPidcbiwgMzI6ICc8c3BhY2U+J1xuLCAzMzogJzxwYWdlLXVwPidcbiwgMzQ6ICc8cGFnZS1kb3duPidcbiwgMzU6ICc8ZW5kPidcbiwgMzY6ICc8aG9tZT4nXG4sIDM3OiAnPGxlZnQ+J1xuLCAzODogJzx1cD4nXG4sIDM5OiAnPHJpZ2h0PidcbiwgNDA6ICc8ZG93bj4nXG4sIDQxOiAnPHNlbGVjdD4nXG4sIDQyOiAnPHByaW50PidcbiwgNDM6ICc8ZXhlY3V0ZT4nXG4sIDQ0OiAnPHNuYXBzaG90PidcbiwgNDU6ICc8aW5zZXJ0PidcbiwgNDY6ICc8ZGVsZXRlPidcbiwgNDc6ICc8aGVscD4nXG4sIDkxOiAnPG1ldGE+JyAgLy8gbWV0YS1sZWZ0IC0tIG5vIG9uZSBoYW5kbGVzIGxlZnQgYW5kIHJpZ2h0IHByb3Blcmx5LCBzbyB3ZSBjb2VyY2UgaW50byBvbmUuXG4sIDkyOiAnPG1ldGE+JyAgLy8gbWV0YS1yaWdodFxuLCA5MzogaXNPU1ggPyAnPG1ldGE+JyA6ICc8bWVudT4nICAgICAgLy8gY2hyb21lLG9wZXJhLHNhZmFyaSBhbGwgcmVwb3J0IHRoaXMgZm9yIG1ldGEtcmlnaHQgKG9zeCBtYnApLlxuLCA5NTogJzxzbGVlcD4nXG4sIDEwNjogJzxudW0tKj4nXG4sIDEwNzogJzxudW0tKz4nXG4sIDEwODogJzxudW0tZW50ZXI+J1xuLCAxMDk6ICc8bnVtLS0+J1xuLCAxMTA6ICc8bnVtLS4+J1xuLCAxMTE6ICc8bnVtLS8+J1xuLCAxNDQ6ICc8bnVtLWxvY2s+J1xuLCAxNDU6ICc8c2Nyb2xsLWxvY2s+J1xuLCAxNjA6ICc8c2hpZnQtbGVmdD4nXG4sIDE2MTogJzxzaGlmdC1yaWdodD4nXG4sIDE2MjogJzxjb250cm9sLWxlZnQ+J1xuLCAxNjM6ICc8Y29udHJvbC1yaWdodD4nXG4sIDE2NDogJzxhbHQtbGVmdD4nXG4sIDE2NTogJzxhbHQtcmlnaHQ+J1xuLCAxNjY6ICc8YnJvd3Nlci1iYWNrPidcbiwgMTY3OiAnPGJyb3dzZXItZm9yd2FyZD4nXG4sIDE2ODogJzxicm93c2VyLXJlZnJlc2g+J1xuLCAxNjk6ICc8YnJvd3Nlci1zdG9wPidcbiwgMTcwOiAnPGJyb3dzZXItc2VhcmNoPidcbiwgMTcxOiAnPGJyb3dzZXItZmF2b3JpdGVzPidcbiwgMTcyOiAnPGJyb3dzZXItaG9tZT4nXG5cbiAgLy8gZmYvb3N4IHJlcG9ydHMgJzx2b2x1bWUtbXV0ZT4nIGZvciAnLSdcbiwgMTczOiBpc09TWCAmJiBtYXliZUZpcmVmb3ggPyAnLScgOiAnPHZvbHVtZS1tdXRlPidcbiwgMTc0OiAnPHZvbHVtZS1kb3duPidcbiwgMTc1OiAnPHZvbHVtZS11cD4nXG4sIDE3NjogJzxuZXh0LXRyYWNrPidcbiwgMTc3OiAnPHByZXYtdHJhY2s+J1xuLCAxNzg6ICc8c3RvcD4nXG4sIDE3OTogJzxwbGF5LXBhdXNlPidcbiwgMTgwOiAnPGxhdW5jaC1tYWlsPidcbiwgMTgxOiAnPGxhdW5jaC1tZWRpYS1zZWxlY3Q+J1xuLCAxODI6ICc8bGF1bmNoLWFwcCAxPidcbiwgMTgzOiAnPGxhdW5jaC1hcHAgMj4nXG4sIDE4NjogJzsnXG4sIDE4NzogJz0nXG4sIDE4ODogJywnXG4sIDE4OTogJy0nXG4sIDE5MDogJy4nXG4sIDE5MTogJy8nXG4sIDE5MjogJ2AnXG4sIDIxOTogJ1snXG4sIDIyMDogJ1xcXFwnXG4sIDIyMTogJ10nXG4sIDIyMjogXCInXCJcbiwgMjIzOiAnPG1ldGE+J1xuLCAyMjQ6ICc8bWV0YT4nICAgICAgIC8vIGZpcmVmb3ggcmVwb3J0cyBtZXRhIGhlcmUuXG4sIDIyNjogJzxhbHQtZ3I+J1xuLCAyMjk6ICc8aW1lLXByb2Nlc3M+J1xuLCAyMzE6IGlzT3BlcmEgPyAnYCcgOiAnPHVuaWNvZGU+J1xuLCAyNDY6ICc8YXR0ZW50aW9uPidcbiwgMjQ3OiAnPGNyc2VsPidcbiwgMjQ4OiAnPGV4c2VsPidcbiwgMjQ5OiAnPGVyYXNlLWVvZj4nXG4sIDI1MDogJzxwbGF5PidcbiwgMjUxOiAnPHpvb20+J1xuLCAyNTI6ICc8bm8tbmFtZT4nXG4sIDI1MzogJzxwYS0xPidcbiwgMjU0OiAnPGNsZWFyPidcbn1cblxuZm9yKGkgPSA1ODsgaSA8IDY1OyArK2kpIHtcbiAgb3V0cHV0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyAwLTlcbmZvcihpID0gNDg7IGkgPCA1ODsgKytpKSB7XG4gIG91dHB1dFtpXSA9IChpIC0gNDgpKycnXG59XG5cbi8vIEEtWlxuZm9yKGkgPSA2NTsgaSA8IDkxOyArK2kpIHtcbiAgb3V0cHV0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyBudW0wLTlcbmZvcihpID0gOTY7IGkgPCAxMDc7ICsraSkge1xuICBvdXRwdXRbaV0gPSAnPG51bS0nKyhpIC0gOTYpKyc+J1xufVxuXG4vLyBGMS1GMjRcbmZvcihpID0gMTEyOyBpIDwgMTM2OyArK2kpIHtcbiAgb3V0cHV0W2ldID0gJ0YnKyhpLTExMSlcbn1cbiIsInZhciBjcmVhdGVHYW1lID0gcmVxdWlyZSgndm94ZWwtZW5naW5lJylcbnZhciBoaWdobGlnaHQgPSByZXF1aXJlKCd2b3hlbC1oaWdobGlnaHQnKVxudmFyIHBsYXllciA9IHJlcXVpcmUoJ3ZveGVsLXBsYXllcicpXG52YXIgdm94ZWwgPSByZXF1aXJlKCd2b3hlbCcpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kJylcbnZhciBmbHkgPSByZXF1aXJlKCd2b3hlbC1mbHknKVxudmFyIHdhbGsgPSByZXF1aXJlKCd2b3hlbC13YWxrJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzLCBzZXR1cCkge1xuICBzZXR1cCA9IHNldHVwIHx8IGRlZmF1bHRTZXR1cFxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgZ2VuZXJhdGU6IHZveGVsLmdlbmVyYXRvclsnVmFsbGV5J10sXG4gICAgY2h1bmtEaXN0YW5jZTogMixcbiAgICBtYXRlcmlhbHM6IFsnI2ZmZicsICcjMDAwJ10sXG4gICAgbWF0ZXJpYWxGbGF0Q29sb3I6IHRydWUsXG4gICAgd29ybGRPcmlnaW46IFswLCAwLCAwXSxcbiAgICBjb250cm9sczogeyBkaXNjcmV0ZUZpcmU6IHRydWUgfVxuICB9XG4gIG9wdHMgPSBleHRlbmQoe30sIGRlZmF1bHRzLCBvcHRzIHx8IHt9KVxuXG4gIC8vIHNldHVwIHRoZSBnYW1lIGFuZCBhZGQgc29tZSB0cmVlc1xuICB2YXIgZ2FtZSA9IGNyZWF0ZUdhbWUob3B0cylcbiAgdmFyIGNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyIHx8IGRvY3VtZW50LmJvZHlcbiAgd2luZG93LmdhbWUgPSBnYW1lIC8vIGZvciBkZWJ1Z2dpbmdcbiAgZ2FtZS5hcHBlbmRUbyhjb250YWluZXIpXG4gIGlmIChnYW1lLm5vdENhcGFibGUoKSkgcmV0dXJuIGdhbWVcbiAgXG4gIHZhciBjcmVhdGVQbGF5ZXIgPSBwbGF5ZXIoZ2FtZSlcblxuICAvLyBjcmVhdGUgdGhlIHBsYXllciBmcm9tIGEgbWluZWNyYWZ0IHNraW4gZmlsZSBhbmQgdGVsbCB0aGVcbiAgLy8gZ2FtZSB0byB1c2UgaXQgYXMgdGhlIG1haW4gcGxheWVyXG4gIHZhciBhdmF0YXIgPSBjcmVhdGVQbGF5ZXIob3B0cy5wbGF5ZXJTa2luIHx8ICdwbGF5ZXIucG5nJylcbiAgYXZhdGFyLnBvc3Nlc3MoKVxuICBhdmF0YXIueWF3LnBvc2l0aW9uLnNldCgyLCAxNCwgNClcblxuICBzZXR1cChnYW1lLCBhdmF0YXIpXG4gIFxuICByZXR1cm4gZ2FtZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2V0dXAoZ2FtZSwgYXZhdGFyKSB7XG4gIFxuICB2YXIgbWFrZUZseSA9IGZseShnYW1lKVxuICB2YXIgdGFyZ2V0ID0gZ2FtZS5jb250cm9scy50YXJnZXQoKVxuICBnYW1lLmZseWVyID0gbWFrZUZseSh0YXJnZXQpXG4gIFxuICAvLyBoaWdobGlnaHQgYmxvY2tzIHdoZW4geW91IGxvb2sgYXQgdGhlbSwgaG9sZCA8Q3RybD4gZm9yIGJsb2NrIHBsYWNlbWVudFxuICB2YXIgYmxvY2tQb3NQbGFjZSwgYmxvY2tQb3NFcmFzZVxuICB2YXIgaGwgPSBnYW1lLmhpZ2hsaWdodGVyID0gaGlnaGxpZ2h0KGdhbWUsIHsgY29sb3I6IDB4ZmYwMDAwIH0pXG4gIGhsLm9uKCdoaWdobGlnaHQnLCBmdW5jdGlvbiAodm94ZWxQb3MpIHsgYmxvY2tQb3NFcmFzZSA9IHZveGVsUG9zIH0pXG4gIGhsLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAodm94ZWxQb3MpIHsgYmxvY2tQb3NFcmFzZSA9IG51bGwgfSlcbiAgaGwub24oJ2hpZ2hsaWdodC1hZGphY2VudCcsIGZ1bmN0aW9uICh2b3hlbFBvcykgeyBibG9ja1Bvc1BsYWNlID0gdm94ZWxQb3MgfSlcbiAgaGwub24oJ3JlbW92ZS1hZGphY2VudCcsIGZ1bmN0aW9uICh2b3hlbFBvcykgeyBibG9ja1Bvc1BsYWNlID0gbnVsbCB9KVxuXG4gIC8vIHRvZ2dsZSBiZXR3ZWVuIGZpcnN0IGFuZCB0aGlyZCBwZXJzb24gbW9kZXNcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICBpZiAoZXYua2V5Q29kZSA9PT0gJ1InLmNoYXJDb2RlQXQoMCkpIGF2YXRhci50b2dnbGUoKVxuICB9KVxuXG4gIC8vIGJsb2NrIGludGVyYWN0aW9uIHN0dWZmLCB1c2VzIGhpZ2hsaWdodCBkYXRhXG4gIHZhciBjdXJyZW50TWF0ZXJpYWwgPSAxXG5cbiAgZ2FtZS5vbignZmlyZScsIGZ1bmN0aW9uICh0YXJnZXQsIHN0YXRlKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gYmxvY2tQb3NQbGFjZVxuICAgIGlmIChwb3NpdGlvbikge1xuICAgICAgZ2FtZS5jcmVhdGVCbG9jayhwb3NpdGlvbiwgY3VycmVudE1hdGVyaWFsKVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHBvc2l0aW9uID0gYmxvY2tQb3NFcmFzZVxuICAgICAgaWYgKHBvc2l0aW9uKSBnYW1lLnNldEJsb2NrKHBvc2l0aW9uLCAwKVxuICAgIH1cbiAgfSlcblxuICBnYW1lLm9uKCd0aWNrJywgZnVuY3Rpb24oKSB7XG4gICAgd2Fsay5yZW5kZXIodGFyZ2V0LnBsYXllclNraW4pXG4gICAgdmFyIHZ4ID0gTWF0aC5hYnModGFyZ2V0LnZlbG9jaXR5LngpXG4gICAgdmFyIHZ6ID0gTWF0aC5hYnModGFyZ2V0LnZlbG9jaXR5LnopXG4gICAgaWYgKHZ4ID4gMC4wMDEgfHwgdnogPiAwLjAwMSkgd2Fsay5zdG9wV2Fsa2luZygpXG4gICAgZWxzZSB3YWxrLnN0YXJ0V2Fsa2luZygpXG4gIH0pXG5cbn1cbiIsInZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xuXHRpZiAoIW9iaiB8fCB0b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IE9iamVjdF0nIHx8IG9iai5ub2RlVHlwZSB8fCBvYmouc2V0SW50ZXJ2YWwpXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdHZhciBoYXNfb3duX2NvbnN0cnVjdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChvYmosICdjb25zdHJ1Y3RvcicpO1xuXHR2YXIgaGFzX2lzX3Byb3BlcnR5X29mX21ldGhvZCA9IGhhc093blByb3BlcnR5LmNhbGwob2JqLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ2lzUHJvdG90eXBlT2YnKTtcblx0Ly8gTm90IG93biBjb25zdHJ1Y3RvciBwcm9wZXJ0eSBtdXN0IGJlIE9iamVjdFxuXHRpZiAob2JqLmNvbnN0cnVjdG9yICYmICFoYXNfb3duX2NvbnN0cnVjdG9yICYmICFoYXNfaXNfcHJvcGVydHlfb2ZfbWV0aG9kKVxuXHRcdHJldHVybiBmYWxzZTtcblxuXHQvLyBPd24gcHJvcGVydGllcyBhcmUgZW51bWVyYXRlZCBmaXJzdGx5LCBzbyB0byBzcGVlZCB1cCxcblx0Ly8gaWYgbGFzdCBvbmUgaXMgb3duLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIGFyZSBvd24uXG5cdHZhciBrZXk7XG5cdGZvciAoIGtleSBpbiBvYmogKSB7fVxuXG5cdHJldHVybiBrZXkgPT09IHVuZGVmaW5lZCB8fCBoYXNPd24uY2FsbCggb2JqLCBrZXkgKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdCAgICB0YXJnZXQgPSBhcmd1bWVudHNbMF0gfHwge30sXG5cdCAgICBpID0gMSxcblx0ICAgIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdCAgICBkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuXHRcdC8vIHNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHRpID0gMjtcblx0fVxuXG5cdC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFyZ2V0IGlzIGEgc3RyaW5nIG9yIHNvbWV0aGluZyAocG9zc2libGUgaW4gZGVlcCBjb3B5KVxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHRhcmdldCAhPT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHQvLyBPbmx5IGRlYWwgd2l0aCBub24tbnVsbC91bmRlZmluZWQgdmFsdWVzXG5cdFx0aWYgKCAob3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdKSAhPSBudWxsICkge1xuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggaXNQbGFpbk9iamVjdChjb3B5KSB8fCAoY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGNvcHkpKSApICkge1xuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgQXJyYXkuaXNBcnJheShzcmMpID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgaXNQbGFpbk9iamVjdChzcmMpID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBleHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG4iLCJ2YXIgdm94ZWwgPSByZXF1aXJlKCd2b3hlbCcpXG52YXIgdm94ZWxNZXNoID0gcmVxdWlyZSgndm94ZWwtbWVzaCcpXG52YXIgcmF5ID0gcmVxdWlyZSgndm94ZWwtcmF5Y2FzdCcpXG52YXIgdGV4dHVyZSA9IHJlcXVpcmUoJ3ZveGVsLXRleHR1cmUnKVxudmFyIGNvbnRyb2wgPSByZXF1aXJlKCd2b3hlbC1jb250cm9sJylcbnZhciB2b3hlbFZpZXcgPSByZXF1aXJlKCd2b3hlbC12aWV3JylcbnZhciBUSFJFRSA9IHJlcXVpcmUoJ3RocmVlJylcbnZhciBTdGF0cyA9IHJlcXVpcmUoJy4vbGliL3N0YXRzJylcbnZhciBEZXRlY3RvciA9IHJlcXVpcmUoJy4vbGliL2RldGVjdG9yJylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5pZiAocHJvY2Vzcy5icm93c2VyKSB2YXIgaW50ZXJhY3QgPSByZXF1aXJlKCdpbnRlcmFjdCcpXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgncmFmJylcbnZhciBjb2xsaXNpb25zID0gcmVxdWlyZSgnY29sbGlkZS0zZC10aWxlbWFwJylcbnZhciBhYWJiID0gcmVxdWlyZSgnYWFiYi0zZCcpXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKCdnbC1tYXRyaXgnKVxudmFyIHZlY3RvciA9IGdsTWF0cml4LnZlYzNcbnZhciBTcGF0aWFsRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnc3BhdGlhbC1ldmVudHMnKVxudmFyIHJlZ2lvbkNoYW5nZSA9IHJlcXVpcmUoJ3ZveGVsLXJlZ2lvbi1jaGFuZ2UnKVxudmFyIGtiID0gcmVxdWlyZSgna2ItY29udHJvbHMnKVxudmFyIHBoeXNpY2FsID0gcmVxdWlyZSgndm94ZWwtcGh5c2ljYWwnKVxudmFyIHBpbiA9IHJlcXVpcmUoJ3Bpbi1pdCcpXG52YXIgdGljID0gcmVxdWlyZSgndGljJykoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdhbWVcblxuZnVuY3Rpb24gR2FtZShvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBHYW1lKSkgcmV0dXJuIG5ldyBHYW1lKG9wdHMpXG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuICBpZiAocHJvY2Vzcy5icm93c2VyICYmIHRoaXMubm90Q2FwYWJsZShvcHRzKSkgcmV0dXJuXG4gIFxuICBpZiAoISgnZ2VuZXJhdGVDaHVua3MnIGluIG9wdHMpKSBvcHRzLmdlbmVyYXRlQ2h1bmtzID0gdHJ1ZVxuICB0aGlzLmdlbmVyYXRlQ2h1bmtzID0gb3B0cy5nZW5lcmF0ZUNodW5rc1xuICB0aGlzLnNldENvbmZpZ3VyYWJsZVBvc2l0aW9ucyhvcHRzKVxuICB0aGlzLmNvbmZpZ3VyZUNodW5rTG9hZGluZyhvcHRzKVxuICB0aGlzLnNldERpbWVuc2lvbnMob3B0cylcbiAgdGhpcy5USFJFRSA9IFRIUkVFXG4gIHRoaXMudmVjdG9yID0gdmVjdG9yXG4gIHRoaXMuZ2xNYXRyaXggPSBnbE1hdHJpeFxuICB0aGlzLmFycmF5VHlwZSA9IG9wdHMuYXJyYXlUeXBlIHx8IFVpbnQ4QXJyYXlcbiAgdGhpcy5jdWJlU2l6ZSA9IDEgLy8gYmFja3dhcmRzIGNvbXBhdFxuICB0aGlzLmNodW5rU2l6ZSA9IG9wdHMuY2h1bmtTaXplIHx8IDMyXG4gIFxuICAvLyBjaHVua0Rpc3RhbmNlIGFuZCByZW1vdmVEaXN0YW5jZSBzaG91bGQgbm90IGJlIHNldCB0byB0aGUgc2FtZSB0aGluZ1xuICAvLyBhcyBpdCBjYXVzZXMgbGFnIHdoZW4geW91IGdvIGJhY2sgYW5kIGZvcnRoIG9uIGEgY2h1bmsgYm91bmRhcnlcbiAgdGhpcy5jaHVua0Rpc3RhbmNlID0gb3B0cy5jaHVua0Rpc3RhbmNlIHx8IDJcbiAgdGhpcy5yZW1vdmVEaXN0YW5jZSA9IG9wdHMucmVtb3ZlRGlzdGFuY2UgfHwgdGhpcy5jaHVua0Rpc3RhbmNlICsgMVxuICBcbiAgdGhpcy5wbGF5ZXJIZWlnaHQgPSBvcHRzLnBsYXllckhlaWdodCB8fCAxLjYyXG4gIHRoaXMubWVzaFR5cGUgPSBvcHRzLm1lc2hUeXBlIHx8ICdzdXJmYWNlTWVzaCdcbiAgdGhpcy5tZXNoZXIgPSBvcHRzLm1lc2hlciB8fCB2b3hlbC5tZXNoZXJzLmN1bGxlZFxuICB0aGlzLm1hdGVyaWFsVHlwZSA9IG9wdHMubWF0ZXJpYWxUeXBlIHx8IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWxcbiAgdGhpcy5tYXRlcmlhbFBhcmFtcyA9IG9wdHMubWF0ZXJpYWxQYXJhbXMgfHwge31cbiAgdGhpcy5pdGVtcyA9IFtdXG4gIHRoaXMudm94ZWxzID0gdm94ZWwodGhpcylcbiAgdGhpcy5zY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpXG4gIHRoaXMudmlldyA9IG9wdHMudmlldyB8fCBuZXcgdm94ZWxWaWV3KFRIUkVFLCB7IHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH0pXG4gIHRoaXMudmlldy5iaW5kVG9TY2VuZSh0aGlzLnNjZW5lKVxuICB0aGlzLmNhbWVyYSA9IHRoaXMudmlldy5nZXRDYW1lcmEoKVxuICBpZiAoIW9wdHMubGlnaHRzRGlzYWJsZWQpIHRoaXMuYWRkTGlnaHRzKHRoaXMuc2NlbmUpXG4gIFxuICB0aGlzLnNreUNvbG9yID0gb3B0cy5za3lDb2xvciB8fCAweEJGRDFFNVxuICB0aGlzLmZvZ1NjYWxlID0gb3B0cy5mb2dTY2FsZSB8fCAzMlxuICBpZiAoIW9wdHMuZm9nRGlzYWJsZWQpIHRoaXMuc2NlbmUuZm9nID0gbmV3IFRIUkVFLkZvZyggdGhpcy5za3lDb2xvciwgMC4wMDAyNSwgdGhpcy53b3JsZFdpZHRoKCkgKiB0aGlzLmZvZ1NjYWxlIClcbiAgXG4gIHRoaXMuY29sbGlkZVZveGVscyA9IGNvbGxpc2lvbnMoXG4gICAgdGhpcy5nZXRCbG9jay5iaW5kKHRoaXMpLFxuICAgIDEsXG4gICAgW0luZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHldLFxuICAgIFstSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5XVxuICApXG4gIFxuICB0aGlzLnRpbWVyID0gdGhpcy5pbml0aWFsaXplVGltZXIoKG9wdHMudGlja0ZQUyB8fCAxNikpXG4gIHRoaXMucGF1c2VkID0gZmFsc2VcblxuICB0aGlzLnNwYXRpYWwgPSBuZXcgU3BhdGlhbEV2ZW50RW1pdHRlclxuICB0aGlzLnJlZ2lvbiA9IHJlZ2lvbkNoYW5nZSh0aGlzLnNwYXRpYWwsIGFhYmIoWzAsIDAsIDBdLCBbMSwgMSwgMV0pLCB0aGlzLmNodW5rU2l6ZSlcbiAgdGhpcy52b3hlbFJlZ2lvbiA9IHJlZ2lvbkNoYW5nZSh0aGlzLnNwYXRpYWwsIDEpXG4gIHRoaXMuY2h1bmtSZWdpb24gPSByZWdpb25DaGFuZ2UodGhpcy5zcGF0aWFsLCB0aGlzLmNodW5rU2l6ZSlcbiAgdGhpcy5hc3luY0NodW5rR2VuZXJhdGlvbiA9IGZhbHNlXG5cbiAgLy8gY29udGFpbnMgY2h1bmtzIHRoYXQgaGFzIGhhZCBhbiB1cGRhdGUgdGhpcyB0aWNrLiBXaWxsIGJlIGdlbmVyYXRlZCByaWdodCBiZWZvcmUgcmVkcmF3aW5nIHRoZSBmcmFtZVxuICB0aGlzLmNodW5rc05lZWRzVXBkYXRlID0ge31cbiAgLy8gY29udGFpbnMgbmV3IGNodW5rcyB5ZXQgdG8gYmUgZ2VuZXJhdGVkLiBIYW5kbGVkIGJ5IGdhbWUubG9hZFBlbmRpbmdDaHVua3NcbiAgdGhpcy5wZW5kaW5nQ2h1bmtzID0gW11cblxuICB0aGlzLm1hdGVyaWFscyA9IHRleHR1cmUoe1xuICAgIGdhbWU6IHRoaXMsXG4gICAgdGV4dHVyZVBhdGg6IG9wdHMudGV4dHVyZVBhdGggfHwgJy4vdGV4dHVyZXMvJyxcbiAgICBtYXRlcmlhbFR5cGU6IG9wdHMubWF0ZXJpYWxUeXBlIHx8IFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwsXG4gICAgbWF0ZXJpYWxQYXJhbXM6IG9wdHMubWF0ZXJpYWxQYXJhbXMgfHwge30sXG4gICAgbWF0ZXJpYWxGbGF0Q29sb3I6IG9wdHMubWF0ZXJpYWxGbGF0Q29sb3IgPT09IHRydWVcbiAgfSlcblxuICB0aGlzLm1hdGVyaWFsTmFtZXMgPSBvcHRzLm1hdGVyaWFscyB8fCBbWydncmFzcycsICdkaXJ0JywgJ2dyYXNzX2RpcnQnXSwgJ2JyaWNrJywgJ2RpcnQnXVxuICBcbiAgc2VsZi5jaHVua1JlZ2lvbi5vbignY2hhbmdlJywgZnVuY3Rpb24obmV3Q2h1bmspIHtcbiAgICBzZWxmLnJlbW92ZUZhckNodW5rcygpXG4gIH0pXG5cbiAgaWYgKHByb2Nlc3MuYnJvd3NlcikgdGhpcy5tYXRlcmlhbHMubG9hZCh0aGlzLm1hdGVyaWFsTmFtZXMpXG5cbiAgaWYgKHRoaXMuZ2VuZXJhdGVDaHVua3MpIHRoaXMuaGFuZGxlQ2h1bmtHZW5lcmF0aW9uKClcblxuICAvLyBjbGllbnQgc2lkZSBvbmx5IGFmdGVyIHRoaXMgcG9pbnRcbiAgaWYgKCFwcm9jZXNzLmJyb3dzZXIpIHJldHVyblxuICBcbiAgdGhpcy5wYXVzZWQgPSB0cnVlXG4gIHRoaXMuaW5pdGlhbGl6ZVJlbmRlcmluZyhvcHRzKVxuICBcbiAgZm9yICh2YXIgY2h1bmtJbmRleCBpbiB0aGlzLnZveGVscy5jaHVua3MpIHRoaXMuc2hvd0NodW5rKHRoaXMudm94ZWxzLmNodW5rc1tjaHVua0luZGV4XSlcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuYXN5bmNDaHVua0dlbmVyYXRpb24gPSAnYXN5bmNDaHVua0dlbmVyYXRpb24nIGluIG9wdHMgPyBvcHRzLmFzeW5jQ2h1bmtHZW5lcmF0aW9uIDogdHJ1ZVxuICB9LCAyMDAwKVxuXG4gIHRoaXMuaW5pdGlhbGl6ZUNvbnRyb2xzKG9wdHMpXG59XG5cbmluaGVyaXRzKEdhbWUsIEV2ZW50RW1pdHRlcilcblxuLy8gIyBFeHRlcm5hbCBBUElcblxuR2FtZS5wcm90b3R5cGUudm94ZWxQb3NpdGlvbiA9IGZ1bmN0aW9uKGdhbWVQb3NpdGlvbikge1xuICB2YXIgXyA9IE1hdGguZmxvb3JcbiAgdmFyIHAgPSBnYW1lUG9zaXRpb25cbiAgdmFyIHYgPSBbXVxuICB2WzBdID0gXyhwWzBdKVxuICB2WzFdID0gXyhwWzFdKVxuICB2WzJdID0gXyhwWzJdKVxuICByZXR1cm4gdlxufVxuXG5HYW1lLnByb3RvdHlwZS5jYW1lcmFQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy52aWV3LmNhbWVyYVBvc2l0aW9uKClcbn1cblxuR2FtZS5wcm90b3R5cGUuY2FtZXJhVmVjdG9yID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZpZXcuY2FtZXJhVmVjdG9yKClcbn1cblxuR2FtZS5wcm90b3R5cGUubWFrZVBoeXNpY2FsID0gZnVuY3Rpb24odGFyZ2V0LCBlbnZlbG9wZSwgYmxvY2tzQ3JlYXRpb24pIHtcbiAgdmFyIHZlbCA9IHRoaXMudGVybWluYWxWZWxvY2l0eVxuICBlbnZlbG9wZSA9IGVudmVsb3BlIHx8IFsyLzMsIDEuNSwgMi8zXVxuICB2YXIgb2JqID0gcGh5c2ljYWwodGFyZ2V0LCB0aGlzLnBvdGVudGlhbENvbGxpc2lvblNldCgpLCBlbnZlbG9wZSwge3g6IHZlbFswXSwgeTogdmVsWzFdLCB6OiB2ZWxbMl19KVxuICBvYmouYmxvY2tzQ3JlYXRpb24gPSAhIWJsb2Nrc0NyZWF0aW9uXG4gIHJldHVybiBvYmpcbn1cblxuR2FtZS5wcm90b3R5cGUuYWRkSXRlbSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgaWYgKCFpdGVtLnRpY2spIHtcbiAgICB2YXIgbmV3SXRlbSA9IHBoeXNpY2FsKFxuICAgICAgaXRlbS5tZXNoLFxuICAgICAgdGhpcy5wb3RlbnRpYWxDb2xsaXNpb25TZXQoKSxcbiAgICAgIFtpdGVtLnNpemUsIGl0ZW0uc2l6ZSwgaXRlbS5zaXplXVxuICAgIClcbiAgICBcbiAgICBpZiAoaXRlbS52ZWxvY2l0eSkge1xuICAgICAgbmV3SXRlbS52ZWxvY2l0eS5jb3B5KGl0ZW0udmVsb2NpdHkpXG4gICAgICBuZXdJdGVtLnN1YmplY3RUbyh0aGlzLmdyYXZpdHkpXG4gICAgfVxuICAgIFxuICAgIG5ld0l0ZW0ucmVwciA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2RlYnJpcycgfVxuICAgIG5ld0l0ZW0ubWVzaCA9IGl0ZW0ubWVzaFxuICAgIG5ld0l0ZW0uYmxvY2tzQ3JlYXRpb24gPSBpdGVtLmJsb2Nrc0NyZWF0aW9uXG4gICAgXG4gICAgaXRlbSA9IG5ld0l0ZW1cbiAgfVxuICBcbiAgdGhpcy5pdGVtcy5wdXNoKGl0ZW0pXG4gIGlmIChpdGVtLm1lc2gpIHRoaXMuc2NlbmUuYWRkKGl0ZW0ubWVzaClcbiAgcmV0dXJuIHRoaXMuaXRlbXNbdGhpcy5pdGVtcy5sZW5ndGggLSAxXVxufVxuXG5HYW1lLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24oaXRlbSkge1xuICB2YXIgaXggPSB0aGlzLml0ZW1zLmluZGV4T2YoaXRlbSlcbiAgaWYgKGl4IDwgMCkgcmV0dXJuXG4gIHRoaXMuaXRlbXMuc3BsaWNlKGl4LCAxKVxuICBpZiAoaXRlbS5tZXNoKSB0aGlzLnNjZW5lLnJlbW92ZShpdGVtLm1lc2gpXG59XG5cbi8vIG9ubHkgaW50ZXJzZWN0cyB2b3hlbHMsIG5vdCBpdGVtcyAoZm9yIG5vdylcbkdhbWUucHJvdG90eXBlLnJheWNhc3QgPSAvLyBiYWNrd2FyZHMgY29tcGF0XG5HYW1lLnByb3RvdHlwZS5yYXljYXN0Vm94ZWxzID0gZnVuY3Rpb24oc3RhcnQsIGRpcmVjdGlvbiwgbWF4RGlzdGFuY2UsIGVwaWxzb24pIHtcbiAgaWYgKCFzdGFydCkgcmV0dXJuIHRoaXMucmF5Y2FzdFZveGVscyh0aGlzLmNhbWVyYVBvc2l0aW9uKCksIHRoaXMuY2FtZXJhVmVjdG9yKCksIDEwKVxuICBcbiAgdmFyIGhpdE5vcm1hbCA9IFswLCAwLCAwXVxuICB2YXIgaGl0UG9zaXRpb24gPSBbMCwgMCwgMF1cbiAgdmFyIGNwID0gc3RhcnQgfHwgdGhpcy5jYW1lcmFQb3NpdGlvbigpXG4gIHZhciBjdiA9IGRpcmVjdGlvbiB8fCB0aGlzLmNhbWVyYVZlY3RvcigpXG4gIHZhciBoaXRCbG9jayA9IHJheSh0aGlzLCBjcCwgY3YsIG1heERpc3RhbmNlIHx8IDEwLjAsIGhpdFBvc2l0aW9uLCBoaXROb3JtYWwsIGVwaWxzb24gfHwgdGhpcy5lcGlsc29uKVxuICBpZiAoaGl0QmxvY2sgPD0gMCkgcmV0dXJuIGZhbHNlXG4gIHZhciBhZGphY2VudFBvc2l0aW9uID0gWzAsIDAsIDBdXG4gIHZhciB2b3hlbFBvc2l0aW9uID0gdGhpcy52b3hlbFBvc2l0aW9uKGhpdFBvc2l0aW9uKVxuICB2ZWN0b3IuYWRkKGFkamFjZW50UG9zaXRpb24sIHZveGVsUG9zaXRpb24sIGhpdE5vcm1hbClcbiAgXG4gIHJldHVybiB7XG4gICAgcG9zaXRpb246IGhpdFBvc2l0aW9uLFxuICAgIHZveGVsOiB2b3hlbFBvc2l0aW9uLFxuICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgIHZhbHVlOiBoaXRCbG9jayxcbiAgICBub3JtYWw6IGhpdE5vcm1hbCxcbiAgICBhZGphY2VudDogYWRqYWNlbnRQb3NpdGlvblxuICB9XG59XG5cbkdhbWUucHJvdG90eXBlLmNhbkNyZWF0ZUJsb2NrID0gZnVuY3Rpb24ocG9zKSB7XG4gIHBvcyA9IHRoaXMucGFyc2VWZWN0b3JBcmd1bWVudHMoYXJndW1lbnRzKVxuICB2YXIgZmxvb3JlZCA9IHBvcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gTWF0aC5mbG9vcihpKSB9KVxuICB2YXIgYmJveCA9IGFhYmIoZmxvb3JlZCwgWzEsIDEsIDFdKVxuICBcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuaXRlbXNbaV1cbiAgICB2YXIgaXRlbUluVGhlV2F5ID0gaXRlbS5ibG9ja3NDcmVhdGlvbiAmJiBpdGVtLmFhYmIgJiYgYmJveC5pbnRlcnNlY3RzKGl0ZW0uYWFiYigpKVxuICAgIGlmIChpdGVtSW5UaGVXYXkpIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxuR2FtZS5wcm90b3R5cGUuY3JlYXRlQmxvY2sgPSBmdW5jdGlvbihwb3MsIHZhbCkge1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHZhbCA9IHRoaXMubWF0ZXJpYWxzLmZpbmQodmFsKVxuICBpZiAoIXRoaXMuY2FuQ3JlYXRlQmxvY2socG9zKSkgcmV0dXJuIGZhbHNlXG4gIHRoaXMuc2V0QmxvY2socG9zLCB2YWwpXG4gIHJldHVybiB0cnVlXG59XG5cbkdhbWUucHJvdG90eXBlLnNldEJsb2NrID0gZnVuY3Rpb24ocG9zLCB2YWwpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB2YWwgPSB0aGlzLm1hdGVyaWFscy5maW5kKHZhbClcbiAgdmFyIG9sZCA9IHRoaXMudm94ZWxzLnZveGVsQXRQb3NpdGlvbihwb3MsIHZhbClcbiAgdmFyIGMgPSB0aGlzLnZveGVscy5jaHVua0F0UG9zaXRpb24ocG9zKVxuICB2YXIgY2h1bmsgPSB0aGlzLnZveGVscy5jaHVua3NbYy5qb2luKCd8JyldXG4gIGlmICghY2h1bmspIHJldHVybi8vIHRvZG8gLSBkb2VzIHNlbGYuZW1pdCgnbWlzc2luZ0NodW5rJywgYy5qb2luKCd8JykpIG1ha2Ugc2Vuc2UgaGVyZT9cbiAgdGhpcy5hZGRDaHVua1RvTmV4dFVwZGF0ZShjaHVuaylcbiAgdGhpcy5zcGF0aWFsLmVtaXQoJ2NoYW5nZS1ibG9jaycsIHBvcywgb2xkLCB2YWwpXG4gIHRoaXMuZW1pdCgnc2V0QmxvY2snLCBwb3MsIHZhbCwgb2xkKVxufVxuXG5HYW1lLnByb3RvdHlwZS5nZXRCbG9jayA9IGZ1bmN0aW9uKHBvcykge1xuICBwb3MgPSB0aGlzLnBhcnNlVmVjdG9yQXJndW1lbnRzKGFyZ3VtZW50cylcbiAgcmV0dXJuIHRoaXMudm94ZWxzLnZveGVsQXRQb3NpdGlvbihwb3MpXG59XG5cbkdhbWUucHJvdG90eXBlLmJsb2NrUG9zaXRpb24gPSBmdW5jdGlvbihwb3MpIHtcbiAgcG9zID0gdGhpcy5wYXJzZVZlY3RvckFyZ3VtZW50cyhhcmd1bWVudHMpXG4gIHZhciBveCA9IE1hdGguZmxvb3IocG9zWzBdKVxuICB2YXIgb3kgPSBNYXRoLmZsb29yKHBvc1sxXSlcbiAgdmFyIG96ID0gTWF0aC5mbG9vcihwb3NbMl0pXG4gIHJldHVybiBbb3gsIG95LCBvel1cbn1cblxuR2FtZS5wcm90b3R5cGUuYmxvY2tzID0gZnVuY3Rpb24obG93LCBoaWdoLCBpdGVyYXRvcikge1xuICB2YXIgbCA9IGxvdywgaCA9IGhpZ2hcbiAgdmFyIGQgPSBbIGhbMF0tbFswXSwgaFsxXS1sWzFdLCBoWzJdLWxbMl0gXVxuICBpZiAoIWl0ZXJhdG9yKSB2YXIgdm94ZWxzID0gbmV3IHRoaXMuYXJyYXlUeXBlKGRbMF0qZFsxXSpkWzJdKVxuICB2YXIgaSA9IDBcbiAgZm9yKHZhciB6PWxbMl07IHo8aFsyXTsgKyt6KVxuICBmb3IodmFyIHk9bFsxXTsgeTxoWzFdOyArK3kpXG4gIGZvcih2YXIgeD1sWzBdOyB4PGhbMF07ICsreCwgKytpKSB7XG4gICAgaWYgKGl0ZXJhdG9yKSBpdGVyYXRvcih4LCB5LCB6LCBpKVxuICAgIGVsc2Ugdm94ZWxzW2ldID0gdGhpcy52b3hlbHMudm94ZWxBdFBvc2l0aW9uKFt4LCB5LCB6XSlcbiAgfVxuICBpZiAoIWl0ZXJhdG9yKSByZXR1cm4ge3ZveGVsczogdm94ZWxzLCBkaW1zOiBkfVxufVxuXG4vLyBiYWNrd2FyZHMgY29tcGF0XG5HYW1lLnByb3RvdHlwZS5jcmVhdGVBZGphY2VudCA9IGZ1bmN0aW9uKGhpdCwgdmFsKSB7XG4gIHRoaXMuY3JlYXRlQmxvY2soaGl0LmFkamFjZW50LCB2YWwpXG59XG5cbkdhbWUucHJvdG90eXBlLmFwcGVuZFRvID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdGhpcy52aWV3LmFwcGVuZFRvKGVsZW1lbnQpXG59XG5cbi8vICMgRGVmYXVsdHMvb3B0aW9ucyBwYXJzaW5nXG5cbkdhbWUucHJvdG90eXBlLmdyYXZpdHkgPSBbMCwgLTAuMDAwMDAzNiwgMF1cbkdhbWUucHJvdG90eXBlLmZyaWN0aW9uID0gMC4zXG5HYW1lLnByb3RvdHlwZS5lcGlsc29uID0gMWUtOFxuR2FtZS5wcm90b3R5cGUudGVybWluYWxWZWxvY2l0eSA9IFswLjksIDAuMSwgMC45XVxuXG5HYW1lLnByb3RvdHlwZS5kZWZhdWx0QnV0dG9ucyA9IHtcbiAgJ1cnOiAnZm9yd2FyZCdcbiwgJ0EnOiAnbGVmdCdcbiwgJ1MnOiAnYmFja3dhcmQnXG4sICdEJzogJ3JpZ2h0J1xuLCAnPHVwPic6ICdmb3J3YXJkJ1xuLCAnPGxlZnQ+JzogJ2xlZnQnXG4sICc8ZG93bj4nOiAnYmFja3dhcmQnXG4sICc8cmlnaHQ+JzogJ3JpZ2h0J1xuLCAnPG1vdXNlIDE+JzogJ2ZpcmUnXG4sICc8bW91c2UgMz4nOiAnZmlyZWFsdCdcbiwgJzxzcGFjZT4nOiAnanVtcCdcbiwgJzxzaGlmdD4nOiAnY3JvdWNoJ1xuLCAnPGNvbnRyb2w+JzogJ2FsdCdcbn1cblxuLy8gdXNlZCBpbiBtZXRob2RzIHRoYXQgaGF2ZSBpZGVudGl0eSBmdW5jdGlvbihwb3MpIHt9XG5HYW1lLnByb3RvdHlwZS5wYXJzZVZlY3RvckFyZ3VtZW50cyA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgaWYgKCFhcmdzKSByZXR1cm4gZmFsc2VcbiAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIGFyZ3NbMF1cbiAgcmV0dXJuIFthcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdXVxufVxuXG5HYW1lLnByb3RvdHlwZS5zZXRDb25maWd1cmFibGVQb3NpdGlvbnMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciBzcCA9IG9wdHMuc3RhcnRpbmdQb3NpdGlvblxuICB0aGlzLnN0YXJ0aW5nUG9zaXRpb24gPSBzcCB8fCBbMzUsIDEwMjQsIDM1XVxuICB2YXIgd28gPSBvcHRzLndvcmxkT3JpZ2luXG4gIHRoaXMud29ybGRPcmlnaW4gPSB3byB8fCBbMCwgMCwgMF1cbn1cblxuR2FtZS5wcm90b3R5cGUuc2V0RGltZW5zaW9ucyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgaWYgKG9wdHMuY29udGFpbmVyKSB0aGlzLmNvbnRhaW5lciA9IG9wdHMuY29udGFpbmVyXG4gIGlmIChvcHRzLmNvbnRhaW5lciAmJiBvcHRzLmNvbnRhaW5lci5jbGllbnRIZWlnaHQpIHtcbiAgICB0aGlzLmhlaWdodCA9IG9wdHMuY29udGFpbmVyLmNsaWVudEhlaWdodFxuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVpZ2h0ID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IDEgOiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgfVxuICBpZiAob3B0cy5jb250YWluZXIgJiYgb3B0cy5jb250YWluZXIuY2xpZW50V2lkdGgpIHtcbiAgICB0aGlzLndpZHRoID0gb3B0cy5jb250YWluZXIuY2xpZW50V2lkdGhcbiAgfSBlbHNlIHtcbiAgICB0aGlzLndpZHRoID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IDEgOiB3aW5kb3cuaW5uZXJXaWR0aFxuICB9XG59XG5cbkdhbWUucHJvdG90eXBlLm5vdENhcGFibGUgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiggIURldGVjdG9yKCkud2ViZ2wgKSB7XG4gICAgdGhpcy52aWV3ID0ge1xuICAgICAgYXBwZW5kVG86IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgIGVsLmFwcGVuZENoaWxkKHNlbGYubm90Q2FwYWJsZU1lc3NhZ2UoKSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuR2FtZS5wcm90b3R5cGUubm90Q2FwYWJsZU1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICB3cmFwcGVyLmNsYXNzTmFtZSA9IFwiZXJyb3JNZXNzYWdlXCJcbiAgdmFyIGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgYS50aXRsZSA9IFwiWW91IG5lZWQgV2ViR0wgYW5kIFBvaW50ZXIgTG9jayAoQ2hyb21lIDIzL0ZpcmVmb3ggMTQpIHRvIHBsYXkgdGhpcyBnYW1lLiBDbGljayBoZXJlIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiXG4gIGEuaW5uZXJIVE1MID0gYS50aXRsZVxuICBhLmhyZWYgPSBcImh0dHA6Ly9nZXQud2ViZ2wub3JnXCJcbiAgd3JhcHBlci5hcHBlbmRDaGlsZChhKVxuICByZXR1cm4gd3JhcHBlclxufVxuXG5HYW1lLnByb3RvdHlwZS5vbldpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICB2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0XG4gIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgIHdpZHRoID0gdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGhcbiAgICBoZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5jbGllbnRIZWlnaHRcbiAgfVxuICB0aGlzLnZpZXcucmVzaXplV2luZG93KHdpZHRoLCBoZWlnaHQpXG59XG5cbi8vICMgUGh5c2ljcy9jb2xsaXNpb24gcmVsYXRlZCBtZXRob2RzXG5cbkdhbWUucHJvdG90eXBlLmNvbnRyb2wgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgdGhpcy5jb250cm9sbGluZyA9IHRhcmdldFxuICByZXR1cm4gdGhpcy5jb250cm9scy50YXJnZXQodGFyZ2V0KVxufVxuXG5HYW1lLnByb3RvdHlwZS5wb3RlbnRpYWxDb2xsaXNpb25TZXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFt7IGNvbGxpZGU6IHRoaXMuY29sbGlkZVRlcnJhaW4uYmluZCh0aGlzKSB9XVxufVxuXG4vKipcbiAqIEdldCB0aGUgcG9zaXRpb24gb2YgdGhlIHBsYXllciB1bmRlciBjb250cm9sLlxuICogSWYgdGhlcmUgaXMgbm8gcGxheWVyIHVuZGVyIGNvbnRyb2wsIHJldHVyblxuICogY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgZ2FtZSdzIGNhbWVyYS5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gYW4gW3gsIHksIHpdIHR1cGxlXG4gKi9cblxuR2FtZS5wcm90b3R5cGUucGxheWVyUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHRhcmdldCA9IHRoaXMuY29udHJvbHMudGFyZ2V0KClcbiAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0XG4gICAgPyB0YXJnZXQuYXZhdGFyLnBvc2l0aW9uXG4gICAgOiB0aGlzLmNhbWVyYS5sb2NhbFRvV29ybGQodGhpcy5jYW1lcmEucG9zaXRpb24uY2xvbmUoKSlcbiAgcmV0dXJuIFtwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56XVxufVxuXG5HYW1lLnByb3RvdHlwZS5wbGF5ZXJBQUJCID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgdmFyIHBvcyA9IHBvc2l0aW9uIHx8IHRoaXMucGxheWVyUG9zaXRpb24oKVxuICB2YXIgbG93ZXIgPSBbXVxuICB2YXIgdXBwZXIgPSBbMS8yLCB0aGlzLnBsYXllckhlaWdodCwgMS8yXVxuICB2YXIgcGxheWVyQm90dG9tID0gWzEvNCwgdGhpcy5wbGF5ZXJIZWlnaHQsIDEvNF1cbiAgdmVjdG9yLnN1YnRyYWN0KGxvd2VyLCBwb3MsIHBsYXllckJvdHRvbSlcbiAgdmFyIGJib3ggPSBhYWJiKGxvd2VyLCB1cHBlcilcbiAgcmV0dXJuIGJib3hcbn1cblxuR2FtZS5wcm90b3R5cGUuY29sbGlkZVRlcnJhaW4gPSBmdW5jdGlvbihvdGhlciwgYmJveCwgdmVjLCByZXN0aW5nKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgYXhlcyA9IFsneCcsICd5JywgJ3onXVxuICB2YXIgdmVjMyA9IFt2ZWMueCwgdmVjLnksIHZlYy56XVxuICB0aGlzLmNvbGxpZGVWb3hlbHMoYmJveCwgdmVjMywgZnVuY3Rpb24gaGl0KGF4aXMsIHRpbGUsIGNvb3JkcywgZGlyLCBlZGdlKSB7XG4gICAgaWYgKCF0aWxlKSByZXR1cm5cbiAgICBpZiAoTWF0aC5hYnModmVjM1theGlzXSkgPCBNYXRoLmFicyhlZGdlKSkgcmV0dXJuXG4gICAgdmVjM1theGlzXSA9IHZlY1theGVzW2F4aXNdXSA9IGVkZ2VcbiAgICBvdGhlci5hY2NlbGVyYXRpb25bYXhlc1theGlzXV0gPSAwXG4gICAgcmVzdGluZ1theGVzW2F4aXNdXSA9IGRpclxuICAgIG90aGVyLmZyaWN0aW9uW2F4ZXNbKGF4aXMgKyAxKSAlIDNdXSA9IG90aGVyLmZyaWN0aW9uW2F4ZXNbKGF4aXMgKyAyKSAlIDNdXSA9IGF4aXMgPT09IDEgPyBzZWxmLmZyaWN0aW9uICA6IDFcbiAgICByZXR1cm4gdHJ1ZVxuICB9KVxufVxuXG4vLyAjIFRocmVlLmpzIHNwZWNpZmljIG1ldGhvZHNcblxuR2FtZS5wcm90b3R5cGUuYWRkU3RhdHMgPSBmdW5jdGlvbigpIHtcbiAgc3RhdHMgPSBuZXcgU3RhdHMoKVxuICBzdGF0cy5kb21FbGVtZW50LnN0eWxlLnBvc2l0aW9uICA9ICdhYnNvbHV0ZSdcbiAgc3RhdHMuZG9tRWxlbWVudC5zdHlsZS5ib3R0b20gID0gJzBweCdcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCggc3RhdHMuZG9tRWxlbWVudCApXG59XG5cbkdhbWUucHJvdG90eXBlLmFkZExpZ2h0cyA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHZhciBhbWJpZW50TGlnaHQsIGRpcmVjdGlvbmFsTGlnaHRcbiAgYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCgweGNjY2NjYylcbiAgc2NlbmUuYWRkKGFtYmllbnRMaWdodClcbiAgdmFyIGxpZ2h0XHQ9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCAweGZmZmZmZiAsIDEpXG4gIGxpZ2h0LnBvc2l0aW9uLnNldCggMSwgMSwgMC41ICkubm9ybWFsaXplKClcbiAgc2NlbmUuYWRkKCBsaWdodCApXG59XG5cbi8vICMgQ2h1bmsgcmVsYXRlZCBtZXRob2RzXG5cbkdhbWUucHJvdG90eXBlLmNvbmZpZ3VyZUNodW5rTG9hZGluZyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0cy5nZW5lcmF0ZUNodW5rcykgcmV0dXJuXG4gIGlmICghb3B0cy5nZW5lcmF0ZSkge1xuICAgIHRoaXMuZ2VuZXJhdGUgPSBmdW5jdGlvbih4LHkseikge1xuICAgICAgcmV0dXJuIHgqeCt5Knkreip6IDw9IDE1KjE1ID8gMSA6IDAgLy8gc3BoZXJlIHdvcmxkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2VuZXJhdGUgPSBvcHRzLmdlbmVyYXRlXG4gIH1cbiAgaWYgKG9wdHMuZ2VuZXJhdGVWb3hlbENodW5rKSB7XG4gICAgdGhpcy5nZW5lcmF0ZVZveGVsQ2h1bmsgPSBvcHRzLmdlbmVyYXRlVm94ZWxDaHVua1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2VuZXJhdGVWb3hlbENodW5rID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gICAgICByZXR1cm4gdm94ZWwuZ2VuZXJhdGUobG93LCBoaWdoLCBzZWxmLmdlbmVyYXRlLCBzZWxmKVxuICAgIH1cbiAgfVxufVxuXG5HYW1lLnByb3RvdHlwZS53b3JsZFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmNodW5rU2l6ZSAqIDIgKiB0aGlzLmNodW5rRGlzdGFuY2Vcbn1cblxuR2FtZS5wcm90b3R5cGUuY2h1bmtUb1dvcmxkID0gZnVuY3Rpb24ocG9zKSB7XG4gIHJldHVybiBbXG4gICAgcG9zWzBdICogdGhpcy5jaHVua1NpemUsXG4gICAgcG9zWzFdICogdGhpcy5jaHVua1NpemUsXG4gICAgcG9zWzJdICogdGhpcy5jaHVua1NpemVcbiAgXVxufVxuXG5HYW1lLnByb3RvdHlwZS5yZW1vdmVGYXJDaHVua3MgPSBmdW5jdGlvbihwbGF5ZXJQb3NpdGlvbikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgcGxheWVyUG9zaXRpb24gPSBwbGF5ZXJQb3NpdGlvbiB8fCB0aGlzLnBsYXllclBvc2l0aW9uKClcbiAgdmFyIG5lYXJieUNodW5rcyA9IHRoaXMudm94ZWxzLm5lYXJieUNodW5rcyhwbGF5ZXJQb3NpdGlvbiwgdGhpcy5yZW1vdmVEaXN0YW5jZSkubWFwKGZ1bmN0aW9uKGNodW5rUG9zKSB7XG4gICAgcmV0dXJuIGNodW5rUG9zLmpvaW4oJ3wnKVxuICB9KVxuICBPYmplY3Qua2V5cyhzZWxmLnZveGVscy5jaHVua3MpLm1hcChmdW5jdGlvbihjaHVua0luZGV4KSB7XG4gICAgaWYgKG5lYXJieUNodW5rcy5pbmRleE9mKGNodW5rSW5kZXgpID4gLTEpIHJldHVyblxuICAgIHZhciBjaHVuayA9IHNlbGYudm94ZWxzLmNodW5rc1tjaHVua0luZGV4XVxuICAgIHZhciBtZXNoID0gc2VsZi52b3hlbHMubWVzaGVzW2NodW5rSW5kZXhdXG4gICAgdmFyIHBlbmRpbmdJbmRleCA9IHNlbGYucGVuZGluZ0NodW5rcy5pbmRleE9mKGNodW5rSW5kZXgpXG4gICAgaWYgKHBlbmRpbmdJbmRleCAhPT0gLTEpIHNlbGYucGVuZGluZ0NodW5rcy5zcGxpY2UocGVuZGluZ0luZGV4LCAxKVxuICAgIGlmICghY2h1bmspIHJldHVyblxuICAgIHZhciBjaHVua1Bvc2l0aW9uID0gY2h1bmsucG9zaXRpb25cbiAgICBpZiAobWVzaCkge1xuICAgICAgc2VsZi5zY2VuZS5yZW1vdmUobWVzaFtzZWxmLm1lc2hUeXBlXSlcbiAgICAgIG1lc2hbc2VsZi5tZXNoVHlwZV0uZ2VvbWV0cnkuZGlzcG9zZSgpXG4gICAgICBkZWxldGUgbWVzaC5kYXRhXG4gICAgICBkZWxldGUgbWVzaC5nZW9tZXRyeVxuICAgICAgZGVsZXRlIG1lc2gubWVzaGVkXG4gICAgICBkZWxldGUgbWVzaC5zdXJmYWNlTWVzaFxuICAgIH1cbiAgICBkZWxldGUgc2VsZi52b3hlbHMuY2h1bmtzW2NodW5rSW5kZXhdXG4gICAgc2VsZi5lbWl0KCdyZW1vdmVDaHVuaycsIGNodW5rUG9zaXRpb24pXG4gIH0pXG4gIHNlbGYudm94ZWxzLnJlcXVlc3RNaXNzaW5nQ2h1bmtzKHBsYXllclBvc2l0aW9uKVxufVxuXG5HYW1lLnByb3RvdHlwZS5hZGRDaHVua1RvTmV4dFVwZGF0ZSA9IGZ1bmN0aW9uKGNodW5rKSB7XG4gIHRoaXMuY2h1bmtzTmVlZHNVcGRhdGVbY2h1bmsucG9zaXRpb24uam9pbignfCcpXSA9IGNodW5rXG59XG5cbkdhbWUucHJvdG90eXBlLnVwZGF0ZURpcnR5Q2h1bmtzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICBPYmplY3Qua2V5cyh0aGlzLmNodW5rc05lZWRzVXBkYXRlKS5mb3JFYWNoKGZ1bmN0aW9uIHNob3dDaHVua0F0SW5kZXgoY2h1bmtJbmRleCkge1xuICAgIHZhciBjaHVuayA9IHNlbGYuY2h1bmtzTmVlZHNVcGRhdGVbY2h1bmtJbmRleF1cbiAgICBzZWxmLmVtaXQoJ2RpcnR5Q2h1bmtVcGRhdGUnLCBjaHVuaylcbiAgICBzZWxmLnNob3dDaHVuayhjaHVuaylcbiAgfSlcbiAgdGhpcy5jaHVua3NOZWVkc1VwZGF0ZSA9IHt9XG59XG5cbkdhbWUucHJvdG90eXBlLmxvYWRQZW5kaW5nQ2h1bmtzID0gZnVuY3Rpb24oY291bnQpIHtcbiAgdmFyIHBlbmRpbmdDaHVua3MgPSB0aGlzLnBlbmRpbmdDaHVua3NcblxuICBpZiAoIXRoaXMuYXN5bmNDaHVua0dlbmVyYXRpb24pIHtcbiAgICBjb3VudCA9IHBlbmRpbmdDaHVua3MubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgY291bnQgPSBjb3VudCB8fCAocGVuZGluZ0NodW5rcy5sZW5ndGggKiAwLjEpXG4gICAgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLm1pbihjb3VudCwgcGVuZGluZ0NodW5rcy5sZW5ndGgpKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgdmFyIGNodW5rUG9zID0gcGVuZGluZ0NodW5rc1tpXS5zcGxpdCgnfCcpXG4gICAgdmFyIGNodW5rID0gdGhpcy52b3hlbHMuZ2VuZXJhdGVDaHVuayhjaHVua1Bvc1swXXwwLCBjaHVua1Bvc1sxXXwwLCBjaHVua1Bvc1syXXwwKVxuXG4gICAgaWYgKHByb2Nlc3MuYnJvd3NlcikgdGhpcy5zaG93Q2h1bmsoY2h1bmspXG4gIH1cblxuICBpZiAoY291bnQpIHBlbmRpbmdDaHVua3Muc3BsaWNlKDAsIGNvdW50KVxufVxuXG5HYW1lLnByb3RvdHlwZS5nZXRDaHVua0F0UG9zaXRpb24gPSBmdW5jdGlvbihwb3MpIHtcbiAgdmFyIGNodW5rSUQgPSB0aGlzLnZveGVscy5jaHVua0F0UG9zaXRpb24ocG9zKS5qb2luKCd8JylcbiAgdmFyIGNodW5rID0gdGhpcy52b3hlbHMuY2h1bmtzW2NodW5rSURdXG4gIHJldHVybiBjaHVua1xufVxuXG5HYW1lLnByb3RvdHlwZS5zaG93Q2h1bmsgPSBmdW5jdGlvbihjaHVuaykge1xuICB2YXIgY2h1bmtJbmRleCA9IGNodW5rLnBvc2l0aW9uLmpvaW4oJ3wnKVxuICB2YXIgYm91bmRzID0gdGhpcy52b3hlbHMuZ2V0Qm91bmRzLmFwcGx5KHRoaXMudm94ZWxzLCBjaHVuay5wb3NpdGlvbilcbiAgdmFyIHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjMoMSwgMSwgMSlcbiAgdmFyIG1lc2ggPSB2b3hlbE1lc2goY2h1bmssIHRoaXMubWVzaGVyLCBzY2FsZSwgdGhpcy5USFJFRSlcbiAgdGhpcy52b3hlbHMuY2h1bmtzW2NodW5rSW5kZXhdID0gY2h1bmtcbiAgaWYgKHRoaXMudm94ZWxzLm1lc2hlc1tjaHVua0luZGV4XSkgdGhpcy5zY2VuZS5yZW1vdmUodGhpcy52b3hlbHMubWVzaGVzW2NodW5rSW5kZXhdW3RoaXMubWVzaFR5cGVdKVxuICB0aGlzLnZveGVscy5tZXNoZXNbY2h1bmtJbmRleF0gPSBtZXNoXG4gIGlmIChwcm9jZXNzLmJyb3dzZXIpIHtcbiAgICBpZiAodGhpcy5tZXNoVHlwZSA9PT0gJ3dpcmVNZXNoJykgbWVzaC5jcmVhdGVXaXJlTWVzaCgpXG4gICAgZWxzZSBtZXNoLmNyZWF0ZVN1cmZhY2VNZXNoKHRoaXMubWF0ZXJpYWxzLm1hdGVyaWFsKVxuICAgIHRoaXMubWF0ZXJpYWxzLnBhaW50KG1lc2gpXG4gIH1cbiAgbWVzaC5zZXRQb3NpdGlvbihib3VuZHNbMF1bMF0sIGJvdW5kc1swXVsxXSwgYm91bmRzWzBdWzJdKVxuICBtZXNoLmFkZFRvU2NlbmUodGhpcy5zY2VuZSlcbiAgdGhpcy5lbWl0KCdyZW5kZXJDaHVuaycsIGNodW5rKVxuICByZXR1cm4gbWVzaFxufVxuXG4vLyAjIERlYnVnZ2luZyBtZXRob2RzXG5cbkdhbWUucHJvdG90eXBlLmFkZE1hcmtlciA9IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gIHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggMC4xLCAxMCwgMTAgKVxuICB2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoIHsgY29sb3I6IDB4ZmZmZmZmLCBzaGFkaW5nOiBUSFJFRS5GbGF0U2hhZGluZyB9IClcbiAgdmFyIG1lc2ggPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsIClcbiAgbWVzaC5wb3NpdGlvbi5jb3B5KHBvc2l0aW9uKVxuICB0aGlzLnNjZW5lLmFkZChtZXNoKVxufVxuXG5HYW1lLnByb3RvdHlwZS5hZGRBQUJCTWFya2VyID0gZnVuY3Rpb24oYWFiYiwgY29sb3IpIHtcbiAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkN1YmVHZW9tZXRyeShhYWJiLndpZHRoKCksIGFhYmIuaGVpZ2h0KCksIGFhYmIuZGVwdGgoKSlcbiAgdmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHsgY29sb3I6IGNvbG9yIHx8IDB4ZmZmZmZmLCB3aXJlZnJhbWU6IHRydWUsIHRyYW5zcGFyZW50OiB0cnVlLCBvcGFjaXR5OiAwLjUsIHNpZGU6IFRIUkVFLkRvdWJsZVNpZGUgfSlcbiAgdmFyIG1lc2ggPSBuZXcgVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpXG4gIG1lc2gucG9zaXRpb24uc2V0KGFhYmIueDAoKSArIGFhYmIud2lkdGgoKSAvIDIsIGFhYmIueTAoKSArIGFhYmIuaGVpZ2h0KCkgLyAyLCBhYWJiLnowKCkgKyBhYWJiLmRlcHRoKCkgLyAyKVxuICB0aGlzLnNjZW5lLmFkZChtZXNoKVxuICByZXR1cm4gbWVzaFxufVxuXG5HYW1lLnByb3RvdHlwZS5hZGRWb3hlbE1hcmtlciA9IGZ1bmN0aW9uKHgsIHksIHosIGNvbG9yKSB7XG4gIHZhciBiYm94ID0gYWFiYihbeCwgeSwgel0sIFsxLCAxLCAxXSlcbiAgcmV0dXJuIHRoaXMuYWRkQUFCQk1hcmtlcihiYm94LCBjb2xvcilcbn1cblxuR2FtZS5wcm90b3R5cGUucGluID0gcGluXG5cbi8vICMgTWlzYyBpbnRlcm5hbCBtZXRob2RzXG5cbkdhbWUucHJvdG90eXBlLm9uQ29udHJvbENoYW5nZSA9IGZ1bmN0aW9uKGdhaW5lZCwgc3RyZWFtKSB7XG4gIHRoaXMucGF1c2VkID0gZmFsc2VcblxuICBpZiAoIWdhaW5lZCAmJiAhdGhpcy5vcHRvdXQpIHtcbiAgICB0aGlzLmJ1dHRvbnMuZGlzYWJsZSgpXG4gICAgcmV0dXJuXG4gIH1cblxuICB0aGlzLmJ1dHRvbnMuZW5hYmxlKClcbiAgc3RyZWFtLnBpcGUodGhpcy5jb250cm9scy5jcmVhdGVXcml0ZVJvdGF0aW9uU3RyZWFtKCkpXG59XG5cbkdhbWUucHJvdG90eXBlLm9uQ29udHJvbE9wdE91dCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLm9wdG91dCA9IHRydWVcbn1cblxuR2FtZS5wcm90b3R5cGUub25GaXJlID0gZnVuY3Rpb24oc3RhdGUpIHtcbiAgdGhpcy5lbWl0KCdmaXJlJywgdGhpcy5jb250cm9sbGluZywgc3RhdGUpXG59XG5cbkdhbWUucHJvdG90eXBlLnNldEludGVydmFsID0gdGljLmludGVydmFsLmJpbmQodGljKVxuR2FtZS5wcm90b3R5cGUuc2V0VGltZW91dCA9IHRpYy50aW1lb3V0LmJpbmQodGljKVxuXG5HYW1lLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oZGVsdGEpIHtcbiAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHRoaXMuaXRlbXNbaV0udGljayhkZWx0YSlcbiAgfVxuICBcbiAgaWYgKHRoaXMubWF0ZXJpYWxzKSB0aGlzLm1hdGVyaWFscy50aWNrKGRlbHRhKVxuXG4gIGlmICh0aGlzLnBlbmRpbmdDaHVua3MubGVuZ3RoKSB0aGlzLmxvYWRQZW5kaW5nQ2h1bmtzKClcbiAgaWYgKE9iamVjdC5rZXlzKHRoaXMuY2h1bmtzTmVlZHNVcGRhdGUpLmxlbmd0aCA+IDApIHRoaXMudXBkYXRlRGlydHlDaHVua3MoKVxuICBcbiAgdGljLnRpY2soZGVsdGEpXG5cbiAgdGhpcy5lbWl0KCd0aWNrJywgZGVsdGEpXG4gIFxuICBpZiAoIXRoaXMuY29udHJvbHMpIHJldHVyblxuICB2YXIgcGxheWVyUG9zID0gdGhpcy5wbGF5ZXJQb3NpdGlvbigpXG4gIHRoaXMuc3BhdGlhbC5lbWl0KCdwb3NpdGlvbicsIHBsYXllclBvcywgcGxheWVyUG9zKVxufVxuXG5HYW1lLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihkZWx0YSkge1xuICB0aGlzLnZpZXcucmVuZGVyKHRoaXMuc2NlbmUpXG59XG5cbkdhbWUucHJvdG90eXBlLmluaXRpYWxpemVUaW1lciA9IGZ1bmN0aW9uKHJhdGUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBhY2N1bSA9IDBcbiAgdmFyIG5vdyA9IDBcbiAgdmFyIGxhc3QgPSBudWxsXG4gIHZhciBkdCA9IDBcbiAgdmFyIHdob2xlVGlja1xuICBcbiAgc2VsZi5mcmFtZVVwZGF0ZWQgPSB0cnVlXG4gIHNlbGYuaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aW1lciwgMClcbiAgcmV0dXJuIHNlbGYuaW50ZXJ2YWxcbiAgXG4gIGZ1bmN0aW9uIHRpbWVyKCkge1xuICAgIGlmIChzZWxmLnBhdXNlZCkge1xuICAgICAgbGFzdCA9IERhdGUubm93KClcbiAgICAgIGFjY3VtID0gMFxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIG5vdyA9IERhdGUubm93KClcbiAgICBkdCA9IG5vdyAtIChsYXN0IHx8IG5vdylcbiAgICBsYXN0ID0gbm93XG4gICAgYWNjdW0gKz0gZHRcbiAgICBpZiAoYWNjdW0gPCByYXRlKSByZXR1cm5cbiAgICB3aG9sZVRpY2sgPSAoKGFjY3VtIC8gcmF0ZSl8MClcbiAgICBpZiAod2hvbGVUaWNrIDw9IDApIHJldHVyblxuICAgIHdob2xlVGljayAqPSByYXRlXG4gICAgXG4gICAgc2VsZi50aWNrKHdob2xlVGljaylcbiAgICBhY2N1bSAtPSB3aG9sZVRpY2tcbiAgICBcbiAgICBzZWxmLmZyYW1lVXBkYXRlZCA9IHRydWVcbiAgfVxufVxuXG5HYW1lLnByb3RvdHlwZS5pbml0aWFsaXplUmVuZGVyaW5nID0gZnVuY3Rpb24ob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBpZiAoIW9wdHMuc3RhdHNEaXNhYmxlZCkgc2VsZi5hZGRTdGF0cygpXG5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHNlbGYub25XaW5kb3dSZXNpemUuYmluZChzZWxmKSwgZmFsc2UpXG5cbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHdpbmRvdykub24oJ2RhdGEnLCBmdW5jdGlvbihkdCkge1xuICAgIHNlbGYuZW1pdCgncHJlcmVuZGVyJywgZHQpXG4gICAgc2VsZi5yZW5kZXIoZHQpXG4gICAgc2VsZi5lbWl0KCdwb3N0cmVuZGVyJywgZHQpXG4gIH0pXG4gIGlmICh0eXBlb2Ygc3RhdHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2VsZi5vbigncG9zdHJlbmRlcicsIGZ1bmN0aW9uKCkge1xuICAgICAgc3RhdHMudXBkYXRlKClcbiAgICB9KVxuICB9XG59XG5cbkdhbWUucHJvdG90eXBlLmluaXRpYWxpemVDb250cm9scyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgLy8gcGxheWVyIGNvbnRyb2xcbiAgdGhpcy5rZXliaW5kaW5ncyA9IG9wdHMua2V5YmluZGluZ3MgfHwgdGhpcy5kZWZhdWx0QnV0dG9uc1xuICB0aGlzLmJ1dHRvbnMgPSBrYihkb2N1bWVudC5ib2R5LCB0aGlzLmtleWJpbmRpbmdzKVxuICB0aGlzLmJ1dHRvbnMuZGlzYWJsZSgpXG4gIHRoaXMub3B0b3V0ID0gZmFsc2VcbiAgdGhpcy5pbnRlcmFjdCA9IGludGVyYWN0KG9wdHMuaW50ZXJhY3RFbGVtZW50IHx8IHRoaXMudmlldy5lbGVtZW50LCBvcHRzLmludGVyYWN0TW91c2VEcmFnKVxuICB0aGlzLmludGVyYWN0XG4gICAgICAub24oJ2F0dGFpbicsIHRoaXMub25Db250cm9sQ2hhbmdlLmJpbmQodGhpcywgdHJ1ZSkpXG4gICAgICAub24oJ3JlbGVhc2UnLCB0aGlzLm9uQ29udHJvbENoYW5nZS5iaW5kKHRoaXMsIGZhbHNlKSlcbiAgICAgIC5vbignb3B0LW91dCcsIHRoaXMub25Db250cm9sT3B0T3V0LmJpbmQodGhpcykpXG4gIHRoaXMuaG9va3VwQ29udHJvbHModGhpcy5idXR0b25zLCBvcHRzKVxufVxuXG5HYW1lLnByb3RvdHlwZS5ob29rdXBDb250cm9scyA9IGZ1bmN0aW9uKGJ1dHRvbnMsIG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgb3B0cy5jb250cm9scyA9IG9wdHMuY29udHJvbHMgfHwge31cbiAgb3B0cy5jb250cm9scy5vbmZpcmUgPSB0aGlzLm9uRmlyZS5iaW5kKHRoaXMpXG4gIHRoaXMuY29udHJvbHMgPSBjb250cm9sKGJ1dHRvbnMsIG9wdHMuY29udHJvbHMpXG4gIHRoaXMuaXRlbXMucHVzaCh0aGlzLmNvbnRyb2xzKVxuICB0aGlzLmNvbnRyb2xsaW5nID0gbnVsbFxufVxuXG5HYW1lLnByb3RvdHlwZS5oYW5kbGVDaHVua0dlbmVyYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMudm94ZWxzLm9uKCdtaXNzaW5nQ2h1bmsnLCBmdW5jdGlvbihjaHVua1Bvcykge1xuICAgIHNlbGYucGVuZGluZ0NodW5rcy5wdXNoKGNodW5rUG9zLmpvaW4oJ3wnKSlcbiAgfSlcbiAgdGhpcy52b3hlbHMucmVxdWVzdE1pc3NpbmdDaHVua3ModGhpcy53b3JsZE9yaWdpbilcbiAgdGhpcy5sb2FkUGVuZGluZ0NodW5rcyh0aGlzLnBlbmRpbmdDaHVua3MubGVuZ3RoKVxufVxuXG4vLyB0ZWFyZG93biBtZXRob2RzXG5HYW1lLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcilcbn1cbiIsIi8qKlxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cbiAqIEBhdXRob3IgbXIuZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gIFx0Y2FudmFzIDogISEgd2luZG93LkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCxcbiAgXHR3ZWJnbCA6ICggZnVuY3Rpb24gKCkgeyB0cnkgeyByZXR1cm4gISEgd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dCAmJiAhISBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLmdldENvbnRleHQoICdleHBlcmltZW50YWwtd2ViZ2wnICk7IH0gY2F0Y2goIGUgKSB7IHJldHVybiBmYWxzZTsgfSB9ICkoKSxcbiAgXHR3b3JrZXJzIDogISEgd2luZG93LldvcmtlcixcbiAgXHRmaWxlYXBpIDogd2luZG93LkZpbGUgJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGVMaXN0ICYmIHdpbmRvdy5CbG9iLFxuXG4gIFx0Z2V0V2ViR0xFcnJvck1lc3NhZ2UgOiBmdW5jdGlvbiAoKSB7XG5cbiAgXHRcdHZhciBkb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblxuICBcdFx0ZG9tRWxlbWVudC5zdHlsZS5mb250RmFtaWx5ID0gJ21vbm9zcGFjZSc7XG4gIFx0XHRkb21FbGVtZW50LnN0eWxlLmZvbnRTaXplID0gJzEzcHgnO1xuICBcdFx0ZG9tRWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgXHRcdGRvbUVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZCA9ICcjZWVlJztcbiAgXHRcdGRvbUVsZW1lbnQuc3R5bGUuY29sb3IgPSAnIzAwMCc7XG4gIFx0XHRkb21FbGVtZW50LnN0eWxlLnBhZGRpbmcgPSAnMWVtJztcbiAgXHRcdGRvbUVsZW1lbnQuc3R5bGUud2lkdGggPSAnNDc1cHgnO1xuICBcdFx0ZG9tRWxlbWVudC5zdHlsZS5tYXJnaW4gPSAnNWVtIGF1dG8gMCc7XG5cbiAgXHRcdGlmICggISB0aGlzLndlYmdsICkge1xuXG4gIFx0XHRcdGRvbUVsZW1lbnQuaW5uZXJIVE1MID0gd2luZG93LldlYkdMUmVuZGVyaW5nQ29udGV4dCA/IFtcbiAgXHRcdFx0XHQnWW91ciBncmFwaGljcyBjYXJkIGRvZXMgbm90IHNlZW0gdG8gc3VwcG9ydCA8YSBocmVmPVwiaHR0cDovL2tocm9ub3Mub3JnL3dlYmdsL3dpa2kvR2V0dGluZ19hX1dlYkdMX0ltcGxlbWVudGF0aW9uXCI+V2ViR0w8L2E+LjxiciAvPicsXG4gIFx0XHRcdFx0J0ZpbmQgb3V0IGhvdyB0byBnZXQgaXQgPGEgaHJlZj1cImh0dHA6Ly9nZXQud2ViZ2wub3JnL1wiPmhlcmU8L2E+LidcbiAgXHRcdFx0XS5qb2luKCAnXFxuJyApIDogW1xuICBcdFx0XHRcdCdZb3VyIGJyb3dzZXIgZG9lcyBub3Qgc2VlbSB0byBzdXBwb3J0IDxhIGhyZWY9XCJodHRwOi8va2hyb25vcy5vcmcvd2ViZ2wvd2lraS9HZXR0aW5nX2FfV2ViR0xfSW1wbGVtZW50YXRpb25cIj5XZWJHTDwvYT4uPGJyLz4nLFxuICBcdFx0XHRcdCdGaW5kIG91dCBob3cgdG8gZ2V0IGl0IDxhIGhyZWY9XCJodHRwOi8vZ2V0LndlYmdsLm9yZy9cIj5oZXJlPC9hPi4nXG4gIFx0XHRcdF0uam9pbiggJ1xcbicgKTtcblxuICBcdFx0fVxuXG4gIFx0XHRyZXR1cm4gZG9tRWxlbWVudDtcblxuICBcdH0sXG5cbiAgXHRhZGRHZXRXZWJHTE1lc3NhZ2UgOiBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XG5cbiAgXHRcdHZhciBwYXJlbnQsIGlkLCBkb21FbGVtZW50O1xuXG4gIFx0XHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcblxuICBcdFx0cGFyZW50ID0gcGFyYW1ldGVycy5wYXJlbnQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucGFyZW50IDogZG9jdW1lbnQuYm9keTtcbiAgXHRcdGlkID0gcGFyYW1ldGVycy5pZCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5pZCA6ICdvbGRpZSc7XG5cbiAgXHRcdGRvbUVsZW1lbnQgPSBEZXRlY3Rvci5nZXRXZWJHTEVycm9yTWVzc2FnZSgpO1xuICBcdFx0ZG9tRWxlbWVudC5pZCA9IGlkO1xuXG4gIFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoIGRvbUVsZW1lbnQgKTtcblxuICBcdH1cblxuICB9O1xufVxuIiwiLyoqXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xuICovXG5cbnZhciBTdGF0cyA9IGZ1bmN0aW9uICgpIHtcblxuXHR2YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKSwgcHJldlRpbWUgPSBzdGFydFRpbWU7XG5cdHZhciBtcyA9IDAsIG1zTWluID0gSW5maW5pdHksIG1zTWF4ID0gMDtcblx0dmFyIGZwcyA9IDAsIGZwc01pbiA9IEluZmluaXR5LCBmcHNNYXggPSAwO1xuXHR2YXIgZnJhbWVzID0gMCwgbW9kZSA9IDA7XG5cblx0dmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdGNvbnRhaW5lci5pZCA9ICdzdGF0cyc7XG5cdGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKCBldmVudCApIHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgc2V0TW9kZSggKysgbW9kZSAlIDIgKSB9LCBmYWxzZSApO1xuXHRjb250YWluZXIuc3R5bGUuY3NzVGV4dCA9ICd3aWR0aDo4MHB4O29wYWNpdHk6MC45O2N1cnNvcjpwb2ludGVyJztcblxuXHR2YXIgZnBzRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0ZnBzRGl2LmlkID0gJ2Zwcyc7XG5cdGZwc0Rpdi5zdHlsZS5jc3NUZXh0ID0gJ3BhZGRpbmc6MCAwIDNweCAzcHg7dGV4dC1hbGlnbjpsZWZ0O2JhY2tncm91bmQtY29sb3I6IzAwMic7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZnBzRGl2ICk7XG5cblx0dmFyIGZwc1RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRmcHNUZXh0LmlkID0gJ2Zwc1RleHQnO1xuXHRmcHNUZXh0LnN0eWxlLmNzc1RleHQgPSAnY29sb3I6IzBmZjtmb250LWZhbWlseTpIZWx2ZXRpY2EsQXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6OXB4O2ZvbnQtd2VpZ2h0OmJvbGQ7bGluZS1oZWlnaHQ6MTVweCc7XG5cdGZwc1RleHQuaW5uZXJIVE1MID0gJ0ZQUyc7XG5cdGZwc0Rpdi5hcHBlbmRDaGlsZCggZnBzVGV4dCApO1xuXG5cdHZhciBmcHNHcmFwaCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdGZwc0dyYXBoLmlkID0gJ2Zwc0dyYXBoJztcblx0ZnBzR3JhcGguc3R5bGUuY3NzVGV4dCA9ICdwb3NpdGlvbjpyZWxhdGl2ZTt3aWR0aDo3NHB4O2hlaWdodDozMHB4O2JhY2tncm91bmQtY29sb3I6IzBmZic7XG5cdGZwc0Rpdi5hcHBlbmRDaGlsZCggZnBzR3JhcGggKTtcblxuXHR3aGlsZSAoIGZwc0dyYXBoLmNoaWxkcmVuLmxlbmd0aCA8IDc0ICkge1xuXG5cdFx0dmFyIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdzcGFuJyApO1xuXHRcdGJhci5zdHlsZS5jc3NUZXh0ID0gJ3dpZHRoOjFweDtoZWlnaHQ6MzBweDtmbG9hdDpsZWZ0O2JhY2tncm91bmQtY29sb3I6IzExMyc7XG5cdFx0ZnBzR3JhcGguYXBwZW5kQ2hpbGQoIGJhciApO1xuXG5cdH1cblxuXHR2YXIgbXNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnZGl2JyApO1xuXHRtc0Rpdi5pZCA9ICdtcyc7XG5cdG1zRGl2LnN0eWxlLmNzc1RleHQgPSAncGFkZGluZzowIDAgM3B4IDNweDt0ZXh0LWFsaWduOmxlZnQ7YmFja2dyb3VuZC1jb2xvcjojMDIwO2Rpc3BsYXk6bm9uZSc7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggbXNEaXYgKTtcblxuXHR2YXIgbXNUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0bXNUZXh0LmlkID0gJ21zVGV4dCc7XG5cdG1zVGV4dC5zdHlsZS5jc3NUZXh0ID0gJ2NvbG9yOiMwZjA7Zm9udC1mYW1pbHk6SGVsdmV0aWNhLEFyaWFsLHNhbnMtc2VyaWY7Zm9udC1zaXplOjlweDtmb250LXdlaWdodDpib2xkO2xpbmUtaGVpZ2h0OjE1cHgnO1xuXHRtc1RleHQuaW5uZXJIVE1MID0gJ01TJztcblx0bXNEaXYuYXBwZW5kQ2hpbGQoIG1zVGV4dCApO1xuXG5cdHZhciBtc0dyYXBoID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0bXNHcmFwaC5pZCA9ICdtc0dyYXBoJztcblx0bXNHcmFwaC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjc0cHg7aGVpZ2h0OjMwcHg7YmFja2dyb3VuZC1jb2xvcjojMGYwJztcblx0bXNEaXYuYXBwZW5kQ2hpbGQoIG1zR3JhcGggKTtcblxuXHR3aGlsZSAoIG1zR3JhcGguY2hpbGRyZW4ubGVuZ3RoIDwgNzQgKSB7XG5cblx0XHR2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3NwYW4nICk7XG5cdFx0YmFyLnN0eWxlLmNzc1RleHQgPSAnd2lkdGg6MXB4O2hlaWdodDozMHB4O2Zsb2F0OmxlZnQ7YmFja2dyb3VuZC1jb2xvcjojMTMxJztcblx0XHRtc0dyYXBoLmFwcGVuZENoaWxkKCBiYXIgKTtcblxuXHR9XG5cblx0dmFyIHNldE1vZGUgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xuXG5cdFx0bW9kZSA9IHZhbHVlO1xuXG5cdFx0c3dpdGNoICggbW9kZSApIHtcblxuXHRcdFx0Y2FzZSAwOlxuXHRcdFx0XHRmcHNEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHRcdG1zRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHRmcHNEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0bXNEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHR9XG5cblx0dmFyIHVwZGF0ZUdyYXBoID0gZnVuY3Rpb24gKCBkb20sIHZhbHVlICkge1xuXG5cdFx0dmFyIGNoaWxkID0gZG9tLmFwcGVuZENoaWxkKCBkb20uZmlyc3RDaGlsZCApO1xuXHRcdGNoaWxkLnN0eWxlLmhlaWdodCA9IHZhbHVlICsgJ3B4JztcblxuXHR9XG5cblx0cmV0dXJuIHtcblxuXHRcdFJFVklTSU9OOiAxMSxcblxuXHRcdGRvbUVsZW1lbnQ6IGNvbnRhaW5lcixcblxuXHRcdHNldE1vZGU6IHNldE1vZGUsXG5cblx0XHRiZWdpbjogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG5cdFx0fSxcblxuXHRcdGVuZDogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHR2YXIgdGltZSA9IERhdGUubm93KCk7XG5cblx0XHRcdG1zID0gdGltZSAtIHN0YXJ0VGltZTtcblx0XHRcdG1zTWluID0gTWF0aC5taW4oIG1zTWluLCBtcyApO1xuXHRcdFx0bXNNYXggPSBNYXRoLm1heCggbXNNYXgsIG1zICk7XG5cblx0XHRcdG1zVGV4dC50ZXh0Q29udGVudCA9IG1zICsgJyBNUyAoJyArIG1zTWluICsgJy0nICsgbXNNYXggKyAnKSc7XG5cdFx0XHR1cGRhdGVHcmFwaCggbXNHcmFwaCwgTWF0aC5taW4oIDMwLCAzMCAtICggbXMgLyAyMDAgKSAqIDMwICkgKTtcblxuXHRcdFx0ZnJhbWVzICsrO1xuXG5cdFx0XHRpZiAoIHRpbWUgPiBwcmV2VGltZSArIDEwMDAgKSB7XG5cblx0XHRcdFx0ZnBzID0gTWF0aC5yb3VuZCggKCBmcmFtZXMgKiAxMDAwICkgLyAoIHRpbWUgLSBwcmV2VGltZSApICk7XG5cdFx0XHRcdGZwc01pbiA9IE1hdGgubWluKCBmcHNNaW4sIGZwcyApO1xuXHRcdFx0XHRmcHNNYXggPSBNYXRoLm1heCggZnBzTWF4LCBmcHMgKTtcblxuXHRcdFx0XHRmcHNUZXh0LnRleHRDb250ZW50ID0gZnBzICsgJyBGUFMgKCcgKyBmcHNNaW4gKyAnLScgKyBmcHNNYXggKyAnKSc7XG5cdFx0XHRcdHVwZGF0ZUdyYXBoKCBmcHNHcmFwaCwgTWF0aC5taW4oIDMwLCAzMCAtICggZnBzIC8gMTAwICkgKiAzMCApICk7XG5cblx0XHRcdFx0cHJldlRpbWUgPSB0aW1lO1xuXHRcdFx0XHRmcmFtZXMgPSAwO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aW1lO1xuXG5cdFx0fSxcblxuXHRcdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuXG5cdFx0XHRzdGFydFRpbWUgPSB0aGlzLmVuZCgpO1xuXG5cdFx0fVxuXG5cdH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTdGF0cyIsIm1vZHVsZS5leHBvcnRzID0gQUFCQlxuXG52YXIgdmVjMyA9IHJlcXVpcmUoJ2dsLW1hdHJpeCcpLnZlYzNcblxuZnVuY3Rpb24gQUFCQihwb3MsIHZlYykge1xuICBpZighKHRoaXMgaW5zdGFuY2VvZiBBQUJCKSkge1xuICAgIHJldHVybiBuZXcgQUFCQihwb3MsIHZlYylcbiAgfVxuXG4gIHRoaXMuYmFzZSA9IHBvc1xuICB0aGlzLnZlYyA9IHZlY1xuXG4gIHRoaXMubWFnID0gdmVjMy5sZW5ndGgodGhpcy52ZWMpXG5cbiAgdGhpcy5tYXggPSB2ZWMzLmNyZWF0ZSgpXG4gIHZlYzMuYWRkKHRoaXMubWF4LCB0aGlzLmJhc2UsIHRoaXMudmVjKVxufVxuXG52YXIgY29ucyA9IEFBQkJcbiAgLCBwcm90byA9IGNvbnMucHJvdG90eXBlXG5cbnByb3RvLndpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZlY1swXVxufVxuXG5wcm90by5oZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMudmVjWzFdXG59XG5cbnByb3RvLmRlcHRoID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLnZlY1syXVxufVxuXG5wcm90by54MCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5iYXNlWzBdXG59XG5cbnByb3RvLnkwID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmJhc2VbMV1cbn1cblxucHJvdG8uejAgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuYmFzZVsyXVxufVxuXG5wcm90by54MSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5tYXhbMF1cbn1cblxucHJvdG8ueTEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubWF4WzFdXG59XG5cbnByb3RvLnoxID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLm1heFsyXVxufVxuXG5wcm90by50cmFuc2xhdGUgPSBmdW5jdGlvbihieSkge1xuICB2ZWMzLmFkZCh0aGlzLm1heCwgdGhpcy5tYXgsIGJ5KVxuICB2ZWMzLmFkZCh0aGlzLmJhc2UsIHRoaXMuYmFzZSwgYnkpXG4gIHJldHVybiB0aGlzXG59XG5cbnByb3RvLmV4cGFuZCA9IGZ1bmN0aW9uKGFhYmIpIHtcbiAgdmFyIG1heCA9IHZlYzMuY3JlYXRlKClcbiAgICAsIG1pbiA9IHZlYzMuY3JlYXRlKClcblxuICB2ZWMzLm1heChtYXgsIGFhYmIubWF4LCB0aGlzLm1heClcbiAgdmVjMy5taW4obWluLCBhYWJiLmJhc2UsIHRoaXMuYmFzZSlcbiAgdmVjMy5zdWIobWF4LCBtYXgsIG1pbilcblxuICByZXR1cm4gbmV3IEFBQkIobWluLCBtYXgpXG59XG5cbnByb3RvLmludGVyc2VjdHMgPSBmdW5jdGlvbihhYWJiKSB7XG4gIGlmKGFhYmIuYmFzZVswXSA+IHRoaXMubWF4WzBdKSByZXR1cm4gZmFsc2VcbiAgaWYoYWFiYi5iYXNlWzFdID4gdGhpcy5tYXhbMV0pIHJldHVybiBmYWxzZVxuICBpZihhYWJiLmJhc2VbMl0gPiB0aGlzLm1heFsyXSkgcmV0dXJuIGZhbHNlXG4gIGlmKGFhYmIubWF4WzBdIDwgdGhpcy5iYXNlWzBdKSByZXR1cm4gZmFsc2VcbiAgaWYoYWFiYi5tYXhbMV0gPCB0aGlzLmJhc2VbMV0pIHJldHVybiBmYWxzZVxuICBpZihhYWJiLm1heFsyXSA8IHRoaXMuYmFzZVsyXSkgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxucHJvdG8udW5pb24gPSBmdW5jdGlvbihhYWJiKSB7XG4gIGlmKCF0aGlzLmludGVyc2VjdHMoYWFiYikpIHJldHVybiBudWxsXG5cbiAgdmFyIGJhc2VfeCA9IE1hdGgubWF4KGFhYmIuYmFzZVswXSwgdGhpcy5iYXNlWzBdKVxuICAgICwgYmFzZV95ID0gTWF0aC5tYXgoYWFiYi5iYXNlWzFdLCB0aGlzLmJhc2VbMV0pXG4gICAgLCBiYXNlX3ogPSBNYXRoLm1heChhYWJiLmJhc2VbMl0sIHRoaXMuYmFzZVsyXSlcbiAgICAsIG1heF94ID0gTWF0aC5taW4oYWFiYi5tYXhbMF0sIHRoaXMubWF4WzBdKVxuICAgICwgbWF4X3kgPSBNYXRoLm1pbihhYWJiLm1heFsxXSwgdGhpcy5tYXhbMV0pXG4gICAgLCBtYXhfeiA9IE1hdGgubWluKGFhYmIubWF4WzJdLCB0aGlzLm1heFsyXSlcblxuICByZXR1cm4gbmV3IEFBQkIoW2Jhc2VfeCwgYmFzZV95LCBiYXNlX3pdLCBbbWF4X3ggLSBiYXNlX3gsIG1heF95IC0gYmFzZV95LCBtYXhfeiAtIGJhc2Vfel0pXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGZpZWxkLCB0aWxlc2l6ZSwgZGltZW5zaW9ucywgb2Zmc2V0KSB7XG4gIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zIHx8IFsgXG4gICAgTWF0aC5zcXJ0KGZpZWxkLmxlbmd0aCkgPj4gMFxuICAsIE1hdGguc3FydChmaWVsZC5sZW5ndGgpID4+IDBcbiAgLCBNYXRoLnNxcnQoZmllbGQubGVuZ3RoKSA+PiAwXG4gIF0gXG5cbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IFtcbiAgICAwXG4gICwgMFxuICAsIDBcbiAgXVxuXG4gIGZpZWxkID0gdHlwZW9mIGZpZWxkID09PSAnZnVuY3Rpb24nID8gZmllbGQgOiBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgcmV0dXJuIHRoaXNbeCArIHkgKiBkaW1lbnNpb25zWzFdICsgKHogKiBkaW1lbnNpb25zWzFdICogZGltZW5zaW9uc1syXSldXG4gIH0uYmluZChmaWVsZCkgXG5cbiAgdmFyIGNvb3Jkc1xuXG4gIGNvb3JkcyA9IFswLCAwLCAwXVxuXG4gIHJldHVybiBjb2xsaWRlXG5cbiAgZnVuY3Rpb24gY29sbGlkZShib3gsIHZlYywgb25jb2xsaXNpb24pIHtcbiAgICBpZih2ZWNbMF0gPT09IDAgJiYgdmVjWzFdID09PSAwICYmIHZlY1syXSA9PT0gMCkgcmV0dXJuXG5cbiAgICAvLyBjb2xsaWRlIHgsIHRoZW4geVxuICAgIGNvbGxpZGVheGlzKDApXG4gICAgY29sbGlkZWF4aXMoMSlcbiAgICBjb2xsaWRlYXhpcygyKVxuXG4gICAgZnVuY3Rpb24gY29sbGlkZWF4aXMoaV9heGlzKSB7XG4gICAgICB2YXIgal9heGlzID0gKGlfYXhpcyArIDEpICUgM1xuICAgICAgICAsIGtfYXhpcyA9IChpX2F4aXMgKyAyKSAlIDMgXG4gICAgICAgICwgcG9zaSA9IHZlY1tpX2F4aXNdID4gMFxuICAgICAgICAsIGxlYWRpbmcgPSBib3hbcG9zaSA/ICdtYXgnIDogJ2Jhc2UnXVtpX2F4aXNdIFxuICAgICAgICAsIGRpciA9IHBvc2kgPyAxIDogLTFcbiAgICAgICAgLCBpX3N0YXJ0ID0gTWF0aC5mbG9vcihsZWFkaW5nIC8gdGlsZXNpemUpXG4gICAgICAgICwgaV9lbmQgPSAoTWF0aC5mbG9vcigobGVhZGluZyArIHZlY1tpX2F4aXNdKSAvIHRpbGVzaXplKSkgKyBkaXJcbiAgICAgICAgLCBqX3N0YXJ0ID0gTWF0aC5mbG9vcihib3guYmFzZVtqX2F4aXNdIC8gdGlsZXNpemUpXG4gICAgICAgICwgal9lbmQgPSBNYXRoLmNlaWwoYm94Lm1heFtqX2F4aXNdIC8gdGlsZXNpemUpXG4gICAgICAgICwga19zdGFydCA9IE1hdGguZmxvb3IoYm94LmJhc2Vba19heGlzXSAvIHRpbGVzaXplKSBcbiAgICAgICAgLCBrX2VuZCA9IE1hdGguY2VpbChib3gubWF4W2tfYXhpc10gLyB0aWxlc2l6ZSlcbiAgICAgICAgLCBkb25lID0gZmFsc2VcbiAgICAgICAgLCBlZGdlX3ZlY3RvclxuICAgICAgICAsIGVkZ2VcbiAgICAgICAgLCB0aWxlXG5cbiAgICAgIC8vIGxvb3AgZnJvbSB0aGUgY3VycmVudCB0aWxlIGNvb3JkIHRvIHRoZSBkZXN0IHRpbGUgY29vcmRcbiAgICAgIC8vICAgIC0+IGxvb3Agb24gdGhlIG9wcG9zaXRlIGF4aXMgdG8gZ2V0IHRoZSBvdGhlciBjYW5kaWRhdGVzXG4gICAgICAvLyAgICAgIC0+IGlmIGBvbmNvbGxpc2lvbmAgcmV0dXJuIGB0cnVlYCB3ZSd2ZSBoaXQgc29tZXRoaW5nIGFuZFxuICAgICAgLy8gICAgICAgICBzaG91bGQgYnJlYWsgb3V0IG9mIHRoZSBsb29wcyBlbnRpcmVseS5cbiAgICAgIC8vICAgICAgICAgTkI6IGBvbmNvbGxpc2lvbmAgaXMgd2hlcmUgdGhlIGNsaWVudCBnZXRzIHRoZSBjaGFuY2VcbiAgICAgIC8vICAgICAgICAgdG8gbW9kaWZ5IHRoZSBgdmVjYCBpbi1mbGlnaHQuXG4gICAgICAvLyBvbmNlIHdlJ3JlIGRvbmUgdHJhbnNsYXRlIHRoZSBib3ggdG8gdGhlIHZlYyByZXN1bHRzXG5cbiAgICAgIHZhciBzdGVwID0gMFxuICAgICAgZm9yKHZhciBpID0gaV9zdGFydDsgIWRvbmUgJiYgaSAhPT0gaV9lbmQ7ICsrc3RlcCwgaSArPSBkaXIpIHtcbiAgICAgICAgaWYoaSA8IG9mZnNldFtpX2F4aXNdIHx8IGkgPj0gZGltZW5zaW9uc1tpX2F4aXNdKSBjb250aW51ZVxuICAgICAgICBmb3IodmFyIGogPSBqX3N0YXJ0OyAhZG9uZSAmJiBqICE9PSBqX2VuZDsgKytqKSB7XG4gICAgICAgICAgaWYoaiA8IG9mZnNldFtqX2F4aXNdIHx8IGogPj0gZGltZW5zaW9uc1tqX2F4aXNdKSBjb250aW51ZVxuICAgICAgICAgIGZvcih2YXIgayA9IGtfc3RhcnQ7IGsgIT09IGtfZW5kOyArK2spIHtcbiAgICAgICAgICAgIGlmKGsgPCBvZmZzZXRba19heGlzXSB8fCBrID49IGRpbWVuc2lvbnNba19heGlzXSkgY29udGludWVcbiAgICAgICAgICAgIGNvb3Jkc1tpX2F4aXNdID0gaVxuICAgICAgICAgICAgY29vcmRzW2pfYXhpc10gPSBqXG4gICAgICAgICAgICBjb29yZHNba19heGlzXSA9IGtcbiAgICAgICAgICAgIHRpbGUgPSBmaWVsZC5hcHBseShmaWVsZCwgY29vcmRzKVxuXG4gICAgICAgICAgICBpZih0aWxlID09PSB1bmRlZmluZWQpIGNvbnRpbnVlXG5cbiAgICAgICAgICAgIGVkZ2UgPSBkaXIgPiAwID8gaSAqIHRpbGVzaXplIDogKGkgKyAxKSAqIHRpbGVzaXplXG4gICAgICAgICAgICBlZGdlX3ZlY3RvciA9IGVkZ2UgLSBsZWFkaW5nXG5cbiAgICAgICAgICAgIGlmKG9uY29sbGlzaW9uKGlfYXhpcywgdGlsZSwgY29vcmRzLCBkaXIsIGVkZ2VfdmVjdG9yKSkge1xuICAgICAgICAgICAgICBkb25lID0gdHJ1ZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29vcmRzWzBdID0gY29vcmRzWzFdID0gY29vcmRzWzJdID0gMFxuICAgICAgY29vcmRzW2lfYXhpc10gPSB2ZWNbaV9heGlzXVxuICAgICAgYm94LnRyYW5zbGF0ZShjb29yZHMpXG4gICAgfVxuICB9ICBcbn1cbiIsIi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuMC4wXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDEyLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuXG4oZnVuY3Rpb24oKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBzaGltID0ge307XG4gIGlmICh0eXBlb2YoZXhwb3J0cykgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIHNoaW0uZXhwb3J0cyA9IHt9O1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2hpbS5leHBvcnRzO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdsLW1hdHJpeCBsaXZlcyBpbiBhIGJyb3dzZXIsIGRlZmluZSBpdHMgbmFtZXNwYWNlcyBpbiBnbG9iYWxcbiAgICAgIHNoaW0uZXhwb3J0cyA9IHdpbmRvdztcbiAgICB9ICAgIFxuICB9XG4gIGVsc2Uge1xuICAgIC8vIGdsLW1hdHJpeCBsaXZlcyBpbiBjb21tb25qcywgZGVmaW5lIGl0cyBuYW1lc3BhY2VzIGluIGV4cG9ydHNcbiAgICBzaGltLmV4cG9ydHMgPSBleHBvcnRzO1xuICB9XG5cbiAgKGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICAvKiBDb3B5cmlnaHQgKGMpIDIwMTIsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAyIERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjMlxuICovXG5cbnZhciB2ZWMyID0ge307XG5cbmlmKCFHTE1BVF9FUFNJTE9OKSB7XG4gICAgdmFyIEdMTUFUX0VQU0lMT04gPSAwLjAwMDAwMTtcbn1cbiBcbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSgyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzJ9IGEgbmV3IDJEIHZlY3RvclxuICovXG52ZWMyLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDIpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzIgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjMn0gYSBuZXcgMkQgdmVjdG9yXG4gKi9cbnZlYzIuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnN1YiA9IHZlYzIuc3VidHJhY3QgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC0gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubXVsID0gdmVjMi5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5kaXYgPSB2ZWMyLmRpdmlkZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjMiBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjMn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGI7XG4gICAgb3V0WzFdID0gYVsxXSAqIGI7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQ2FjbHVsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIENhY2x1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzIuc3FyTGVuID0gdmVjMi5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIHJldHVybiB4KnggKyB5Knk7XG59O1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhY2x1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMi5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzIuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzIgd2l0aCBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJ9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0MiA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVsxXTtcbiAgICBvdXRbMV0gPSB4ICogbVsyXSArIHkgKiBtWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMycy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMyLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjMnMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICovXG52ZWMyLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnZlYzIgPSB2ZWMyO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgMyBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzNcbiAqL1xuXG52YXIgdmVjMyA9IHt9O1xuXG5pZighR0xNQVRfRVBTSUxPTikge1xuICAgIHZhciBHTE1BVF9FUFNJTE9OID0gMC4wMDAwMDE7XG59XG4gXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzNcbiAqXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbnZlYzMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkoMyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHopIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc3ViID0gdmVjMy5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tdWwgPSB2ZWMzLm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmRpdiA9IHZlYzMuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5kaXN0ID0gdmVjMy5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjMy5zcXJEaXN0ID0gdmVjMy5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogQ2FjbHVsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xudmVjMy5sZW4gPSB2ZWMzLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopO1xufTtcblxuLyoqXG4gKiBDYWNsdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMzLnNxckxlbiA9IHZlYzMuc3F1YXJlZExlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqejtcbn07XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeSArIHoqejtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhY2x1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMy5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl07XG59O1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBjcm9zcyBwcm9kdWN0IG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXTtcblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF6ICogYnggLSBheCAqIGJ6O1xuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl07XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHogKyBtWzEyXTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXTtcbiAgICBvdXRbMl0gPSBtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6O1xuXG4gICAgLy8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxuICAgIG91dFswXSA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xejtcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICovXG52ZWMzLmZvckVhY2ggPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZlYyA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsO1xuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoIW9mZnNldCkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IoaSA9IG9mZnNldDsgaSA8IGw7IGkgKz0gc3RyaWRlKSB7XG4gICAgICAgICAgICB2ZWNbMF0gPSBhW2ldOyB2ZWNbMV0gPSBhW2krMV07IHZlY1syXSA9IGFbaSsyXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMzLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMzKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLnZlYzMgPSB2ZWMzO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgNCBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBuYW1lIHZlYzRcbiAqL1xuXG52YXIgdmVjNCA9IHt9O1xuXG5pZighR0xNQVRfRVBTSUxPTikge1xuICAgIHZhciBHTE1BVF9FUFNJTE9OID0gMC4wMDAwMDE7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjNFxuICpcbiAqIEByZXR1cm5zIHt2ZWM0fSBhIG5ldyA0RCB2ZWN0b3JcbiAqL1xudmVjNC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheSg0KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHosIHcpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWM0IHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6LCB3KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgb3V0WzNdID0gdztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuYWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSArIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSArIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU3VidHJhY3RzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc3ViID0gdmVjNC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tdWwgPSB2ZWM0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogRGl2aWRlcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmRpdiA9IHZlYzQuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIG91dFszXSA9IE1hdGgubWluKGFbM10sIGJbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWM0IGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWM0fSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5kaXN0ID0gdmVjNC5kaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6ICsgdyp3KTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWM0LnNxckRpc3QgPSB2ZWM0LnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXSxcbiAgICAgICAgdyA9IGJbM10gLSBhWzNdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG59O1xuXG4vKipcbiAqIENhY2x1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQubGVuID0gdmVjNC5sZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIENhY2x1bGF0ZXMgdGhlIHNxdWFyZWQgbGVuZ3RoIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIHNxdWFyZWQgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQuc3FyTGVuID0gdmVjNC5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn07XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAtYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubm9ybWFsaXplID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBhWzNdO1xuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnogKyB3Knc7XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBvdXRbMF0gPSBhWzBdICogbGVuO1xuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuO1xuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuO1xuICAgICAgICBvdXRbM10gPSBhWzNdICogbGVuO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWNsdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbnZlYzQuZG90ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYVswXSAqIGJbMF0gKyBhWzFdICogYlsxXSArIGFbMl0gKiBiWzJdICsgYVszXSAqIGJbM107XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdLFxuICAgICAgICBheiA9IGFbMl0sXG4gICAgICAgIGF3ID0gYVszXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICBvdXRbM10gPSBhdyArIHQgKiAoYlszXSAtIGF3KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sIHcgPSBhWzNdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gICAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjNHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjNC4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzJzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqL1xudmVjNC5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSBuZXcgRmxvYXQzMkFycmF5KDQpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdOyB2ZWNbMl0gPSBhW2krMl07IHZlY1szXSA9IGFbaSszXTtcbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpO1xuICAgICAgICAgICAgYVtpXSA9IHZlY1swXTsgYVtpKzFdID0gdmVjWzFdOyBhW2krMl0gPSB2ZWNbMl07IGFbaSszXSA9IHZlY1szXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy52ZWM0ID0gdmVjNDtcbn1cbjtcbi8qIENvcHlyaWdodCAoYykgMjAxMiwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXQgbW9kaWZpY2F0aW9uLFxuYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICAgIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gXG4gICAgYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG5cblRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiIEFORFxuQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFIElNUExJRURcbldBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgXG5ESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIEhPTERFUiBPUiBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUlxuQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTXG4oSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7XG5MT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT05cbkFOWSBUSEVPUlkgT0YgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUXG4oSU5DTFVESU5HIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuICovXG5cbi8qKlxuICogQGNsYXNzIDJ4MiBNYXRyaXhcbiAqIEBuYW1lIG1hdDJcbiAqL1xuXG52YXIgbWF0MiA9IHt9O1xuXG52YXIgbWF0MklkZW50aXR5ID0gbmV3IEZsb2F0MzJBcnJheShbXG4gICAgMSwgMCxcbiAgICAwLCAxXG5dKTtcblxuaWYoIUdMTUFUX0VQU0lMT04pIHtcbiAgICB2YXIgR0xNQVRfRVBTSUxPTiA9IDAuMDAwMDAxO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0MlxuICpcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobWF0MklkZW50aXR5KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQyIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDJ9IGEgbmV3IDJ4MiBtYXRyaXhcbiAqL1xubWF0Mi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSBtYXQyIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0IGEgbWF0MiB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMSA9IGFbMV07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGExO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMl07XG4gICAgICAgIG91dFsyXSA9IGFbMV07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBhMCAqIGEzIC0gYTIgKiBhMTtcblxuICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG4gICAgXG4gICAgb3V0WzBdID0gIGEzICogZGV0O1xuICAgIG91dFsxXSA9IC1hMSAqIGRldDtcbiAgICBvdXRbMl0gPSAtYTIgKiBkZXQ7XG4gICAgb3V0WzNdID0gIGEwICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FjbHVsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBDYWNoaW5nIHRoaXMgdmFsdWUgaXMgbmVzc2VjYXJ5IGlmIG91dCA9PSBhXG4gICAgdmFyIGEwID0gYVswXTtcbiAgICBvdXRbMF0gPSAgYVszXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAgYTA7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0Mi5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsyXSAqIGFbMV07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDInc1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0Mn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5tdWwgPSBtYXQyLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTEgKiBiMjtcbiAgICBvdXRbMV0gPSBhMCAqIGIxICsgYTEgKiBiMztcbiAgICBvdXRbMl0gPSBhMiAqIGIwICsgYTMgKiBiMjtcbiAgICBvdXRbM10gPSBhMiAqIGIxICsgYTMgKiBiMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MiBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge21hdDJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5yb3RhdGUgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgb3V0WzBdID0gYTAgKiAgYyArIGExICogcztcbiAgICBvdXRbMV0gPSBhMCAqIC1zICsgYTEgKiBjO1xuICAgIG91dFsyXSA9IGEyICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzNdID0gYTIgKiAtcyArIGEzICogYztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDIgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge21hdDJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJ9IG91dFxuICoqL1xubWF0Mi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM10sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwICogdjA7XG4gICAgb3V0WzFdID0gYTEgKiB2MTtcbiAgICBvdXRbMl0gPSBhMiAqIHYwO1xuICAgIG91dFszXSA9IGEzICogdjE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxuaWYodHlwZW9mKGV4cG9ydHMpICE9PSAndW5kZWZpbmVkJykge1xuICAgIGV4cG9ydHMubWF0MiA9IG1hdDI7XG59XG47XG4vKiBDb3B5cmlnaHQgKGMpIDIwMTIsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcbmFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICAgIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSxcbiAgICB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIFxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkRcbkFOWSBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEXG5XQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIFxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1JcbkFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OXG5BTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVNcblNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLiAqL1xuXG4vKipcbiAqIEBjbGFzcyAzeDMgTWF0cml4XG4gKiBAbmFtZSBtYXQzXG4gKi9cblxudmFyIG1hdDMgPSB7fTtcblxudmFyIG1hdDNJZGVudGl0eSA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgIDEsIDAsIDAsXG4gICAgMCwgMSwgMCxcbiAgICAwLCAwLCAxXG5dKTtcblxuaWYoIUdMTUFUX0VQU0lMT04pIHtcbiAgICB2YXIgR0xNQVRfRVBTSUxPTiA9IDAuMDAwMDAxO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xuICpcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobWF0M0lkZW50aXR5KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQzfSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDN9IGEgbmV3IDN4MyBtYXRyaXhcbiAqL1xubWF0My5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg5KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMTIgPSBhWzVdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhMDE7XG4gICAgICAgIG91dFs1XSA9IGFbN107XG4gICAgICAgIG91dFs2XSA9IGEwMjtcbiAgICAgICAgb3V0WzddID0gYTEyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGFbMV07XG4gICAgICAgIG91dFs0XSA9IGFbNF07XG4gICAgICAgIG91dFs1XSA9IGFbN107XG4gICAgICAgIG91dFs2XSA9IGFbMl07XG4gICAgICAgIG91dFs3XSA9IGFbNV07XG4gICAgICAgIG91dFs4XSA9IGFbOF07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMSxcbiAgICAgICAgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMCxcbiAgICAgICAgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYjAxICogZGV0O1xuICAgIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgICBvdXRbM10gPSBiMTEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICAgIG91dFs2XSA9IGIyMSAqIGRldDtcbiAgICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FjbHVsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgIG91dFswXSA9IChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpO1xuICAgIG91dFsxXSA9IChhMDIgKiBhMjEgLSBhMDEgKiBhMjIpO1xuICAgIG91dFsyXSA9IChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICAgIG91dFszXSA9IChhMTIgKiBhMjAgLSBhMTAgKiBhMjIpO1xuICAgIG91dFs0XSA9IChhMDAgKiBhMjIgLSBhMDIgKiBhMjApO1xuICAgIG91dFs1XSA9IChhMDIgKiBhMTAgLSBhMDAgKiBhMTIpO1xuICAgIG91dFs2XSA9IChhMTAgKiBhMjEgLSBhMTEgKiBhMjApO1xuICAgIG91dFs3XSA9IChhMDEgKiBhMjAgLSBhMDAgKiBhMjEpO1xuICAgIG91dFs4XSA9IChhMDAgKiBhMTEgLSBhMDEgKiBhMTApO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQzLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMubXVsID0gbWF0My5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XSxcblxuICAgICAgICBiMDAgPSBiWzBdLCBiMDEgPSBiWzFdLCBiMDIgPSBiWzJdLFxuICAgICAgICBiMTAgPSBiWzNdLCBiMTEgPSBiWzRdLCBiMTIgPSBiWzVdLFxuICAgICAgICBiMjAgPSBiWzZdLCBiMjEgPSBiWzddLCBiMjIgPSBiWzhdO1xuXG4gICAgb3V0WzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICAgIG91dFsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgICBvdXRbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG5cbiAgICBvdXRbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gICAgb3V0WzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICAgIG91dFs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcblxuICAgIG91dFs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgICBvdXRbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gICAgb3V0WzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xubWF0My5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MygnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbM10gKyAnLCAnICsgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICsgYVs4XSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDMgPSBtYXQzO1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgNHg0IE1hdHJpeFxuICogQG5hbWUgbWF0NFxuICovXG5cbnZhciBtYXQ0ID0ge307XG5cbnZhciBtYXQ0SWRlbnRpdHkgPSBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAxLCAwLCAwLCAwLFxuICAgIDAsIDEsIDAsIDAsXG4gICAgMCwgMCwgMSwgMCxcbiAgICAwLCAwLCAwLCAxXG5dKTtcblxuaWYoIUdMTUFUX0VQU0lMT04pIHtcbiAgICB2YXIgR0xNQVRfRVBTSUxPTiA9IDAuMDAwMDAxO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbm1hdDQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobWF0NElkZW50aXR5KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC50cmFuc3Bvc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgICAgIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzFdID0gKGEwMiAqIGIxMCAtIGEwMSAqIGIxMSAtIGEwMyAqIGIwOSkgKiBkZXQ7XG4gICAgb3V0WzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGExMiAqIGIwOCAtIGExMCAqIGIxMSAtIGExMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEyMCAqIGIwNSAtIGEyMiAqIGIwMiArIGEyMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEwXSA9IChhMzAgKiBiMDQgLSBhMzEgKiBiMDIgKyBhMzMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzEzXSA9IChhMDAgKiBiMDkgLSBhMDEgKiBiMDcgKyBhMDIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWNsdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gICAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRldGVybWluYW50IG9mIGFcbiAqL1xubWF0NC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQ0J3NcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubXVsID0gbWF0NC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDQgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjM30gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNsYXRlID0gZnVuY3Rpb24gKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gc2NhbGVcbiAqIEBwYXJhbSB7dmVjM30gdiB0aGUgdmVjMyB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKiovXG5tYXQ0LnNjYWxlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgICBvdXRbMF0gPSBhWzBdICogeDtcbiAgICBvdXRbMV0gPSBhWzFdICogeDtcbiAgICBvdXRbMl0gPSBhWzJdICogeDtcbiAgICBvdXRbM10gPSBhWzNdICogeDtcbiAgICBvdXRbNF0gPSBhWzRdICogeTtcbiAgICBvdXRbNV0gPSBhWzVdICogeTtcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcbiAgICBvdXRbN10gPSBhWzddICogeTtcbiAgICBvdXRbOF0gPSBhWzhdICogejtcbiAgICBvdXRbOV0gPSBhWzldICogejtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICAgIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdCxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMyxcbiAgICAgICAgYjAwLCBiMDEsIGIwMixcbiAgICAgICAgYjEwLCBiMTEsIGIxMixcbiAgICAgICAgYjIwLCBiMjEsIGIyMjtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgR0xNQVRfRVBTSUxPTikgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzBdICA9IGFbMF07XG4gICAgICAgIG91dFsxXSAgPSBhWzFdO1xuICAgICAgICBvdXRbMl0gID0gYVsyXTtcbiAgICAgICAgb3V0WzNdICA9IGFbM107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzRdID0gYTEwICogYyArIGEyMCAqIHM7XG4gICAgb3V0WzVdID0gYTExICogYyArIGEyMSAqIHM7XG4gICAgb3V0WzZdID0gYTEyICogYyArIGEyMiAqIHM7XG4gICAgb3V0WzddID0gYTEzICogYyArIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTIwICogYyAtIGExMCAqIHM7XG4gICAgb3V0WzldID0gYTIxICogYyAtIGExMSAqIHM7XG4gICAgb3V0WzEwXSA9IGEyMiAqIGMgLSBhMTIgKiBzO1xuICAgIG91dFsxMV0gPSBhMjMgKiBjIC0gYTEzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVaID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKG91dCwgcSwgdikge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgICBvdXRbMV0gPSB4eSArIHd6O1xuICAgIG91dFsyXSA9IHh6IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4eSAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gICAgb3V0WzZdID0geXogKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHh6ICsgd3k7XG4gICAgb3V0WzldID0geXogLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcnVzdHVtID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXG4gICAgICAgIHRiID0gMSAvICh0b3AgLSBib3R0b20pLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbiAob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5vcnRobyA9IGZ1bmN0aW9uIChvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGxyID0gMSAvIChsZWZ0IC0gcmlnaHQpLFxuICAgICAgICBidCA9IDEgLyAoYm90dG9tIC0gdG9wKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IC0yICogbHI7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAtMiAqIGJ0O1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDIgKiBuZjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gKGxlZnQgKyByaWdodCkgKiBscjtcbiAgICBvdXRbMTNdID0gKHRvcCArIGJvdHRvbSkgKiBidDtcbiAgICBvdXRbMTRdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lmxvb2tBdCA9IGZ1bmN0aW9uIChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgR0xNQVRfRVBTSUxPTiAmJlxuICAgICAgICBNYXRoLmFicyhleWV5IC0gY2VudGVyeSkgPCBHTE1BVF9FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IEdMTUFUX0VQU0lMT04pIHtcbiAgICAgICAgcmV0dXJuIG1hdDQuaWRlbnRpdHkob3V0KTtcbiAgICB9XG5cbiAgICB6MCA9IGV5ZXggLSBjZW50ZXJ4O1xuICAgIHoxID0gZXlleSAtIGNlbnRlcnk7XG4gICAgejIgPSBleWV6IC0gY2VudGVyejtcblxuICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQoejAgKiB6MCArIHoxICogejEgKyB6MiAqIHoyKTtcbiAgICB6MCAqPSBsZW47XG4gICAgejEgKj0gbGVuO1xuICAgIHoyICo9IGxlbjtcblxuICAgIHgwID0gdXB5ICogejIgLSB1cHogKiB6MTtcbiAgICB4MSA9IHVweiAqIHowIC0gdXB4ICogejI7XG4gICAgeDIgPSB1cHggKiB6MSAtIHVweSAqIHowO1xuICAgIGxlbiA9IE1hdGguc3FydCh4MCAqIHgwICsgeDEgKiB4MSArIHgyICogeDIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHgwID0gMDtcbiAgICAgICAgeDEgPSAwO1xuICAgICAgICB4MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeDAgKj0gbGVuO1xuICAgICAgICB4MSAqPSBsZW47XG4gICAgICAgIHgyICo9IGxlbjtcbiAgICB9XG5cbiAgICB5MCA9IHoxICogeDIgLSB6MiAqIHgxO1xuICAgIHkxID0gejIgKiB4MCAtIHowICogeDI7XG4gICAgeTIgPSB6MCAqIHgxIC0gejEgKiB4MDtcblxuICAgIGxlbiA9IE1hdGguc3FydCh5MCAqIHkwICsgeTEgKiB5MSArIHkyICogeTIpO1xuICAgIGlmICghbGVuKSB7XG4gICAgICAgIHkwID0gMDtcbiAgICAgICAgeTEgPSAwO1xuICAgICAgICB5MiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gMSAvIGxlbjtcbiAgICAgICAgeTAgKj0gbGVuO1xuICAgICAgICB5MSAqPSBsZW47XG4gICAgICAgIHkyICo9IGxlbjtcbiAgICB9XG5cbiAgICBvdXRbMF0gPSB4MDtcbiAgICBvdXRbMV0gPSB5MDtcbiAgICBvdXRbMl0gPSB6MDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHgxO1xuICAgIG91dFs1XSA9IHkxO1xuICAgIG91dFs2XSA9IHoxO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geDI7XG4gICAgb3V0WzldID0geTI7XG4gICAgb3V0WzEwXSA9IHoyO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAtKHgwICogZXlleCArIHgxICogZXlleSArIHgyICogZXlleik7XG4gICAgb3V0WzEzXSA9IC0oeTAgKiBleWV4ICsgeTEgKiBleWV5ICsgeTIgKiBleWV6KTtcbiAgICBvdXRbMTRdID0gLSh6MCAqIGV5ZXggKyB6MSAqIGV5ZXkgKyB6MiAqIGV5ZXopO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG1hdCBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQ0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn07XG5cbmlmKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLm1hdDQgPSBtYXQ0O1xufVxuO1xuLyogQ29weXJpZ2h0IChjKSAyMDEyLCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cblJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dCBtb2RpZmljYXRpb24sXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXNcbiAgICBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBcbiAgICBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBcbkRJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SXG5BTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbihJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbkxPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTlxuQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbihJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTXG5TT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQG5hbWUgcXVhdFxuICovXG5cbnZhciBxdWF0ID0ge307XG5cbnZhciBxdWF0SWRlbnRpdHkgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAwLCAxXSk7XG5cbmlmKCFHTE1BVF9FUFNJTE9OKSB7XG4gICAgdmFyIEdMTUFUX0VQU0lMT04gPSAwLjAwMDAwMTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IHF1YXRcbiAqXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICovXG5xdWF0LmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHF1YXRJZGVudGl0eSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdGVybmlvbiB0byBjbG9uZVxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqL1xucXVhdC5jbG9uZSA9IHZlYzQuY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICovXG5xdWF0LmZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNvcHkgPSB2ZWM0LmNvcHk7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgcXVhdCB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNldCA9IHZlYzQuc2V0O1xuXG4vKipcbiAqIFNldCBhIHF1YXQgdG8gdGhlIGlkZW50aXR5IHF1YXRlcm5pb25cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXQgZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYW5kIHJvdGF0aW9uIGF4aXMsXG4gKiB0aGVuIHJldHVybnMgaXQuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgYXJvdW5kIHdoaWNoIHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgaW4gcmFkaWFuc1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICoqL1xucXVhdC5zZXRBeGlzQW5nbGUgPSBmdW5jdGlvbihvdXQsIGF4aXMsIHJhZCkge1xuICAgIHJhZCA9IHJhZCAqIDAuNTtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgb3V0WzBdID0gcyAqIGF4aXNbMF07XG4gICAgb3V0WzFdID0gcyAqIGF4aXNbMV07XG4gICAgb3V0WzJdID0gcyAqIGF4aXNbMl07XG4gICAgb3V0WzNdID0gTWF0aC5jb3MocmFkKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmFkZCA9IHZlYzQuYWRkO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQubXVsID0gcXVhdC5tdWx0aXBseSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYlszXTtcblxuICAgIG91dFswXSA9IGF4ICogYncgKyBhdyAqIGJ4ICsgYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnkgKyBheiAqIGJ4IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBieiArIGF4ICogYnkgLSBheSAqIGJ4O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheCAqIGJ4IC0gYXkgKiBieSAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7cXVhdH0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNjYWxlID0gdmVjNC5zY2FsZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgcXVhdGVybmlvbiBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gICAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgcXVhdCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gcmFkIGFuZ2xlIChpbiByYWRpYW5zKSB0byByb3RhdGVcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgcmFkICo9IDAuNTsgXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieSA9IE1hdGguc2luKHJhZCksIGJ3ID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGF4ICogYncgLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5O1xuICAgIG91dFsyXSA9IGF6ICogYncgKyBheCAqIGJ5O1xuICAgIG91dFszXSA9IGF3ICogYncgLSBheSAqIGJ5O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBxdWF0ZXJuaW9uIGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHF1YXQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZCBhbmdsZSAoaW4gcmFkaWFucykgdG8gcm90YXRlXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRlWiA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHJhZCAqPSAwLjU7IFxuXG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sIGF3ID0gYVszXSxcbiAgICAgICAgYnogPSBNYXRoLnNpbihyYWQpLCBidyA9IE1hdGguY29zKHJhZCk7XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXkgKiBiejtcbiAgICBvdXRbMV0gPSBheSAqIGJ3IC0gYXggKiBiejtcbiAgICBvdXRbMl0gPSBheiAqIGJ3ICsgYXcgKiBiejtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXogKiBiejtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBXIGNvbXBvbmVudCBvZiBhIHF1YXQgZnJvbSB0aGUgWCwgWSwgYW5kIFogY29tcG9uZW50cy5cbiAqIEFzc3VtZXMgdGhhdCBxdWF0ZXJuaW9uIGlzIDEgdW5pdCBpbiBsZW5ndGguXG4gKiBBbnkgZXhpc3RpbmcgVyBjb21wb25lbnQgd2lsbCBiZSBpZ25vcmVkLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIFcgY29tcG9uZW50IG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuY2FsY3VsYXRlVyA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXTtcblxuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IC1NYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FjbHVsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5xdWF0LmRvdCA9IHZlYzQuZG90O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5sZXJwID0gdmVjNC5sZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgc3BoZXJpY2FsIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNsZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl0sIGJ3ID0gYVszXTtcblxuICAgIHZhciBjb3NIYWxmVGhldGEgPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3LFxuICAgICAgICBoYWxmVGhldGEsXG4gICAgICAgIHNpbkhhbGZUaGV0YSxcbiAgICAgICAgcmF0aW9BLFxuICAgICAgICByYXRpb0I7XG5cbiAgICBpZiAoTWF0aC5hYnMoY29zSGFsZlRoZXRhKSA+PSAxLjApIHtcbiAgICAgICAgaWYgKG91dCAhPT0gYSkge1xuICAgICAgICAgICAgb3V0WzBdID0gYXg7XG4gICAgICAgICAgICBvdXRbMV0gPSBheTtcbiAgICAgICAgICAgIG91dFsyXSA9IGF6O1xuICAgICAgICAgICAgb3V0WzNdID0gYXc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBoYWxmVGhldGEgPSBNYXRoLmFjb3MoY29zSGFsZlRoZXRhKTtcbiAgICBzaW5IYWxmVGhldGEgPSBNYXRoLnNxcnQoMS4wIC0gY29zSGFsZlRoZXRhICogY29zSGFsZlRoZXRhKTtcblxuICAgIGlmIChNYXRoLmFicyhzaW5IYWxmVGhldGEpIDwgMC4wMDEpIHtcbiAgICAgICAgb3V0WzBdID0gKGF4ICogMC41ICsgYnggKiAwLjUpO1xuICAgICAgICBvdXRbMV0gPSAoYXkgKiAwLjUgKyBieSAqIDAuNSk7XG4gICAgICAgIG91dFsyXSA9IChheiAqIDAuNSArIGJ6ICogMC41KTtcbiAgICAgICAgb3V0WzNdID0gKGF3ICogMC41ICsgYncgKiAwLjUpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIHJhdGlvQSA9IE1hdGguc2luKCgxIC0gdCkgKiBoYWxmVGhldGEpIC8gc2luSGFsZlRoZXRhO1xuICAgIHJhdGlvQiA9IE1hdGguc2luKHQgKiBoYWxmVGhldGEpIC8gc2luSGFsZlRoZXRhO1xuXG4gICAgb3V0WzBdID0gKGF4ICogcmF0aW9BICsgYnggKiByYXRpb0IpO1xuICAgIG91dFsxXSA9IChheSAqIHJhdGlvQSArIGJ5ICogcmF0aW9CKTtcbiAgICBvdXRbMl0gPSAoYXogKiByYXRpb0EgKyBieiAqIHJhdGlvQik7XG4gICAgb3V0WzNdID0gKGF3ICogcmF0aW9BICsgYncgKiByYXRpb0IpO1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgaW52ZXJzZSBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBpbnZlcnNlIG9mXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgZG90ID0gYTAqYTAgKyBhMSphMSArIGEyKmEyICsgYTMqYTMsXG4gICAgICAgIGludkRvdCA9IGRvdCA/IDEuMC9kb3QgOiAwO1xuICAgIFxuICAgIC8vIFRPRE86IFdvdWxkIGJlIGZhc3RlciB0byByZXR1cm4gWzAsMCwwLDBdIGltbWVkaWF0ZWx5IGlmIGRvdCA9PSAwXG5cbiAgICBvdXRbMF0gPSAtYTAqaW52RG90O1xuICAgIG91dFsxXSA9IC1hMSppbnZEb3Q7XG4gICAgb3V0WzJdID0gLWEyKmludkRvdDtcbiAgICBvdXRbM10gPSBhMyppbnZEb3Q7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgY29uanVnYXRlIG9mIGEgcXVhdFxuICogSWYgdGhlIHF1YXRlcm5pb24gaXMgbm9ybWFsaXplZCwgdGhpcyBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbiBxdWF0LmludmVyc2UgYW5kIHByb2R1Y2VzIHRoZSBzYW1lIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBjb25qdWdhdGUgb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5jb25qdWdhdGUgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWNsdWxhdGVzIHRoZSBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5xdWF0LmxlbiA9IHF1YXQubGVuZ3RoID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQ2FjbHVsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xucXVhdC5zcXJMZW4gPSBxdWF0LnNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQubm9ybWFsaXplID0gdmVjNC5ub3JtYWxpemU7XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnF1YXQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG5pZih0eXBlb2YoZXhwb3J0cykgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgZXhwb3J0cy5xdWF0ID0gcXVhdDtcbn1cbjtcblxuXG5cblxuXG5cblxuXG5cblxuICB9KShzaGltLmV4cG9ydHMpO1xufSkoKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gaW5oZXJpdHNcblxuZnVuY3Rpb24gaW5oZXJpdHMgKGMsIHAsIHByb3RvKSB7XG4gIHByb3RvID0gcHJvdG8gfHwge31cbiAgdmFyIGUgPSB7fVxuICA7W2MucHJvdG90eXBlLCBwcm90b10uZm9yRWFjaChmdW5jdGlvbiAocykge1xuICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHMpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgIGVba10gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHMsIGspXG4gICAgfSlcbiAgfSlcbiAgYy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHAucHJvdG90eXBlLCBlKVxuICBjLnN1cGVyID0gcFxufVxuXG4vL2Z1bmN0aW9uIENoaWxkICgpIHtcbi8vICBDaGlsZC5zdXBlci5jYWxsKHRoaXMpXG4vLyAgY29uc29sZS5lcnJvcihbdGhpc1xuLy8gICAgICAgICAgICAgICAgLHRoaXMuY29uc3RydWN0b3Jcbi8vICAgICAgICAgICAgICAgICx0aGlzLmNvbnN0cnVjdG9yID09PSBDaGlsZFxuLy8gICAgICAgICAgICAgICAgLHRoaXMuY29uc3RydWN0b3Iuc3VwZXIgPT09IFBhcmVudFxuLy8gICAgICAgICAgICAgICAgLE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSA9PT0gQ2hpbGQucHJvdG90eXBlXG4vLyAgICAgICAgICAgICAgICAsT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSlcbi8vICAgICAgICAgICAgICAgICA9PT0gUGFyZW50LnByb3RvdHlwZVxuLy8gICAgICAgICAgICAgICAgLHRoaXMgaW5zdGFuY2VvZiBDaGlsZFxuLy8gICAgICAgICAgICAgICAgLHRoaXMgaW5zdGFuY2VvZiBQYXJlbnRdKVxuLy99XG4vL2Z1bmN0aW9uIFBhcmVudCAoKSB7fVxuLy9pbmhlcml0cyhDaGlsZCwgUGFyZW50KVxuLy9uZXcgQ2hpbGRcbiIsInZhciBsb2NrID0gcmVxdWlyZSgncG9pbnRlci1sb2NrJylcbiAgLCBkcmFnID0gcmVxdWlyZSgnZHJhZy1zdHJlYW0nKVxuICAsIGZ1bGwgPSByZXF1aXJlKCdmdWxsc2NyZWVuJylcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG5cbm1vZHVsZS5leHBvcnRzID0gaW50ZXJhY3RcblxuZnVuY3Rpb24gaW50ZXJhY3QoZWwsIHNraXBsb2NrKSB7XG4gIHZhciBlZSA9IG5ldyBFRVxuICAgICwgaW50ZXJuYWxcblxuICBpZighbG9jay5hdmFpbGFibGUoKSB8fCBza2lwbG9jaykge1xuICAgIGludGVybmFsID0gdXNlZHJhZyhlbClcbiAgfSBlbHNlIHtcbiAgICBpbnRlcm5hbCA9IHVzZWxvY2soZWwsIHBvbGl0ZWx5ZGVjbGluZWQpXG4gIH1cblxuICBlZS5yZWxlYXNlID0gZnVuY3Rpb24oKSB7IGludGVybmFsLnJlbGVhc2UgJiYgaW50ZXJuYWwucmVsZWFzZSgpIH1cbiAgZWUucmVxdWVzdCA9IGZ1bmN0aW9uKCkgeyBpbnRlcm5hbC5yZXF1ZXN0ICYmIGludGVybmFsLnJlcXVlc3QoKSB9XG4gIGVlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHsgaW50ZXJuYWwuZGVzdHJveSAmJiBpbnRlcm5hbC5kZXN0cm95KCkgfVxuICBlZS5wb2ludGVyQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7IHJldHVybiBsb2NrLmF2YWlsYWJsZSgpIH1cbiAgZWUuZnVsbHNjcmVlbkF2YWlsYWJsZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVsbC5hdmFpbGFibGUoKSB9XG5cbiAgZm9yd2FyZCgpXG5cbiAgcmV0dXJuIGVlXG5cbiAgZnVuY3Rpb24gcG9saXRlbHlkZWNsaW5lZCgpIHtcbiAgICBlZS5lbWl0KCdvcHQtb3V0JylcbiAgICBpbnRlcm5hbC5kZXN0cm95KClcbiAgICBpbnRlcm5hbCA9IHVzZWRyYWcoZWwpXG4gICAgZm9yd2FyZCgpXG4gIH1cblxuICBmdW5jdGlvbiBmb3J3YXJkKCkge1xuICAgIGludGVybmFsLm9uKCdhdHRhaW4nLCBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICAgIGVlLmVtaXQoJ2F0dGFpbicsIHN0cmVhbSlcbiAgICB9KVxuXG4gICAgaW50ZXJuYWwub24oJ3JlbGVhc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIGVlLmVtaXQoJ3JlbGVhc2UnKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gdXNlbG9jayhlbCwgZGVjbGluZWQpIHtcbiAgdmFyIHBvaW50ZXIgPSBsb2NrKGVsKVxuICAgICwgZnMgPSBmdWxsKGVsKVxuXG4gIHBvaW50ZXIub24oJ25lZWRzLWZ1bGxzY3JlZW4nLCBmdW5jdGlvbigpIHtcbiAgICBmcy5vbmNlKCdhdHRhaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgIHBvaW50ZXIucmVxdWVzdCgpXG4gICAgfSlcbiAgICBmcy5yZXF1ZXN0KClcbiAgfSlcblxuICBwb2ludGVyLm9uKCdlcnJvcicsIGRlY2xpbmVkKVxuXG4gIHJldHVybiBwb2ludGVyXG59XG5cbmZ1bmN0aW9uIHVzZWRyYWcoZWwpIHtcbiAgdmFyIGVlID0gbmV3IEVFXG4gICAgLCBkID0gZHJhZyhlbClcbiAgICAsIHN0cmVhbVxuXG4gIGQucGF1c2VkID0gdHJ1ZVxuXG4gIGQub24oJ3Jlc3VtZScsIGZ1bmN0aW9uKCkge1xuICAgIHN0cmVhbSA9IG5ldyBTdHJlYW1cbiAgICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlXG4gICAgc3RyZWFtLmluaXRpYWwgPSBudWxsXG4gIH0pXG5cbiAgZC5vbignZGF0YScsIGZ1bmN0aW9uKGRhdHVtKSB7XG4gICAgaWYoIXN0cmVhbSkge1xuICAgICAgc3RyZWFtID0gbmV3IFN0cmVhbVxuICAgICAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZVxuICAgICAgc3RyZWFtLmluaXRpYWwgPSBudWxsXG4gICAgfVxuXG4gICAgaWYoIXN0cmVhbS5pbml0aWFsKSB7XG4gICAgICBzdHJlYW0uaW5pdGlhbCA9IHtcbiAgICAgICAgeDogZGF0dW0uZHhcbiAgICAgICwgeTogZGF0dW0uZHlcbiAgICAgICwgdDogZGF0dW0uZHRcbiAgICAgIH1cbiAgICAgIHJldHVybiBlZS5lbWl0KCdhdHRhaW4nLCBzdHJlYW0pXG4gICAgfVxuXG4gICAgaWYoc3RyZWFtLnBhdXNlZCkge1xuICAgICAgZWUuZW1pdCgncmVsZWFzZScpXG4gICAgICBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICAgICAgc3RyZWFtID0gbnVsbFxuICAgIH1cblxuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgZGF0dW0pXG4gIH0pXG5cbiAgcmV0dXJuIGVlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGRyYWdzdHJlYW1cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG4gICwgcmVhZCA9IHJlcXVpcmUoJ2RvbW5vZGUtZG9tJykuY3JlYXRlUmVhZFN0cmVhbVxuICAsIHRocm91Z2ggPSByZXF1aXJlKCd0aHJvdWdoJylcblxuZnVuY3Rpb24gZHJhZ3N0cmVhbShlbCkge1xuICB2YXIgYm9keSA9IGVsLm93bmVyRG9jdW1lbnQuYm9keVxuICAgICwgZG93biA9IHJlYWQoZWwsICdtb3VzZWRvd24nKVxuICAgICwgdXAgPSByZWFkKGJvZHksICdtb3VzZXVwJywgZmFsc2UpXG4gICAgLCBtb3ZlID0gcmVhZChib2R5LCAnbW91c2Vtb3ZlJywgZmFsc2UpXG4gICAgLCBhbmNob3IgPSB7eDogMCwgeTogMCwgdDogMH1cbiAgICAsIGRyYWcgPSB0aHJvdWdoKG9uX21vdmUpXG5cbiAgLy8gZGVmYXVsdCB0byBcInBhdXNlZFwiXG4gIGRyYWcucGF1c2UoKVxuXG4gIGRvd24ub24oJ2RhdGEnLCBvbl9kb3duKVxuICB1cC5vbignZGF0YScsIG9uX3VwKVxuXG4gIHJldHVybiBtb3ZlLnBpcGUoZHJhZylcblxuICAvLyBsaXN0ZW5lcnM6XG5cbiAgZnVuY3Rpb24gb25fbW92ZShldikge1xuICAgIGlmKGRyYWcucGF1c2VkKSByZXR1cm5cblxuICAgIGRyYWcuZW1pdCgnZGF0YScsIGRhdHVtKFxuICAgICAgICBldi5zY3JlZW5YIC0gYW5jaG9yLnhcbiAgICAgICwgZXYuc2NyZWVuWSAtIGFuY2hvci55XG4gICAgICAsICtuZXcgRGF0ZVxuICAgICkpXG5cbiAgICBhbmNob3IueCA9IGV2LnNjcmVlblhcbiAgICBhbmNob3IueSA9IGV2LnNjcmVlbllcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uX2Rvd24oZXYpIHtcbiAgICBhbmNob3IueCA9IGV2LnNjcmVlblhcbiAgICBhbmNob3IueSA9IGV2LnNjcmVlbllcbiAgICBhbmNob3IudCA9ICtuZXcgRGF0ZVxuICAgIGRyYWcucmVzdW1lKClcbiAgICBkcmFnLmVtaXQoJ2RhdGEnLCBkYXR1bShcbiAgICAgICAgYW5jaG9yLnhcbiAgICAgICwgYW5jaG9yLnlcbiAgICAgICwgYW5jaG9yLnRcbiAgICApKVxuICB9XG5cbiAgZnVuY3Rpb24gb25fdXAoZXYpIHtcbiAgICBkcmFnLnBhdXNlKClcbiAgICBkcmFnLmVtaXQoJ2RhdGEnLCBkYXR1bShcbiAgICAgICAgZXYuc2NyZWVuWCAtIGFuY2hvci54XG4gICAgICAsIGV2LnNjcmVlblkgLSBhbmNob3IueVxuICAgICAgLCArbmV3IERhdGVcbiAgICApKVxuICB9XG5cbiAgZnVuY3Rpb24gZGF0dW0oZHgsIGR5LCB3aGVuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGR4OiBkeFxuICAgICwgZHk6IGR5XG4gICAgLCBkdDogd2hlbiAtIGFuY2hvci50XG4gICAgfVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2luZGV4JylcbiIsInZhciBXcml0ZVN0cmVhbSA9IHJlcXVpcmUoJy4vd3JpdGFibGUnKVxuICAsIFJlYWRTdHJlYW0gPSByZXF1aXJlKCcuL3JlYWRhYmxlJylcbiAgLCBET01TdHJlYW0gPSB7fVxuXG5ET01TdHJlYW0uV3JpdGVTdHJlYW0gPSBXcml0ZVN0cmVhbVxuRE9NU3RyZWFtLlJlYWRTdHJlYW0gPSBSZWFkU3RyZWFtXG5cbkRPTVN0cmVhbS5jcmVhdGVBcHBlbmRTdHJlYW0gPSBmdW5jdGlvbihlbCwgbWltZXR5cGUpIHtcbiAgcmV0dXJuIG5ldyBET01TdHJlYW0uV3JpdGVTdHJlYW0oXG4gICAgICBlbFxuICAgICwgRE9NU3RyZWFtLldyaXRlU3RyZWFtLkFQUEVORFxuICAgICwgbWltZXR5cGVcbiAgKVxufVxuXG5ET01TdHJlYW0uY3JlYXRlV3JpdGVTdHJlYW0gPSBmdW5jdGlvbihlbCwgbWltZXR5cGUpIHtcbiAgcmV0dXJuIG5ldyBET01TdHJlYW0uV3JpdGVTdHJlYW0oXG4gICAgICBlbFxuICAgICwgRE9NU3RyZWFtLldyaXRlU3RyZWFtLldSSVRFXG4gICAgLCBtaW1ldHlwZVxuICApXG59XG5cbkRPTVN0cmVhbS5jcmVhdGVSZWFkU3RyZWFtID1cbkRPTVN0cmVhbS5jcmVhdGVFdmVudFN0cmVhbSA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBwcmV2ZW50RGVmYXVsdCkge1xuICBwcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0ID09PSB1bmRlZmluZWQgPyB0cnVlIDogcHJldmVudERlZmF1bHRcblxuICByZXR1cm4gbmV3IERPTVN0cmVhbS5SZWFkU3RyZWFtKFxuICAgICAgZWxcbiAgICAsIHR5cGVcbiAgICAsIHByZXZlbnREZWZhdWx0XG4gIClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBET01TdHJlYW1cblxuIiwibW9kdWxlLmV4cG9ydHMgPSBET01TdHJlYW1cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpLlN0cmVhbVxuXG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihlbCwgdHlwZSwgb25tc2cpIHtcbiAgcmV0dXJuIGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgb25tc2csIGZhbHNlKVxufVxuXG5pZih0eXBlb2YgJCAhPT0gJ3VuZGVmaW5lZCcpXG4gIGxpc3RlbmVyID0gZnVuY3Rpb24oZWwsIHR5cGUsIG9ubXNnKSB7XG4gICAgcmV0dXJuIGVsID0gJChlbClbdHlwZV0ob25tc2cpXG4gIH1cblxuaWYodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiAhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykuYWRkRXZlbnRMaXN0ZW5lcilcbiAgbGlzdGVuZXIgPSBmdW5jdGlvbihlbCwgdHlwZSwgb25tc2cpIHtcbiAgICByZXR1cm4gZWwuYXR0YWNoRXZlbnQoJ29uJyt0eXBlLCBvbm1zZylcbiAgfVxuXG5mdW5jdGlvbiBET01TdHJlYW0oZWwsIGV2ZW50VHlwZSwgc2hvdWxkUHJldmVudERlZmF1bHQpIHtcbiAgdGhpcy5lbCA9IGVsXG4gIHRoaXMuZXZlbnRUeXBlID0gZXZlbnRUeXBlXG4gIHRoaXMuc2hvdWxkUHJldmVudERlZmF1bHQgPSBzaG91bGRQcmV2ZW50RGVmYXVsdFxuXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGlmKGVsICYmIHRoaXMuZXZlbnRUeXBlKVxuICAgIGxpc3RlbmVyKFxuICAgICAgICB0aGlzLmVsXG4gICAgICAsIHRoaXMuZXZlbnRUeXBlXG4gICAgICAsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2VsZi5saXN0ZW4uYXBwbHkoc2VsZiwgYXJndW1lbnRzKSB9XG4gICAgKVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpXG59XG5cbnZhciBjb25zID0gRE9NU3RyZWFtXG4gICwgcHJvdG8gPSBjb25zLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3RyZWFtLnByb3RvdHlwZSlcblxucHJvdG8uY29uc3RydWN0b3IgPSBjb25zXG5cbnByb3RvLmxpc3RlbiA9IGZ1bmN0aW9uKGV2KSB7XG4gIGlmKHRoaXMuc2hvdWxkUHJldmVudERlZmF1bHQpXG4gICAgZXYucHJldmVudERlZmF1bHQgPyBldi5wcmV2ZW50RGVmYXVsdCgpIDogKGV2LnJldHVyblZhbHVlID0gZmFsc2UpXG5cbiAgdmFyIGNvbGxlY3REYXRhID1cbiAgICB0aGlzLmV2ZW50VHlwZSA9PT0gJ3N1Ym1pdCcgfHxcbiAgICB0aGlzLmV2ZW50VHlwZSA9PT0gJ2NoYW5nZScgfHxcbiAgICB0aGlzLmV2ZW50VHlwZSA9PT0gJ2tleWRvd24nIHx8XG4gICAgdGhpcy5ldmVudFR5cGUgPT09ICdrZXl1cCcgfHxcbiAgICB0aGlzLmV2ZW50VHlwZSA9PT0gJ2lucHV0J1xuXG4gIGlmKGNvbGxlY3REYXRhKSB7XG4gICAgaWYodGhpcy5lbC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdGT1JNJylcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUZvcm1TdWJtaXQoZXYpXG5cbiAgICByZXR1cm4gdGhpcy5lbWl0KCdkYXRhJywgdmFsdWVGcm9tRWxlbWVudCh0aGlzLmVsKSlcbiAgfVxuXG4gIHRoaXMuZW1pdCgnZGF0YScsIGV2KVxufVxuXG5wcm90by5oYW5kbGVGb3JtU3VibWl0ID0gZnVuY3Rpb24oZXYpIHtcbiAgdmFyIGVsZW1lbnRzID0gW11cblxuICBpZih0aGlzLmVsLnF1ZXJ5U2VsZWN0b3JBbGwpIHtcbiAgICBlbGVtZW50cyA9IHRoaXMuZWwucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQsdGV4dGFyZWEsc2VsZWN0JylcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5wdXRzID0geydJTlBVVCc6dHJ1ZSwgJ1RFWFRBUkVBJzp0cnVlLCAnU0VMRUNUJzp0cnVlfVxuXG4gICAgdmFyIHJlY3Vyc2UgPSBmdW5jdGlvbihlbCkge1xuICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gZWwuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgICBpZihlbC5jaGlsZE5vZGVzW2ldLnRhZ05hbWUpIHtcbiAgICAgICAgICBpZihpbnB1dHNbZWwuY2hpbGROb2Rlc1tpXS50YWdOYW1lLnRvVXBwZXJDYXNlKCldKSB7XG4gICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWN1cnNlKGVsLmNoaWxkTm9kZXNbaV0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVjdXJzZSh0aGlzLmVsKVxuICB9XG5cbiAgdmFyIG91dHB1dCA9IHt9XG4gICAgLCBhdHRyXG4gICAgLCB2YWxcblxuICBmb3IodmFyIGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGF0dHIgPSBlbGVtZW50c1tpXS5nZXRBdHRyaWJ1dGUoJ25hbWUnKVxuICAgIHZhbCA9IHZhbHVlRnJvbUVsZW1lbnQoZWxlbWVudHNbaV0pXG5cbiAgICBpZih2YWwgIT09IG51bGwpIHtcbiAgICAgIG91dHB1dFthdHRyXSA9IHZhbFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzLmVtaXQoJ2RhdGEnLCBvdXRwdXQpXG59XG5cbmZ1bmN0aW9uIHZhbHVlRnJvbUVsZW1lbnQoZWwpIHtcbiAgc3dpdGNoKGVsLmdldEF0dHJpYnV0ZSgndHlwZScpKSB7XG4gICAgY2FzZSAncmFkaW8nOlxuICAgICAgcmV0dXJuIGVsLmNoZWNrZWQgPyBlbC52YWx1ZSA6IG51bGxcbiAgICBjYXNlICdjaGVja2JveCc6XG4gICAgICByZXR1cm4gJ2RhdGEnLCBlbC5jaGVja2VkXG4gIH1cbiAgcmV0dXJuIGVsLnZhbHVlXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IERPTVN0cmVhbVxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJykuU3RyZWFtXG5cbmZ1bmN0aW9uIERPTVN0cmVhbShlbCwgbW9kZSwgbWltZXR5cGUpIHtcbiAgdGhpcy5lbCA9IGVsXG4gIHRoaXMubW9kZSA9IG1vZGVcbiAgdGhpcy5taW1ldHlwZSA9IG1pbWV0eXBlIHx8ICd0ZXh0L2h0bWwnXG5cbiAgU3RyZWFtLmNhbGwodGhpcylcbn1cblxudmFyIGNvbnMgPSBET01TdHJlYW1cbiAgLCBwcm90byA9IGNvbnMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdHJlYW0ucHJvdG90eXBlKVxuXG5wcm90by5jb25zdHJ1Y3RvciA9IGNvbnNcblxuY29ucy5BUFBFTkQgPSAwXG5jb25zLldSSVRFID0gMVxuXG5wcm90by53cml0YWJsZSA9IHRydWVcblxucHJvdG8uc2V0TWltZXR5cGUgPSBmdW5jdGlvbihtaW1lKSB7XG4gIHRoaXMubWltZXR5cGUgPSBtaW1lXG59XG5cbnByb3RvLndyaXRlID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgcmVzdWx0ID0gKHRoaXMubW9kZSA9PT0gY29ucy5BUFBFTkQpID8gdGhpcy5hcHBlbmQoZGF0YSkgOiB0aGlzLmluc2VydChkYXRhKVxuICB0aGlzLmVtaXQoJ2RhdGEnLCB0aGlzLmVsLmNoaWxkTm9kZXMpXG4gIHJldHVybiByZXN1bHRcbn1cblxucHJvdG8uZW5kID0gZnVuY3Rpb24oKSB7XG5cbn1cblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLmVsLmlubmVySFRNTCA9ICcnXG4gIHJldHVybiB0aGlzLmFwcGVuZChkYXRhKVxufVxuXG5wcm90by5hcHBlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHZhciByZXN1bHQgPSB0aGlzW3RoaXMucmVzb2x2ZU1pbWV0eXBlSGFuZGxlcigpXShkYXRhKVxuXG4gIGZvcih2YXIgaSA9IDAsIGxlbiA9IHJlc3VsdC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHRoaXMuZWwuYXBwZW5kQ2hpbGQocmVzdWx0W2ldKVxuICB9XG5cbiAgcmV0dXJuIHRydWVcbn1cblxucHJvdG8ucmVzb2x2ZU1pbWV0eXBlSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdHlwZSA9IHRoaXMubWltZXR5cGUucmVwbGFjZSgvKFxcL1xcdykvLCBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHguc2xpY2UoMSkudG9VcHBlckNhc2UoKVxuICB9KVxuICB0eXBlID0gdHlwZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHR5cGUuc2xpY2UoMSlcblxuICByZXR1cm4gJ2NvbnN0cnVjdCcrdHlwZVxufVxuXG5wcm90by5jb25zdHJ1Y3RUZXh0SHRtbCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGlzVGFibGVGcmFnbWVudCA9IC8odHJ8dGR8dGgpLy50ZXN0KGRhdGEpICYmICEvdGFibGUvLnRlc3QoZGF0YSlcbiAgICAsIGRpdlxuXG4gIGlmKGlzVGFibGVGcmFnbWVudCkge1xuICAgIC8vIHd1aC1vaC5cbiAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpXG4gIH1cblxuICBkaXYgPSBkaXYgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgZGl2LmlubmVySFRNTCA9IGRhdGEgXG5cbiAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoZGl2LmNoaWxkTm9kZXMpXG59XG5cbnByb3RvLmNvbnN0cnVjdFRleHRQbGFpbiA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSlcblxuICByZXR1cm4gW3RleHROb2RlXVxufVxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbi8vIHRocm91Z2hcbi8vXG4vLyBhIHN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyBidXQgcmUtZW1pdCB0aGUgaW5wdXQuXG4vLyB1c2VmdWwgZm9yIGFnZ3JlZ2F0aW5nIGEgc2VyaWVzIG9mIGNoYW5naW5nIGJ1dCBub3QgZW5kaW5nIHN0cmVhbXMgaW50byBvbmUgc3RyZWFtKVxuXG5cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdGhyb3VnaFxudGhyb3VnaC50aHJvdWdoID0gdGhyb3VnaFxuXG4vL2NyZWF0ZSBhIHJlYWRhYmxlIHdyaXRhYmxlIHN0cmVhbS5cblxuZnVuY3Rpb24gdGhyb3VnaCAod3JpdGUsIGVuZCkge1xuICB3cml0ZSA9IHdyaXRlIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpIH1cbiAgZW5kID0gZW5kIHx8IGZ1bmN0aW9uICgpIHsgdGhpcy5lbWl0KCdlbmQnKSB9XG5cbiAgdmFyIGVuZGVkID0gZmFsc2UsIGRlc3Ryb3llZCA9IGZhbHNlXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKCksIGJ1ZmZlciA9IFtdXG4gIHN0cmVhbS5idWZmZXIgPSBidWZmZXJcbiAgc3RyZWFtLnJlYWRhYmxlID0gc3RyZWFtLndyaXRhYmxlID0gdHJ1ZVxuICBzdHJlYW0ucGF1c2VkID0gZmFsc2VcbiAgc3RyZWFtLndyaXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB3cml0ZS5jYWxsKHRoaXMsIGRhdGEpXG4gICAgcmV0dXJuICFzdHJlYW0ucGF1c2VkXG4gIH1cblxuICBmdW5jdGlvbiBkcmFpbigpIHtcbiAgICB3aGlsZShidWZmZXIubGVuZ3RoICYmICFzdHJlYW0ucGF1c2VkKSB7XG4gICAgICB2YXIgZGF0YSA9IGJ1ZmZlci5zaGlmdCgpXG4gICAgICBpZihudWxsID09PSBkYXRhKVxuICAgICAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2VuZCcpXG4gICAgICBlbHNlXG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB9XG4gIH1cblxuICBzdHJlYW0ucXVldWUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICB9XG5cbiAgLy90aGlzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0aGUgZmlyc3QgJ2VuZCcgbGlzdGVuZXJcbiAgLy9tdXN0IGNhbGwgZGVzdHJveSBuZXh0IHRpY2ssIHRvIG1ha2Ugc3VyZSB3ZSdyZSBhZnRlciBhbnlcbiAgLy9zdHJlYW0gcGlwZWQgZnJvbSBoZXJlLlxuICAvL3RoaXMgaXMgb25seSBhIHByb2JsZW0gaWYgZW5kIGlzIG5vdCBlbWl0dGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vYSBuaWNlciB3YXkgdG8gZG8gdGhpcyBpcyB0byBtYWtlIHN1cmUgdGhpcyBpcyB0aGUgbGFzdCBsaXN0ZW5lciBmb3IgJ2VuZCdcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmKCFzdHJlYW0ud3JpdGFibGUpXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICAgICAgfSlcbiAgfSlcblxuICBmdW5jdGlvbiBfZW5kICgpIHtcbiAgICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZVxuICAgIGVuZC5jYWxsKHN0cmVhbSlcbiAgICBpZighc3RyZWFtLnJlYWRhYmxlKVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHN0cmVhbS53cml0ZShkYXRhKVxuICAgIF9lbmQoKSAvLyB3aWxsIGVtaXQgb3IgcXVldWVcbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgc3RyZWFtLndyaXRhYmxlID0gc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICB9XG5cbiAgc3RyZWFtLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHJldHVyblxuICAgIHN0cmVhbS5wYXVzZWQgPSB0cnVlXG4gICAgc3RyZWFtLmVtaXQoJ3BhdXNlJylcbiAgfVxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuICAgIH1cbiAgICBkcmFpbigpXG4gICAgLy9tYXkgaGF2ZSBiZWNvbWUgcGF1c2VkIGFnYWluLFxuICAgIC8vYXMgZHJhaW4gZW1pdHMgJ2RhdGEnLlxuICAgIGlmKCFzdHJlYW0ucGF1c2VkKVxuICAgICAgc3RyZWFtLmVtaXQoJ2RyYWluJylcbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVsbHNjcmVlblxuZnVsbHNjcmVlbi5hdmFpbGFibGUgPSBhdmFpbGFibGVcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5cbmZ1bmN0aW9uIGF2YWlsYWJsZSgpIHtcbiAgcmV0dXJuICEhc2hpbShkb2N1bWVudC5ib2R5KVxufVxuXG5mdW5jdGlvbiBmdWxsc2NyZWVuKGVsKSB7XG4gIHZhciBhZWwgPSBlbC5hZGRFdmVudExpc3RlbmVyIHx8IGVsLmF0dGFjaEV2ZW50XG4gICAgLCBkb2MgPSBlbC5vd25lckRvY3VtZW50XG4gICAgLCBib2R5ID0gZG9jLmJvZHlcbiAgICAsIHJmcyA9IHNoaW0oZWwpXG4gICAgLCBlZSA9IG5ldyBFRVxuXG4gIHZhciB2ZW5kb3JzID0gWycnLCAnd2Via2l0JywgJ21veicsICdtcycsICdvJ11cblxuICBmb3IodmFyIGkgPSAwLCBsZW4gPSB2ZW5kb3JzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYWVsLmNhbGwoZG9jLCB2ZW5kb3JzW2ldKydmdWxsc2NyZWVuY2hhbmdlJywgb25mdWxsc2NyZWVuY2hhbmdlKVxuICAgIGFlbC5jYWxsKGRvYywgdmVuZG9yc1tpXSsnZnVsbHNjcmVlbmVycm9yJywgb25mdWxsc2NyZWVuZXJyb3IpXG4gIH1cblxuICBlZS5yZWxlYXNlID0gcmVsZWFzZVxuICBlZS5yZXF1ZXN0ID0gcmVxdWVzdFxuICBlZS50YXJnZXQgPSBmdWxsc2NyZWVuZWxlbWVudFxuXG4gIGlmKCFzaGltKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGVlLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdmdWxsc2NyZWVuIGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICB9LCAwKVxuICB9XG4gIHJldHVybiBlZVxuXG4gIGZ1bmN0aW9uIG9uZnVsbHNjcmVlbmNoYW5nZSgpIHtcbiAgICBpZighZnVsbHNjcmVlbmVsZW1lbnQoKSkge1xuICAgICAgcmV0dXJuIGVlLmVtaXQoJ3JlbGVhc2UnKVxuICAgIH1cbiAgICBlZS5lbWl0KCdhdHRhaW4nKVxuICB9XG5cbiAgZnVuY3Rpb24gb25mdWxsc2NyZWVuZXJyb3IoKSB7XG4gICAgZWUuZW1pdCgnZXJyb3InKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVxdWVzdCgpIHtcbiAgICByZXR1cm4gcmZzLmNhbGwoZWwpXG4gIH1cblxuICBmdW5jdGlvbiByZWxlYXNlKCkge1xuICAgIChlbC5leGl0RnVsbHNjcmVlbiB8fFxuICAgIGVsLmV4aXRGdWxsc2NyZWVuIHx8XG4gICAgZWwud2Via2l0RXhpdEZ1bGxTY3JlZW4gfHxcbiAgICBlbC53ZWJraXRFeGl0RnVsbHNjcmVlbiB8fFxuICAgIGVsLm1vekV4aXRGdWxsU2NyZWVuIHx8XG4gICAgZWwubW96RXhpdEZ1bGxzY3JlZW4gfHxcbiAgICBlbC5tc0V4aXRGdWxsU2NyZWVuIHx8XG4gICAgZWwubXNFeGl0RnVsbHNjcmVlbiB8fFxuICAgIGVsLm9FeGl0RnVsbFNjcmVlbiB8fFxuICAgIGVsLm9FeGl0RnVsbHNjcmVlbikuY2FsbChlbClcbiAgfSBcblxuICBmdW5jdGlvbiBmdWxsc2NyZWVuZWxlbWVudCgpIHtcbiAgICByZXR1cm4gMCB8fFxuICAgICAgZG9jLmZ1bGxTY3JlZW5FbGVtZW50IHx8XG4gICAgICBkb2MuZnVsbHNjcmVlbkVsZW1lbnQgfHxcbiAgICAgIGRvYy53ZWJraXRGdWxsU2NyZWVuRWxlbWVudCB8fFxuICAgICAgZG9jLndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICBkb2MubW96RnVsbFNjcmVlbkVsZW1lbnQgfHxcbiAgICAgIGRvYy5tb3pGdWxsc2NyZWVuRWxlbWVudCB8fFxuICAgICAgZG9jLm1zRnVsbFNjcmVlbkVsZW1lbnQgfHxcbiAgICAgIGRvYy5tc0Z1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICBkb2Mub0Z1bGxTY3JlZW5FbGVtZW50IHx8XG4gICAgICBkb2Mub0Z1bGxzY3JlZW5FbGVtZW50IHx8XG4gICAgICBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gc2hpbShlbCkge1xuICByZXR1cm4gKGVsLnJlcXVlc3RGdWxsc2NyZWVuIHx8XG4gICAgZWwud2Via2l0UmVxdWVzdEZ1bGxzY3JlZW4gfHxcbiAgICBlbC53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbiB8fFxuICAgIGVsLm1velJlcXVlc3RGdWxsc2NyZWVuIHx8XG4gICAgZWwubW96UmVxdWVzdEZ1bGxTY3JlZW4gfHxcbiAgICBlbC5tc1JlcXVlc3RGdWxsc2NyZWVuIHx8XG4gICAgZWwubXNSZXF1ZXN0RnVsbFNjcmVlbiB8fFxuICAgIGVsLm9SZXF1ZXN0RnVsbHNjcmVlbiB8fFxuICAgIGVsLm9SZXF1ZXN0RnVsbFNjcmVlbilcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcG9pbnRlclxuXG5wb2ludGVyLmF2YWlsYWJsZSA9IGF2YWlsYWJsZVxuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxuZnVuY3Rpb24gYXZhaWxhYmxlKCkge1xuICByZXR1cm4gISFzaGltKGRvY3VtZW50LmJvZHkpXG59XG5cbmZ1bmN0aW9uIHBvaW50ZXIoZWwpIHtcbiAgdmFyIGFlbCA9IGVsLmFkZEV2ZW50TGlzdGVuZXIgfHwgZWwuYXR0YWNoRXZlbnRcbiAgICAsIHJlbCA9IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIgfHwgZWwuZGV0YWNoRXZlbnRcbiAgICAsIGRvYyA9IGVsLm93bmVyRG9jdW1lbnRcbiAgICAsIGJvZHkgPSBkb2MuYm9keVxuICAgICwgcnBsID0gc2hpbShlbCkgXG4gICAgLCBvdXQgPSB7ZHg6IDAsIGR5OiAwLCBkdDogMH1cbiAgICAsIGVlID0gbmV3IEVFXG4gICAgLCBzdHJlYW0gPSBudWxsXG4gICAgLCBsYXN0UGFnZVgsIGxhc3RQYWdlWVxuICAgICwgbmVlZHNGdWxsc2NyZWVuID0gZmFsc2VcbiAgICAsIG1vdXNlRG93bk1TXG5cbiAgYWVsLmNhbGwoZWwsICdtb3VzZWRvd24nLCBvbm1vdXNlZG93biwgZmFsc2UpXG4gIGFlbC5jYWxsKGVsLCAnbW91c2V1cCcsIG9ubW91c2V1cCwgZmFsc2UpXG4gIGFlbC5jYWxsKGJvZHksICdtb3VzZW1vdmUnLCBvbm1vdmUsIGZhbHNlKVxuXG4gIHZhciB2ZW5kb3JzID0gWycnLCAnd2Via2l0JywgJ21veicsICdtcycsICdvJ11cblxuICBmb3IodmFyIGkgPSAwLCBsZW4gPSB2ZW5kb3JzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYWVsLmNhbGwoZG9jLCB2ZW5kb3JzW2ldKydwb2ludGVybG9ja2NoYW5nZScsIG9ucG9pbnRlcmxvY2tjaGFuZ2UpXG4gICAgYWVsLmNhbGwoZG9jLCB2ZW5kb3JzW2ldKydwb2ludGVybG9ja2Vycm9yJywgb25wb2ludGVybG9ja2Vycm9yKVxuICB9XG5cbiAgZWUucmVsZWFzZSA9IHJlbGVhc2VcbiAgZWUudGFyZ2V0ID0gcG9pbnRlcmxvY2tlbGVtZW50XG4gIGVlLnJlcXVlc3QgPSBvbm1vdXNlZG93blxuICBlZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gICAgcmVsLmNhbGwoZWwsICdtb3VzZXVwJywgb25tb3VzZXVwLCBmYWxzZSlcbiAgICByZWwuY2FsbChlbCwgJ21vdXNlZG93bicsIG9ubW91c2Vkb3duLCBmYWxzZSlcbiAgICByZWwuY2FsbChlbCwgJ21vdXNlbW92ZScsIG9ubW92ZSwgZmFsc2UpXG4gIH1cblxuICBpZighc2hpbSkge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBlZS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcigncG9pbnRlciBsb2NrIGlzIG5vdCBzdXBwb3J0ZWQnKSlcbiAgICB9LCAwKVxuICB9XG4gIHJldHVybiBlZVxuXG4gIGZ1bmN0aW9uIG9ubW91c2Vkb3duKGV2KSB7XG4gICAgaWYocG9pbnRlcmxvY2tlbGVtZW50KCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBtb3VzZURvd25NUyA9ICtuZXcgRGF0ZVxuICAgIHJwbC5jYWxsKGVsKVxuICB9XG5cbiAgZnVuY3Rpb24gb25tb3VzZXVwKGV2KSB7XG4gICAgaWYoIW5lZWRzRnVsbHNjcmVlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgZWUuZW1pdCgnbmVlZHMtZnVsbHNjcmVlbicpXG4gICAgbmVlZHNGdWxsc2NyZWVuID0gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ucG9pbnRlcmxvY2tjaGFuZ2UoZXYpIHtcbiAgICBpZighcG9pbnRlcmxvY2tlbGVtZW50KCkpIHtcbiAgICAgIGlmKHN0cmVhbSkgcmVsZWFzZSgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBzdHJlYW0gPSBuZXcgU3RyZWFtXG4gICAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZVxuICAgIHN0cmVhbS5pbml0aWFsID0ge3g6IGxhc3RQYWdlWCwgeTogbGFzdFBhZ2VZLCB0OiBEYXRlLm5vdygpfVxuXG4gICAgZWUuZW1pdCgnYXR0YWluJywgc3RyZWFtKVxuICB9XG5cbiAgZnVuY3Rpb24gb25wb2ludGVybG9ja2Vycm9yKGV2KSB7XG4gICAgdmFyIGR0ID0gKyhuZXcgRGF0ZSkgLSBtb3VzZURvd25NU1xuICAgIGlmKGR0IDwgMTAwKSB7XG4gICAgICAvLyB3ZSBlcnJvcmVkIGltbWVkaWF0ZWx5LCB3ZSBuZWVkIHRvIGRvIGZ1bGxzY3JlZW4gZmlyc3QuXG4gICAgICBuZWVkc0Z1bGxzY3JlZW4gPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZihzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGV2KVxuICAgICAgc3RyZWFtID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbGVhc2UoKSB7XG4gICAgZWUuZW1pdCgncmVsZWFzZScpXG5cbiAgICBpZihzdHJlYW0pIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKVxuICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICAgIHN0cmVhbS5lbWl0KCdjbG9zZScpXG4gICAgICBzdHJlYW0gPSBudWxsXG4gICAgfVxuXG4gICAgdmFyIHBlbCA9IHBvaW50ZXJsb2NrZWxlbWVudCgpXG4gICAgaWYoIXBlbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgKGRvYy5leGl0UG9pbnRlckxvY2sgfHxcbiAgICBkb2MubW96RXhpdFBvaW50ZXJMb2NrIHx8XG4gICAgZG9jLndlYmtpdEV4aXRQb2ludGVyTG9jayB8fFxuICAgIGRvYy5tc0V4aXRQb2ludGVyTG9jayB8fFxuICAgIGRvYy5vRXhpdFBvaW50ZXJMb2NrKS5jYWxsKGRvYylcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubW92ZShldikge1xuICAgIGxhc3RQYWdlWCA9IGV2LnBhZ2VYXG4gICAgbGFzdFBhZ2VZID0gZXYucGFnZVlcblxuICAgIGlmKCFzdHJlYW0pIHJldHVyblxuXG4gICAgLy8gd2UncmUgcmV1c2luZyBhIHNpbmdsZSBvYmplY3RcbiAgICAvLyBiZWNhdXNlIEknZCBsaWtlIHRvIGF2b2lkIHBpbGluZyB1cFxuICAgIC8vIGEgdG9uIG9mIG9iamVjdHMgZm9yIHRoZSBnYXJiYWdlXG4gICAgLy8gY29sbGVjdG9yLlxuICAgIG91dC5keCA9XG4gICAgICBldi5tb3ZlbWVudFggfHwgZXYud2Via2l0TW92ZW1lbnRYIHx8XG4gICAgICBldi5tb3pNb3ZlbWVudFggfHwgZXYubXNNb3ZlbWVudFggfHxcbiAgICAgIGV2Lm9Nb3ZlbWVudFggfHwgMFxuXG4gICAgb3V0LmR5ID0gXG4gICAgICBldi5tb3ZlbWVudFkgfHwgZXYud2Via2l0TW92ZW1lbnRZIHx8XG4gICAgICBldi5tb3pNb3ZlbWVudFkgfHwgZXYubXNNb3ZlbWVudFkgfHxcbiAgICAgIGV2Lm9Nb3ZlbWVudFkgfHwgMFxuXG4gICAgb3V0LmR0ID0gRGF0ZS5ub3coKSAtIHN0cmVhbS5pbml0aWFsLnRcblxuICAgIGVlLmVtaXQoJ2RhdGEnLCBvdXQpXG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBvdXQpXG4gIH1cblxuICBmdW5jdGlvbiBwb2ludGVybG9ja2VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIDAgfHxcbiAgICAgIGRvYy5wb2ludGVyTG9ja0VsZW1lbnQgfHxcbiAgICAgIGRvYy5tb3pQb2ludGVyTG9ja0VsZW1lbnQgfHxcbiAgICAgIGRvYy53ZWJraXRQb2ludGVyTG9ja0VsZW1lbnQgfHxcbiAgICAgIGRvYy5tc1BvaW50ZXJMb2NrRWxlbWVudCB8fFxuICAgICAgZG9jLm9Qb2ludGVyTG9ja0VsZW1lbnQgfHxcbiAgICAgIG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBzaGltKGVsKSB7XG4gIHJldHVybiBlbC5yZXF1ZXN0UG9pbnRlckxvY2sgfHxcbiAgICBlbC53ZWJraXRSZXF1ZXN0UG9pbnRlckxvY2sgfHxcbiAgICBlbC5tb3pSZXF1ZXN0UG9pbnRlckxvY2sgfHxcbiAgICBlbC5tc1JlcXVlc3RQb2ludGVyTG9jayB8fFxuICAgIGVsLm9SZXF1ZXN0UG9pbnRlckxvY2sgfHxcbiAgICBudWxsXG59XG4iLCJ2YXIgZXZlciA9IHJlcXVpcmUoJ2V2ZXInKVxuICAsIHZrZXkgPSByZXF1aXJlKCd2a2V5JylcbiAgLCBtYXggPSBNYXRoLm1heFxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVsLCBiaW5kaW5ncywgc3RhdGUpIHtcbiAgaWYoYmluZGluZ3MgPT09IHVuZGVmaW5lZCB8fCAhZWwub3duZXJEb2N1bWVudCkge1xuICAgIHN0YXRlID0gYmluZGluZ3NcbiAgICBiaW5kaW5ncyA9IGVsXG4gICAgZWwgPSB0aGlzLmRvY3VtZW50LmJvZHlcbiAgfVxuXG4gIHZhciBlZSA9IGV2ZXIoZWwpXG4gICAgLCBtZWFzdXJlZCA9IHt9XG4gICAgLCBlbmFibGVkID0gdHJ1ZVxuXG4gIHN0YXRlID0gc3RhdGUgfHwge31cblxuICAvLyBhbHdheXMgaW5pdGlhbGl6ZSB0aGUgc3RhdGUuXG4gIGZvcih2YXIga2V5IGluIGJpbmRpbmdzKSB7XG4gICAgaWYoYmluZGluZ3Nba2V5XSA9PT0gJ2VuYWJsZWQnIHx8XG4gICAgICAgYmluZGluZ3Nba2V5XSA9PT0gJ2VuYWJsZScgfHxcbiAgICAgICBiaW5kaW5nc1trZXldID09PSAnZGlzYWJsZScgfHxcbiAgICAgICBiaW5kaW5nc1trZXldID09PSAnZGVzdHJveScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihiaW5kaW5nc1trZXldKycgaXMgcmVzZXJ2ZWQnKVxuICAgIH1cbiAgICBzdGF0ZVtiaW5kaW5nc1trZXldXSA9IDBcbiAgICBtZWFzdXJlZFtrZXldID0gMVxuICB9XG5cbiAgZWUub24oJ2tleXVwJywgd3JhcHBlZChvbm9mZihrYiwgZmFsc2UpKSlcbiAgZWUub24oJ2tleWRvd24nLCB3cmFwcGVkKG9ub2ZmKGtiLCB0cnVlKSkpXG4gIGVlLm9uKCdtb3VzZXVwJywgd3JhcHBlZChvbm9mZihtb3VzZSwgZmFsc2UpKSlcbiAgZWUub24oJ21vdXNlZG93bicsIHdyYXBwZWQob25vZmYobW91c2UsIHRydWUpKSlcblxuICBzdGF0ZS5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGVuYWJsZWRcbiAgfVxuXG4gIHN0YXRlLmVuYWJsZSA9IGVuYWJsZV9kaXNhYmxlKHRydWUpXG4gIHN0YXRlLmRpc2FibGUgPSBlbmFibGVfZGlzYWJsZShmYWxzZSlcbiAgc3RhdGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgIGVlLnJlbW92ZUFsbExpc3RlbmVycygpXG4gIH0gXG4gIHJldHVybiBzdGF0ZVxuXG4gIGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIC8vIGFsd2F5cyBpbml0aWFsaXplIHRoZSBzdGF0ZS5cbiAgICBmb3IodmFyIGtleSBpbiBiaW5kaW5ncykge1xuICAgICAgc3RhdGVbYmluZGluZ3Nba2V5XV0gPSAwXG4gICAgICBtZWFzdXJlZFtrZXldID0gMVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuYWJsZV9kaXNhYmxlKG9uX29yX29mZikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyKClcbiAgICAgIGVuYWJsZWQgPSBvbl9vcl9vZmZcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd3JhcHBlZChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbihldikge1xuICAgICAgaWYoZW5hYmxlZCkge1xuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIGZuKGV2KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25vZmYoZmluZCwgb25fb3Jfb2ZmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGV2KSB7XG4gICAgICB2YXIga2V5ID0gZmluZChldilcbiAgICAgICAgLCBiaW5kaW5nID0gYmluZGluZ3Nba2V5XVxuXG4gICAgICBpZihiaW5kaW5nKSB7XG4gICAgICAgIHN0YXRlW2JpbmRpbmddICs9IG9uX29yX29mZiA/IG1heChtZWFzdXJlZFtrZXldLS0sIDApIDogLShtZWFzdXJlZFtrZXldID0gMSlcblxuICAgICAgICBpZighb25fb3Jfb2ZmICYmIHN0YXRlW2JpbmRpbmddIDwgMCkge1xuICAgICAgICAgIHN0YXRlW2JpbmRpbmddID0gMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91c2UoZXYpIHtcbiAgICByZXR1cm4gJzxtb3VzZSAnK2V2LndoaWNoKyc+J1xuICB9XG5cbiAgZnVuY3Rpb24ga2IoZXYpIHtcbiAgICByZXR1cm4gdmtleVtldi5rZXlDb2RlXSB8fCBldi5jaGFyXG4gIH1cbn1cbiIsInZhciB1YSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQgOiAnJ1xuICAsIGlzT1NYID0gL09TIFgvLnRlc3QodWEpXG4gICwgaXNPcGVyYSA9IC9PcGVyYS8udGVzdCh1YSlcbiAgLCBtYXliZUZpcmVmb3ggPSAhL2xpa2UgR2Vja28vLnRlc3QodWEpICYmICFpc09wZXJhXG5cbnZhciBpLCBvdXRwdXQgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgMDogIGlzT1NYID8gJzxtZW51PicgOiAnPFVOSz4nXG4sIDE6ICAnPG1vdXNlIDE+J1xuLCAyOiAgJzxtb3VzZSAyPidcbiwgMzogICc8YnJlYWs+J1xuLCA0OiAgJzxtb3VzZSAzPidcbiwgNTogICc8bW91c2UgND4nXG4sIDY6ICAnPG1vdXNlIDU+J1xuLCA4OiAgJzxiYWNrc3BhY2U+J1xuLCA5OiAgJzx0YWI+J1xuLCAxMjogJzxjbGVhcj4nXG4sIDEzOiAnPGVudGVyPidcbiwgMTY6ICc8c2hpZnQ+J1xuLCAxNzogJzxjb250cm9sPidcbiwgMTg6ICc8YWx0PidcbiwgMTk6ICc8cGF1c2U+J1xuLCAyMDogJzxjYXBzLWxvY2s+J1xuLCAyMTogJzxpbWUtaGFuZ3VsPidcbiwgMjM6ICc8aW1lLWp1bmphPidcbiwgMjQ6ICc8aW1lLWZpbmFsPidcbiwgMjU6ICc8aW1lLWthbmppPidcbiwgMjc6ICc8ZXNjYXBlPidcbiwgMjg6ICc8aW1lLWNvbnZlcnQ+J1xuLCAyOTogJzxpbWUtbm9uY29udmVydD4nXG4sIDMwOiAnPGltZS1hY2NlcHQ+J1xuLCAzMTogJzxpbWUtbW9kZS1jaGFuZ2U+J1xuLCAyNzogJzxlc2NhcGU+J1xuLCAzMjogJzxzcGFjZT4nXG4sIDMzOiAnPHBhZ2UtdXA+J1xuLCAzNDogJzxwYWdlLWRvd24+J1xuLCAzNTogJzxlbmQ+J1xuLCAzNjogJzxob21lPidcbiwgMzc6ICc8bGVmdD4nXG4sIDM4OiAnPHVwPidcbiwgMzk6ICc8cmlnaHQ+J1xuLCA0MDogJzxkb3duPidcbiwgNDE6ICc8c2VsZWN0PidcbiwgNDI6ICc8cHJpbnQ+J1xuLCA0MzogJzxleGVjdXRlPidcbiwgNDQ6ICc8c25hcHNob3Q+J1xuLCA0NTogJzxpbnNlcnQ+J1xuLCA0NjogJzxkZWxldGU+J1xuLCA0NzogJzxoZWxwPidcbiwgOTE6ICc8bWV0YT4nICAvLyBtZXRhLWxlZnQgLS0gbm8gb25lIGhhbmRsZXMgbGVmdCBhbmQgcmlnaHQgcHJvcGVybHksIHNvIHdlIGNvZXJjZSBpbnRvIG9uZS5cbiwgOTI6ICc8bWV0YT4nICAvLyBtZXRhLXJpZ2h0XG4sIDkzOiBpc09TWCA/ICc8bWV0YT4nIDogJzxtZW51PicgICAgICAvLyBjaHJvbWUsb3BlcmEsc2FmYXJpIGFsbCByZXBvcnQgdGhpcyBmb3IgbWV0YS1yaWdodCAob3N4IG1icCkuXG4sIDk1OiAnPHNsZWVwPidcbiwgMTA2OiAnPG51bS0qPidcbiwgMTA3OiAnPG51bS0rPidcbiwgMTA4OiAnPG51bS1lbnRlcj4nXG4sIDEwOTogJzxudW0tLT4nXG4sIDExMDogJzxudW0tLj4nXG4sIDExMTogJzxudW0tLz4nXG4sIDE0NDogJzxudW0tbG9jaz4nXG4sIDE0NTogJzxzY3JvbGwtbG9jaz4nXG4sIDE2MDogJzxzaGlmdC1sZWZ0PidcbiwgMTYxOiAnPHNoaWZ0LXJpZ2h0PidcbiwgMTYyOiAnPGNvbnRyb2wtbGVmdD4nXG4sIDE2MzogJzxjb250cm9sLXJpZ2h0PidcbiwgMTY0OiAnPGFsdC1sZWZ0PidcbiwgMTY1OiAnPGFsdC1yaWdodD4nXG4sIDE2NjogJzxicm93c2VyLWJhY2s+J1xuLCAxNjc6ICc8YnJvd3Nlci1mb3J3YXJkPidcbiwgMTY4OiAnPGJyb3dzZXItcmVmcmVzaD4nXG4sIDE2OTogJzxicm93c2VyLXN0b3A+J1xuLCAxNzA6ICc8YnJvd3Nlci1zZWFyY2g+J1xuLCAxNzE6ICc8YnJvd3Nlci1mYXZvcml0ZXM+J1xuLCAxNzI6ICc8YnJvd3Nlci1ob21lPidcblxuICAvLyBmZi9vc3ggcmVwb3J0cyAnPHZvbHVtZS1tdXRlPicgZm9yICctJ1xuLCAxNzM6IGlzT1NYICYmIG1heWJlRmlyZWZveCA/ICctJyA6ICc8dm9sdW1lLW11dGU+J1xuLCAxNzQ6ICc8dm9sdW1lLWRvd24+J1xuLCAxNzU6ICc8dm9sdW1lLXVwPidcbiwgMTc2OiAnPG5leHQtdHJhY2s+J1xuLCAxNzc6ICc8cHJldi10cmFjaz4nXG4sIDE3ODogJzxzdG9wPidcbiwgMTc5OiAnPHBsYXktcGF1c2U+J1xuLCAxODA6ICc8bGF1bmNoLW1haWw+J1xuLCAxODE6ICc8bGF1bmNoLW1lZGlhLXNlbGVjdD4nXG4sIDE4MjogJzxsYXVuY2gtYXBwIDE+J1xuLCAxODM6ICc8bGF1bmNoLWFwcCAyPidcbiwgMTg2OiAnOydcbiwgMTg3OiAnPSdcbiwgMTg4OiAnLCdcbiwgMTg5OiAnLSdcbiwgMTkwOiAnLidcbiwgMTkxOiAnLydcbiwgMTkyOiAnYCdcbiwgMjE5OiAnWydcbiwgMjIwOiAnXFxcXCdcbiwgMjIxOiAnXSdcbiwgMjIyOiBcIidcIlxuLCAyMjM6ICc8bWV0YT4nXG4sIDIyNDogJzxtZXRhPicgICAgICAgLy8gZmlyZWZveCByZXBvcnRzIG1ldGEgaGVyZS5cbiwgMjI2OiAnPGFsdC1ncj4nXG4sIDIyOTogJzxpbWUtcHJvY2Vzcz4nXG4sIDIzMTogaXNPcGVyYSA/ICdgJyA6ICc8dW5pY29kZT4nXG4sIDI0NjogJzxhdHRlbnRpb24+J1xuLCAyNDc6ICc8Y3JzZWw+J1xuLCAyNDg6ICc8ZXhzZWw+J1xuLCAyNDk6ICc8ZXJhc2UtZW9mPidcbiwgMjUwOiAnPHBsYXk+J1xuLCAyNTE6ICc8em9vbT4nXG4sIDI1MjogJzxuby1uYW1lPidcbiwgMjUzOiAnPHBhLTE+J1xuLCAyNTQ6ICc8Y2xlYXI+J1xufVxuXG5mb3IoaSA9IDU4OyBpIDwgNjU7ICsraSkge1xuICBvdXRwdXRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXG59XG5cbi8vIDAtOVxuZm9yKGkgPSA0ODsgaSA8IDU4OyArK2kpIHtcbiAgb3V0cHV0W2ldID0gKGkgLSA0OCkrJydcbn1cblxuLy8gQS1aXG5mb3IoaSA9IDY1OyBpIDwgOTE7ICsraSkge1xuICBvdXRwdXRbaV0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXG59XG5cbi8vIG51bTAtOVxuZm9yKGkgPSA5NjsgaSA8IDEwNjsgKytpKSB7XG4gIG91dHB1dFtpXSA9ICc8bnVtLScrKGkgLSA5NikrJz4nXG59XG5cbi8vIEYxLUYyNFxuZm9yKGkgPSAxMTI7IGkgPCAxMzY7ICsraSkge1xuICBvdXRwdXRbaV0gPSAnRicrKGktMTExKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBwaW5cblxudmFyIHBpbnMgPSB7fVxuICAsIHN0YWNrX2hvbGRlciA9IHt9XG4gICwgcGluX2hvbGRlclxuXG5mdW5jdGlvbiBtYWtlX3Bpbl9mb3IobmFtZSwgb2JqKSB7XG4gIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICwgaGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDQnKVxuICAgICwgYm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ByZScpXG5cbiAgY29udGFpbmVyLnN0eWxlLmJhY2tncm91bmQgPSAnd2hpdGUnXG4gIGNvbnRhaW5lci5zdHlsZS5tYXJnaW5Cb3R0b20gPSAnNHB4J1xuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaGVhZGVyKVxuICBjb250YWluZXIuYXBwZW5kQ2hpbGQoYm9keSlcbiAgaGVhZGVyLnRleHRDb250ZW50cyA9IGhlYWRlci5pbm5lclRleHQgPSBvYmogJiYgb2JqLnJlcHIgPyBvYmoucmVwcigpIDogbmFtZVxuICBib2R5LnN0eWxlLnBhZGRpbmcgPSAnOHB4J1xuXG5cbiAgaWYoIXBpbl9ob2xkZXIpIHtcbiAgICBwaW5faG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBwaW5faG9sZGVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIHBpbl9ob2xkZXIuc3R5bGUudG9wID1cbiAgICBwaW5faG9sZGVyLnN0eWxlLnJpZ2h0ID0gJzRweCdcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGluX2hvbGRlcilcbiAgfVxuXG4gIHBpbl9ob2xkZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKVxuXG4gIHJldHVybiAocGluc1tuYW1lXSA9IHBpbnNbbmFtZV0gfHwgW10pLnB1c2goe2JvZHk6IGJvZHksIGxhc3Q6IC1JbmZpbml0eSwgZm9yX29iamVjdDogb2JqfSksIHBpbnNbbmFtZV1cbn1cblxuZnVuY3Rpb24gdXBkYXRlX3BpbihpdGVtLCBpbnRvLCByZXRhaW4sIGRlcHRoKSB7XG4gIGlmKCFyZXRhaW4pIGludG8uaW5uZXJIVE1MID0gJydcbiAgaWYoZGVwdGggPiAxKSByZXR1cm5cbiAgZGVwdGggPSBkZXB0aCB8fCAwXG5cbiAgc3dpdGNoKHR5cGVvZiBpdGVtKSB7XG4gICAgY2FzZSAnbnVtYmVyJzogaW50by5pbm5lclRleHQgKz0gaXRlbS50b0ZpeGVkKDMpOyBicmVha1xuICAgIGNhc2UgJ3N0cmluZyc6IGludG8uaW5uZXJUZXh0ICs9ICdcIicraXRlbSsnXCInOyBicmVha1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmKGl0ZW0pIHtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gaXRlbSkgaWYoaXRlbS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgaW50by5pbm5lclRleHQgKz0ga2V5ICsnOidcbiAgICAgICAgICB1cGRhdGVfcGluKGl0ZW1ba2V5XSwgaW50bywgdHJ1ZSwgZGVwdGgrMSlcbiAgICAgICAgICBpbnRvLmlubmVyVGV4dCArPSAnXFxuJ1xuICAgICAgICB9IFxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIGNhc2UgJ2Jvb2xlYW4nOiBpbnRvLmlubmVyVGV4dCArPSAnJytpdGVtOyBicmVha1xuICB9ICBcbn1cblxuZnVuY3Rpb24gcGluKGl0ZW0sIGV2ZXJ5LCBvYmosIG5hbWUpIHtcbiAgaWYoIW5hbWUpIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHN0YWNrX2hvbGRlcilcbiAgdmFyIGxvY2F0aW9uID0gbmFtZSB8fCBzdGFja19ob2xkZXIuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDIpWzBdLnJlcGxhY2UoL15cXHMrYXQgL2csICcnKVxuICAgICwgdGFyZ2V0ID0gcGluc1tsb2NhdGlvbl0gfHwgbWFrZV9waW5fZm9yKGxvY2F0aW9uLCBvYmopXG4gICAgLCBub3cgPSBEYXRlLm5vdygpXG4gICAgLCBldmVyeSA9IGV2ZXJ5IHx8IDBcblxuICBpZihhcmd1bWVudHMubGVuZ3RoIDwgMykgdGFyZ2V0ID0gdGFyZ2V0WzBdXG4gIGVsc2Uge1xuICAgIGZvcih2YXIgaSA9IDAsIGxlbiA9IHRhcmdldC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmKHRhcmdldFtpXS5mb3Jfb2JqZWN0ID09PSBvYmopIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldFtpXVxuICAgICAgYnJlYWsgICBcbiAgICB9XG4gIH1cbiAgICBpZihpID09PSBsZW4pIHtcbiAgICAgIHBpbnNbbG9jYXRpb25dLnB1c2godGFyZ2V0ID0gbWFrZV9waW5fZm9yKGxvY2F0aW9uLCBvYmopKVxuICAgIH1cbiAgfVxuXG4gIGlmKG5vdyAtIHRhcmdldC5sYXN0ID4gZXZlcnkpIHtcbiAgICB1cGRhdGVfcGluKGl0ZW0sIHRhcmdldC5ib2R5KVxuICAgIHRhcmdldC5sYXN0ID0gbm93IFxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJhZlxuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBnbG9iYWwgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHRoaXMgOiB3aW5kb3dcblxudmFyIF9yYWYgPVxuICBnbG9iYWwucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gIGdsb2JhbC53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgZ2xvYmFsLm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxuICBnbG9iYWwubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgZ2xvYmFsLm9SZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcbiAgKGdsb2JhbC5zZXRJbW1lZGlhdGUgPyBmdW5jdGlvbihmbiwgZWwpIHtcbiAgICBzZXRJbW1lZGlhdGUoZm4pXG4gIH0gOlxuICBmdW5jdGlvbihmbiwgZWwpIHtcbiAgICBzZXRUaW1lb3V0KGZuLCAwKVxuICB9KVxuXG5mdW5jdGlvbiByYWYoZWwpIHtcbiAgdmFyIG5vdyA9IHJhZi5ub3coKVxuICAgICwgZWUgPSBuZXcgRUVcblxuICBlZS5wYXVzZSA9IGZ1bmN0aW9uKCkgeyBlZS5wYXVzZWQgPSB0cnVlIH1cbiAgZWUucmVzdW1lID0gZnVuY3Rpb24oKSB7IGVlLnBhdXNlZCA9IGZhbHNlIH1cblxuICBfcmFmKGl0ZXIsIGVsKVxuXG4gIHJldHVybiBlZVxuXG4gIGZ1bmN0aW9uIGl0ZXIodGltZXN0YW1wKSB7XG4gICAgdmFyIF9ub3cgPSByYWYubm93KClcbiAgICAgICwgZHQgPSBfbm93IC0gbm93XG4gICAgXG4gICAgbm93ID0gX25vd1xuXG4gICAgZWUuZW1pdCgnZGF0YScsIGR0KVxuXG4gICAgaWYoIWVlLnBhdXNlZCkge1xuICAgICAgX3JhZihpdGVyLCBlbClcbiAgICB9XG4gIH1cbn1cblxucmFmLnBvbHlmaWxsID0gX3JhZlxucmFmLm5vdyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gRGF0ZS5ub3coKSB9XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFNwYXRpYWxFdmVudEVtaXR0ZXJcblxudmFyIHNsaWNlID0gW10uc2xpY2VcbiAgLCBUcmVlID0gcmVxdWlyZSgnLi90cmVlJylcbiAgLCBhYWJiID0gcmVxdWlyZSgnYWFiYi0zZCcpXG5cbmZ1bmN0aW9uIFNwYXRpYWxFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMucm9vdCA9IG51bGxcbiAgdGhpcy5pbmZpbml0ZXMgPSB7fVxufVxuXG52YXIgY29ucyA9IFNwYXRpYWxFdmVudEVtaXR0ZXJcbiAgLCBwcm90byA9IGNvbnMucHJvdG90eXBlXG5cbnByb3RvLnNpemUgPSAxNlxuXG5wcm90by5hZGRMaXN0ZW5lciA9IFxucHJvdG8uYWRkRXZlbnRMaXN0ZW5lciA9IFxucHJvdG8ub24gPSBmdW5jdGlvbihldmVudCwgYmJveCwgbGlzdGVuZXIpIHtcbiAgaWYoIWZpbml0ZShiYm94KSkge1xuICAgICh0aGlzLmluZmluaXRlc1tldmVudF0gPSB0aGlzLmluZmluaXRlc1tldmVudF0gfHwgW10pLnB1c2goe1xuICAgICAgYmJveDogYmJveFxuICAgICwgZnVuYzogbGlzdGVuZXJcbiAgICB9KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAodGhpcy5yb290ID0gdGhpcy5yb290IHx8IHRoaXMuY3JlYXRlX3Jvb3QoYmJveCkpXG4gICAgLmFkZChldmVudCwgYmJveCwgbGlzdGVuZXIpXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxucHJvdG8ub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBiYm94LCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBzZWxmLm9uKGV2ZW50LCBiYm94LCBmdW5jdGlvbiBvbmNlKCkge1xuICAgIGxpc3RlbmVyLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICBzZWxmLnJlbW92ZShldmVudCwgb25jZSlcbiAgfSlcblxuICByZXR1cm4gc2VsZlxufVxuXG5wcm90by5yZW1vdmVMaXN0ZW5lciA9XG5wcm90by5yZW1vdmVFdmVudExpc3RlbmVyID1cbnByb3RvLnJlbW92ZSA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICBpZih0aGlzLnJvb3QpIHtcbiAgICB0aGlzLnJvb3QucmVtb3ZlKGV2ZW50LCBsaXN0ZW5lcilcbiAgfVxuXG4gIGlmKCF0aGlzLmluZmluaXRlc1tldmVudF0pIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5pbmZpbml0ZXNbZXZlbnRdLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYodGhpcy5pbmZpbml0ZXNbZXZlbnRdW2ldLmZ1bmMgPT09IGxpc3RlbmVyKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmKGkgIT09IGxlbikge1xuICAgIHRoaXMuaW5maW5pdGVzW2V2ZW50XS5zcGxpY2UoaSwgMSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbnByb3RvLmVtaXQgPSBmdW5jdGlvbihldmVudCwgYmJveC8qLCAuLi5hcmdzICovKSB7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXG5cbiAgLy8gc3VwcG9ydCBwb2ludCBlbWl0dGluZ1xuICBpZignMCcgaW4gYmJveCkge1xuICAgIGJib3ggPSBhYWJiKGJib3gsIFswLCAwLCAwXSkgXG4gIH1cblxuICBpZih0aGlzLnJvb3QpIHtcbiAgICB0aGlzLnJvb3Quc2VuZChldmVudCwgYmJveCwgYXJncylcbiAgfVxuXG4gIGlmKCF0aGlzLmluZmluaXRlc1tldmVudF0pIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgdmFyIGxpc3QgPSB0aGlzLmluZmluaXRlc1tldmVudF0uc2xpY2UoKVxuICBmb3IodmFyIGkgPSAwLCBsZW4gPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYobGlzdFtpXS5iYm94LmludGVyc2VjdHMoYmJveCkpIHtcbiAgICAgIGxpc3RbaV0uZnVuYy5hcHBseShudWxsLCBhcmdzKSBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5wcm90by5yb290U2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgcHJvdG8uc2l6ZSA9IHNpemVcbn1cblxucHJvdG8uY3JlYXRlX3Jvb3QgPSBmdW5jdGlvbihiYm94KSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgc2l6ZSA9IHNlbGYuc2l6ZVxuICAgICwgYmFzZSA9IFtcbiAgICAgICAgTWF0aC5mbG9vcihiYm94LngwKCkgLyBzaXplKSAqIHNpemVcbiAgICAgICwgTWF0aC5mbG9vcihiYm94LnkwKCkgLyBzaXplKSAqIHNpemVcbiAgICAgICwgTWF0aC5mbG9vcihiYm94LnowKCkgLyBzaXplKSAqIHNpemVcbiAgICAgIF1cbiAgICAsIHRyZWVfYmJveCA9IG5ldyBiYm94LmNvbnN0cnVjdG9yKGJhc2UsIFtzaXplLCBzaXplLCBzaXplXSlcblxuICBmdW5jdGlvbiBPdXJUcmVlKHNpemUsIGJib3gpIHtcbiAgICBUcmVlLmNhbGwodGhpcywgc2l6ZSwgYmJveCwgbnVsbClcbiAgfVxuXG4gIE91clRyZWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShUcmVlLnByb3RvdHlwZSlcbiAgT3VyVHJlZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPdXJUcmVlXG4gIE91clRyZWUucHJvdG90eXBlLmdyb3cgPSBmdW5jdGlvbihuZXdfcm9vdCkge1xuICAgIHNlbGYucm9vdCA9IG5ld19yb290XG4gIH1cbiAgT3VyVHJlZS5wcm90b3R5cGUubWluX3NpemUgPSBzaXplXG5cbiAgcmV0dXJuIG5ldyBPdXJUcmVlKHNpemUsIHRyZWVfYmJveCkgXG59XG5cbmZ1bmN0aW9uIGZpbml0ZShiYm94KSB7XG4gIHJldHVybiBpc0Zpbml0ZShiYm94LngwKCkpICYmXG4gICAgICAgICBpc0Zpbml0ZShiYm94LngxKCkpICYmXG4gICAgICAgICBpc0Zpbml0ZShiYm94LnkwKCkpICYmXG4gICAgICAgICBpc0Zpbml0ZShiYm94LnkxKCkpICYmXG4gICAgICAgICBpc0Zpbml0ZShiYm94LnowKCkpICYmXG4gICAgICAgICBpc0Zpbml0ZShiYm94LnoxKCkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFRyZWVcblxudmFyIGFhYmIgPSByZXF1aXJlKCdhYWJiLTNkJylcblxuZnVuY3Rpb24gVHJlZShzaXplLCBiYm94LCBwYXJlbnQpIHtcbiAgdGhpcy5saXN0ZW5lcnMgPSB7fVxuICB0aGlzLnNpemUgPSBzaXplXG4gIHRoaXMuYmJveCA9IGJib3hcbiAgdGhpcy5wYXJlbnQgPSBwYXJlbnRcbiAgdGhpcy5jaGlsZHJlbiA9IFtdXG59XG5cbnZhciBjb25zID0gVHJlZVxuICAsIHByb3RvID0gY29ucy5wcm90b3R5cGVcblxucHJvdG8uYWRkID0gZnVuY3Rpb24oZXZlbnQsIGJib3gsIGxpc3RlbmVyKSB7XG4gIGlmKCF0aGlzLnBhcmVudCAmJiAhdGhpcy5jb250YWlucyhiYm94KSkge1xuICAgIHJldHVybiB0aGlzLmV4cGFuZChiYm94KS5hZGQoZXZlbnQsIGJib3gsIGxpc3RlbmVyKVxuICB9XG5cbiAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmKHRoaXMuY2hpbGRyZW5baV0uY29udGFpbnMoYmJveCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuW2ldLmFkZChldmVudCwgYmJveCwgbGlzdGVuZXIpXG4gICAgfVxuICB9XG5cbiAgdmFyIHNpemUgPSB0aGlzLnNpemUgLyAyXG5cbiAgaWYoc2l6ZSA+IHRoaXMubWluX3NpemUgJiYgYmJveC52ZWNbMF0gPCBzaXplICYmIGJib3gudmVjWzFdIDwgc2l6ZSAmJiBiYm94LnZlY1syXSA8IHNpemUpIHtcbiAgICAvLyBpZiBpdCBmaXRzIGludG8gYSBjaGlsZCBub2RlLCBtYWtlIHRoYXQgY2hpbGRub2RlXG4gICAgaWYoTWF0aC5mbG9vcihiYm94LngwKCkgLyBzaXplKSA9PT0gTWF0aC5mbG9vcihiYm94LngxKCkgLyBzaXplKSAmJlxuICAgICAgIE1hdGguZmxvb3IoYmJveC55MCgpIC8gc2l6ZSkgPT09IE1hdGguZmxvb3IoYmJveC55MSgpIC8gc2l6ZSkgJiZcbiAgICAgICBNYXRoLmZsb29yKGJib3guejAoKSAvIHNpemUpID09PSBNYXRoLmZsb29yKGJib3guejEoKSAvIHNpemUpKSB7XG4gICAgICB2YXIgaW5zdCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKFxuICAgICAgICAgIHNpemVcbiAgICAgICAgLCBhYWJiKFtcbiAgICAgICAgICAgICAgTWF0aC5mbG9vcihiYm94LngwKCkgLyBzaXplKSAqIHNpemVcbiAgICAgICAgICAgICwgTWF0aC5mbG9vcihiYm94LnkwKCkgLyBzaXplKSAqIHNpemVcbiAgICAgICAgICAgICwgTWF0aC5mbG9vcihiYm94LnowKCkgLyBzaXplKSAqIHNpemVcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAsIFtzaXplLCBzaXplLCBzaXplXVxuICAgICAgICAgIClcbiAgICAgICAgLCB0aGlzXG4gICAgICApXG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goaW5zdClcbiAgICAgIHJldHVybiBpbnN0LmFkZChldmVudCwgYmJveCwgbGlzdGVuZXIpXG4gICAgfVxuICB9XG5cbiAgKHRoaXMubGlzdGVuZXJzW2V2ZW50XSA9IHRoaXMubGlzdGVuZXJzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaCh7YmJveDogYmJveCwgZnVuYzogbGlzdGVuZXJ9KVxufVxuXG5wcm90by5jb250YWlucyA9IGZ1bmN0aW9uKGJib3gpIHtcbiAgcmV0dXJuIGJib3gueDAoKSA+PSB0aGlzLmJib3gueDAoKSAmJlxuICAgICAgICAgYmJveC55MCgpID49IHRoaXMuYmJveC55MCgpICYmXG4gICAgICAgICBiYm94LnowKCkgPj0gdGhpcy5iYm94LnowKCkgJiZcbiAgICAgICAgIGJib3gueDEoKSA8PSB0aGlzLmJib3gueDEoKSAmJlxuICAgICAgICAgYmJveC55MSgpIDw9IHRoaXMuYmJveC55MSgpICYmXG4gICAgICAgICBiYm94LnoxKCkgPD0gdGhpcy5iYm94LnoxKClcbn1cblxucHJvdG8uZXhwYW5kID0gZnVuY3Rpb24oYmJveCkge1xuICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZVxuICAgICwgbmV3X3NpemUgPSBzaXplICogMlxuICAgICwgZXhwYW5kZWQgPSB0aGlzLmJib3guZXhwYW5kKGJib3gpXG4gICAgLCBuZXdfaSA9IE1hdGguZmxvb3IoYmJveC54MCgpIC8gc2l6ZSlcbiAgICAsIG5ld19qID0gTWF0aC5mbG9vcihiYm94LnkwKCkgLyBzaXplKVxuICAgICwgbmV3X2sgPSBNYXRoLmZsb29yKGJib3guejAoKSAvIHNpemUpXG4gICAgLCBjdXJfaSA9IE1hdGguZmxvb3IodGhpcy5iYm94LngwKCkgLyBzaXplKVxuICAgICwgY3VyX2ogPSBNYXRoLmZsb29yKHRoaXMuYmJveC55MCgpIC8gc2l6ZSlcbiAgICAsIGN1cl9rID0gTWF0aC5mbG9vcih0aGlzLmJib3guejAoKSAvIHNpemUpXG4gICAgLCBuZXdfYmFzZSA9IFtcbiAgICAgICAgbmV3X2kgLSBjdXJfaSA+PSAwID8gY3VyX2kgOiBjdXJfaSAtIDFcbiAgICAgICwgbmV3X2ogLSBjdXJfaiA+PSAwID8gY3VyX2ogOiBjdXJfaiAtIDFcbiAgICAgICwgbmV3X2sgLSBjdXJfayA+PSAwID8gY3VyX2sgOiBjdXJfayAtIDFcbiAgICAgIF0ubWFwKGZ1bmN0aW9uKGlpKSB7IHJldHVybiBpaSAqIHNpemUgfSlcbiAgICAsIG5ld19iYm94ID0gYWFiYihuZXdfYmFzZSwgW25ld19zaXplLCBuZXdfc2l6ZSwgbmV3X3NpemVdKVxuICAgICwgbmV3X3Jvb3QgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihuZXdfc2l6ZSwgbmV3X2Jib3gpXG4gICAgLCBzZWxmID0gdGhpc1xuXG4gIHRoaXMucGFyZW50ID0gbmV3X3Jvb3RcbiAgdGhpcy5ncm93KHRoaXMucGFyZW50KVxuXG4gIG5ld19yb290LmNoaWxkcmVuLnB1c2goc2VsZilcblxuICByZXR1cm4gbmV3X3Jvb3Rcbn1cblxucHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0ID0gdGhpcy5saXN0ZW5lcnNbZXZlbnRdXG4gIGlmKGxpc3QpIHtcbiAgICBmb3IodmFyIGkgPSAwLCBsZW4gPSBsaXN0Lmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBpZihsaXN0W2ldLmZ1bmMgPT09IGxpc3RlbmVyKVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIGlmKGkgIT09IGxlbikge1xuICAgICAgbGlzdC5zcGxpY2UoaSwgMSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHRoaXMuY2hpbGRyZW5baV0ucmVtb3ZlKGV2ZW50LCBsaXN0ZW5lcilcbiAgfVxufVxuXG5wcm90by5zZW5kID0gZnVuY3Rpb24oZXZlbnQsIGJib3gsIGFyZ3MpIHtcbiAgZm9yKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmKGJib3guaW50ZXJzZWN0cyh0aGlzLmNoaWxkcmVuW2ldLmJib3gpKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuW2ldLnNlbmQoZXZlbnQsIGJib3gsIGFyZ3MpXG4gICAgfVxuICB9XG5cbiAgdmFyIGxpc3QgPSB0aGlzLmxpc3RlbmVyc1tldmVudF1cbiAgaWYoIWxpc3QpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIGZvcih2YXIgaSA9IDAsIGxlbiA9IGxpc3QubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZihsaXN0W2ldLmJib3guaW50ZXJzZWN0cyhiYm94KSkge1xuICAgICAgbGlzdFtpXS5mdW5jLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgfVxuICB9XG59XG4iLCJcclxudmFyIHdpbmRvdyA9IHdpbmRvdyB8fCB7fTtcclxudmFyIHNlbGYgPSBzZWxmIHx8IHt9O1xyXG5cclxuLy8gSGlnaC1yZXN1bHV0aW9uIGNvdW50ZXI6IGVtdWxhdGUgd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIGZvciBUSFJFRS5DTE9DS1xyXG5pZiggd2luZG93LnBlcmZvcm1hbmNlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdHdpbmRvdy5wZXJmb3JtYW5jZSA9IHsgfTtcclxuXHJcbn1cclxuXHJcbmlmKCB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRpbWUgPSBwcm9jZXNzLmhydGltZSgpO1xyXG5cdFx0cmV0dXJuICggdGltZVswXSArIHRpbWVbMV0gLyAxZTkgKSAqIDEwMDA7XHJcblxyXG5cdH07XHJcblxyXG59XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIExhcnJ5IEJhdHRsZSAvIGh0dHA6Ly9iYXRlcnUuY29tL25ld3NcclxuICovXHJcblxyXG52YXIgVEhSRUUgPSBUSFJFRSB8fCB7IFJFVklTSU9OOiAnNTYnIH07XHJcblxyXG5zZWxmLmNvbnNvbGUgPSBzZWxmLmNvbnNvbGUgfHwge1xyXG5cclxuXHRpbmZvOiBmdW5jdGlvbiAoKSB7fSxcclxuXHRsb2c6IGZ1bmN0aW9uICgpIHt9LFxyXG5cdGRlYnVnOiBmdW5jdGlvbiAoKSB7fSxcclxuXHR3YXJuOiBmdW5jdGlvbiAoKSB7fSxcclxuXHRlcnJvcjogZnVuY3Rpb24gKCkge31cclxuXHJcbn07XHJcblxyXG5zZWxmLkludDMyQXJyYXkgPSBzZWxmLkludDMyQXJyYXkgfHwgQXJyYXk7XHJcbnNlbGYuRmxvYXQzMkFycmF5ID0gc2VsZi5GbG9hdDMyQXJyYXkgfHwgQXJyYXk7XHJcblxyXG5TdHJpbmcucHJvdG90eXBlLnRyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW0gfHwgZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gdGhpcy5yZXBsYWNlKCAvXlxccyt8XFxzKyQvZywgJycgKTtcclxuXHJcbn07XHJcblxyXG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZG9jdW1lbnRjbG91ZC91bmRlcnNjb3JlL2Jsb2IvYmY2NTdiZTI0M2EwNzViNWU3MmFjYzhhODNlNmYxMmE1NjRkOGY1NS91bmRlcnNjb3JlLmpzI0w3NjdcclxuVEhSRUUuZXh0ZW5kID0gZnVuY3Rpb24gKCBvYmosIHNvdXJjZSApIHtcclxuXHJcblx0Ly8gRUNNQVNjcmlwdDUgY29tcGF0aWJpbGl0eSBiYXNlZCBvbjogaHR0cDovL3d3dy5uY3pvbmxpbmUubmV0L2Jsb2cvMjAxMi8xMi8xMS9hcmUteW91ci1taXhpbnMtZWNtYXNjcmlwdC01LWNvbXBhdGlibGUvXHJcblx0aWYgKCBPYmplY3Qua2V5cyApIHtcclxuXHJcblx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKCBzb3VyY2UgKTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgaWwgPSBrZXlzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHtcclxuXHJcblx0XHRcdHZhciBwcm9wID0ga2V5c1tpXTtcclxuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosIHByb3AsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHNvdXJjZSwgcHJvcCApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHZhciBzYWZlSGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcclxuXHJcblx0XHRmb3IgKCB2YXIgcHJvcCBpbiBzb3VyY2UgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHNhZmVIYXNPd25Qcm9wZXJ0eS5jYWxsKCBzb3VyY2UsIHByb3AgKSApIHtcclxuXHJcblx0XHRcdFx0b2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gb2JqO1xyXG5cclxufTtcclxuXHJcbi8vIGh0dHA6Ly9wYXVsaXJpc2guY29tLzIwMTEvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1hbmltYXRpbmcvXHJcbi8vIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcclxuXHJcbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXJcclxuLy8gZml4ZXMgZnJvbSBQYXVsIElyaXNoIGFuZCBUaW5vIFppamRlbFxyXG5cclxuKCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBsYXN0VGltZSA9IDA7XHJcblx0dmFyIHZlbmRvcnMgPSBbICdtcycsICdtb3onLCAnd2Via2l0JywgJ28nIF07XHJcblxyXG5cdGZvciAoIHZhciB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArKyB4ICkge1xyXG5cclxuXHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbIHZlbmRvcnNbIHggXSArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIF07XHJcblx0XHR3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbIHZlbmRvcnNbIHggXSArICdDYW5jZWxBbmltYXRpb25GcmFtZScgXSB8fCB3aW5kb3dbIHZlbmRvcnNbIHggXSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnIF07XHJcblxyXG5cdH1cclxuXHJcblx0aWYgKCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHR2YXIgY3VyclRpbWUgPSBEYXRlLm5vdygpLCB0aW1lVG9DYWxsID0gTWF0aC5tYXgoIDAsIDE2IC0gKCBjdXJyVGltZSAtIGxhc3RUaW1lICkgKTtcclxuXHRcdFx0dmFyIGlkID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkgeyBjYWxsYmFjayggY3VyclRpbWUgKyB0aW1lVG9DYWxsICk7IH0sIHRpbWVUb0NhbGwgKTtcclxuXHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XHJcblx0XHRcdHJldHVybiBpZDtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9XHJcblxyXG5cdHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbiAoIGlkICkgeyB3aW5kb3cuY2xlYXJUaW1lb3V0KCBpZCApIH07XHJcblxyXG59KCkgKTtcclxuXHJcbi8vIEdMIFNUQVRFIENPTlNUQU5UU1xyXG5cclxuVEhSRUUuQ3VsbEZhY2VOb25lID0gMDtcclxuVEhSRUUuQ3VsbEZhY2VCYWNrID0gMTtcclxuVEhSRUUuQ3VsbEZhY2VGcm9udCA9IDI7XHJcblRIUkVFLkN1bGxGYWNlRnJvbnRCYWNrID0gMztcclxuXHJcblRIUkVFLkZyb250RmFjZURpcmVjdGlvbkNXID0gMDtcclxuVEhSRUUuRnJvbnRGYWNlRGlyZWN0aW9uQ0NXID0gMTtcclxuXHJcbi8vIFNIQURPV0lORyBUWVBFU1xyXG5cclxuVEhSRUUuQmFzaWNTaGFkb3dNYXAgPSAwO1xyXG5USFJFRS5QQ0ZTaGFkb3dNYXAgPSAxO1xyXG5USFJFRS5QQ0ZTb2Z0U2hhZG93TWFwID0gMjtcclxuXHJcbi8vIE1BVEVSSUFMIENPTlNUQU5UU1xyXG5cclxuLy8gc2lkZVxyXG5cclxuVEhSRUUuRnJvbnRTaWRlID0gMDtcclxuVEhSRUUuQmFja1NpZGUgPSAxO1xyXG5USFJFRS5Eb3VibGVTaWRlID0gMjtcclxuXHJcbi8vIHNoYWRpbmdcclxuXHJcblRIUkVFLk5vU2hhZGluZyA9IDA7XHJcblRIUkVFLkZsYXRTaGFkaW5nID0gMTtcclxuVEhSRUUuU21vb3RoU2hhZGluZyA9IDI7XHJcblxyXG4vLyBjb2xvcnNcclxuXHJcblRIUkVFLk5vQ29sb3JzID0gMDtcclxuVEhSRUUuRmFjZUNvbG9ycyA9IDE7XHJcblRIUkVFLlZlcnRleENvbG9ycyA9IDI7XHJcblxyXG4vLyBibGVuZGluZyBtb2Rlc1xyXG5cclxuVEhSRUUuTm9CbGVuZGluZyA9IDA7XHJcblRIUkVFLk5vcm1hbEJsZW5kaW5nID0gMTtcclxuVEhSRUUuQWRkaXRpdmVCbGVuZGluZyA9IDI7XHJcblRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSAzO1xyXG5USFJFRS5NdWx0aXBseUJsZW5kaW5nID0gNDtcclxuVEhSRUUuQ3VzdG9tQmxlbmRpbmcgPSA1O1xyXG5cclxuLy8gY3VzdG9tIGJsZW5kaW5nIGVxdWF0aW9uc1xyXG4vLyAobnVtYmVycyBzdGFydCBmcm9tIDEwMCBub3QgdG8gY2xhc2ggd2l0aCBvdGhlclxyXG4vLyAgbWFwcGluZ3MgdG8gT3BlbkdMIGNvbnN0YW50cyBkZWZpbmVkIGluIFRleHR1cmUuanMpXHJcblxyXG5USFJFRS5BZGRFcXVhdGlvbiA9IDEwMDtcclxuVEhSRUUuU3VidHJhY3RFcXVhdGlvbiA9IDEwMTtcclxuVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSAxMDI7XHJcblxyXG4vLyBjdXN0b20gYmxlbmRpbmcgZGVzdGluYXRpb24gZmFjdG9yc1xyXG5cclxuVEhSRUUuWmVyb0ZhY3RvciA9IDIwMDtcclxuVEhSRUUuT25lRmFjdG9yID0gMjAxO1xyXG5USFJFRS5TcmNDb2xvckZhY3RvciA9IDIwMjtcclxuVEhSRUUuT25lTWludXNTcmNDb2xvckZhY3RvciA9IDIwMztcclxuVEhSRUUuU3JjQWxwaGFGYWN0b3IgPSAyMDQ7XHJcblRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcblRIUkVFLkRzdEFscGhhRmFjdG9yID0gMjA2O1xyXG5USFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yID0gMjA3O1xyXG5cclxuLy8gY3VzdG9tIGJsZW5kaW5nIHNvdXJjZSBmYWN0b3JzXHJcblxyXG4vL1RIUkVFLlplcm9GYWN0b3IgPSAyMDA7XHJcbi8vVEhSRUUuT25lRmFjdG9yID0gMjAxO1xyXG4vL1RIUkVFLlNyY0FscGhhRmFjdG9yID0gMjA0O1xyXG4vL1RIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3IgPSAyMDU7XHJcbi8vVEhSRUUuRHN0QWxwaGFGYWN0b3IgPSAyMDY7XHJcbi8vVEhSRUUuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcclxuVEhSRUUuRHN0Q29sb3JGYWN0b3IgPSAyMDg7XHJcblRIUkVFLk9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XHJcblRIUkVFLlNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XHJcblxyXG5cclxuLy8gVEVYVFVSRSBDT05TVEFOVFNcclxuXHJcblRIUkVFLk11bHRpcGx5T3BlcmF0aW9uID0gMDtcclxuVEhSRUUuTWl4T3BlcmF0aW9uID0gMTtcclxuVEhSRUUuQWRkT3BlcmF0aW9uID0gMjtcclxuXHJcbi8vIE1hcHBpbmcgbW9kZXNcclxuXHJcblRIUkVFLlVWTWFwcGluZyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuVEhSRUUuQ3ViZVJlZmxlY3Rpb25NYXBwaW5nID0gZnVuY3Rpb24gKCkge307XHJcblRIUkVFLkN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuVEhSRUUuU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcclxuVEhSRUUuU3BoZXJpY2FsUmVmcmFjdGlvbk1hcHBpbmcgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbi8vIFdyYXBwaW5nIG1vZGVzXHJcblxyXG5USFJFRS5SZXBlYXRXcmFwcGluZyA9IDEwMDA7XHJcblRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xyXG5USFJFRS5NaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcclxuXHJcbi8vIEZpbHRlcnNcclxuXHJcblRIUkVFLk5lYXJlc3RGaWx0ZXIgPSAxMDAzO1xyXG5USFJFRS5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IDEwMDQ7XHJcblRIUkVFLk5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA1O1xyXG5USFJFRS5MaW5lYXJGaWx0ZXIgPSAxMDA2O1xyXG5USFJFRS5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNztcclxuVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyID0gMTAwODtcclxuXHJcbi8vIERhdGEgdHlwZXNcclxuXHJcblRIUkVFLlVuc2lnbmVkQnl0ZVR5cGUgPSAxMDA5O1xyXG5USFJFRS5CeXRlVHlwZSA9IDEwMTA7XHJcblRIUkVFLlNob3J0VHlwZSA9IDEwMTE7XHJcblRIUkVFLlVuc2lnbmVkU2hvcnRUeXBlID0gMTAxMjtcclxuVEhSRUUuSW50VHlwZSA9IDEwMTM7XHJcblRIUkVFLlVuc2lnbmVkSW50VHlwZSA9IDEwMTQ7XHJcblRIUkVFLkZsb2F0VHlwZSA9IDEwMTU7XHJcblxyXG4vLyBQaXhlbCB0eXBlc1xyXG5cclxuLy9USFJFRS5VbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcclxuVEhSRUUuVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNjtcclxuVEhSRUUuVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxNztcclxuVEhSRUUuVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE4O1xyXG5cclxuLy8gUGl4ZWwgZm9ybWF0c1xyXG5cclxuVEhSRUUuQWxwaGFGb3JtYXQgPSAxMDE5O1xyXG5USFJFRS5SR0JGb3JtYXQgPSAxMDIwO1xyXG5USFJFRS5SR0JBRm9ybWF0ID0gMTAyMTtcclxuVEhSRUUuTHVtaW5hbmNlRm9ybWF0ID0gMTAyMjtcclxuVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgPSAxMDIzO1xyXG5cclxuLy8gQ29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcclxuXHJcblRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMTtcclxuVEhSRUUuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMjtcclxuVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gMjAwMztcclxuVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMjAwNDtcclxuXHJcbi8qXHJcbi8vIFBvdGVudGlhbCBmdXR1cmUgUFZSVEMgY29tcHJlc3NlZCB0ZXh0dXJlIGZvcm1hdHNcclxuVEhSRUUuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAwO1xyXG5USFJFRS5SR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDE7XHJcblRIUkVFLlJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDI7XHJcblRIUkVFLlJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDM7XHJcbiovXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkNvbG9yID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkgdGhpcy5zZXQoIHZhbHVlICk7XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuQ29sb3IucHJvdG90eXBlLCB7XHJcblxyXG5cdHI6IDEsIGc6IDEsIGI6IDEsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCB0eXBlb2YgdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRjYXNlIFwibnVtYmVyXCI6XHJcblx0XHRcdFx0dGhpcy5zZXRIZXgoIHZhbHVlICk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIFwic3RyaW5nXCI6XHJcblx0XHRcdFx0dGhpcy5zZXRTdHlsZSggdmFsdWUgKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEhleDogZnVuY3Rpb24gKCBoZXggKSB7XHJcblxyXG5cdFx0aGV4ID0gTWF0aC5mbG9vciggaGV4ICk7XHJcblxyXG5cdFx0dGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcclxuXHRcdHRoaXMuZyA9ICggaGV4ID4+IDggJiAyNTUgKSAvIDI1NTtcclxuXHRcdHRoaXMuYiA9ICggaGV4ICYgMjU1ICkgLyAyNTU7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFJHQjogZnVuY3Rpb24gKCByLCBnLCBiICkge1xyXG5cclxuXHRcdHRoaXMuciA9IHI7XHJcblx0XHR0aGlzLmcgPSBnO1xyXG5cdFx0dGhpcy5iID0gYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0SFNWOiBmdW5jdGlvbiAoIGgsIHMsIHYgKSB7XHJcblxyXG5cdFx0Y29uc29sZS5sb2coICdERVBSRUNBVEVEOiBDb2xvclxcJ3MgLnNldEhTVigpIHdpbGwgYmUgcmVtb3ZlZC4gVXNlIC5zZXRIU0woIGgsIHMsIGwgKSBpbnN0ZWFkLicgKTtcclxuXHRcdHJldHVybiB0aGlzLnNldEhTTChoLHMqdi8oKGg9KDItcykqdik8MT9oOjItaCksaC8yKTsgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20veHBhbnNpdmUvMTMzNzg5MFxyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRIU0w6IGZ1bmN0aW9uICggaCwgcywgbCApIHtcclxuXHJcblx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxyXG5cclxuXHRcdGlmICggcyA9PT0gMCApIHtcclxuXHJcblx0XHRcdHRoaXMuciA9IHRoaXMuZyA9IHRoaXMuYiA9IGw7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciBodWUycmdiID0gZnVuY3Rpb24gKCBwLCBxLCB0ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHQgPCAwICkgdCArPSAxO1xyXG5cdFx0XHRcdGlmICggdCA+IDEgKSB0IC09IDE7XHJcblx0XHRcdFx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xyXG5cdFx0XHRcdGlmICggdCA8IDEgLyAyICkgcmV0dXJuIHE7XHJcblx0XHRcdFx0aWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xyXG5cdFx0XHRcdHJldHVybiBwO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHZhciBwID0gbCA8PSAwLjUgPyBsICogKCAxICsgcyApIDogbCArIHMgLSAoIGwgKiBzICk7XHJcblx0XHRcdHZhciBxID0gKCAyICogbCApIC0gcDtcclxuXHJcblx0XHRcdHRoaXMuciA9IGh1ZTJyZ2IoIHEsIHAsIGggKyAxIC8gMyApO1xyXG5cdFx0XHR0aGlzLmcgPSBodWUycmdiKCBxLCBwLCBoICk7XHJcblx0XHRcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uICggc3R5bGUgKSB7XHJcblxyXG5cdFx0Ly8gcmdiKDI1NSwwLDApXHJcblxyXG5cdFx0aWYgKCAvXnJnYlxcKChcXGQrKSwoXFxkKyksKFxcZCspXFwpJC9pLnRlc3QoIHN0eWxlICkgKSB7XHJcblxyXG5cdFx0XHR2YXIgY29sb3IgPSAvXnJnYlxcKChcXGQrKSwoXFxkKyksKFxcZCspXFwpJC9pLmV4ZWMoIHN0eWxlICk7XHJcblxyXG5cdFx0XHR0aGlzLnIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDEgXSwgMTAgKSApIC8gMjU1O1xyXG5cdFx0XHR0aGlzLmcgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSApIC8gMjU1O1xyXG5cdFx0XHR0aGlzLmIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMjU1O1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJnYigxMDAlLDAlLDAlKVxyXG5cclxuXHRcdGlmICggL15yZ2JcXCgoXFxkKylcXCUsKFxcZCspXFwlLChcXGQrKVxcJVxcKSQvaS50ZXN0KCBzdHlsZSApICkge1xyXG5cclxuXHRcdFx0dmFyIGNvbG9yID0gL15yZ2JcXCgoXFxkKylcXCUsKFxcZCspXFwlLChcXGQrKVxcJVxcKSQvaS5leGVjKCBzdHlsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5yID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAxIF0sIDEwICkgKSAvIDEwMDtcclxuXHRcdFx0dGhpcy5nID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDEwMDtcclxuXHRcdFx0dGhpcy5iID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAzIF0sIDEwICkgKSAvIDEwMDtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyAjZmYwMDAwXHJcblxyXG5cdFx0aWYgKCAvXlxcIyhbMC05YS1mXXs2fSkkL2kudGVzdCggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdHZhciBjb2xvciA9IC9eXFwjKFswLTlhLWZdezZ9KSQvaS5leGVjKCBzdHlsZSApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRIZXgoIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxNiApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gI2YwMFxyXG5cclxuXHRcdGlmICggL15cXCMoWzAtOWEtZl0pKFswLTlhLWZdKShbMC05YS1mXSkkL2kudGVzdCggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdHZhciBjb2xvciA9IC9eXFwjKFswLTlhLWZdKShbMC05YS1mXSkoWzAtOWEtZl0pJC9pLmV4ZWMoIHN0eWxlICk7XHJcblxyXG5cdFx0XHR0aGlzLnNldEhleCggcGFyc2VJbnQoIGNvbG9yWyAxIF0gKyBjb2xvclsgMSBdICsgY29sb3JbIDIgXSArIGNvbG9yWyAyIF0gKyBjb2xvclsgMyBdICsgY29sb3JbIDMgXSwgMTYgKSApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlZFxyXG5cclxuXHRcdGlmICggL14oXFx3KykkL2kudGVzdCggc3R5bGUgKSApIHtcclxuXHJcblx0XHRcdHRoaXMuc2V0SGV4KCBUSFJFRS5Db2xvcktleXdvcmRzWyBzdHlsZSBdICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciA9IGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iID0gY29sb3IuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggY29sb3IgKSB7XHJcblxyXG5cdFx0dGhpcy5yID0gY29sb3IuciAqIGNvbG9yLnI7XHJcblx0XHR0aGlzLmcgPSBjb2xvci5nICogY29sb3IuZztcclxuXHRcdHRoaXMuYiA9IGNvbG9yLmIgKiBjb2xvci5iO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgPSBNYXRoLnNxcnQoIGNvbG9yLnIgKTtcclxuXHRcdHRoaXMuZyA9IE1hdGguc3FydCggY29sb3IuZyApO1xyXG5cdFx0dGhpcy5iID0gTWF0aC5zcXJ0KCBjb2xvci5iICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbnZlcnRHYW1tYVRvTGluZWFyOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XHJcblxyXG5cdFx0dGhpcy5yID0gciAqIHI7XHJcblx0XHR0aGlzLmcgPSBnICogZztcclxuXHRcdHRoaXMuYiA9IGIgKiBiO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb252ZXJ0TGluZWFyVG9HYW1tYTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuciA9IE1hdGguc3FydCggdGhpcy5yICk7XHJcblx0XHR0aGlzLmcgPSBNYXRoLnNxcnQoIHRoaXMuZyApO1xyXG5cdFx0dGhpcy5iID0gTWF0aC5zcXJ0KCB0aGlzLmIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0SGV4OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggdGhpcy5yICogMjU1ICkgPDwgMTYgXiAoIHRoaXMuZyAqIDI1NSApIDw8IDggXiAoIHRoaXMuYiAqIDI1NSApIDw8IDA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEhleFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoICcwMDAwMDAnICsgdGhpcy5nZXRIZXgoKS50b1N0cmluZyggMTYgKSApLnNsaWNlKCAtIDYgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0SFNMOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGhzbCA9IHsgaDogMCwgczogMCwgbDogMCB9O1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHQvLyBoLHMsbCByYW5nZXMgYXJlIGluIDAuMCAtIDEuMFxyXG5cclxuXHRcdFx0dmFyIHIgPSB0aGlzLnIsIGcgPSB0aGlzLmcsIGIgPSB0aGlzLmI7XHJcblxyXG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgoIHIsIGcsIGIgKTtcclxuXHRcdFx0dmFyIG1pbiA9IE1hdGgubWluKCByLCBnLCBiICk7XHJcblxyXG5cdFx0XHR2YXIgaHVlLCBzYXR1cmF0aW9uO1xyXG5cdFx0XHR2YXIgbGlnaHRuZXNzID0gKCBtaW4gKyBtYXggKSAvIDIuMDtcclxuXHJcblx0XHRcdGlmICggbWluID09PSBtYXggKSB7XHJcblxyXG5cdFx0XHRcdGh1ZSA9IDA7XHJcblx0XHRcdFx0c2F0dXJhdGlvbiA9IDA7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgZGVsdGEgPSBtYXggLSBtaW47XHJcblxyXG5cdFx0XHRcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRcdFx0c3dpdGNoICggbWF4ICkge1xyXG5cclxuXHRcdFx0XHRcdGNhc2UgcjogaHVlID0gKCBnIC0gYiApIC8gZGVsdGEgKyAoIGcgPCBiID8gNiA6IDAgKTsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XHJcblx0XHRcdFx0XHRjYXNlIGI6IGh1ZSA9ICggciAtIGcgKSAvIGRlbHRhICsgNDsgYnJlYWs7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aHVlIC89IDY7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRoc2wuaCA9IGh1ZTtcclxuXHRcdFx0aHNsLnMgPSBzYXR1cmF0aW9uO1xyXG5cdFx0XHRoc2wubCA9IGxpZ2h0bmVzcztcclxuXHJcblx0XHRcdHJldHVybiBoc2w7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAncmdiKCcgKyAoICggdGhpcy5yICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5nICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5iICogMjU1ICkgfCAwICkgKyAnKSc7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9mZnNldEhTTDogZnVuY3Rpb24gKCBoLCBzLCBsICkge1xyXG5cclxuXHRcdHZhciBoc2wgPSB0aGlzLmdldEhTTCgpO1xyXG5cclxuXHRcdGhzbC5oICs9IGg7IGhzbC5zICs9IHM7IGhzbC5sICs9IGw7XHJcblxyXG5cdFx0dGhpcy5zZXRIU0woIGhzbC5oLCBoc2wucywgaHNsLmwgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIGNvbG9yICkge1xyXG5cclxuXHRcdHRoaXMuciArPSBjb2xvci5yO1xyXG5cdFx0dGhpcy5nICs9IGNvbG9yLmc7XHJcblx0XHR0aGlzLmIgKz0gY29sb3IuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkQ29sb3JzOiBmdW5jdGlvbiAoIGNvbG9yMSwgY29sb3IyICkge1xyXG5cclxuXHRcdHRoaXMuciA9IGNvbG9yMS5yICsgY29sb3IyLnI7XHJcblx0XHR0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xyXG5cdFx0dGhpcy5iID0gY29sb3IxLmIgKyBjb2xvcjIuYjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy5yICs9IHM7XHJcblx0XHR0aGlzLmcgKz0gcztcclxuXHRcdHRoaXMuYiArPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseTogZnVuY3Rpb24gKCBjb2xvciApIHtcclxuXHJcblx0XHR0aGlzLnIgKj0gY29sb3IucjtcclxuXHRcdHRoaXMuZyAqPSBjb2xvci5nO1xyXG5cdFx0dGhpcy5iICo9IGNvbG9yLmI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy5yICo9IHM7XHJcblx0XHR0aGlzLmcgKj0gcztcclxuXHRcdHRoaXMuYiAqPSBzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwOiBmdW5jdGlvbiAoIGNvbG9yLCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnIgKz0gKCBjb2xvci5yIC0gdGhpcy5yICkgKiBhbHBoYTtcclxuXHRcdHRoaXMuZyArPSAoIGNvbG9yLmcgLSB0aGlzLmcgKSAqIGFscGhhO1xyXG5cdFx0dGhpcy5iICs9ICggY29sb3IuYiAtIHRoaXMuYiApICogYWxwaGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Db2xvcigpLnNldFJHQiggdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcblxyXG5USFJFRS5Db2xvcktleXdvcmRzID0geyBcImFsaWNlYmx1ZVwiOiAweEYwRjhGRiwgXCJhbnRpcXVld2hpdGVcIjogMHhGQUVCRDcsIFwiYXF1YVwiOiAweDAwRkZGRiwgXCJhcXVhbWFyaW5lXCI6IDB4N0ZGRkQ0LCBcImF6dXJlXCI6IDB4RjBGRkZGLFxyXG5cImJlaWdlXCI6IDB4RjVGNURDLCBcImJpc3F1ZVwiOiAweEZGRTRDNCwgXCJibGFja1wiOiAweDAwMDAwMCwgXCJibGFuY2hlZGFsbW9uZFwiOiAweEZGRUJDRCwgXCJibHVlXCI6IDB4MDAwMEZGLCBcImJsdWV2aW9sZXRcIjogMHg4QTJCRTIsXHJcblwiYnJvd25cIjogMHhBNTJBMkEsIFwiYnVybHl3b29kXCI6IDB4REVCODg3LCBcImNhZGV0Ymx1ZVwiOiAweDVGOUVBMCwgXCJjaGFydHJldXNlXCI6IDB4N0ZGRjAwLCBcImNob2NvbGF0ZVwiOiAweEQyNjkxRSwgXCJjb3JhbFwiOiAweEZGN0Y1MCxcclxuXCJjb3JuZmxvd2VyYmx1ZVwiOiAweDY0OTVFRCwgXCJjb3Juc2lsa1wiOiAweEZGRjhEQywgXCJjcmltc29uXCI6IDB4REMxNDNDLCBcImN5YW5cIjogMHgwMEZGRkYsIFwiZGFya2JsdWVcIjogMHgwMDAwOEIsIFwiZGFya2N5YW5cIjogMHgwMDhCOEIsXHJcblwiZGFya2dvbGRlbnJvZFwiOiAweEI4ODYwQiwgXCJkYXJrZ3JheVwiOiAweEE5QTlBOSwgXCJkYXJrZ3JlZW5cIjogMHgwMDY0MDAsIFwiZGFya2dyZXlcIjogMHhBOUE5QTksIFwiZGFya2toYWtpXCI6IDB4QkRCNzZCLCBcImRhcmttYWdlbnRhXCI6IDB4OEIwMDhCLFxyXG5cImRhcmtvbGl2ZWdyZWVuXCI6IDB4NTU2QjJGLCBcImRhcmtvcmFuZ2VcIjogMHhGRjhDMDAsIFwiZGFya29yY2hpZFwiOiAweDk5MzJDQywgXCJkYXJrcmVkXCI6IDB4OEIwMDAwLCBcImRhcmtzYWxtb25cIjogMHhFOTk2N0EsIFwiZGFya3NlYWdyZWVuXCI6IDB4OEZCQzhGLFxyXG5cImRhcmtzbGF0ZWJsdWVcIjogMHg0ODNEOEIsIFwiZGFya3NsYXRlZ3JheVwiOiAweDJGNEY0RiwgXCJkYXJrc2xhdGVncmV5XCI6IDB4MkY0RjRGLCBcImRhcmt0dXJxdW9pc2VcIjogMHgwMENFRDEsIFwiZGFya3Zpb2xldFwiOiAweDk0MDBEMyxcclxuXCJkZWVwcGlua1wiOiAweEZGMTQ5MywgXCJkZWVwc2t5Ymx1ZVwiOiAweDAwQkZGRiwgXCJkaW1ncmF5XCI6IDB4Njk2OTY5LCBcImRpbWdyZXlcIjogMHg2OTY5NjksIFwiZG9kZ2VyYmx1ZVwiOiAweDFFOTBGRiwgXCJmaXJlYnJpY2tcIjogMHhCMjIyMjIsXHJcblwiZmxvcmFsd2hpdGVcIjogMHhGRkZBRjAsIFwiZm9yZXN0Z3JlZW5cIjogMHgyMjhCMjIsIFwiZnVjaHNpYVwiOiAweEZGMDBGRiwgXCJnYWluc2Jvcm9cIjogMHhEQ0RDREMsIFwiZ2hvc3R3aGl0ZVwiOiAweEY4RjhGRiwgXCJnb2xkXCI6IDB4RkZENzAwLFxyXG5cImdvbGRlbnJvZFwiOiAweERBQTUyMCwgXCJncmF5XCI6IDB4ODA4MDgwLCBcImdyZWVuXCI6IDB4MDA4MDAwLCBcImdyZWVueWVsbG93XCI6IDB4QURGRjJGLCBcImdyZXlcIjogMHg4MDgwODAsIFwiaG9uZXlkZXdcIjogMHhGMEZGRjAsIFwiaG90cGlua1wiOiAweEZGNjlCNCxcclxuXCJpbmRpYW5yZWRcIjogMHhDRDVDNUMsIFwiaW5kaWdvXCI6IDB4NEIwMDgyLCBcIml2b3J5XCI6IDB4RkZGRkYwLCBcImtoYWtpXCI6IDB4RjBFNjhDLCBcImxhdmVuZGVyXCI6IDB4RTZFNkZBLCBcImxhdmVuZGVyYmx1c2hcIjogMHhGRkYwRjUsIFwibGF3bmdyZWVuXCI6IDB4N0NGQzAwLFxyXG5cImxlbW9uY2hpZmZvblwiOiAweEZGRkFDRCwgXCJsaWdodGJsdWVcIjogMHhBREQ4RTYsIFwibGlnaHRjb3JhbFwiOiAweEYwODA4MCwgXCJsaWdodGN5YW5cIjogMHhFMEZGRkYsIFwibGlnaHRnb2xkZW5yb2R5ZWxsb3dcIjogMHhGQUZBRDIsIFwibGlnaHRncmF5XCI6IDB4RDNEM0QzLFxyXG5cImxpZ2h0Z3JlZW5cIjogMHg5MEVFOTAsIFwibGlnaHRncmV5XCI6IDB4RDNEM0QzLCBcImxpZ2h0cGlua1wiOiAweEZGQjZDMSwgXCJsaWdodHNhbG1vblwiOiAweEZGQTA3QSwgXCJsaWdodHNlYWdyZWVuXCI6IDB4MjBCMkFBLCBcImxpZ2h0c2t5Ymx1ZVwiOiAweDg3Q0VGQSxcclxuXCJsaWdodHNsYXRlZ3JheVwiOiAweDc3ODg5OSwgXCJsaWdodHNsYXRlZ3JleVwiOiAweDc3ODg5OSwgXCJsaWdodHN0ZWVsYmx1ZVwiOiAweEIwQzRERSwgXCJsaWdodHllbGxvd1wiOiAweEZGRkZFMCwgXCJsaW1lXCI6IDB4MDBGRjAwLCBcImxpbWVncmVlblwiOiAweDMyQ0QzMixcclxuXCJsaW5lblwiOiAweEZBRjBFNiwgXCJtYWdlbnRhXCI6IDB4RkYwMEZGLCBcIm1hcm9vblwiOiAweDgwMDAwMCwgXCJtZWRpdW1hcXVhbWFyaW5lXCI6IDB4NjZDREFBLCBcIm1lZGl1bWJsdWVcIjogMHgwMDAwQ0QsIFwibWVkaXVtb3JjaGlkXCI6IDB4QkE1NUQzLFxyXG5cIm1lZGl1bXB1cnBsZVwiOiAweDkzNzBEQiwgXCJtZWRpdW1zZWFncmVlblwiOiAweDNDQjM3MSwgXCJtZWRpdW1zbGF0ZWJsdWVcIjogMHg3QjY4RUUsIFwibWVkaXVtc3ByaW5nZ3JlZW5cIjogMHgwMEZBOUEsIFwibWVkaXVtdHVycXVvaXNlXCI6IDB4NDhEMUNDLFxyXG5cIm1lZGl1bXZpb2xldHJlZFwiOiAweEM3MTU4NSwgXCJtaWRuaWdodGJsdWVcIjogMHgxOTE5NzAsIFwibWludGNyZWFtXCI6IDB4RjVGRkZBLCBcIm1pc3R5cm9zZVwiOiAweEZGRTRFMSwgXCJtb2NjYXNpblwiOiAweEZGRTRCNSwgXCJuYXZham93aGl0ZVwiOiAweEZGREVBRCxcclxuXCJuYXZ5XCI6IDB4MDAwMDgwLCBcIm9sZGxhY2VcIjogMHhGREY1RTYsIFwib2xpdmVcIjogMHg4MDgwMDAsIFwib2xpdmVkcmFiXCI6IDB4NkI4RTIzLCBcIm9yYW5nZVwiOiAweEZGQTUwMCwgXCJvcmFuZ2VyZWRcIjogMHhGRjQ1MDAsIFwib3JjaGlkXCI6IDB4REE3MEQ2LFxyXG5cInBhbGVnb2xkZW5yb2RcIjogMHhFRUU4QUEsIFwicGFsZWdyZWVuXCI6IDB4OThGQjk4LCBcInBhbGV0dXJxdW9pc2VcIjogMHhBRkVFRUUsIFwicGFsZXZpb2xldHJlZFwiOiAweERCNzA5MywgXCJwYXBheWF3aGlwXCI6IDB4RkZFRkQ1LCBcInBlYWNocHVmZlwiOiAweEZGREFCOSxcclxuXCJwZXJ1XCI6IDB4Q0Q4NTNGLCBcInBpbmtcIjogMHhGRkMwQ0IsIFwicGx1bVwiOiAweEREQTBERCwgXCJwb3dkZXJibHVlXCI6IDB4QjBFMEU2LCBcInB1cnBsZVwiOiAweDgwMDA4MCwgXCJyZWRcIjogMHhGRjAwMDAsIFwicm9zeWJyb3duXCI6IDB4QkM4RjhGLFxyXG5cInJveWFsYmx1ZVwiOiAweDQxNjlFMSwgXCJzYWRkbGVicm93blwiOiAweDhCNDUxMywgXCJzYWxtb25cIjogMHhGQTgwNzIsIFwic2FuZHlicm93blwiOiAweEY0QTQ2MCwgXCJzZWFncmVlblwiOiAweDJFOEI1NywgXCJzZWFzaGVsbFwiOiAweEZGRjVFRSxcclxuXCJzaWVubmFcIjogMHhBMDUyMkQsIFwic2lsdmVyXCI6IDB4QzBDMEMwLCBcInNreWJsdWVcIjogMHg4N0NFRUIsIFwic2xhdGVibHVlXCI6IDB4NkE1QUNELCBcInNsYXRlZ3JheVwiOiAweDcwODA5MCwgXCJzbGF0ZWdyZXlcIjogMHg3MDgwOTAsIFwic25vd1wiOiAweEZGRkFGQSxcclxuXCJzcHJpbmdncmVlblwiOiAweDAwRkY3RiwgXCJzdGVlbGJsdWVcIjogMHg0NjgyQjQsIFwidGFuXCI6IDB4RDJCNDhDLCBcInRlYWxcIjogMHgwMDgwODAsIFwidGhpc3RsZVwiOiAweEQ4QkZEOCwgXCJ0b21hdG9cIjogMHhGRjYzNDcsIFwidHVycXVvaXNlXCI6IDB4NDBFMEQwLFxyXG5cInZpb2xldFwiOiAweEVFODJFRSwgXCJ3aGVhdFwiOiAweEY1REVCMywgXCJ3aGl0ZVwiOiAweEZGRkZGRiwgXCJ3aGl0ZXNtb2tlXCI6IDB4RjVGNUY1LCBcInllbGxvd1wiOiAweEZGRkYwMCwgXCJ5ZWxsb3dncmVlblwiOiAweDlBQ0QzMiB9O1xyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLlF1YXRlcm5pb24gPSBmdW5jdGlvbiggeCwgeSwgeiwgdyApIHtcclxuXHJcblx0dGhpcy54ID0geCB8fCAwO1xyXG5cdHRoaXMueSA9IHkgfHwgMDtcclxuXHR0aGlzLnogPSB6IHx8IDA7XHJcblx0dGhpcy53ID0gKCB3ICE9PSB1bmRlZmluZWQgKSA/IHcgOiAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuUXVhdGVybmlvbi5wcm90b3R5cGUsIHtcclxuXHJcblx0c2V0OiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0geDtcclxuXHRcdHRoaXMueSA9IHk7XHJcblx0XHR0aGlzLnogPSB6O1xyXG5cdFx0dGhpcy53ID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHEueDtcclxuXHRcdHRoaXMueSA9IHEueTtcclxuXHRcdHRoaXMueiA9IHEuejtcclxuXHRcdHRoaXMudyA9IHEudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIHYsIG9yZGVyICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cubWF0aHdvcmtzLmNvbS9tYXRsYWJjZW50cmFsL2ZpbGVleGNoYW5nZS9cclxuXHRcdC8vIFx0MjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvXHJcblx0XHQvL1x0Y29udGVudC9TcGluQ2FsYy5tXHJcblxyXG5cdFx0dmFyIGMxID0gTWF0aC5jb3MoIHYueCAvIDIgKTtcclxuXHRcdHZhciBjMiA9IE1hdGguY29zKCB2LnkgLyAyICk7XHJcblx0XHR2YXIgYzMgPSBNYXRoLmNvcyggdi56IC8gMiApO1xyXG5cdFx0dmFyIHMxID0gTWF0aC5zaW4oIHYueCAvIDIgKTtcclxuXHRcdHZhciBzMiA9IE1hdGguc2luKCB2LnkgLyAyICk7XHJcblx0XHR2YXIgczMgPSBNYXRoLnNpbiggdi56IC8gMiApO1xyXG5cclxuXHRcdGlmICggb3JkZXIgPT09IHVuZGVmaW5lZCB8fCBvcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBzMSAqIGMyICogYzMgKyBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMueSA9IGMxICogczIgKiBjMyAtIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy56ID0gYzEgKiBjMiAqIHMzICsgczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLncgPSBjMSAqIGMyICogYzMgLSBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLnkgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy53ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy55ID0gYzEgKiBzMiAqIGMzICsgczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLnogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMudyA9IGMxICogYzIgKiBjMyAtIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBzMSAqIGMyICogYzMgLSBjMSAqIHMyICogczM7XHJcblx0XHRcdHRoaXMueSA9IGMxICogczIgKiBjMyArIHMxICogYzIgKiBzMztcclxuXHRcdFx0dGhpcy56ID0gYzEgKiBjMiAqIHMzIC0gczEgKiBzMiAqIGMzO1xyXG5cdFx0XHR0aGlzLncgPSBjMSAqIGMyICogYzMgKyBzMSAqIHMyICogczM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xyXG5cdFx0XHR0aGlzLnkgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XHJcblx0XHRcdHRoaXMueiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcclxuXHRcdFx0dGhpcy53ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHMxICogYzIgKiBjMyAtIGMxICogczIgKiBzMztcclxuXHRcdFx0dGhpcy55ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xyXG5cdFx0XHR0aGlzLnogPSBjMSAqIGMyICogczMgKyBzMSAqIHMyICogYzM7XHJcblx0XHRcdHRoaXMudyA9IGMxICogYzIgKiBjMyArIHMxICogczIgKiBzMztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0Ly8gZnJvbSBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvYW5nbGVUb1F1YXRlcm5pb24vaW5kZXguaHRtXHJcblx0XHQvLyBheGlzIGhhdmUgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuXHRcdHZhciBoYWxmQW5nbGUgPSBhbmdsZSAvIDIsXHJcblx0XHRcdHMgPSBNYXRoLnNpbiggaGFsZkFuZ2xlICk7XHJcblxyXG5cdFx0dGhpcy54ID0gYXhpcy54ICogcztcclxuXHRcdHRoaXMueSA9IGF4aXMueSAqIHM7XHJcblx0XHR0aGlzLnogPSBheGlzLnogKiBzO1xyXG5cdFx0dGhpcy53ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tUm90YXRpb25NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBodHRwOi8vd3d3LmV1Y2xpZGVhbnNwYWNlLmNvbS9tYXRocy9nZW9tZXRyeS9yb3RhdGlvbnMvY29udmVyc2lvbnMvbWF0cml4VG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxyXG5cclxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG5cdFx0dmFyIHRlID0gbS5lbGVtZW50cyxcclxuXHJcblx0XHRcdG0xMSA9IHRlWzBdLCBtMTIgPSB0ZVs0XSwgbTEzID0gdGVbOF0sXHJcblx0XHRcdG0yMSA9IHRlWzFdLCBtMjIgPSB0ZVs1XSwgbTIzID0gdGVbOV0sXHJcblx0XHRcdG0zMSA9IHRlWzJdLCBtMzIgPSB0ZVs2XSwgbTMzID0gdGVbMTBdLFxyXG5cclxuXHRcdFx0dHJhY2UgPSBtMTEgKyBtMjIgKyBtMzMsXHJcblx0XHRcdHM7XHJcblxyXG5cdFx0aWYgKCB0cmFjZSA+IDAgKSB7XHJcblxyXG5cdFx0XHRzID0gMC41IC8gTWF0aC5zcXJ0KCB0cmFjZSArIDEuMCApO1xyXG5cclxuXHRcdFx0dGhpcy53ID0gMC4yNSAvIHM7XHJcblx0XHRcdHRoaXMueCA9ICggbTMyIC0gbTIzICkgKiBzO1xyXG5cdFx0XHR0aGlzLnkgPSAoIG0xMyAtIG0zMSApICogcztcclxuXHRcdFx0dGhpcy56ID0gKCBtMjEgLSBtMTIgKSAqIHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcclxuXHJcblx0XHRcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0xMSAtIG0yMiAtIG0zMyApO1xyXG5cclxuXHRcdFx0dGhpcy53ID0gKG0zMiAtIG0yMyApIC8gcztcclxuXHRcdFx0dGhpcy54ID0gMC4yNSAqIHM7XHJcblx0XHRcdHRoaXMueSA9IChtMTIgKyBtMjEgKSAvIHM7XHJcblx0XHRcdHRoaXMueiA9IChtMTMgKyBtMzEgKSAvIHM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xyXG5cclxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTIyIC0gbTExIC0gbTMzICk7XHJcblxyXG5cdFx0XHR0aGlzLncgPSAobTEzIC0gbTMxICkgLyBzO1xyXG5cdFx0XHR0aGlzLnggPSAobTEyICsgbTIxICkgLyBzO1xyXG5cdFx0XHR0aGlzLnkgPSAwLjI1ICogcztcclxuXHRcdFx0dGhpcy56ID0gKG0yMyArIG0zMiApIC8gcztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cyA9IDIuMCAqIE1hdGguc3FydCggMS4wICsgbTMzIC0gbTExIC0gbTIyICk7XHJcblxyXG5cdFx0XHR0aGlzLncgPSAoIG0yMSAtIG0xMiApIC8gcztcclxuXHRcdFx0dGhpcy54ID0gKCBtMTMgKyBtMzEgKSAvIHM7XHJcblx0XHRcdHRoaXMueSA9ICggbTIzICsgbTMyICkgLyBzO1xyXG5cdFx0XHR0aGlzLnogPSAwLjI1ICogcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludmVyc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmNvbmp1Z2F0ZSgpLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb25qdWdhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnggKj0gLTE7XHJcblx0XHR0aGlzLnkgKj0gLTE7XHJcblx0XHR0aGlzLnogKj0gLTE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBsID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRpZiAoIGwgPT09IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHR0aGlzLnkgPSAwO1xyXG5cdFx0XHR0aGlzLnogPSAwO1xyXG5cdFx0XHR0aGlzLncgPSAxO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRsID0gMSAvIGw7XHJcblxyXG5cdFx0XHR0aGlzLnggPSB0aGlzLnggKiBsO1xyXG5cdFx0XHR0aGlzLnkgPSB0aGlzLnkgKiBsO1xyXG5cdFx0XHR0aGlzLnogPSB0aGlzLnogKiBsO1xyXG5cdFx0XHR0aGlzLncgPSB0aGlzLncgKiBsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcclxuXHJcblx0XHRpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IFF1YXRlcm5pb25cXCdzIC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5UXVhdGVybmlvbnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cclxuXHJcblx0XHR2YXIgcWF4ID0gYS54LCBxYXkgPSBhLnksIHFheiA9IGEueiwgcWF3ID0gYS53O1xyXG5cdFx0dmFyIHFieCA9IGIueCwgcWJ5ID0gYi55LCBxYnogPSBiLnosIHFidyA9IGIudztcclxuXHJcblx0XHR0aGlzLnggPSBxYXggKiBxYncgKyBxYXcgKiBxYnggKyBxYXkgKiBxYnogLSBxYXogKiBxYnk7XHJcblx0XHR0aGlzLnkgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XHJcblx0XHR0aGlzLnogPSBxYXogKiBxYncgKyBxYXcgKiBxYnogKyBxYXggKiBxYnkgLSBxYXkgKiBxYng7XHJcblx0XHR0aGlzLncgPSBxYXcgKiBxYncgLSBxYXggKiBxYnggLSBxYXkgKiBxYnkgLSBxYXogKiBxYno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogUXVhdGVybmlvblxcJ3MgLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBpcyBub3cgdmVjdG9yLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2xlcnA6IGZ1bmN0aW9uICggcWIsIHQgKSB7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XHJcblxyXG5cdFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cclxuXHJcblx0XHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLncgKyB4ICogcWIueCArIHkgKiBxYi55ICsgeiAqIHFiLno7XHJcblxyXG5cdFx0aWYgKCBjb3NIYWxmVGhldGEgPCAwICkge1xyXG5cclxuXHRcdFx0dGhpcy53ID0gLXFiLnc7XHJcblx0XHRcdHRoaXMueCA9IC1xYi54O1xyXG5cdFx0XHR0aGlzLnkgPSAtcWIueTtcclxuXHRcdFx0dGhpcy56ID0gLXFiLno7XHJcblxyXG5cdFx0XHRjb3NIYWxmVGhldGEgPSAtY29zSGFsZlRoZXRhO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmNvcHkoIHFiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggY29zSGFsZlRoZXRhID49IDEuMCApIHtcclxuXHJcblx0XHRcdHRoaXMudyA9IHc7XHJcblx0XHRcdHRoaXMueCA9IHg7XHJcblx0XHRcdHRoaXMueSA9IHk7XHJcblx0XHRcdHRoaXMueiA9IHo7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhhbGZUaGV0YSA9IE1hdGguYWNvcyggY29zSGFsZlRoZXRhICk7XHJcblx0XHR2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGEgKTtcclxuXHJcblx0XHRpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xyXG5cclxuXHRcdFx0dGhpcy53ID0gMC41ICogKCB3ICsgdGhpcy53ICk7XHJcblx0XHRcdHRoaXMueCA9IDAuNSAqICggeCArIHRoaXMueCApO1xyXG5cdFx0XHR0aGlzLnkgPSAwLjUgKiAoIHkgKyB0aGlzLnkgKTtcclxuXHRcdFx0dGhpcy56ID0gMC41ICogKCB6ICsgdGhpcy56ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJhdGlvQSA9IE1hdGguc2luKCAoIDEgLSB0ICkgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YSxcclxuXHRcdHJhdGlvQiA9IE1hdGguc2luKCB0ICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGE7XHJcblxyXG5cdFx0dGhpcy53ID0gKCB3ICogcmF0aW9BICsgdGhpcy53ICogcmF0aW9CICk7XHJcblx0XHR0aGlzLnggPSAoIHggKiByYXRpb0EgKyB0aGlzLnggKiByYXRpb0IgKTtcclxuXHRcdHRoaXMueSA9ICggeSAqIHJhdGlvQSArIHRoaXMueSAqIHJhdGlvQiApO1xyXG5cdFx0dGhpcy56ID0gKCB6ICogcmF0aW9BICsgdGhpcy56ICogcmF0aW9CICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICYmICggdi53ID09PSB0aGlzLncgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuUXVhdGVybmlvbiggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuXHJcblRIUkVFLlF1YXRlcm5pb24uc2xlcnAgPSBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XHJcblxyXG5cdHJldHVybiBxbS5jb3B5KCBxYSApLnNsZXJwKCBxYiwgdCApO1xyXG5cclxufVxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjIgPSBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuZXh0ZW5kKCBUSFJFRS5WZWN0b3IyLnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WDogZnVuY3Rpb24gKCB4ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFk6IGZ1bmN0aW9uICggeSApIHtcclxuXHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHJcblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCBcImluZGV4IGlzIG91dCBvZiByYW5nZTogXCIgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiByZXR1cm4gdGhpcy54O1xyXG5cdFx0XHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB2Lng7XHJcblx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogVmVjdG9yMlxcJ3MgLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9IHM7XHJcblx0XHR0aGlzLnkgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBWZWN0b3IyXFwncyAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAtPSB2Lng7XHJcblx0XHR0aGlzLnkgLT0gdi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS54IC0gYi54O1xyXG5cdFx0dGhpcy55ID0gYS55IC0gYi55O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHRoaXMueCAqPSBzO1xyXG5cdFx0dGhpcy55ICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdGlmICggcyAhPT0gMCApIHtcclxuXHJcblx0XHRcdHRoaXMueCAvPSBzO1xyXG5cdFx0XHR0aGlzLnkgLz0gcztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5zZXQoIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy54ID4gdi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gdi54O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueSA+IHYueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IHYueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy54IDwgdi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gdi54O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueSA8IHYueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IHYueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdC8vIFRoaXMgZnVuY3Rpb24gYXNzdW1lcyBtaW4gPCBtYXgsIGlmIHRoaXMgYXNzdW1wdGlvbiBpc24ndCB0cnVlIGl0IHdpbGwgbm90IG9wZXJhdGUgY29ycmVjdGx5XHJcblxyXG5cdFx0aWYgKCB0aGlzLnggPCBtaW4ueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IG1pbi54O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueCA+IG1heC54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gbWF4Lng7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy55IDwgbWluLnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSBtaW4ueTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnkgPiBtYXgueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IG1heC55O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bmVnYXRlOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggLSAxICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueTtcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueTtcclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGwgKSB7XHJcblxyXG5cdFx0dmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0aWYgKCBvbGRMZW5ndGggIT09IDAgJiYgbCAhPT0gb2xkTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dGhpcy5tdWx0aXBseVNjYWxhciggbCAvIG9sZExlbmd0aCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xyXG5cclxuXHRcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XHJcblx0XHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBbIHRoaXMueCwgdGhpcy55IF07XHJcblx0XHRcclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMiggdGhpcy54LCB0aGlzLnkgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciAqa2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cclxuICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cclxuICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuVmVjdG9yMyA9IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0dGhpcy54ID0geCB8fCAwO1xyXG5cdHRoaXMueSA9IHkgfHwgMDtcclxuXHR0aGlzLnogPSB6IHx8IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuZXh0ZW5kKCBUSFJFRS5WZWN0b3IzLnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cdFx0dGhpcy55ID0geTtcclxuXHRcdHRoaXMueiA9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XHJcblxyXG5cdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xyXG5cclxuXHRcdHRoaXMueiA9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCwgdmFsdWUgKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAxOiB0aGlzLnkgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoIFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIiArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXggKSB7XHJcblxyXG5cdFx0c3dpdGNoICggaW5kZXggKSB7XHJcblxyXG5cdFx0XHRjYXNlIDA6IHJldHVybiB0aGlzLng7XHJcblx0XHRcdGNhc2UgMTogcmV0dXJuIHRoaXMueTtcclxuXHRcdFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xyXG5cdFx0XHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoIFwiaW5kZXggaXMgb3V0IG9mIHJhbmdlOiBcIiArIGluZGV4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gdi54O1xyXG5cdFx0dGhpcy55ID0gdi55O1xyXG5cdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGQ6IGZ1bmN0aW9uICggdiwgdyApIHtcclxuXHJcblx0XHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IFZlY3RvcjNcXCdzIC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZFZlY3RvcnMoIHYsIHcgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy54ICs9IHYueDtcclxuXHRcdHRoaXMueSArPSB2Lnk7XHJcblx0XHR0aGlzLnogKz0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gcztcclxuXHRcdHRoaXMueSArPSBzO1xyXG5cdFx0dGhpcy56ICs9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggKyBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgKyBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogKyBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YjogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogVmVjdG9yM1xcJ3MgLnN1YigpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLnN1YlZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuc3ViVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggLT0gdi54O1xyXG5cdFx0dGhpcy55IC09IHYueTtcclxuXHRcdHRoaXMueiAtPSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBWZWN0b3IzXFwncyAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAqPSB2Lng7XHJcblx0XHR0aGlzLnkgKj0gdi55O1xyXG5cdFx0dGhpcy56ICo9IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggKj0gcztcclxuXHRcdHRoaXMueSAqPSBzO1xyXG5cdFx0dGhpcy56ICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5VmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCAqIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSAqIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiAqIGIuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLng7XHJcblx0XHR2YXIgeSA9IHRoaXMueTtcclxuXHRcdHZhciB6ID0gdGhpcy56O1xyXG5cclxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWzBdICogeCArIGVbM10gKiB5ICsgZVs2XSAqIHo7XHJcblx0XHR0aGlzLnkgPSBlWzFdICogeCArIGVbNF0gKiB5ICsgZVs3XSAqIHo7XHJcblx0XHR0aGlzLnogPSBlWzJdICogeCArIGVbNV0gKiB5ICsgZVs4XSAqIHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGlucHV0OiBUSFJFRS5NYXRyaXg0IGFmZmluZSBtYXRyaXhcclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gICogeiArIGVbMTJdO1xyXG5cdFx0dGhpcy55ID0gZVsxXSAqIHggKyBlWzVdICogeSArIGVbOV0gICogeiArIGVbMTNdO1xyXG5cdFx0dGhpcy56ID0gZVsyXSAqIHggKyBlWzZdICogeSArIGVbMTBdICogeiArIGVbMTRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhcHBseVByb2plY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBwcm9qZWN0aW9uIG1hdHJpeFxyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cclxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHRcdHZhciBkID0gMSAvICggZVszXSAqIHggKyBlWzddICogeSArIGVbMTFdICogeiArIGVbMTVdICk7IC8vIHBlcnNwZWN0aXZlIGRpdmlkZVxyXG5cclxuXHRcdHRoaXMueCA9ICggZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gICogeiArIGVbMTJdICkgKiBkO1xyXG5cdFx0dGhpcy55ID0gKCBlWzFdICogeCArIGVbNV0gKiB5ICsgZVs5XSAgKiB6ICsgZVsxM10gKSAqIGQ7XHJcblx0XHR0aGlzLnogPSAoIGVbMl0gKiB4ICsgZVs2XSAqIHkgKyBlWzEwXSAqIHogKyBlWzE0XSApICogZDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlRdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0dmFyIHggPSB0aGlzLng7XHJcblx0XHR2YXIgeSA9IHRoaXMueTtcclxuXHRcdHZhciB6ID0gdGhpcy56O1xyXG5cclxuXHRcdHZhciBxeCA9IHEueDtcclxuXHRcdHZhciBxeSA9IHEueTtcclxuXHRcdHZhciBxeiA9IHEuejtcclxuXHRcdHZhciBxdyA9IHEudztcclxuXHJcblx0XHQvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY3RvclxyXG5cclxuXHRcdHZhciBpeCA9ICBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XHJcblx0XHR2YXIgaXkgPSAgcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xyXG5cdFx0dmFyIGl6ID0gIHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcclxuXHRcdHZhciBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHo7XHJcblxyXG5cdFx0Ly8gY2FsY3VsYXRlIHJlc3VsdCAqIGludmVyc2UgcXVhdFxyXG5cclxuXHRcdHRoaXMueCA9IGl4ICogcXcgKyBpdyAqIC1xeCArIGl5ICogLXF6IC0gaXogKiAtcXk7XHJcblx0XHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtcXkgKyBpeiAqIC1xeCAtIGl4ICogLXF6O1xyXG5cdFx0dGhpcy56ID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlFdWxlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxMSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdiwgZXVsZXJPcmRlciApIHtcclxuXHJcblx0XHRcdHZhciBxdWF0ZXJuaW9uID0gcTEuc2V0RnJvbUV1bGVyKCB2LCBldWxlck9yZGVyICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBxMSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0XHR2YXIgcXVhdGVybmlvbiA9IHExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XHJcblxyXG5cdFx0XHR0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XHJcblx0XHQvLyB2ZWN0b3IgaW50ZXJwcmV0ZWQgYXMgYSBkaXJlY3Rpb25cclxuXHJcblx0XHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcclxuXHJcblx0XHR2YXIgZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGhpcy54ID0gZVswXSAqIHggKyBlWzRdICogeSArIGVbOF0gICogejtcclxuXHRcdHRoaXMueSA9IGVbMV0gKiB4ICsgZVs1XSAqIHkgKyBlWzldICAqIHo7XHJcblx0XHR0aGlzLnogPSBlWzJdICogeCArIGVbNl0gKiB5ICsgZVsxMF0gKiB6O1xyXG5cclxuXHRcdHRoaXMubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCAvPSB2Lng7XHJcblx0XHR0aGlzLnkgLz0gdi55O1xyXG5cdFx0dGhpcy56IC89IHYuejtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0aWYgKCBzICE9PSAwICkge1xyXG5cclxuXHRcdFx0dGhpcy54IC89IHM7XHJcblx0XHRcdHRoaXMueSAvPSBzO1xyXG5cdFx0XHR0aGlzLnogLz0gcztcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gMDtcclxuXHRcdFx0dGhpcy55ID0gMDtcclxuXHRcdFx0dGhpcy56ID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1pbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy54ID4gdi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gdi54O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueSA+IHYueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IHYueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnogPiB2LnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSB2Lno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56IDwgdi56ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IG1pbi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gbWluLng7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBtYXgueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IG1pbi55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gbWF4Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56IDwgbWluLnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSBtaW4uejtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnogPiBtYXgueiApIHtcclxuXHJcblx0XHRcdHRoaXMueiA9IG1heC56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIC0gMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56O1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGwgKSB7XHJcblxyXG5cdFx0dmFyIG9sZExlbmd0aCA9IHRoaXMubGVuZ3RoKCk7XHJcblxyXG5cdFx0aWYgKCBvbGRMZW5ndGggIT09IDAgJiYgbCAhPT0gb2xkTGVuZ3RoICApIHtcclxuXHJcblx0XHRcdHRoaXMubXVsdGlwbHlTY2FsYXIoIGwgLyBvbGRMZW5ndGggKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xyXG5cdFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueiArPSAoIHYueiAtIHRoaXMueiApICogYWxwaGE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyb3NzOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBWZWN0b3IzXFwncyAuY3Jvc3MoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5jcm9zc1ZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY3Jvc3NWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55LCB6ID0gdGhpcy56O1xyXG5cclxuXHRcdHRoaXMueCA9IHkgKiB2LnogLSB6ICogdi55O1xyXG5cdFx0dGhpcy55ID0geiAqIHYueCAtIHggKiB2Lno7XHJcblx0XHR0aGlzLnogPSB4ICogdi55IC0geSAqIHYueDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y3Jvc3NWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gYS55ICogYi56IC0gYS56ICogYi55O1xyXG5cdFx0dGhpcy55ID0gYS56ICogYi54IC0gYS54ICogYi56O1xyXG5cdFx0dGhpcy56ID0gYS54ICogYi55IC0gYS55ICogYi54O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwcm9qZWN0T25WZWN0b3I6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiggdmVjdG9yICkge1xyXG5cclxuXHRcdFx0djEuY29weSggdmVjdG9yICkubm9ybWFsaXplKCk7XHJcblx0XHRcdHZhciBkID0gdGhpcy5kb3QoIHYxICk7XHJcblx0XHRcdHJldHVybiB0aGlzLmNvcHkoIHYxICkubXVsdGlwbHlTY2FsYXIoIGQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHByb2plY3RPblBsYW5lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBsYW5lTm9ybWFsICkge1xyXG5cclxuXHRcdFx0djEuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnN1YiggdjEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cmVmbGVjdDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdCAgICB2MS5jb3B5KCB0aGlzICkucHJvamVjdE9uVmVjdG9yKCB2ZWN0b3IgKS5tdWx0aXBseVNjYWxhciggMiApO1xyXG5cclxuXHRcdCAgICByZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MSwgdGhpcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSgpLFxyXG5cclxuXHRhbmdsZVRvOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0dmFyIHRoZXRhID0gdGhpcy5kb3QoIHYgKSAvICggdGhpcy5sZW5ndGgoKSAqIHYubGVuZ3RoKCkgKTtcclxuXHJcblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFjb3MoIFRIUkVFLk1hdGguY2xhbXAoIHRoZXRhLCAtMSwgMSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1NxdWFyZWQ6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgZHggPSB0aGlzLnggLSB2Lng7XHJcblx0XHR2YXIgZHkgPSB0aGlzLnkgLSB2Lnk7XHJcblx0XHR2YXIgZHogPSB0aGlzLnogLSB2Lno7XHJcblxyXG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UG9zaXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dGhpcy54ID0gbS5lbGVtZW50c1sxMl07XHJcblx0XHR0aGlzLnkgPSBtLmVsZW1lbnRzWzEzXTtcclxuXHRcdHRoaXMueiA9IG0uZWxlbWVudHNbMTRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciApIHtcclxuXHJcblx0XHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxyXG5cclxuXHRcdC8vIGNsYW1wLCB0byBoYW5kbGUgbnVtZXJpY2FsIHByb2JsZW1zXHJcblxyXG5cdFx0ZnVuY3Rpb24gY2xhbXAoIHggKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gTWF0aC5taW4oIE1hdGgubWF4KCB4LCAtMSApLCAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0ZSA9IG0uZWxlbWVudHM7XHJcblx0XHR2YXIgbTExID0gdGVbMF0sIG0xMiA9IHRlWzRdLCBtMTMgPSB0ZVs4XTtcclxuXHRcdHZhciBtMjEgPSB0ZVsxXSwgbTIyID0gdGVbNV0sIG0yMyA9IHRlWzldO1xyXG5cdFx0dmFyIG0zMSA9IHRlWzJdLCBtMzIgPSB0ZVs2XSwgbTMzID0gdGVbMTBdO1xyXG5cclxuXHRcdGlmICggb3JkZXIgPT09IHVuZGVmaW5lZCB8fCBvcmRlciA9PT0gJ1hZWicgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSBNYXRoLmFzaW4oIGNsYW1wKCBtMTMgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEzICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XHJcblx0XHRcdFx0dGhpcy56ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0xMSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy54ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLnogPSAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IE1hdGguYXNpbiggLSBjbGFtcCggbTIzICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0yMyApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy55ID0gTWF0aC5hdGFuMiggbTEzLCBtMzMgKTtcclxuXHRcdFx0XHR0aGlzLnogPSBNYXRoLmF0YW4yKCBtMjEsIG0yMiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy55ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xyXG5cdFx0XHRcdHRoaXMueiA9IDA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5hc2luKCBjbGFtcCggbTMyICkgKTtcclxuXHJcblx0XHRcdGlmICggTWF0aC5hYnMoIG0zMiApIDwgMC45OTk5OSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy55ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0zMyApO1xyXG5cdFx0XHRcdHRoaXMueiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMueSA9IDA7XHJcblx0XHRcdFx0dGhpcy56ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pZWCcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0zMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMzEgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMueCA9IE1hdGguYXRhbjIoIG0zMiwgbTMzICk7XHJcblx0XHRcdFx0dGhpcy56ID0gTWF0aC5hdGFuMiggbTIxLCBtMTEgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXMueCA9IDA7XHJcblx0XHRcdFx0dGhpcy56ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcclxuXHJcblx0XHRcdHRoaXMueiA9IE1hdGguYXNpbiggY2xhbXAoIG0yMSApICk7XHJcblxyXG5cdFx0XHRpZiAoIE1hdGguYWJzKCBtMjEgKSA8IDAuOTk5OTkgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMueCA9IE1hdGguYXRhbjIoIC0gbTIzLCBtMjIgKTtcclxuXHRcdFx0XHR0aGlzLnkgPSBNYXRoLmF0YW4yKCAtIG0zMSwgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLnggPSAwO1xyXG5cdFx0XHRcdHRoaXMueSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdYWlknICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMTIgKSApO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggbTEyICkgPCAwLjk5OTk5ICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnggPSBNYXRoLmF0YW4yKCBtMzIsIG0yMiApO1xyXG5cdFx0XHRcdHRoaXMueSA9IE1hdGguYXRhbjIoIG0xMywgbTExICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLnggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XHJcblx0XHRcdFx0dGhpcy55ID0gMDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEV1bGVyRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSwgb3JkZXIgKSB7XHJcblxyXG5cdFx0Ly8gcSBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcclxuXHJcblx0XHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNsYW1wKCB4ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIE1hdGgubWluKCBNYXRoLm1heCggeCwgLTEgKSwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBodHRwOi8vd3d3Lm1hdGh3b3Jrcy5jb20vbWF0bGFiY2VudHJhbC9maWxlZXhjaGFuZ2UvMjA2OTYtZnVuY3Rpb24tdG8tY29udmVydC1iZXR3ZWVuLWRjbS1ldWxlci1hbmdsZXMtcXVhdGVybmlvbnMtYW5kLWV1bGVyLXZlY3RvcnMvY29udGVudC9TcGluQ2FsYy5tXHJcblxyXG5cdFx0dmFyIHNxeCA9IHEueCAqIHEueDtcclxuXHRcdHZhciBzcXkgPSBxLnkgKiBxLnk7XHJcblx0XHR2YXIgc3F6ID0gcS56ICogcS56O1xyXG5cdFx0dmFyIHNxdyA9IHEudyAqIHEudztcclxuXHJcblx0XHRpZiAoIG9yZGVyID09PSB1bmRlZmluZWQgfHwgb3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5hdGFuMiggMiAqICggcS54ICogcS53IC0gcS55ICogcS56ICksICggc3F3IC0gc3F4IC0gc3F5ICsgc3F6ICkgKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5hc2luKCAgY2xhbXAoIDIgKiAoIHEueCAqIHEueiArIHEueSAqIHEudyApICkgKTtcclxuXHRcdFx0dGhpcy56ID0gTWF0aC5hdGFuMiggMiAqICggcS56ICogcS53IC0gcS54ICogcS55ICksICggc3F3ICsgc3F4IC0gc3F5IC0gc3F6ICkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gICdZWFonICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5hc2luKCAgY2xhbXAoIDIgKiAoIHEueCAqIHEudyAtIHEueSAqIHEueiApICkgKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5hdGFuMiggMiAqICggcS54ICogcS56ICsgcS55ICogcS53ICksICggc3F3IC0gc3F4IC0gc3F5ICsgc3F6ICkgKTtcclxuXHRcdFx0dGhpcy56ID0gTWF0aC5hdGFuMiggMiAqICggcS54ICogcS55ICsgcS56ICogcS53ICksICggc3F3IC0gc3F4ICsgc3F5IC0gc3F6ICkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLmFzaW4oICBjbGFtcCggMiAqICggcS54ICogcS53ICsgcS55ICogcS56ICkgKSApO1xyXG5cdFx0XHR0aGlzLnkgPSBNYXRoLmF0YW4yKCAyICogKCBxLnkgKiBxLncgLSBxLnogKiBxLnggKSwgKCBzcXcgLSBzcXggLSBzcXkgKyBzcXogKSApO1xyXG5cdFx0XHR0aGlzLnogPSBNYXRoLmF0YW4yKCAyICogKCBxLnogKiBxLncgLSBxLnggKiBxLnkgKSwgKCBzcXcgLSBzcXggKyBzcXkgLSBzcXogKSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEudyArIHEueiAqIHEueSApLCAoIHNxdyAtIHNxeCAtIHNxeSArIHNxeiApICk7XHJcblx0XHRcdHRoaXMueSA9IE1hdGguYXNpbiggIGNsYW1wKCAyICogKCBxLnkgKiBxLncgLSBxLnggKiBxLnogKSApICk7XHJcblx0XHRcdHRoaXMueiA9IE1hdGguYXRhbjIoIDIgKiAoIHEueCAqIHEueSArIHEueiAqIHEudyApLCAoIHNxdyArIHNxeCAtIHNxeSAtIHNxeiApICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gTWF0aC5hdGFuMiggMiAqICggcS54ICogcS53IC0gcS56ICogcS55ICksICggc3F3IC0gc3F4ICsgc3F5IC0gc3F6ICkgKTtcclxuXHRcdFx0dGhpcy55ID0gTWF0aC5hdGFuMiggMiAqICggcS55ICogcS53IC0gcS54ICogcS56ICksICggc3F3ICsgc3F4IC0gc3F5IC0gc3F6ICkgKTtcclxuXHRcdFx0dGhpcy56ID0gTWF0aC5hc2luKCAgY2xhbXAoIDIgKiAoIHEueCAqIHEueSArIHEueiAqIHEudyApICkgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBNYXRoLmF0YW4yKCAyICogKCBxLnggKiBxLncgKyBxLnkgKiBxLnogKSwgKCBzcXcgLSBzcXggKyBzcXkgLSBzcXogKSApO1xyXG5cdFx0XHR0aGlzLnkgPSBNYXRoLmF0YW4yKCAyICogKCBxLnggKiBxLnogKyBxLnkgKiBxLncgKSwgKCBzcXcgKyBzcXggLSBzcXkgLSBzcXogKSApO1xyXG5cdFx0XHR0aGlzLnogPSBNYXRoLmFzaW4oICBjbGFtcCggMiAqICggcS56ICogcS53IC0gcS54ICogcS55ICkgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0U2NhbGVGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHN4ID0gdGhpcy5zZXQoIG0uZWxlbWVudHNbMF0sIG0uZWxlbWVudHNbMV0sIG0uZWxlbWVudHNbMl0gKS5sZW5ndGgoKTtcclxuXHRcdHZhciBzeSA9IHRoaXMuc2V0KCBtLmVsZW1lbnRzWzRdLCBtLmVsZW1lbnRzWzVdLCBtLmVsZW1lbnRzWzZdICkubGVuZ3RoKCk7XHJcblx0XHR2YXIgc3ogPSB0aGlzLnNldCggbS5lbGVtZW50c1s4XSwgbS5lbGVtZW50c1s5XSwgbS5lbGVtZW50c1sxMF0gKS5sZW5ndGgoKTtcclxuXHJcblx0XHR0aGlzLnggPSBzeDtcclxuXHRcdHRoaXMueSA9IHN5O1xyXG5cdFx0dGhpcy56ID0gc3o7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0dG9BcnJheTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBbIHRoaXMueCwgdGhpcy55LCB0aGlzLnogXTtcclxuXHRcdFxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0aGlzLngsIHRoaXMueSwgdGhpcy56ICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKi9cclxuXHJcblRIUkVFLlZlY3RvcjQgPSBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcblx0dGhpcy56ID0geiB8fCAwO1xyXG5cdHRoaXMudyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5leHRlbmQoIFRIUkVFLlZlY3RvcjQucHJvdG90eXBlLCB7XHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHg7XHJcblx0XHR0aGlzLnkgPSB5O1xyXG5cdFx0dGhpcy56ID0gejtcclxuXHRcdHRoaXMudyA9IHc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFg6IGZ1bmN0aW9uICggeCApIHtcclxuXHJcblx0XHR0aGlzLnggPSB4O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRZOiBmdW5jdGlvbiAoIHkgKSB7XHJcblxyXG5cdFx0dGhpcy55ID0geTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xyXG5cclxuXHRcdHRoaXMueiA9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFc6IGZ1bmN0aW9uICggdyApIHtcclxuXHJcblx0XHR0aGlzLncgPSB3O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xyXG5cclxuXHRcdHN3aXRjaCAoIGluZGV4ICkge1xyXG5cclxuXHRcdFx0Y2FzZSAwOiB0aGlzLnggPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xyXG5cdFx0XHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcclxuXHRcdFx0Y2FzZSAzOiB0aGlzLncgPSB2YWx1ZTsgYnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggXCJpbmRleCBpcyBvdXQgb2YgcmFuZ2U6IFwiICsgaW5kZXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcclxuXHJcblx0XHRzd2l0Y2ggKCBpbmRleCApIHtcclxuXHJcblx0XHRcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xyXG5cdFx0XHRjYXNlIDI6IHJldHVybiB0aGlzLno7XHJcblx0XHRcdGNhc2UgMzogcmV0dXJuIHRoaXMudztcclxuXHRcdFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCBcImluZGV4IGlzIG91dCBvZiByYW5nZTogXCIgKyBpbmRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHRoaXMueCA9IHYueDtcclxuXHRcdHRoaXMueSA9IHYueTtcclxuXHRcdHRoaXMueiA9IHYuejtcclxuXHRcdHRoaXMudyA9ICggdi53ICE9PSB1bmRlZmluZWQgKSA/IHYudyA6IDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xyXG5cclxuXHRcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnREVQUkVDQVRFRDogVmVjdG9yNFxcJ3MgLmFkZCgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmFkZFZlY3RvcnMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnggKz0gdi54O1xyXG5cdFx0dGhpcy55ICs9IHYueTtcclxuXHRcdHRoaXMueiArPSB2Lno7XHJcblx0XHR0aGlzLncgKz0gdi53O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR0aGlzLnggKz0gcztcclxuXHRcdHRoaXMueSArPSBzO1xyXG5cdFx0dGhpcy56ICs9IHM7XHJcblx0XHR0aGlzLncgKz0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdHRoaXMueCA9IGEueCArIGIueDtcclxuXHRcdHRoaXMueSA9IGEueSArIGIueTtcclxuXHRcdHRoaXMueiA9IGEueiArIGIuejtcclxuXHRcdHRoaXMudyA9IGEudyArIGIudztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c3ViOiBmdW5jdGlvbiAoIHYsIHcgKSB7XHJcblxyXG5cdFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBWZWN0b3I0XFwncyAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2LCB3ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMueCAtPSB2Lng7XHJcblx0XHR0aGlzLnkgLT0gdi55O1xyXG5cdFx0dGhpcy56IC09IHYuejtcclxuXHRcdHRoaXMudyAtPSB2Lnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR0aGlzLnggPSBhLnggLSBiLng7XHJcblx0XHR0aGlzLnkgPSBhLnkgLSBiLnk7XHJcblx0XHR0aGlzLnogPSBhLnogLSBiLno7XHJcblx0XHR0aGlzLncgPSBhLncgLSBiLnc7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0dGhpcy54ICo9IHM7XHJcblx0XHR0aGlzLnkgKj0gcztcclxuXHRcdHRoaXMueiAqPSBzO1xyXG5cdFx0dGhpcy53ICo9IHM7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciB4ID0gdGhpcy54O1xyXG5cdFx0dmFyIHkgPSB0aGlzLnk7XHJcblx0XHR2YXIgeiA9IHRoaXMuejtcclxuXHRcdHZhciB3ID0gdGhpcy53O1xyXG5cclxuXHRcdHZhciBlID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnggPSBlWzBdICogeCArIGVbNF0gKiB5ICsgZVs4XSAqIHogKyBlWzEyXSAqIHc7XHJcblx0XHR0aGlzLnkgPSBlWzFdICogeCArIGVbNV0gKiB5ICsgZVs5XSAqIHogKyBlWzEzXSAqIHc7XHJcblx0XHR0aGlzLnogPSBlWzJdICogeCArIGVbNl0gKiB5ICsgZVsxMF0gKiB6ICsgZVsxNF0gKiB3O1xyXG5cdFx0dGhpcy53ID0gZVszXSAqIHggKyBlWzddICogeSArIGVbMTFdICogeiArIGVbMTVdICogdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XHJcblxyXG5cdFx0aWYgKCBzICE9PSAwICkge1xyXG5cclxuXHRcdFx0dGhpcy54IC89IHM7XHJcblx0XHRcdHRoaXMueSAvPSBzO1xyXG5cdFx0XHR0aGlzLnogLz0gcztcclxuXHRcdFx0dGhpcy53IC89IHM7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IDA7XHJcblx0XHRcdHRoaXMueSA9IDA7XHJcblx0XHRcdHRoaXMueiA9IDA7XHJcblx0XHRcdHRoaXMudyA9IDE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9xdWF0ZXJuaW9uVG9BbmdsZS9pbmRleC5odG1cclxuXHJcblx0XHQvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxyXG5cclxuXHRcdHRoaXMudyA9IDIgKiBNYXRoLmFjb3MoIHEudyApO1xyXG5cclxuXHRcdHZhciBzID0gTWF0aC5zcXJ0KCAxIC0gcS53ICogcS53ICk7XHJcblxyXG5cdFx0aWYgKCBzIDwgMC4wMDAxICkge1xyXG5cclxuXHRcdFx0IHRoaXMueCA9IDE7XHJcblx0XHRcdCB0aGlzLnkgPSAwO1xyXG5cdFx0XHQgdGhpcy56ID0gMDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0IHRoaXMueCA9IHEueCAvIHM7XHJcblx0XHRcdCB0aGlzLnkgPSBxLnkgLyBzO1xyXG5cdFx0XHQgdGhpcy56ID0gcS56IC8gcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldEF4aXNBbmdsZUZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9tYXRyaXhUb0FuZ2xlL2luZGV4Lmh0bVxyXG5cclxuXHRcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXHJcblxyXG5cdFx0dmFyIGFuZ2xlLCB4LCB5LCB6LFx0XHQvLyB2YXJpYWJsZXMgZm9yIHJlc3VsdFxyXG5cdFx0XHRlcHNpbG9uID0gMC4wMSxcdFx0Ly8gbWFyZ2luIHRvIGFsbG93IGZvciByb3VuZGluZyBlcnJvcnNcclxuXHRcdFx0ZXBzaWxvbjIgPSAwLjEsXHRcdC8vIG1hcmdpbiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDAgYW5kIDE4MCBkZWdyZWVzXHJcblxyXG5cdFx0XHR0ZSA9IG0uZWxlbWVudHMsXHJcblxyXG5cdFx0XHRtMTEgPSB0ZVswXSwgbTEyID0gdGVbNF0sIG0xMyA9IHRlWzhdLFxyXG5cdFx0XHRtMjEgPSB0ZVsxXSwgbTIyID0gdGVbNV0sIG0yMyA9IHRlWzldLFxyXG5cdFx0XHRtMzEgPSB0ZVsyXSwgbTMyID0gdGVbNl0sIG0zMyA9IHRlWzEwXTtcclxuXHJcblx0XHRpZiAoICggTWF0aC5hYnMoIG0xMiAtIG0yMSApIDwgZXBzaWxvbiApXHJcblx0XHQgICYmICggTWF0aC5hYnMoIG0xMyAtIG0zMSApIDwgZXBzaWxvbiApXHJcblx0XHQgICYmICggTWF0aC5hYnMoIG0yMyAtIG0zMiApIDwgZXBzaWxvbiApICkge1xyXG5cclxuXHRcdFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcclxuXHRcdFx0Ly8gZmlyc3QgY2hlY2sgZm9yIGlkZW50aXR5IG1hdHJpeCB3aGljaCBtdXN0IGhhdmUgKzEgZm9yIGFsbCB0ZXJtc1xyXG5cdFx0XHQvLyBpbiBsZWFkaW5nIGRpYWdvbmFsIGFuZCB6ZXJvIGluIG90aGVyIHRlcm1zXHJcblxyXG5cdFx0XHRpZiAoICggTWF0aC5hYnMoIG0xMiArIG0yMSApIDwgZXBzaWxvbjIgKVxyXG5cdFx0XHQgICYmICggTWF0aC5hYnMoIG0xMyArIG0zMSApIDwgZXBzaWxvbjIgKVxyXG5cdFx0XHQgICYmICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKVxyXG5cdFx0XHQgICYmICggTWF0aC5hYnMoIG0xMSArIG0yMiArIG0zMyAtIDMgKSA8IGVwc2lsb24yICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHRoaXMgc2luZ3VsYXJpdHkgaXMgaWRlbnRpdHkgbWF0cml4IHNvIGFuZ2xlID0gMFxyXG5cclxuXHRcdFx0XHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gdGhpczsgLy8gemVybyBhbmdsZSwgYXJiaXRyYXJ5IGF4aXNcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG90aGVyd2lzZSB0aGlzIHNpbmd1bGFyaXR5IGlzIGFuZ2xlID0gMTgwXHJcblxyXG5cdFx0XHRhbmdsZSA9IE1hdGguUEk7XHJcblxyXG5cdFx0XHR2YXIgeHggPSAoIG0xMSArIDEgKSAvIDI7XHJcblx0XHRcdHZhciB5eSA9ICggbTIyICsgMSApIC8gMjtcclxuXHRcdFx0dmFyIHp6ID0gKCBtMzMgKyAxICkgLyAyO1xyXG5cdFx0XHR2YXIgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcclxuXHRcdFx0dmFyIHh6ID0gKCBtMTMgKyBtMzEgKSAvIDQ7XHJcblx0XHRcdHZhciB5eiA9ICggbTIzICsgbTMyICkgLyA0O1xyXG5cclxuXHRcdFx0aWYgKCAoIHh4ID4geXkgKSAmJiAoIHh4ID4genogKSApIHsgLy8gbTExIGlzIHRoZSBsYXJnZXN0IGRpYWdvbmFsIHRlcm1cclxuXHJcblx0XHRcdFx0aWYgKCB4eCA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDA7XHJcblx0XHRcdFx0XHR5ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR6ID0gMC43MDcxMDY3ODE7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IE1hdGguc3FydCggeHggKTtcclxuXHRcdFx0XHRcdHkgPSB4eSAvIHg7XHJcblx0XHRcdFx0XHR6ID0geHogLyB4O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB5eSA+IHp6ICkgeyAvLyBtMjIgaXMgdGhlIGxhcmdlc3QgZGlhZ29uYWwgdGVybVxyXG5cclxuXHRcdFx0XHRpZiAoIHl5IDwgZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdFx0XHR4ID0gMC43MDcxMDY3ODE7XHJcblx0XHRcdFx0XHR5ID0gMDtcclxuXHRcdFx0XHRcdHogPSAwLjcwNzEwNjc4MTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR5ID0gTWF0aC5zcXJ0KCB5eSApO1xyXG5cdFx0XHRcdFx0eCA9IHh5IC8geTtcclxuXHRcdFx0XHRcdHogPSB5eiAvIHk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7IC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcclxuXHJcblx0XHRcdFx0aWYgKCB6eiA8IGVwc2lsb24gKSB7XHJcblxyXG5cdFx0XHRcdFx0eCA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eSA9IDAuNzA3MTA2NzgxO1xyXG5cdFx0XHRcdFx0eiA9IDA7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0eiA9IE1hdGguc3FydCggenogKTtcclxuXHRcdFx0XHRcdHggPSB4eiAvIHo7XHJcblx0XHRcdFx0XHR5ID0geXogLyB6O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzOyAvLyByZXR1cm4gMTgwIGRlZyByb3RhdGlvblxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBhcyB3ZSBoYXZlIHJlYWNoZWQgaGVyZSB0aGVyZSBhcmUgbm8gc2luZ3VsYXJpdGllcyBzbyB3ZSBjYW4gaGFuZGxlIG5vcm1hbGx5XHJcblxyXG5cdFx0dmFyIHMgPSBNYXRoLnNxcnQoICggbTMyIC0gbTIzICkgKiAoIG0zMiAtIG0yMyApXHJcblx0XHRcdFx0XHRcdCArICggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApXHJcblx0XHRcdFx0XHRcdCArICggbTIxIC0gbTEyICkgKiAoIG0yMSAtIG0xMiApICk7IC8vIHVzZWQgdG8gbm9ybWFsaXplXHJcblxyXG5cdFx0aWYgKCBNYXRoLmFicyggcyApIDwgMC4wMDEgKSBzID0gMTtcclxuXHJcblx0XHQvLyBwcmV2ZW50IGRpdmlkZSBieSB6ZXJvLCBzaG91bGQgbm90IGhhcHBlbiBpZiBtYXRyaXggaXMgb3J0aG9nb25hbCBhbmQgc2hvdWxkIGJlXHJcblx0XHQvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcclxuXHJcblx0XHR0aGlzLnggPSAoIG0zMiAtIG0yMyApIC8gcztcclxuXHRcdHRoaXMueSA9ICggbTEzIC0gbTMxICkgLyBzO1xyXG5cdFx0dGhpcy56ID0gKCBtMjEgLSBtMTIgKSAvIHM7XHJcblx0XHR0aGlzLncgPSBNYXRoLmFjb3MoICggbTExICsgbTIyICsgbTMzIC0gMSApIC8gMiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtaW46IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMueCA+IHYueCApIHtcclxuXHJcblx0XHRcdHRoaXMueCA9IHYueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPiB2LnkgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnkgPSB2Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56ID4gdi56ICkge1xyXG5cclxuXHRcdFx0dGhpcy56ID0gdi56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMudyA+IHYudyApIHtcclxuXHJcblx0XHRcdHRoaXMudyA9IHYudztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1heDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdGlmICggdGhpcy54IDwgdi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gdi54O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMueSA8IHYueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IHYueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnogPCB2LnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSB2Lno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy53IDwgdi53ICkge1xyXG5cclxuXHRcdFx0dGhpcy53ID0gdi53O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiBhc3N1bWVzIG1pbiA8IG1heCwgaWYgdGhpcyBhc3N1bXB0aW9uIGlzbid0IHRydWUgaXQgd2lsbCBub3Qgb3BlcmF0ZSBjb3JyZWN0bHlcclxuXHJcblx0XHRpZiAoIHRoaXMueCA8IG1pbi54ICkge1xyXG5cclxuXHRcdFx0dGhpcy54ID0gbWluLng7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy54ID4gbWF4LnggKSB7XHJcblxyXG5cdFx0XHR0aGlzLnggPSBtYXgueDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnkgPCBtaW4ueSApIHtcclxuXHJcblx0XHRcdHRoaXMueSA9IG1pbi55O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHRoaXMueSA+IG1heC55ICkge1xyXG5cclxuXHRcdFx0dGhpcy55ID0gbWF4Lnk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy56IDwgbWluLnogKSB7XHJcblxyXG5cdFx0XHR0aGlzLnogPSBtaW4uejtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCB0aGlzLnogPiBtYXgueiApIHtcclxuXHJcblx0XHRcdHRoaXMueiA9IG1heC56O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMudyA8IG1pbi53ICkge1xyXG5cclxuXHRcdFx0dGhpcy53ID0gbWluLnc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdGhpcy53ID4gbWF4LncgKSB7XHJcblxyXG5cdFx0XHR0aGlzLncgPSBtYXgudztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIC0xICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRvdDogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2LnkgKyB0aGlzLnogKiB2LnogKyB0aGlzLncgKiB2Lnc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aFNxOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSArIHRoaXMueiAqIHRoaXMueiArIHRoaXMudyAqIHRoaXMudztcclxuXHJcblx0fSxcclxuXHJcblx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICkgKyBNYXRoLmFicyggdGhpcy53ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpdmlkZVNjYWxhciggdGhpcy5sZW5ndGgoKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbCApIHtcclxuXHJcblx0XHR2YXIgb2xkTGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcclxuXHJcblx0XHRpZiAoIG9sZExlbmd0aCAhPT0gMCAmJiBsICE9PSBvbGRMZW5ndGggKSB7XHJcblxyXG5cdFx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCBsIC8gb2xkTGVuZ3RoICk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XHJcblxyXG5cdFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcclxuXHRcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XHJcblx0XHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xyXG5cdFx0dGhpcy53ICs9ICggdi53IC0gdGhpcy53ICkgKiBhbHBoYTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHYgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggKCB2LnggPT09IHRoaXMueCApICYmICggdi55ID09PSB0aGlzLnkgKSAmJiAoIHYueiA9PT0gdGhpcy56ICkgJiYgKCB2LncgPT09IHRoaXMudyApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRvQXJyYXk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gWyB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgXTtcclxuXHRcdFxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3I0KCB0aGlzLngsIHRoaXMueSwgdGhpcy56LCB0aGlzLncgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuQm94MiA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjIoIEluZmluaXR5LCBJbmZpbml0eSApO1xyXG5cdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFRIUkVFLlZlY3RvcjIoIC1JbmZpbml0eSwgLUluZmluaXR5ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuZXh0ZW5kKCBUSFJFRS5Cb3gyLnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBwb2ludCA9IHBvaW50c1sgMCBdO1xyXG5cclxuXHRcdFx0dGhpcy5taW4uY29weSggcG9pbnQgKTtcclxuXHRcdFx0dGhpcy5tYXguY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMSwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50ID0gcG9pbnRzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggcG9pbnQueCA8IHRoaXMubWluLnggKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5taW4ueCA9IHBvaW50Lng7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBvaW50LnggPiB0aGlzLm1heC54ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWF4LnggPSBwb2ludC54O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcG9pbnQueSA8IHRoaXMubWluLnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5taW4ueSA9IHBvaW50Lnk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWF4LnkgPSBwb2ludC55O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cdFx0XHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XHJcblx0XHRcdHRoaXMubWF4LmNvcHkoIGNlbnRlciApLmFkZCggaGFsZlNpemUgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlRW1wdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm1pbi54ID0gdGhpcy5taW4ueSA9IEluZmluaXR5O1xyXG5cdFx0dGhpcy5tYXgueCA9IHRoaXMubWF4LnkgPSAtSW5maW5pdHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNpemU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMubWF4LCB0aGlzLm1pbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcclxuXHRcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcclxuXHRcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLXNjYWxhciApO1xyXG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdGlmICggcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcclxuXHRcdCAgICAgcG9pbnQueSA8IHRoaXMubWluLnkgfHwgcG9pbnQueSA+IHRoaXMubWF4LnkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0aWYgKCAoIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICkgJiYgKCBib3gubWF4LnggPD0gdGhpcy5tYXgueCApICYmXHJcblx0XHQgICAgICggdGhpcy5taW4ueSA8PSBib3gubWluLnkgKSAmJiAoIGJveC5tYXgueSA8PSB0aGlzLm1heC55ICkgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcclxuXHRcdC8vIGhhcyBhIHNpemUgZGltZW5zaW9uIG9mIDAuXHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKFxyXG5cdFx0XHQoIHBvaW50LnggLSB0aGlzLm1pbi54ICkgLyAoIHRoaXMubWF4LnggLSB0aGlzLm1pbi54ICksXHJcblx0XHRcdCggcG9pbnQueSAtIHRoaXMubWluLnkgKSAvICggdGhpcy5tYXgueSAtIHRoaXMubWluLnkgKVxyXG5cdFx0KTtcclxuXHJcblx0fSxcclxuXHJcblx0aXNJbnRlcnNlY3Rpb25Cb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxyXG5cclxuXHRcdGlmICggYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XHJcblx0XHQgICAgIGJveC5tYXgueSA8IHRoaXMubWluLnkgfHwgYm94Lm1pbi55ID4gdGhpcy5tYXgueSApIHtcclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsYW1wUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cdFx0XHRyZXR1cm4gY2xhbXBlZFBvaW50LnN1YiggcG9pbnQgKS5sZW5ndGgoKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5taW4oIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dW5pb246IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLm1pbiggYm94Lm1pbiApO1xyXG5cdFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcclxuXHRcdHRoaXMubWF4LmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuQm94MigpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG4vKipcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuQm94MyA9IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFRIUkVFLlZlY3RvcjMoIEluZmluaXR5LCBJbmZpbml0eSwgSW5maW5pdHkgKTtcclxuXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAtSW5maW5pdHksIC1JbmZpbml0eSwgLUluZmluaXR5ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuZXh0ZW5kKCBUSFJFRS5Cb3gzLnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbWluLCBtYXggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4uY29weSggbWluICk7XHJcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0aWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdHZhciBwb2ludCA9IHBvaW50c1sgMCBdO1xyXG5cclxuXHRcdFx0dGhpcy5taW4uY29weSggcG9pbnQgKTtcclxuXHRcdFx0dGhpcy5tYXguY29weSggcG9pbnQgKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMSwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50ID0gcG9pbnRzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggcG9pbnQueCA8IHRoaXMubWluLnggKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5taW4ueCA9IHBvaW50Lng7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBvaW50LnggPiB0aGlzLm1heC54ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWF4LnggPSBwb2ludC54O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcG9pbnQueSA8IHRoaXMubWluLnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5taW4ueSA9IHBvaW50Lnk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBvaW50LnkgPiB0aGlzLm1heC55ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWF4LnkgPSBwb2ludC55O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggcG9pbnQueiA8IHRoaXMubWluLnogKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5taW4ueiA9IHBvaW50Lno7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBvaW50LnogPiB0aGlzLm1heC56ICkge1xyXG5cclxuXHRcdFx0XHRcdHRoaXMubWF4LnogPSBwb2ludC56O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBjZW50ZXIsIHNpemUgKSB7XHJcblxyXG5cdFx0XHR2YXIgaGFsZlNpemUgPSB2MS5jb3B5KCBzaXplICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0dGhpcy5taW4uY29weSggY2VudGVyICkuc3ViKCBoYWxmU2l6ZSApO1xyXG5cdFx0XHR0aGlzLm1heC5jb3B5KCBjZW50ZXIgKS5hZGQoIGhhbGZTaXplICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNvcHk6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdHRoaXMubWluLmNvcHkoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gSW5maW5pdHk7XHJcblx0XHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtSW5maW5pdHk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKSB8fCAoIHRoaXMubWF4LnogPCB0aGlzLm1pbi56ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5taW4oIHBvaW50ICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCB2ZWN0b3IgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xyXG5cclxuXHRcdHRoaXMubWluLmFkZFNjYWxhciggLXNjYWxhciApO1xyXG5cdFx0dGhpcy5tYXguYWRkU2NhbGFyKCBzY2FsYXIgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRpZiAoIHBvaW50LnggPCB0aGlzLm1pbi54IHx8IHBvaW50LnggPiB0aGlzLm1heC54IHx8XHJcblx0XHQgICAgIHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55IHx8XHJcblx0XHQgICAgIHBvaW50LnogPCB0aGlzLm1pbi56IHx8IHBvaW50LnogPiB0aGlzLm1heC56ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xyXG5cclxuXHRcdGlmICggKCB0aGlzLm1pbi54IDw9IGJveC5taW4ueCApICYmICggYm94Lm1heC54IDw9IHRoaXMubWF4LnggKSAmJlxyXG5cdFx0XHQgKCB0aGlzLm1pbi55IDw9IGJveC5taW4ueSApICYmICggYm94Lm1heC55IDw9IHRoaXMubWF4LnkgKSAmJlxyXG5cdFx0XHQgKCB0aGlzLm1pbi56IDw9IGJveC5taW4ueiApICYmICggYm94Lm1heC56IDw9IHRoaXMubWF4LnogKSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHQvLyBUaGlzIGNhbiBwb3RlbnRpYWxseSBoYXZlIGEgZGl2aWRlIGJ5IHplcm8gaWYgdGhlIGJveFxyXG5cdFx0Ly8gaGFzIGEgc2l6ZSBkaW1lbnNpb24gb2YgMC5cclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoXHJcblx0XHRcdCggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcclxuXHRcdFx0KCBwb2ludC55IC0gdGhpcy5taW4ueSApIC8gKCB0aGlzLm1heC55IC0gdGhpcy5taW4ueSApLFxyXG5cdFx0XHQoIHBvaW50LnogLSB0aGlzLm1pbi56ICkgLyAoIHRoaXMubWF4LnogLSB0aGlzLm1pbi56IClcclxuXHRcdCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHQvLyB1c2luZyA2IHNwbGl0dGluZyBwbGFuZXMgdG8gcnVsZSBvdXQgaW50ZXJzZWN0aW9ucy5cclxuXHJcblx0XHRpZiAoIGJveC5tYXgueCA8IHRoaXMubWluLnggfHwgYm94Lm1pbi54ID4gdGhpcy5tYXgueCB8fFxyXG5cdFx0ICAgICBib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcclxuXHRcdCAgICAgYm94Lm1heC56IDwgdGhpcy5taW4ueiB8fCBib3gubWluLnogPiB0aGlzLm1heC56ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XHJcblx0XHRcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0Z2V0Qm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuXHRcdFx0cmVzdWx0LmNlbnRlciA9IHRoaXMuY2VudGVyKCk7XHJcblx0XHRcdHJlc3VsdC5yYWRpdXMgPSB0aGlzLnNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0aW50ZXJzZWN0OiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5tYXgoIGJveC5taW4gKTtcclxuXHRcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XHJcblxyXG5cdFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XHJcblx0XHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgcG9pbnRzID0gW1xyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMygpXHJcblx0XHRcdF07XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdFx0Ly8gTk9URTogSSBhbSB1c2luZyBhIGJpbmFyeSBwYXR0ZXJuIHRvIHNwZWNpZnkgYWxsIDJeMyBjb21iaW5hdGlvbnMgYmVsb3dcclxuXHRcdFx0cG9pbnRzWzBdLnNldCggdGhpcy5taW4ueCwgdGhpcy5taW4ueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAwMFxyXG5cdFx0XHRwb2ludHNbMV0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXHJcblx0XHRcdHBvaW50c1syXS5zZXQoIHRoaXMubWluLngsIHRoaXMubWF4LnksIHRoaXMubWluLnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAwMTBcclxuXHRcdFx0cG9pbnRzWzNdLnNldCggdGhpcy5taW4ueCwgdGhpcy5tYXgueSwgdGhpcy5tYXgueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDAxMVxyXG5cdFx0XHRwb2ludHNbNF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXHJcblx0XHRcdHBvaW50c1s1XS5zZXQoIHRoaXMubWF4LngsIHRoaXMubWluLnksIHRoaXMubWF4LnogKS5hcHBseU1hdHJpeDQoIG1hdHJpeCApOyAvLyAxMDFcclxuXHRcdFx0cG9pbnRzWzZdLnNldCggdGhpcy5tYXgueCwgdGhpcy5tYXgueSwgdGhpcy5taW4ueiApLmFwcGx5TWF0cml4NCggbWF0cml4ICk7IC8vIDExMFxyXG5cdFx0XHRwb2ludHNbN10uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgIC8vIDExMVxyXG5cclxuXHRcdFx0dGhpcy5tYWtlRW1wdHkoKTtcclxuXHRcdFx0dGhpcy5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0dHJhbnNsYXRlOiBmdW5jdGlvbiAoIG9mZnNldCApIHtcclxuXHJcblx0XHR0aGlzLm1pbi5hZGQoIG9mZnNldCApO1xyXG5cdFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcclxuXHJcblx0XHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5Cb3gzKCkuY29weSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuTWF0cml4MyA9IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcclxuXHJcblx0dGhpcy5lbGVtZW50cyA9IG5ldyBGbG9hdDMyQXJyYXkoOSk7XHJcblxyXG5cdHRoaXMuc2V0KFxyXG5cclxuXHRcdCggbjExICE9PSB1bmRlZmluZWQgKSA/IG4xMSA6IDEsIG4xMiB8fCAwLCBuMTMgfHwgMCxcclxuXHRcdG4yMSB8fCAwLCAoIG4yMiAhPT0gdW5kZWZpbmVkICkgPyBuMjIgOiAxLCBuMjMgfHwgMCxcclxuXHRcdG4zMSB8fCAwLCBuMzIgfHwgMCwgKCBuMzMgIT09IHVuZGVmaW5lZCApID8gbjMzIDogMVxyXG5cclxuXHQpO1xyXG59O1xyXG5cclxuVEhSRUUuZXh0ZW5kKCBUSFJFRS5NYXRyaXgzLnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWzBdID0gbjExOyB0ZVszXSA9IG4xMjsgdGVbNl0gPSBuMTM7XHJcblx0XHR0ZVsxXSA9IG4yMTsgdGVbNF0gPSBuMjI7IHRlWzddID0gbjIzO1xyXG5cdFx0dGVbMl0gPSBuMzE7IHRlWzVdID0gbjMyOyB0ZVs4XSA9IG4zMztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIDAsIDAsXHJcblx0XHRcdDAsIDEsIDAsXHJcblx0XHRcdDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdG1lWzBdLCBtZVszXSwgbWVbNl0sXHJcblx0XHRcdG1lWzFdLCBtZVs0XSwgbWVbN10sXHJcblx0XHRcdG1lWzJdLCBtZVs1XSwgbWVbOF1cclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IE1hdHJpeDNcXCdzIC5tdWx0aXBseVZlY3RvcjMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4MyggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4MyggdGhpcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGEubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0djEueCA9IGFbIGkgXTtcclxuXHRcdFx0XHR2MS55ID0gYVsgaSArIDEgXTtcclxuXHRcdFx0XHR2MS56ID0gYVsgaSArIDIgXTtcclxuXHJcblx0XHRcdFx0djEuYXBwbHlNYXRyaXgzKHRoaXMpO1xyXG5cclxuXHRcdFx0XHRhWyBpIF0gICAgID0gdjEueDtcclxuXHRcdFx0XHRhWyBpICsgMSBdID0gdjEueTtcclxuXHRcdFx0XHRhWyBpICsgMiBdID0gdjEuejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHRlWzBdICo9IHM7IHRlWzNdICo9IHM7IHRlWzZdICo9IHM7XHJcblx0XHR0ZVsxXSAqPSBzOyB0ZVs0XSAqPSBzOyB0ZVs3XSAqPSBzO1xyXG5cdFx0dGVbMl0gKj0gczsgdGVbNV0gKj0gczsgdGVbOF0gKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBhID0gdGVbMF0sIGIgPSB0ZVsxXSwgYyA9IHRlWzJdLFxyXG5cdFx0XHRkID0gdGVbM10sIGUgPSB0ZVs0XSwgZiA9IHRlWzVdLFxyXG5cdFx0XHRnID0gdGVbNl0sIGggPSB0ZVs3XSwgaSA9IHRlWzhdO1xyXG5cclxuXHRcdHJldHVybiBhKmUqaSAtIGEqZipoIC0gYipkKmkgKyBiKmYqZyArIGMqZCpoIC0gYyplKmc7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldEludmVyc2U6IGZ1bmN0aW9uICggbWF0cml4LCB0aHJvd09uSW52ZXJ0aWJsZSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NFxyXG5cdFx0Ly8gKCBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3Avd2ViZ2wtbWpzLyApXHJcblxyXG5cdFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVsgMCBdID0gICBtZVsxMF0gKiBtZVs1XSAtIG1lWzZdICogbWVbOV07XHJcblx0XHR0ZVsgMSBdID0gLSBtZVsxMF0gKiBtZVsxXSArIG1lWzJdICogbWVbOV07XHJcblx0XHR0ZVsgMiBdID0gICBtZVs2XSAqIG1lWzFdIC0gbWVbMl0gKiBtZVs1XTtcclxuXHRcdHRlWyAzIF0gPSAtIG1lWzEwXSAqIG1lWzRdICsgbWVbNl0gKiBtZVs4XTtcclxuXHRcdHRlWyA0IF0gPSAgIG1lWzEwXSAqIG1lWzBdIC0gbWVbMl0gKiBtZVs4XTtcclxuXHRcdHRlWyA1IF0gPSAtIG1lWzZdICogbWVbMF0gKyBtZVsyXSAqIG1lWzRdO1xyXG5cdFx0dGVbIDYgXSA9ICAgbWVbOV0gKiBtZVs0XSAtIG1lWzVdICogbWVbOF07XHJcblx0XHR0ZVsgNyBdID0gLSBtZVs5XSAqIG1lWzBdICsgbWVbMV0gKiBtZVs4XTtcclxuXHRcdHRlWyA4IF0gPSAgIG1lWzVdICogbWVbMF0gLSBtZVsxXSAqIG1lWzRdO1xyXG5cclxuXHRcdHZhciBkZXQgPSBtZVsgMCBdICogdGVbIDAgXSArIG1lWyAxIF0gKiB0ZVsgMyBdICsgbWVbIDIgXSAqIHRlWyA2IF07XHJcblxyXG5cdFx0Ly8gbm8gaW52ZXJzZVxyXG5cclxuXHRcdGlmICggZGV0ID09PSAwICkge1xyXG5cclxuXHRcdFx0dmFyIG1zZyA9IFwiTWF0cml4My5nZXRJbnZlcnNlKCk6IGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcIjtcclxuXHJcblx0XHRcdGlmICggdGhyb3dPbkludmVydGlibGUgfHwgZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7IFxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS53YXJuKCBtc2cgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuaWRlbnRpdHkoKTtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCAxLjAgLyBkZXQgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRtcCwgbSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dG1wID0gbVsxXTsgbVsxXSA9IG1bM107IG1bM10gPSB0bXA7XHJcblx0XHR0bXAgPSBtWzJdOyBtWzJdID0gbVs2XTsgbVs2XSA9IHRtcDtcclxuXHRcdHRtcCA9IG1bNV07IG1bNV0gPSBtWzddOyBtWzddID0gdG1wO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXROb3JtYWxNYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NFxyXG5cclxuXHRcdHRoaXMuZ2V0SW52ZXJzZSggbSApLnRyYW5zcG9zZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc3Bvc2VJbnRvQXJyYXk6IGZ1bmN0aW9uICggciApIHtcclxuXHJcblx0XHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0clsgMCBdID0gbVsgMCBdO1xyXG5cdFx0clsgMSBdID0gbVsgMyBdO1xyXG5cdFx0clsgMiBdID0gbVsgNiBdO1xyXG5cdFx0clsgMyBdID0gbVsgMSBdO1xyXG5cdFx0clsgNCBdID0gbVsgNCBdO1xyXG5cdFx0clsgNSBdID0gbVsgNyBdO1xyXG5cdFx0clsgNiBdID0gbVsgMiBdO1xyXG5cdFx0clsgNyBdID0gbVsgNSBdO1xyXG5cdFx0clsgOCBdID0gbVsgOCBdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5NYXRyaXgzKFxyXG5cclxuXHRcdFx0dGVbMF0sIHRlWzNdLCB0ZVs2XSxcclxuXHRcdFx0dGVbMV0sIHRlWzRdLCB0ZVs3XSxcclxuXHRcdFx0dGVbMl0sIHRlWzVdLCB0ZVs4XVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgcGhpbG9nYiAvIGh0dHA6Ly9ibG9nLnRoZWppdC5vcmcvXHJcbiAqIEBhdXRob3Igam9yZGlfcm9zIC8gaHR0cDovL3BsYXR0c29mdC5jb21cclxuICogQGF1dGhvciBEMXBsbzFkIC8gaHR0cDovL2dpdGh1Yi5jb20vRDFwbG8xZFxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIHRpbWtuaXAgLyBodHRwOi8vd3d3LmZsb29ycGxhbm5lci5jb20vXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblxyXG5USFJFRS5NYXRyaXg0ID0gZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XHJcblxyXG5cdHZhciB0ZSA9IHRoaXMuZWxlbWVudHMgPSBuZXcgRmxvYXQzMkFycmF5KCAxNiApO1xyXG5cclxuXHQvLyBUT0RPOiBpZiBuMTEgaXMgdW5kZWZpbmVkLCB0aGVuIGp1c3Qgc2V0IHRvIGlkZW50aXR5LCBvdGhlcndpc2UgY29weSBhbGwgb3RoZXIgdmFsdWVzIGludG8gbWF0cml4XHJcblx0Ly8gICB3ZSBzaG91bGQgbm90IHN1cHBvcnQgc2VtaSBzcGVjaWZpY2F0aW9uIG9mIE1hdHJpeDQsIGl0IGlzIGp1c3Qgd2VpcmQuXHJcblxyXG5cdHRlWzBdID0gKCBuMTEgIT09IHVuZGVmaW5lZCApID8gbjExIDogMTsgdGVbNF0gPSBuMTIgfHwgMDsgdGVbOF0gPSBuMTMgfHwgMDsgdGVbMTJdID0gbjE0IHx8IDA7XHJcblx0dGVbMV0gPSBuMjEgfHwgMDsgdGVbNV0gPSAoIG4yMiAhPT0gdW5kZWZpbmVkICkgPyBuMjIgOiAxOyB0ZVs5XSA9IG4yMyB8fCAwOyB0ZVsxM10gPSBuMjQgfHwgMDtcclxuXHR0ZVsyXSA9IG4zMSB8fCAwOyB0ZVs2XSA9IG4zMiB8fCAwOyB0ZVsxMF0gPSAoIG4zMyAhPT0gdW5kZWZpbmVkICkgPyBuMzMgOiAxOyB0ZVsxNF0gPSBuMzQgfHwgMDtcclxuXHR0ZVszXSA9IG40MSB8fCAwOyB0ZVs3XSA9IG40MiB8fCAwOyB0ZVsxMV0gPSBuNDMgfHwgMDsgdGVbMTVdID0gKCBuNDQgIT09IHVuZGVmaW5lZCApID8gbjQ0IDogMTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5leHRlbmQoIFRIUkVFLk1hdHJpeDQucHJvdG90eXBlLCB7XHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0ZVswXSA9IG4xMTsgdGVbNF0gPSBuMTI7IHRlWzhdID0gbjEzOyB0ZVsxMl0gPSBuMTQ7XHJcblx0XHR0ZVsxXSA9IG4yMTsgdGVbNV0gPSBuMjI7IHRlWzldID0gbjIzOyB0ZVsxM10gPSBuMjQ7XHJcblx0XHR0ZVsyXSA9IG4zMTsgdGVbNl0gPSBuMzI7IHRlWzEwXSA9IG4zMzsgdGVbMTRdID0gbjM0O1xyXG5cdFx0dGVbM10gPSBuNDE7IHRlWzddID0gbjQyOyB0ZVsxMV0gPSBuNDM7IHRlWzE1XSA9IG40NDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdDEsIDAsIDAsIDAsXHJcblx0XHRcdDAsIDEsIDAsIDAsXHJcblx0XHRcdDAsIDAsIDEsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIG1lID0gbS5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdG1lWzBdLCBtZVs0XSwgbWVbOF0sIG1lWzEyXSxcclxuXHRcdFx0bWVbMV0sIG1lWzVdLCBtZVs5XSwgbWVbMTNdLFxyXG5cdFx0XHRtZVsyXSwgbWVbNl0sIG1lWzEwXSwgbWVbMTRdLFxyXG5cdFx0XHRtZVszXSwgbWVbN10sIG1lWzExXSwgbWVbMTVdXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0Um90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggdiwgb3JkZXIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcclxuXHRcdHZhciBhID0gTWF0aC5jb3MoIHggKSwgYiA9IE1hdGguc2luKCB4ICk7XHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB5ICksIGQgPSBNYXRoLnNpbiggeSApO1xyXG5cdFx0dmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcclxuXHJcblx0XHRpZiAoIG9yZGVyID09PSB1bmRlZmluZWQgfHwgb3JkZXIgPT09ICdYWVonICkge1xyXG5cclxuXHRcdFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XHJcblxyXG5cdFx0XHR0ZVswXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVs0XSA9IC0gYyAqIGY7XHJcblx0XHRcdHRlWzhdID0gZDtcclxuXHJcblx0XHRcdHRlWzFdID0gYWYgKyBiZSAqIGQ7XHJcblx0XHRcdHRlWzVdID0gYWUgLSBiZiAqIGQ7XHJcblx0XHRcdHRlWzldID0gLSBiICogYztcclxuXHJcblx0XHRcdHRlWzJdID0gYmYgLSBhZSAqIGQ7XHJcblx0XHRcdHRlWzZdID0gYmUgKyBhZiAqIGQ7XHJcblx0XHRcdHRlWzEwXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcclxuXHJcblx0XHRcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xyXG5cclxuXHRcdFx0dGVbMF0gPSBjZSArIGRmICogYjtcclxuXHRcdFx0dGVbNF0gPSBkZSAqIGIgLSBjZjtcclxuXHRcdFx0dGVbOF0gPSBhICogZDtcclxuXHJcblx0XHRcdHRlWzFdID0gYSAqIGY7XHJcblx0XHRcdHRlWzVdID0gYSAqIGU7XHJcblx0XHRcdHRlWzldID0gLSBiO1xyXG5cclxuXHRcdFx0dGVbMl0gPSBjZiAqIGIgLSBkZTtcclxuXHRcdFx0dGVbNl0gPSBkZiArIGNlICogYjtcclxuXHRcdFx0dGVbMTBdID0gYSAqIGM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdaWFknICkge1xyXG5cclxuXHRcdFx0dmFyIGNlID0gYyAqIGUsIGNmID0gYyAqIGYsIGRlID0gZCAqIGUsIGRmID0gZCAqIGY7XHJcblxyXG5cdFx0XHR0ZVswXSA9IGNlIC0gZGYgKiBiO1xyXG5cdFx0XHR0ZVs0XSA9IC0gYSAqIGY7XHJcblx0XHRcdHRlWzhdID0gZGUgKyBjZiAqIGI7XHJcblxyXG5cdFx0XHR0ZVsxXSA9IGNmICsgZGUgKiBiO1xyXG5cdFx0XHR0ZVs1XSA9IGEgKiBlO1xyXG5cdFx0XHR0ZVs5XSA9IGRmIC0gY2UgKiBiO1xyXG5cclxuXHRcdFx0dGVbMl0gPSAtIGEgKiBkO1xyXG5cdFx0XHR0ZVs2XSA9IGI7XHJcblx0XHRcdHRlWzEwXSA9IGEgKiBjO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcclxuXHJcblx0XHRcdHZhciBhZSA9IGEgKiBlLCBhZiA9IGEgKiBmLCBiZSA9IGIgKiBlLCBiZiA9IGIgKiBmO1xyXG5cclxuXHRcdFx0dGVbMF0gPSBjICogZTtcclxuXHRcdFx0dGVbNF0gPSBiZSAqIGQgLSBhZjtcclxuXHRcdFx0dGVbOF0gPSBhZSAqIGQgKyBiZjtcclxuXHJcblx0XHRcdHRlWzFdID0gYyAqIGY7XHJcblx0XHRcdHRlWzVdID0gYmYgKiBkICsgYWU7XHJcblx0XHRcdHRlWzldID0gYWYgKiBkIC0gYmU7XHJcblxyXG5cdFx0XHR0ZVsyXSA9IC0gZDtcclxuXHRcdFx0dGVbNl0gPSBiICogYztcclxuXHRcdFx0dGVbMTBdID0gYSAqIGM7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xyXG5cclxuXHRcdFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XHJcblxyXG5cdFx0XHR0ZVswXSA9IGMgKiBlO1xyXG5cdFx0XHR0ZVs0XSA9IGJkIC0gYWMgKiBmO1xyXG5cdFx0XHR0ZVs4XSA9IGJjICogZiArIGFkO1xyXG5cclxuXHRcdFx0dGVbMV0gPSBmO1xyXG5cdFx0XHR0ZVs1XSA9IGEgKiBlO1xyXG5cdFx0XHR0ZVs5XSA9IC0gYiAqIGU7XHJcblxyXG5cdFx0XHR0ZVsyXSA9IC0gZCAqIGU7XHJcblx0XHRcdHRlWzZdID0gYWQgKiBmICsgYmM7XHJcblx0XHRcdHRlWzEwXSA9IGFjIC0gYmQgKiBmO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcclxuXHJcblx0XHRcdHZhciBhYyA9IGEgKiBjLCBhZCA9IGEgKiBkLCBiYyA9IGIgKiBjLCBiZCA9IGIgKiBkO1xyXG5cclxuXHRcdFx0dGVbMF0gPSBjICogZTtcclxuXHRcdFx0dGVbNF0gPSAtIGY7XHJcblx0XHRcdHRlWzhdID0gZCAqIGU7XHJcblxyXG5cdFx0XHR0ZVsxXSA9IGFjICogZiArIGJkO1xyXG5cdFx0XHR0ZVs1XSA9IGEgKiBlO1xyXG5cdFx0XHR0ZVs5XSA9IGFkICogZiAtIGJjO1xyXG5cclxuXHRcdFx0dGVbMl0gPSBiYyAqIGYgLSBhZDtcclxuXHRcdFx0dGVbNl0gPSBiICogZTtcclxuXHRcdFx0dGVbMTBdID0gYmQgKiBmICsgYWM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgeCA9IHEueCwgeSA9IHEueSwgeiA9IHEueiwgdyA9IHEudztcclxuXHRcdHZhciB4MiA9IHggKyB4LCB5MiA9IHkgKyB5LCB6MiA9IHogKyB6O1xyXG5cdFx0dmFyIHh4ID0geCAqIHgyLCB4eSA9IHggKiB5MiwgeHogPSB4ICogejI7XHJcblx0XHR2YXIgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6MjtcclxuXHRcdHZhciB3eCA9IHcgKiB4Miwgd3kgPSB3ICogeTIsIHd6ID0gdyAqIHoyO1xyXG5cclxuXHRcdHRlWzBdID0gMSAtICggeXkgKyB6eiApO1xyXG5cdFx0dGVbNF0gPSB4eSAtIHd6O1xyXG5cdFx0dGVbOF0gPSB4eiArIHd5O1xyXG5cclxuXHRcdHRlWzFdID0geHkgKyB3ejtcclxuXHRcdHRlWzVdID0gMSAtICggeHggKyB6eiApO1xyXG5cdFx0dGVbOV0gPSB5eiAtIHd4O1xyXG5cclxuXHRcdHRlWzJdID0geHogLSB3eTtcclxuXHRcdHRlWzZdID0geXogKyB3eDtcclxuXHRcdHRlWzEwXSA9IDEgLSAoIHh4ICsgeXkgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bG9va0F0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgeCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgeSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgeiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZXllLCB0YXJnZXQsIHVwICkge1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRcdHouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGlmICggei5sZW5ndGgoKSA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0ei56ID0gMTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0aWYgKCB4Lmxlbmd0aCgpID09PSAwICkge1xyXG5cclxuXHRcdFx0XHR6LnggKz0gMC4wMDAxO1xyXG5cdFx0XHRcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0eS5jcm9zc1ZlY3RvcnMoIHosIHggKTtcclxuXHJcblxyXG5cdFx0XHR0ZVswXSA9IHgueDsgdGVbNF0gPSB5Lng7IHRlWzhdID0gei54O1xyXG5cdFx0XHR0ZVsxXSA9IHgueTsgdGVbNV0gPSB5Lnk7IHRlWzldID0gei55O1xyXG5cdFx0XHR0ZVsyXSA9IHguejsgdGVbNl0gPSB5Lno7IHRlWzEwXSA9IHouejtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bXVsdGlwbHk6IGZ1bmN0aW9uICggbSwgbiApIHtcclxuXHJcblx0XHRpZiAoIG4gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IE1hdHJpeDRcXCdzIC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcclxuXHRcdFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLCBtICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG11bHRpcGx5TWF0cmljZXM6IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHR2YXIgYWUgPSBhLmVsZW1lbnRzO1xyXG5cdFx0dmFyIGJlID0gYi5lbGVtZW50cztcclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIGExMSA9IGFlWzBdLCBhMTIgPSBhZVs0XSwgYTEzID0gYWVbOF0sIGExNCA9IGFlWzEyXTtcclxuXHRcdHZhciBhMjEgPSBhZVsxXSwgYTIyID0gYWVbNV0sIGEyMyA9IGFlWzldLCBhMjQgPSBhZVsxM107XHJcblx0XHR2YXIgYTMxID0gYWVbMl0sIGEzMiA9IGFlWzZdLCBhMzMgPSBhZVsxMF0sIGEzNCA9IGFlWzE0XTtcclxuXHRcdHZhciBhNDEgPSBhZVszXSwgYTQyID0gYWVbN10sIGE0MyA9IGFlWzExXSwgYTQ0ID0gYWVbMTVdO1xyXG5cclxuXHRcdHZhciBiMTEgPSBiZVswXSwgYjEyID0gYmVbNF0sIGIxMyA9IGJlWzhdLCBiMTQgPSBiZVsxMl07XHJcblx0XHR2YXIgYjIxID0gYmVbMV0sIGIyMiA9IGJlWzVdLCBiMjMgPSBiZVs5XSwgYjI0ID0gYmVbMTNdO1xyXG5cdFx0dmFyIGIzMSA9IGJlWzJdLCBiMzIgPSBiZVs2XSwgYjMzID0gYmVbMTBdLCBiMzQgPSBiZVsxNF07XHJcblx0XHR2YXIgYjQxID0gYmVbM10sIGI0MiA9IGJlWzddLCBiNDMgPSBiZVsxMV0sIGI0NCA9IGJlWzE1XTtcclxuXHJcblx0XHR0ZVswXSA9IGExMSAqIGIxMSArIGExMiAqIGIyMSArIGExMyAqIGIzMSArIGExNCAqIGI0MTtcclxuXHRcdHRlWzRdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xyXG5cdFx0dGVbOF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XHJcblx0XHR0ZVsxMl0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbMV0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XHJcblx0XHR0ZVs1XSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0MjtcclxuXHRcdHRlWzldID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG5cdFx0dGVbMTNdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xyXG5cclxuXHRcdHRlWzJdID0gYTMxICogYjExICsgYTMyICogYjIxICsgYTMzICogYjMxICsgYTM0ICogYjQxO1xyXG5cdFx0dGVbNl0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XHJcblx0XHR0ZVsxMF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XHJcblx0XHR0ZVsxNF0gPSBhMzEgKiBiMTQgKyBhMzIgKiBiMjQgKyBhMzMgKiBiMzQgKyBhMzQgKiBiNDQ7XHJcblxyXG5cdFx0dGVbM10gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XHJcblx0XHR0ZVs3XSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcclxuXHRcdHRlWzExXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0MztcclxuXHRcdHRlWzE1XSA9IGE0MSAqIGIxNCArIGE0MiAqIGIyNCArIGE0MyAqIGIzNCArIGE0NCAqIGI0NDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlUb0FycmF5OiBmdW5jdGlvbiAoIGEsIGIsIHIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR0aGlzLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKTtcclxuXHJcblx0XHRyWyAwIF0gPSB0ZVswXTsgclsgMSBdID0gdGVbMV07IHJbIDIgXSA9IHRlWzJdOyByWyAzIF0gPSB0ZVszXTtcclxuXHRcdHJbIDQgXSA9IHRlWzRdOyByWyA1IF0gPSB0ZVs1XTsgclsgNiBdID0gdGVbNl07IHJbIDcgXSA9IHRlWzddO1xyXG5cdFx0clsgOCBdICA9IHRlWzhdOyByWyA5IF0gID0gdGVbOV07IHJbIDEwIF0gPSB0ZVsxMF07IHJbIDExIF0gPSB0ZVsxMV07XHJcblx0XHRyWyAxMiBdID0gdGVbMTJdOyByWyAxMyBdID0gdGVbMTNdOyByWyAxNCBdID0gdGVbMTRdOyByWyAxNSBdID0gdGVbMTVdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbMF0gKj0gczsgdGVbNF0gKj0gczsgdGVbOF0gKj0gczsgdGVbMTJdICo9IHM7XHJcblx0XHR0ZVsxXSAqPSBzOyB0ZVs1XSAqPSBzOyB0ZVs5XSAqPSBzOyB0ZVsxM10gKj0gcztcclxuXHRcdHRlWzJdICo9IHM7IHRlWzZdICo9IHM7IHRlWzEwXSAqPSBzOyB0ZVsxNF0gKj0gcztcclxuXHRcdHRlWzNdICo9IHM7IHRlWzddICo9IHM7IHRlWzExXSAqPSBzOyB0ZVsxNV0gKj0gcztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBNYXRyaXg0XFwncyAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIG9yIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3I0OiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRjb25zb2xlLndhcm4oICdERVBSRUNBVEVEOiBNYXRyaXg0XFwncyAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlWZWN0b3IzQXJyYXk6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggYSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhLmxlbmd0aDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdHYxLnggPSBhWyBpIF07XHJcblx0XHRcdFx0djEueSA9IGFbIGkgKyAxIF07XHJcblx0XHRcdFx0djEueiA9IGFbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdHYxLmFwcGx5UHJvamVjdGlvbiggdGhpcyApO1xyXG5cclxuXHRcdFx0XHRhWyBpIF0gICAgID0gdjEueDtcclxuXHRcdFx0XHRhWyBpICsgMSBdID0gdjEueTtcclxuXHRcdFx0XHRhWyBpICsgMiBdID0gdjEuejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBhO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cm90YXRlQXhpczogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgdnggPSB2LngsIHZ5ID0gdi55LCB2eiA9IHYuejtcclxuXHJcblx0XHR2LnggPSB2eCAqIHRlWzBdICsgdnkgKiB0ZVs0XSArIHZ6ICogdGVbOF07XHJcblx0XHR2LnkgPSB2eCAqIHRlWzFdICsgdnkgKiB0ZVs1XSArIHZ6ICogdGVbOV07XHJcblx0XHR2LnogPSB2eCAqIHRlWzJdICsgdnkgKiB0ZVs2XSArIHZ6ICogdGVbMTBdO1xyXG5cclxuXHRcdHYubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHY7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNyb3NzVmVjdG9yOiBmdW5jdGlvbiAoIGEgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjQoKTtcclxuXHJcblx0XHR2LnggPSB0ZVswXSAqIGEueCArIHRlWzRdICogYS55ICsgdGVbOF0gKiBhLnogKyB0ZVsxMl0gKiBhLnc7XHJcblx0XHR2LnkgPSB0ZVsxXSAqIGEueCArIHRlWzVdICogYS55ICsgdGVbOV0gKiBhLnogKyB0ZVsxM10gKiBhLnc7XHJcblx0XHR2LnogPSB0ZVsyXSAqIGEueCArIHRlWzZdICogYS55ICsgdGVbMTBdICogYS56ICsgdGVbMTRdICogYS53O1xyXG5cclxuXHRcdHYudyA9ICggYS53ICkgPyB0ZVszXSAqIGEueCArIHRlWzddICogYS55ICsgdGVbMTFdICogYS56ICsgdGVbMTVdICogYS53IDogMTtcclxuXHJcblx0XHRyZXR1cm4gdjtcclxuXHJcblx0fSxcclxuXHJcblx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cclxuXHRcdHZhciBuMTEgPSB0ZVswXSwgbjEyID0gdGVbNF0sIG4xMyA9IHRlWzhdLCBuMTQgPSB0ZVsxMl07XHJcblx0XHR2YXIgbjIxID0gdGVbMV0sIG4yMiA9IHRlWzVdLCBuMjMgPSB0ZVs5XSwgbjI0ID0gdGVbMTNdO1xyXG5cdFx0dmFyIG4zMSA9IHRlWzJdLCBuMzIgPSB0ZVs2XSwgbjMzID0gdGVbMTBdLCBuMzQgPSB0ZVsxNF07XHJcblx0XHR2YXIgbjQxID0gdGVbM10sIG40MiA9IHRlWzddLCBuNDMgPSB0ZVsxMV0sIG40NCA9IHRlWzE1XTtcclxuXHJcblx0XHQvL1RPRE86IG1ha2UgdGhpcyBtb3JlIGVmZmljaWVudFxyXG5cdFx0Ly8oIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bSApXHJcblxyXG5cdFx0cmV0dXJuIChcclxuXHRcdFx0bjQxICogKFxyXG5cdFx0XHRcdCtuMTQgKiBuMjMgKiBuMzJcclxuXHRcdFx0XHQtbjEzICogbjI0ICogbjMyXHJcblx0XHRcdFx0LW4xNCAqIG4yMiAqIG4zM1xyXG5cdFx0XHRcdCtuMTIgKiBuMjQgKiBuMzNcclxuXHRcdFx0XHQrbjEzICogbjIyICogbjM0XHJcblx0XHRcdFx0LW4xMiAqIG4yMyAqIG4zNFxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQyICogKFxyXG5cdFx0XHRcdCtuMTEgKiBuMjMgKiBuMzRcclxuXHRcdFx0XHQtbjExICogbjI0ICogbjMzXHJcblx0XHRcdFx0K24xNCAqIG4yMSAqIG4zM1xyXG5cdFx0XHRcdC1uMTMgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHQrbjEzICogbjI0ICogbjMxXHJcblx0XHRcdFx0LW4xNCAqIG4yMyAqIG4zMVxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQzICogKFxyXG5cdFx0XHRcdCtuMTEgKiBuMjQgKiBuMzJcclxuXHRcdFx0XHQtbjExICogbjIyICogbjM0XHJcblx0XHRcdFx0LW4xNCAqIG4yMSAqIG4zMlxyXG5cdFx0XHRcdCtuMTIgKiBuMjEgKiBuMzRcclxuXHRcdFx0XHQrbjE0ICogbjIyICogbjMxXHJcblx0XHRcdFx0LW4xMiAqIG4yNCAqIG4zMVxyXG5cdFx0XHQpICtcclxuXHRcdFx0bjQ0ICogKFxyXG5cdFx0XHRcdC1uMTMgKiBuMjIgKiBuMzFcclxuXHRcdFx0XHQtbjExICogbjIzICogbjMyXHJcblx0XHRcdFx0K24xMSAqIG4yMiAqIG4zM1xyXG5cdFx0XHRcdCtuMTMgKiBuMjEgKiBuMzJcclxuXHRcdFx0XHQtbjEyICogbjIxICogbjMzXHJcblx0XHRcdFx0K24xMiAqIG4yMyAqIG4zMVxyXG5cdFx0XHQpXHJcblxyXG5cdFx0KTtcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB0bXA7XHJcblxyXG5cdFx0dG1wID0gdGVbMV07IHRlWzFdID0gdGVbNF07IHRlWzRdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbMl07IHRlWzJdID0gdGVbOF07IHRlWzhdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbNl07IHRlWzZdID0gdGVbOV07IHRlWzldID0gdG1wO1xyXG5cclxuXHRcdHRtcCA9IHRlWzNdOyB0ZVszXSA9IHRlWzEyXTsgdGVbMTJdID0gdG1wO1xyXG5cdFx0dG1wID0gdGVbN107IHRlWzddID0gdGVbMTNdOyB0ZVsxM10gPSB0bXA7XHJcblx0XHR0bXAgPSB0ZVsxMV07IHRlWzExXSA9IHRlWzE0XTsgdGVbMTRdID0gdG1wO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRmbGF0dGVuVG9BcnJheTogZnVuY3Rpb24gKCBmbGF0ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRmbGF0WyAwIF0gPSB0ZVswXTsgZmxhdFsgMSBdID0gdGVbMV07IGZsYXRbIDIgXSA9IHRlWzJdOyBmbGF0WyAzIF0gPSB0ZVszXTtcclxuXHRcdGZsYXRbIDQgXSA9IHRlWzRdOyBmbGF0WyA1IF0gPSB0ZVs1XTsgZmxhdFsgNiBdID0gdGVbNl07IGZsYXRbIDcgXSA9IHRlWzddO1xyXG5cdFx0ZmxhdFsgOCBdID0gdGVbOF07IGZsYXRbIDkgXSA9IHRlWzldOyBmbGF0WyAxMCBdID0gdGVbMTBdOyBmbGF0WyAxMSBdID0gdGVbMTFdO1xyXG5cdFx0ZmxhdFsgMTIgXSA9IHRlWzEyXTsgZmxhdFsgMTMgXSA9IHRlWzEzXTsgZmxhdFsgMTQgXSA9IHRlWzE0XTsgZmxhdFsgMTUgXSA9IHRlWzE1XTtcclxuXHJcblx0XHRyZXR1cm4gZmxhdDtcclxuXHJcblx0fSxcclxuXHJcblx0ZmxhdHRlblRvQXJyYXlPZmZzZXQ6IGZ1bmN0aW9uKCBmbGF0LCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdGZsYXRbIG9mZnNldCBdID0gdGVbMF07XHJcblx0XHRmbGF0WyBvZmZzZXQgKyAxIF0gPSB0ZVsxXTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDIgXSA9IHRlWzJdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMyBdID0gdGVbM107XHJcblxyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgNCBdID0gdGVbNF07XHJcblx0XHRmbGF0WyBvZmZzZXQgKyA1IF0gPSB0ZVs1XTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDYgXSA9IHRlWzZdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgNyBdID0gdGVbN107XHJcblxyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgOCBdICA9IHRlWzhdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgOSBdICA9IHRlWzldO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMTAgXSA9IHRlWzEwXTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDExIF0gPSB0ZVsxMV07XHJcblxyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMTIgXSA9IHRlWzEyXTtcclxuXHRcdGZsYXRbIG9mZnNldCArIDEzIF0gPSB0ZVsxM107XHJcblx0XHRmbGF0WyBvZmZzZXQgKyAxNCBdID0gdGVbMTRdO1xyXG5cdFx0ZmxhdFsgb2Zmc2V0ICsgMTUgXSA9IHRlWzE1XTtcclxuXHJcblx0XHRyZXR1cm4gZmxhdDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ0RFUFJFQ0FURUQ6IE1hdHJpeDRcXCdzIC5nZXRQb3NpdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggbWF0cml4ICkgaW5zdGVhZC4nICk7XHJcblxyXG5cdFx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0XHRyZXR1cm4gdjEuc2V0KCB0ZVsxMl0sIHRlWzEzXSwgdGVbMTRdICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbMTJdID0gdi54O1xyXG5cdFx0dGVbMTNdID0gdi55O1xyXG5cdFx0dGVbMTRdID0gdi56O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG0sIHRocm93T25JbnZlcnRpYmxlICkge1xyXG5cclxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dmFyIG4xMSA9IG1lWzBdLCBuMTIgPSBtZVs0XSwgbjEzID0gbWVbOF0sIG4xNCA9IG1lWzEyXTtcclxuXHRcdHZhciBuMjEgPSBtZVsxXSwgbjIyID0gbWVbNV0sIG4yMyA9IG1lWzldLCBuMjQgPSBtZVsxM107XHJcblx0XHR2YXIgbjMxID0gbWVbMl0sIG4zMiA9IG1lWzZdLCBuMzMgPSBtZVsxMF0sIG4zNCA9IG1lWzE0XTtcclxuXHRcdHZhciBuNDEgPSBtZVszXSwgbjQyID0gbWVbN10sIG40MyA9IG1lWzExXSwgbjQ0ID0gbWVbMTVdO1xyXG5cclxuXHRcdHRlWzBdID0gbjIzKm4zNCpuNDIgLSBuMjQqbjMzKm40MiArIG4yNCpuMzIqbjQzIC0gbjIyKm4zNCpuNDMgLSBuMjMqbjMyKm40NCArIG4yMipuMzMqbjQ0O1xyXG5cdFx0dGVbNF0gPSBuMTQqbjMzKm40MiAtIG4xMypuMzQqbjQyIC0gbjE0Km4zMipuNDMgKyBuMTIqbjM0Km40MyArIG4xMypuMzIqbjQ0IC0gbjEyKm4zMypuNDQ7XHJcblx0XHR0ZVs4XSA9IG4xMypuMjQqbjQyIC0gbjE0Km4yMypuNDIgKyBuMTQqbjIyKm40MyAtIG4xMipuMjQqbjQzIC0gbjEzKm4yMipuNDQgKyBuMTIqbjIzKm40NDtcclxuXHRcdHRlWzEyXSA9IG4xNCpuMjMqbjMyIC0gbjEzKm4yNCpuMzIgLSBuMTQqbjIyKm4zMyArIG4xMipuMjQqbjMzICsgbjEzKm4yMipuMzQgLSBuMTIqbjIzKm4zNDtcclxuXHRcdHRlWzFdID0gbjI0Km4zMypuNDEgLSBuMjMqbjM0Km40MSAtIG4yNCpuMzEqbjQzICsgbjIxKm4zNCpuNDMgKyBuMjMqbjMxKm40NCAtIG4yMSpuMzMqbjQ0O1xyXG5cdFx0dGVbNV0gPSBuMTMqbjM0Km40MSAtIG4xNCpuMzMqbjQxICsgbjE0Km4zMSpuNDMgLSBuMTEqbjM0Km40MyAtIG4xMypuMzEqbjQ0ICsgbjExKm4zMypuNDQ7XHJcblx0XHR0ZVs5XSA9IG4xNCpuMjMqbjQxIC0gbjEzKm4yNCpuNDEgLSBuMTQqbjIxKm40MyArIG4xMSpuMjQqbjQzICsgbjEzKm4yMSpuNDQgLSBuMTEqbjIzKm40NDtcclxuXHRcdHRlWzEzXSA9IG4xMypuMjQqbjMxIC0gbjE0Km4yMypuMzEgKyBuMTQqbjIxKm4zMyAtIG4xMSpuMjQqbjMzIC0gbjEzKm4yMSpuMzQgKyBuMTEqbjIzKm4zNDtcclxuXHRcdHRlWzJdID0gbjIyKm4zNCpuNDEgLSBuMjQqbjMyKm40MSArIG4yNCpuMzEqbjQyIC0gbjIxKm4zNCpuNDIgLSBuMjIqbjMxKm40NCArIG4yMSpuMzIqbjQ0O1xyXG5cdFx0dGVbNl0gPSBuMTQqbjMyKm40MSAtIG4xMipuMzQqbjQxIC0gbjE0Km4zMSpuNDIgKyBuMTEqbjM0Km40MiArIG4xMipuMzEqbjQ0IC0gbjExKm4zMipuNDQ7XHJcblx0XHR0ZVsxMF0gPSBuMTIqbjI0Km40MSAtIG4xNCpuMjIqbjQxICsgbjE0Km4yMSpuNDIgLSBuMTEqbjI0Km40MiAtIG4xMipuMjEqbjQ0ICsgbjExKm4yMipuNDQ7XHJcblx0XHR0ZVsxNF0gPSBuMTQqbjIyKm4zMSAtIG4xMipuMjQqbjMxIC0gbjE0Km4yMSpuMzIgKyBuMTEqbjI0Km4zMiArIG4xMipuMjEqbjM0IC0gbjExKm4yMipuMzQ7XHJcblx0XHR0ZVszXSA9IG4yMypuMzIqbjQxIC0gbjIyKm4zMypuNDEgLSBuMjMqbjMxKm40MiArIG4yMSpuMzMqbjQyICsgbjIyKm4zMSpuNDMgLSBuMjEqbjMyKm40MztcclxuXHRcdHRlWzddID0gbjEyKm4zMypuNDEgLSBuMTMqbjMyKm40MSArIG4xMypuMzEqbjQyIC0gbjExKm4zMypuNDIgLSBuMTIqbjMxKm40MyArIG4xMSpuMzIqbjQzO1xyXG5cdFx0dGVbMTFdID0gbjEzKm4yMipuNDEgLSBuMTIqbjIzKm40MSAtIG4xMypuMjEqbjQyICsgbjExKm4yMypuNDIgKyBuMTIqbjIxKm40MyAtIG4xMSpuMjIqbjQzO1xyXG5cdFx0dGVbMTVdID0gbjEyKm4yMypuMzEgLSBuMTMqbjIyKm4zMSArIG4xMypuMjEqbjMyIC0gbjExKm4yMypuMzIgLSBuMTIqbjIxKm4zMyArIG4xMSpuMjIqbjMzO1xyXG5cclxuXHRcdHZhciBkZXQgPSBtZVsgMCBdICogdGVbIDAgXSArIG1lWyAxIF0gKiB0ZVsgNCBdICsgbWVbIDIgXSAqIHRlWyA4IF0gKyBtZVsgMyBdICogdGVbIDEyIF07XHJcblxyXG5cdFx0aWYgKCBkZXQgPT0gMCApIHtcclxuXHJcblx0XHRcdHZhciBtc2cgPSBcIk1hdHJpeDQuZ2V0SW52ZXJzZSgpOiBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXCI7XHJcblxyXG5cdFx0XHRpZiAoIHRocm93T25JbnZlcnRpYmxlIHx8IGZhbHNlICkge1xyXG5cclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApOyBcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUud2FybiggbXNnICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmlkZW50aXR5KCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gZGV0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXBvc2U6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciBtUm90YXRpb24gPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cdFx0XHRtU2NhbGUgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdFx0XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCB0cmFuc2xhdGlvbiwgcm90YXRpb24sIHNjYWxlICkge1xyXG5cclxuXHRcdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHRcdG1Sb3RhdGlvbi5pZGVudGl0eSgpO1xyXG5cdFx0XHRtUm90YXRpb24uc2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbiggcm90YXRpb24gKTtcclxuXHJcblx0XHRcdG1TY2FsZS5tYWtlU2NhbGUoIHNjYWxlLngsIHNjYWxlLnksIHNjYWxlLnogKTtcclxuXHJcblx0XHRcdHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbVJvdGF0aW9uLCBtU2NhbGUgKTtcclxuXHJcblx0XHRcdHRlWzEyXSA9IHRyYW5zbGF0aW9uLng7XHJcblx0XHRcdHRlWzEzXSA9IHRyYW5zbGF0aW9uLnk7XHJcblx0XHRcdHRlWzE0XSA9IHRyYW5zbGF0aW9uLno7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGRlY29tcG9zZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHggPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHR5ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0eiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdG1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggdHJhbnNsYXRpb24sIHJvdGF0aW9uLCBzY2FsZSApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0XHQvLyBncmFiIHRoZSBheGlzIHZlY3RvcnNcclxuXHRcdFx0eC5zZXQoIHRlWzBdLCB0ZVsxXSwgdGVbMl0gKTtcclxuXHRcdFx0eS5zZXQoIHRlWzRdLCB0ZVs1XSwgdGVbNl0gKTtcclxuXHRcdFx0ei5zZXQoIHRlWzhdLCB0ZVs5XSwgdGVbMTBdICk7XHJcblxyXG5cdFx0XHR0cmFuc2xhdGlvbiA9ICggdHJhbnNsYXRpb24gaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICkgPyB0cmFuc2xhdGlvbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdHJvdGF0aW9uID0gKCByb3RhdGlvbiBpbnN0YW5jZW9mIFRIUkVFLlF1YXRlcm5pb24gKSA/IHJvdGF0aW9uIDogbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcclxuXHRcdFx0c2NhbGUgPSAoIHNjYWxlIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyApID8gc2NhbGUgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0c2NhbGUueCA9IHgubGVuZ3RoKCk7XHJcblx0XHRcdHNjYWxlLnkgPSB5Lmxlbmd0aCgpO1xyXG5cdFx0XHRzY2FsZS56ID0gei5sZW5ndGgoKTtcclxuXHJcblx0XHRcdHRyYW5zbGF0aW9uLnggPSB0ZVsxMl07XHJcblx0XHRcdHRyYW5zbGF0aW9uLnkgPSB0ZVsxM107XHJcblx0XHRcdHRyYW5zbGF0aW9uLnogPSB0ZVsxNF07XHJcblxyXG5cdFx0XHQvLyBzY2FsZSB0aGUgcm90YXRpb24gcGFydFxyXG5cclxuXHRcdFx0bWF0cml4LmNvcHkoIHRoaXMgKTtcclxuXHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1swXSAvPSBzY2FsZS54O1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbMV0gLz0gc2NhbGUueDtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWzJdIC89IHNjYWxlLng7XHJcblxyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbNF0gLz0gc2NhbGUueTtcclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWzVdIC89IHNjYWxlLnk7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1s2XSAvPSBzY2FsZS55O1xyXG5cclxuXHRcdFx0bWF0cml4LmVsZW1lbnRzWzhdIC89IHNjYWxlLno7XHJcblx0XHRcdG1hdHJpeC5lbGVtZW50c1s5XSAvPSBzY2FsZS56O1xyXG5cdFx0XHRtYXRyaXguZWxlbWVudHNbMTBdIC89IHNjYWxlLno7XHJcblxyXG5cdFx0XHRyb3RhdGlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIFsgdHJhbnNsYXRpb24sIHJvdGF0aW9uLCBzY2FsZSBdO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0ZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0dGVbMTJdID0gbWVbMTJdO1xyXG5cdFx0dGVbMTNdID0gbWVbMTNdO1xyXG5cdFx0dGVbMTRdID0gbWVbMTRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRleHRyYWN0Um90YXRpb246IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggbSApIHtcclxuXHJcblx0XHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblxyXG5cdFx0XHR2YXIgc2NhbGVYID0gMSAvIHYxLnNldCggbWVbMF0sIG1lWzFdLCBtZVsyXSApLmxlbmd0aCgpO1xyXG5cdFx0XHR2YXIgc2NhbGVZID0gMSAvIHYxLnNldCggbWVbNF0sIG1lWzVdLCBtZVs2XSApLmxlbmd0aCgpO1xyXG5cdFx0XHR2YXIgc2NhbGVaID0gMSAvIHYxLnNldCggbWVbOF0sIG1lWzldLCBtZVsxMF0gKS5sZW5ndGgoKTtcclxuXHJcblx0XHRcdHRlWzBdID0gbWVbMF0gKiBzY2FsZVg7XHJcblx0XHRcdHRlWzFdID0gbWVbMV0gKiBzY2FsZVg7XHJcblx0XHRcdHRlWzJdID0gbWVbMl0gKiBzY2FsZVg7XHJcblxyXG5cdFx0XHR0ZVs0XSA9IG1lWzRdICogc2NhbGVZO1xyXG5cdFx0XHR0ZVs1XSA9IG1lWzVdICogc2NhbGVZO1xyXG5cdFx0XHR0ZVs2XSA9IG1lWzZdICogc2NhbGVZO1xyXG5cclxuXHRcdFx0dGVbOF0gPSBtZVs4XSAqIHNjYWxlWjtcclxuXHRcdFx0dGVbOV0gPSBtZVs5XSAqIHNjYWxlWjtcclxuXHRcdFx0dGVbMTBdID0gbWVbMTBdICogc2NhbGVaO1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggdiApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XHJcblxyXG5cdFx0dGVbMTJdID0gdGVbMF0gKiB4ICsgdGVbNF0gKiB5ICsgdGVbOF0gKiB6ICsgdGVbMTJdO1xyXG5cdFx0dGVbMTNdID0gdGVbMV0gKiB4ICsgdGVbNV0gKiB5ICsgdGVbOV0gKiB6ICsgdGVbMTNdO1xyXG5cdFx0dGVbMTRdID0gdGVbMl0gKiB4ICsgdGVbNl0gKiB5ICsgdGVbMTBdICogeiArIHRlWzE0XTtcclxuXHRcdHRlWzE1XSA9IHRlWzNdICogeCArIHRlWzddICogeSArIHRlWzExXSAqIHogKyB0ZVsxNV07XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZVg6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciBtMTIgPSB0ZVs0XTtcclxuXHRcdHZhciBtMjIgPSB0ZVs1XTtcclxuXHRcdHZhciBtMzIgPSB0ZVs2XTtcclxuXHRcdHZhciBtNDIgPSB0ZVs3XTtcclxuXHRcdHZhciBtMTMgPSB0ZVs4XTtcclxuXHRcdHZhciBtMjMgPSB0ZVs5XTtcclxuXHRcdHZhciBtMzMgPSB0ZVsxMF07XHJcblx0XHR2YXIgbTQzID0gdGVbMTFdO1xyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcclxuXHRcdHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0dGVbNF0gPSBjICogbTEyICsgcyAqIG0xMztcclxuXHRcdHRlWzVdID0gYyAqIG0yMiArIHMgKiBtMjM7XHJcblx0XHR0ZVs2XSA9IGMgKiBtMzIgKyBzICogbTMzO1xyXG5cdFx0dGVbN10gPSBjICogbTQyICsgcyAqIG00MztcclxuXHJcblx0XHR0ZVs4XSA9IGMgKiBtMTMgLSBzICogbTEyO1xyXG5cdFx0dGVbOV0gPSBjICogbTIzIC0gcyAqIG0yMjtcclxuXHRcdHRlWzEwXSA9IGMgKiBtMzMgLSBzICogbTMyO1xyXG5cdFx0dGVbMTFdID0gYyAqIG00MyAtIHMgKiBtNDI7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZVk6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciBtMTEgPSB0ZVswXTtcclxuXHRcdHZhciBtMjEgPSB0ZVsxXTtcclxuXHRcdHZhciBtMzEgPSB0ZVsyXTtcclxuXHRcdHZhciBtNDEgPSB0ZVszXTtcclxuXHRcdHZhciBtMTMgPSB0ZVs4XTtcclxuXHRcdHZhciBtMjMgPSB0ZVs5XTtcclxuXHRcdHZhciBtMzMgPSB0ZVsxMF07XHJcblx0XHR2YXIgbTQzID0gdGVbMTFdO1xyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcclxuXHRcdHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0dGVbMF0gPSBjICogbTExIC0gcyAqIG0xMztcclxuXHRcdHRlWzFdID0gYyAqIG0yMSAtIHMgKiBtMjM7XHJcblx0XHR0ZVsyXSA9IGMgKiBtMzEgLSBzICogbTMzO1xyXG5cdFx0dGVbM10gPSBjICogbTQxIC0gcyAqIG00MztcclxuXHJcblx0XHR0ZVs4XSA9IGMgKiBtMTMgKyBzICogbTExO1xyXG5cdFx0dGVbOV0gPSBjICogbTIzICsgcyAqIG0yMTtcclxuXHRcdHRlWzEwXSA9IGMgKiBtMzMgKyBzICogbTMxO1xyXG5cdFx0dGVbMTFdID0gYyAqIG00MyArIHMgKiBtNDE7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdHJvdGF0ZVo6IGZ1bmN0aW9uICggYW5nbGUgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciBtMTEgPSB0ZVswXTtcclxuXHRcdHZhciBtMjEgPSB0ZVsxXTtcclxuXHRcdHZhciBtMzEgPSB0ZVsyXTtcclxuXHRcdHZhciBtNDEgPSB0ZVszXTtcclxuXHRcdHZhciBtMTIgPSB0ZVs0XTtcclxuXHRcdHZhciBtMjIgPSB0ZVs1XTtcclxuXHRcdHZhciBtMzIgPSB0ZVs2XTtcclxuXHRcdHZhciBtNDIgPSB0ZVs3XTtcclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0XHR2YXIgcyA9IE1hdGguc2luKCBhbmdsZSApO1xyXG5cclxuXHRcdHRlWzBdID0gYyAqIG0xMSArIHMgKiBtMTI7XHJcblx0XHR0ZVsxXSA9IGMgKiBtMjEgKyBzICogbTIyO1xyXG5cdFx0dGVbMl0gPSBjICogbTMxICsgcyAqIG0zMjtcclxuXHRcdHRlWzNdID0gYyAqIG00MSArIHMgKiBtNDI7XHJcblxyXG5cdFx0dGVbNF0gPSBjICogbTEyIC0gcyAqIG0xMTtcclxuXHRcdHRlWzVdID0gYyAqIG0yMiAtIHMgKiBtMjE7XHJcblx0XHR0ZVs2XSA9IGMgKiBtMzIgLSBzICogbTMxO1xyXG5cdFx0dGVbN10gPSBjICogbTQyIC0gcyAqIG00MTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0cm90YXRlQnlBeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0Ly8gb3B0aW1pemUgYnkgY2hlY2tpbmcgYXhpc1xyXG5cclxuXHRcdGlmICggYXhpcy54ID09PSAxICYmIGF4aXMueSA9PT0gMCAmJiBheGlzLnogPT09IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcy5yb3RhdGVYKCBhbmdsZSApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGF4aXMueCA9PT0gMCAmJiBheGlzLnkgPT09IDEgJiYgYXhpcy56ID09PSAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRoaXMucm90YXRlWSggYW5nbGUgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBheGlzLnggPT09IDAgJiYgYXhpcy55ID09PSAwICYmIGF4aXMueiA9PT0gMSApIHtcclxuXHJcblx0XHRcdHJldHVybiB0aGlzLnJvdGF0ZVooIGFuZ2xlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xyXG5cdFx0dmFyIG4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KTtcclxuXHJcblx0XHR4IC89IG47XHJcblx0XHR5IC89IG47XHJcblx0XHR6IC89IG47XHJcblxyXG5cdFx0dmFyIHh4ID0geCAqIHgsIHl5ID0geSAqIHksIHp6ID0geiAqIHo7XHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0dmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHRcdHZhciBvbmVNaW51c0Nvc2luZSA9IDEgLSBjO1xyXG5cdFx0dmFyIHh5ID0geCAqIHkgKiBvbmVNaW51c0Nvc2luZTtcclxuXHRcdHZhciB4eiA9IHggKiB6ICogb25lTWludXNDb3NpbmU7XHJcblx0XHR2YXIgeXogPSB5ICogeiAqIG9uZU1pbnVzQ29zaW5lO1xyXG5cdFx0dmFyIHhzID0geCAqIHM7XHJcblx0XHR2YXIgeXMgPSB5ICogcztcclxuXHRcdHZhciB6cyA9IHogKiBzO1xyXG5cclxuXHRcdHZhciByMTEgPSB4eCArICgxIC0geHgpICogYztcclxuXHRcdHZhciByMjEgPSB4eSArIHpzO1xyXG5cdFx0dmFyIHIzMSA9IHh6IC0geXM7XHJcblx0XHR2YXIgcjEyID0geHkgLSB6cztcclxuXHRcdHZhciByMjIgPSB5eSArICgxIC0geXkpICogYztcclxuXHRcdHZhciByMzIgPSB5eiArIHhzO1xyXG5cdFx0dmFyIHIxMyA9IHh6ICsgeXM7XHJcblx0XHR2YXIgcjIzID0geXogLSB4cztcclxuXHRcdHZhciByMzMgPSB6eiArICgxIC0genopICogYztcclxuXHJcblx0XHR2YXIgbTExID0gdGVbMF0sIG0yMSA9IHRlWzFdLCBtMzEgPSB0ZVsyXSwgbTQxID0gdGVbM107XHJcblx0XHR2YXIgbTEyID0gdGVbNF0sIG0yMiA9IHRlWzVdLCBtMzIgPSB0ZVs2XSwgbTQyID0gdGVbN107XHJcblx0XHR2YXIgbTEzID0gdGVbOF0sIG0yMyA9IHRlWzldLCBtMzMgPSB0ZVsxMF0sIG00MyA9IHRlWzExXTtcclxuXHJcblx0XHR0ZVswXSA9IHIxMSAqIG0xMSArIHIyMSAqIG0xMiArIHIzMSAqIG0xMztcclxuXHRcdHRlWzFdID0gcjExICogbTIxICsgcjIxICogbTIyICsgcjMxICogbTIzO1xyXG5cdFx0dGVbMl0gPSByMTEgKiBtMzEgKyByMjEgKiBtMzIgKyByMzEgKiBtMzM7XHJcblx0XHR0ZVszXSA9IHIxMSAqIG00MSArIHIyMSAqIG00MiArIHIzMSAqIG00MztcclxuXHJcblx0XHR0ZVs0XSA9IHIxMiAqIG0xMSArIHIyMiAqIG0xMiArIHIzMiAqIG0xMztcclxuXHRcdHRlWzVdID0gcjEyICogbTIxICsgcjIyICogbTIyICsgcjMyICogbTIzO1xyXG5cdFx0dGVbNl0gPSByMTIgKiBtMzEgKyByMjIgKiBtMzIgKyByMzIgKiBtMzM7XHJcblx0XHR0ZVs3XSA9IHIxMiAqIG00MSArIHIyMiAqIG00MiArIHIzMiAqIG00MztcclxuXHJcblx0XHR0ZVs4XSA9IHIxMyAqIG0xMSArIHIyMyAqIG0xMiArIHIzMyAqIG0xMztcclxuXHRcdHRlWzldID0gcjEzICogbTIxICsgcjIzICogbTIyICsgcjMzICogbTIzO1xyXG5cdFx0dGVbMTBdID0gcjEzICogbTMxICsgcjIzICogbTMyICsgcjMzICogbTMzO1xyXG5cdFx0dGVbMTFdID0gcjEzICogbTQxICsgcjIzICogbTQyICsgcjMzICogbTQzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblx0XHR2YXIgeCA9IHYueCwgeSA9IHYueSwgeiA9IHYuejtcclxuXHJcblx0XHR0ZVswXSAqPSB4OyB0ZVs0XSAqPSB5OyB0ZVs4XSAqPSB6O1xyXG5cdFx0dGVbMV0gKj0geDsgdGVbNV0gKj0geTsgdGVbOV0gKj0gejtcclxuXHRcdHRlWzJdICo9IHg7IHRlWzZdICo9IHk7IHRlWzEwXSAqPSB6O1xyXG5cdFx0dGVbM10gKj0geDsgdGVbN10gKj0geTsgdGVbMTFdICo9IHo7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldE1heFNjYWxlT25BeGlzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHJcblx0XHR2YXIgc2NhbGVYU3EgPSB0ZVswXSAqIHRlWzBdICsgdGVbMV0gKiB0ZVsxXSArIHRlWzJdICogdGVbMl07XHJcblx0XHR2YXIgc2NhbGVZU3EgPSB0ZVs0XSAqIHRlWzRdICsgdGVbNV0gKiB0ZVs1XSArIHRlWzZdICogdGVbNl07XHJcblx0XHR2YXIgc2NhbGVaU3EgPSB0ZVs4XSAqIHRlWzhdICsgdGVbOV0gKiB0ZVs5XSArIHRlWzEwXSAqIHRlWzEwXTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KCBNYXRoLm1heCggc2NhbGVYU3EsIE1hdGgubWF4KCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VUcmFuc2xhdGlvbjogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0MSwgMCwgMCwgeCxcclxuXHRcdFx0MCwgMSwgMCwgeSxcclxuXHRcdFx0MCwgMCwgMSwgeixcclxuXHRcdFx0MCwgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvblg6IGZ1bmN0aW9uICggdGhldGEgKSB7XHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xyXG5cclxuXHRcdHRoaXMuc2V0KFxyXG5cclxuXHRcdFx0MSwgMCwgIDAsIDAsXHJcblx0XHRcdDAsIGMsIC1zLCAwLFxyXG5cdFx0XHQwLCBzLCAgYywgMCxcclxuXHRcdFx0MCwgMCwgIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUm90YXRpb25ZOiBmdW5jdGlvbiAoIHRoZXRhICkge1xyXG5cclxuXHRcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdCBjLCAwLCBzLCAwLFxyXG5cdFx0XHQgMCwgMSwgMCwgMCxcclxuXHRcdFx0LXMsIDAsIGMsIDAsXHJcblx0XHRcdCAwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVJvdGF0aW9uWjogZnVuY3Rpb24gKCB0aGV0YSApIHtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHRjLCAtcywgMCwgMCxcclxuXHRcdFx0cywgIGMsIDAsIDAsXHJcblx0XHRcdDAsICAwLCAxLCAwLFxyXG5cdFx0XHQwLCAgMCwgMCwgMVxyXG5cclxuXHRcdCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdG1ha2VSb3RhdGlvbkF4aXM6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XHJcblxyXG5cdFx0Ly8gQmFzZWQgb24gaHR0cDovL3d3dy5nYW1lZGV2Lm5ldC9yZWZlcmVuY2UvYXJ0aWNsZXMvYXJ0aWNsZTExOTkuYXNwXHJcblxyXG5cdFx0dmFyIGMgPSBNYXRoLmNvcyggYW5nbGUgKTtcclxuXHRcdHZhciBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XHJcblx0XHR2YXIgdCA9IDEgLSBjO1xyXG5cdFx0dmFyIHggPSBheGlzLngsIHkgPSBheGlzLnksIHogPSBheGlzLno7XHJcblx0XHR2YXIgdHggPSB0ICogeCwgdHkgPSB0ICogeTtcclxuXHJcblx0XHR0aGlzLnNldChcclxuXHJcblx0XHRcdHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcclxuXHRcdFx0dHggKiB5ICsgcyAqIHosIHR5ICogeSArIGMsIHR5ICogeiAtIHMgKiB4LCAwLFxyXG5cdFx0XHR0eCAqIHogLSBzICogeSwgdHkgKiB6ICsgcyAqIHgsIHQgKiB6ICogeiArIGMsIDAsXHJcblx0XHRcdDAsIDAsIDAsIDFcclxuXHJcblx0XHQpO1xyXG5cclxuXHRcdCByZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZVNjYWxlOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0dGhpcy5zZXQoXHJcblxyXG5cdFx0XHR4LCAwLCAwLCAwLFxyXG5cdFx0XHQwLCB5LCAwLCAwLFxyXG5cdFx0XHQwLCAwLCB6LCAwLFxyXG5cdFx0XHQwLCAwLCAwLCAxXHJcblxyXG5cdFx0KTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZUZydXN0dW06IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcclxuXHRcdHZhciB4ID0gMiAqIG5lYXIgLyAoIHJpZ2h0IC0gbGVmdCApO1xyXG5cdFx0dmFyIHkgPSAyICogbmVhciAvICggdG9wIC0gYm90dG9tICk7XHJcblxyXG5cdFx0dmFyIGEgPSAoIHJpZ2h0ICsgbGVmdCApIC8gKCByaWdodCAtIGxlZnQgKTtcclxuXHRcdHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XHJcblx0XHR2YXIgYyA9IC0gKCBmYXIgKyBuZWFyICkgLyAoIGZhciAtIG5lYXIgKTtcclxuXHRcdHZhciBkID0gLSAyICogZmFyICogbmVhciAvICggZmFyIC0gbmVhciApO1xyXG5cclxuXHRcdHRlWzBdID0geDtcdHRlWzRdID0gMDtcdHRlWzhdID0gYTtcdHRlWzEyXSA9IDA7XHJcblx0XHR0ZVsxXSA9IDA7XHR0ZVs1XSA9IHk7XHR0ZVs5XSA9IGI7XHR0ZVsxM10gPSAwO1xyXG5cdFx0dGVbMl0gPSAwO1x0dGVbNl0gPSAwO1x0dGVbMTBdID0gYztcdHRlWzE0XSA9IGQ7XHJcblx0XHR0ZVszXSA9IDA7XHR0ZVs3XSA9IDA7XHR0ZVsxMV0gPSAtIDE7XHR0ZVsxNV0gPSAwO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRtYWtlUGVyc3BlY3RpdmU6IGZ1bmN0aW9uICggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApIHtcclxuXHJcblx0XHR2YXIgeW1heCA9IG5lYXIgKiBNYXRoLnRhbiggVEhSRUUuTWF0aC5kZWdUb1JhZCggZm92ICogMC41ICkgKTtcclxuXHRcdHZhciB5bWluID0gLSB5bWF4O1xyXG5cdFx0dmFyIHhtaW4gPSB5bWluICogYXNwZWN0O1xyXG5cdFx0dmFyIHhtYXggPSB5bWF4ICogYXNwZWN0O1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm1ha2VGcnVzdHVtKCB4bWluLCB4bWF4LCB5bWluLCB5bWF4LCBuZWFyLCBmYXIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bWFrZU9ydGhvZ3JhcGhpYzogZnVuY3Rpb24gKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcclxuXHJcblx0XHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xyXG5cdFx0dmFyIHcgPSByaWdodCAtIGxlZnQ7XHJcblx0XHR2YXIgaCA9IHRvcCAtIGJvdHRvbTtcclxuXHRcdHZhciBwID0gZmFyIC0gbmVhcjtcclxuXHJcblx0XHR2YXIgeCA9ICggcmlnaHQgKyBsZWZ0ICkgLyB3O1xyXG5cdFx0dmFyIHkgPSAoIHRvcCArIGJvdHRvbSApIC8gaDtcclxuXHRcdHZhciB6ID0gKCBmYXIgKyBuZWFyICkgLyBwO1xyXG5cclxuXHRcdHRlWzBdID0gMiAvIHc7XHR0ZVs0XSA9IDA7XHR0ZVs4XSA9IDA7XHR0ZVsxMl0gPSAteDtcclxuXHRcdHRlWzFdID0gMDtcdHRlWzVdID0gMiAvIGg7XHR0ZVs5XSA9IDA7XHR0ZVsxM10gPSAteTtcclxuXHRcdHRlWzJdID0gMDtcdHRlWzZdID0gMDtcdHRlWzEwXSA9IC0yL3A7XHR0ZVsxNF0gPSAtejtcclxuXHRcdHRlWzNdID0gMDtcdHRlWzddID0gMDtcdHRlWzExXSA9IDA7XHR0ZVsxNV0gPSAxO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5NYXRyaXg0KFxyXG5cclxuXHRcdFx0dGVbMF0sIHRlWzRdLCB0ZVs4XSwgdGVbMTJdLFxyXG5cdFx0XHR0ZVsxXSwgdGVbNV0sIHRlWzldLCB0ZVsxM10sXHJcblx0XHRcdHRlWzJdLCB0ZVs2XSwgdGVbMTBdLCB0ZVsxNF0sXHJcblx0XHRcdHRlWzNdLCB0ZVs3XSwgdGVbMTFdLCB0ZVsxNV1cclxuXHJcblx0XHQpO1xyXG5cclxuXHR9XHJcblxyXG59ICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICovXHJcblxyXG5USFJFRS5SYXkgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xyXG5cclxuXHR0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5kaXJlY3Rpb24gPSAoIGRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkaXJlY3Rpb24gOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuUmF5LnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4uY29weSggb3JpZ2luICk7XHJcblx0XHR0aGlzLmRpcmVjdGlvbi5jb3B5KCBkaXJlY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCByYXkgKSB7XHJcblxyXG5cdFx0dGhpcy5vcmlnaW4uY29weSggcmF5Lm9yaWdpbiApO1xyXG5cdFx0dGhpcy5kaXJlY3Rpb24uY29weSggcmF5LmRpcmVjdGlvbiApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhdDogZnVuY3Rpb24oIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy5vcmlnaW4gKTtcclxuXHJcblx0fSxcclxuXHJcblx0cmVjYXN0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmVzdWx0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xyXG5cdFx0dmFyIGRpcmVjdGlvbkRpc3RhbmNlID0gcmVzdWx0LmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGlyZWN0aW9uRGlzdGFuY2UgPSB2MS5zdWJWZWN0b3JzKCBwb2ludCwgdGhpcy5vcmlnaW4gKS5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XHJcblx0XHRcdHYxLmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHYxLmRpc3RhbmNlVG8oIHBvaW50ICk7XHJcblxyXG5cdFx0fTtcclxuXHJcblx0fSgpLFxyXG5cclxuXHRpc0ludGVyc2VjdGlvblNwaGVyZTogZnVuY3Rpb24oIHNwaGVyZSApIHtcclxuXHJcblx0XHRyZXR1cm4gKCB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIDw9IHNwaGVyZS5yYWRpdXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aXNJbnRlcnNlY3Rpb25QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHQvLyBjaGVjayBpZiB0aGUgbGluZSBhbmQgcGxhbmUgYXJlIG5vbi1wZXJwZW5kaWN1bGFyLCBpZiB0aGV5XHJcblx0XHQvLyBldmVudHVhbGx5IHRoZXkgd2lsbCBpbnRlcnNlY3QuXHJcblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cdFx0aWYgKCBkZW5vbWluYXRvciAhPSAwICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cclxuXHRcdGlmKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHRoaXMub3JpZ2luICkgPT0gMCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcclxuXHJcblx0XHR2YXIgZGVub21pbmF0b3IgPSBwbGFuZS5ub3JtYWwuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xyXG5cdFx0aWYgKCBkZW5vbWluYXRvciA9PSAwICkge1xyXG5cclxuXHRcdFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxyXG5cdFx0XHRpZiggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApID09IDAgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiAwO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0ID0gLSAoIHRoaXMub3JpZ2luLmRvdCggcGxhbmUubm9ybWFsICkgKyBwbGFuZS5jb25zdGFudCApIC8gZGVub21pbmF0b3I7XHJcblxyXG5cdFx0cmV0dXJuIHQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdFBsYW5lOiBmdW5jdGlvbiAoIHBsYW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2YXIgdCA9IHRoaXMuZGlzdGFuY2VUb1BsYW5lKCBwbGFuZSApO1xyXG5cclxuXHRcdGlmICggdCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hdCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeDQgKSB7XHJcblxyXG5cdFx0dGhpcy5kaXJlY3Rpb24uYWRkKCB0aGlzLm9yaWdpbiApLmFwcGx5TWF0cml4NCggbWF0cml4NCApO1xyXG5cdFx0dGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XHJcblx0XHR0aGlzLmRpcmVjdGlvbi5zdWIoIHRoaXMub3JpZ2luICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAoIHJheSApIHtcclxuXHJcblx0XHRyZXR1cm4gcmF5Lm9yaWdpbi5lcXVhbHMoIHRoaXMub3JpZ2luICkgJiYgcmF5LmRpcmVjdGlvbi5lcXVhbHMoIHRoaXMuZGlyZWN0aW9uICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5SYXkoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwaGVyZSA9IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XHJcblxyXG5cdHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuZXh0ZW5kKCBUSFJFRS5TcGhlcmUucHJvdG90eXBlLCB7XHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBjZW50ZXIsIHJhZGl1cyApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5jb3B5KCBjZW50ZXIgKTtcclxuXHRcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldEZyb21DZW50ZXJBbmRQb2ludHM6IGZ1bmN0aW9uICggY2VudGVyLCBwb2ludHMgKSB7XHJcblxyXG5cdFx0dmFyIG1heFJhZGl1c1NxID0gMDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHJhZGl1c1NxID0gY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludHNbIGkgXSApO1xyXG5cdFx0XHRtYXhSYWRpdXNTcSA9IE1hdGgubWF4KCBtYXhSYWRpdXNTcSwgcmFkaXVzU3EgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIgPSBjZW50ZXI7XHJcblx0XHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0dGhpcy5jZW50ZXIuY29weSggc3BoZXJlLmNlbnRlciApO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSBzcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlbXB0eTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiAoIHRoaXMucmFkaXVzIDw9IDAgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggdGhpcy5jZW50ZXIgKSA8PSAoIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUbyggdGhpcy5jZW50ZXIgKSAtIHRoaXMucmFkaXVzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHZhciByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XHJcblxyXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGRlbHRhTGVuZ3RoU3EgPSB0aGlzLmNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHJlc3VsdC5jb3B5KCBwb2ludCApO1xyXG5cclxuXHRcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xyXG5cclxuXHRcdFx0cmVzdWx0LnN1YiggdGhpcy5jZW50ZXIgKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0cmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGJveCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG5cdFx0Ym94LnNldCggdGhpcy5jZW50ZXIsIHRoaXMuY2VudGVyICk7XHJcblx0XHRib3guZXhwYW5kQnlTY2FsYXIoIHRoaXMucmFkaXVzICk7XHJcblxyXG5cdFx0cmV0dXJuIGJveDtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cdFx0dGhpcy5yYWRpdXMgPSB0aGlzLnJhZGl1cyAqIG1hdHJpeC5nZXRNYXhTY2FsZU9uQXhpcygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdHRoaXMuY2VudGVyLmFkZCggb2Zmc2V0ICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlNwaGVyZSgpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuRnJ1c3R1bSA9IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcclxuXHJcblx0dGhpcy5wbGFuZXMgPSBbXHJcblxyXG5cdFx0KCBwMCAhPT0gdW5kZWZpbmVkICkgPyBwMCA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwMSAhPT0gdW5kZWZpbmVkICkgPyBwMSA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwMiAhPT0gdW5kZWZpbmVkICkgPyBwMiA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwMyAhPT0gdW5kZWZpbmVkICkgPyBwMyA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwNCAhPT0gdW5kZWZpbmVkICkgPyBwNCA6IG5ldyBUSFJFRS5QbGFuZSgpLFxyXG5cdFx0KCBwNSAhPT0gdW5kZWZpbmVkICkgPyBwNSA6IG5ldyBUSFJFRS5QbGFuZSgpXHJcblxyXG5cdF07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuZXh0ZW5kKCBUSFJFRS5GcnVzdHVtLnByb3RvdHlwZSwge1xyXG5cclxuXHRzZXQ6IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0cGxhbmVzWzBdLmNvcHkoIHAwICk7XHJcblx0XHRwbGFuZXNbMV0uY29weSggcDEgKTtcclxuXHRcdHBsYW5lc1syXS5jb3B5KCBwMiApO1xyXG5cdFx0cGxhbmVzWzNdLmNvcHkoIHAzICk7XHJcblx0XHRwbGFuZXNbNF0uY29weSggcDQgKTtcclxuXHRcdHBsYW5lc1s1XS5jb3B5KCBwNSApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIGZydXN0dW0gKSB7XHJcblxyXG5cdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cclxuXHRcdGZvciggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdHBsYW5lc1tpXS5jb3B5KCBmcnVzdHVtLnBsYW5lc1tpXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU1hdHJpeDogZnVuY3Rpb24gKCBtICkge1xyXG5cclxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHRcdHZhciBtZSA9IG0uZWxlbWVudHM7XHJcblx0XHR2YXIgbWUwID0gbWVbMF0sIG1lMSA9IG1lWzFdLCBtZTIgPSBtZVsyXSwgbWUzID0gbWVbM107XHJcblx0XHR2YXIgbWU0ID0gbWVbNF0sIG1lNSA9IG1lWzVdLCBtZTYgPSBtZVs2XSwgbWU3ID0gbWVbN107XHJcblx0XHR2YXIgbWU4ID0gbWVbOF0sIG1lOSA9IG1lWzldLCBtZTEwID0gbWVbMTBdLCBtZTExID0gbWVbMTFdO1xyXG5cdFx0dmFyIG1lMTIgPSBtZVsxMl0sIG1lMTMgPSBtZVsxM10sIG1lMTQgPSBtZVsxNF0sIG1lMTUgPSBtZVsxNV07XHJcblxyXG5cdFx0cGxhbmVzWyAwIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUwLCBtZTcgLSBtZTQsIG1lMTEgLSBtZTgsIG1lMTUgLSBtZTEyICkubm9ybWFsaXplKCk7XHJcblx0XHRwbGFuZXNbIDEgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTAsIG1lNyArIG1lNCwgbWUxMSArIG1lOCwgbWUxNSArIG1lMTIgKS5ub3JtYWxpemUoKTtcclxuXHRcdHBsYW5lc1sgMiBdLnNldENvbXBvbmVudHMoIG1lMyArIG1lMSwgbWU3ICsgbWU1LCBtZTExICsgbWU5LCBtZTE1ICsgbWUxMyApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0cGxhbmVzWyAzIF0uc2V0Q29tcG9uZW50cyggbWUzIC0gbWUxLCBtZTcgLSBtZTUsIG1lMTEgLSBtZTksIG1lMTUgLSBtZTEzICkubm9ybWFsaXplKCk7XHJcblx0XHRwbGFuZXNbIDQgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTIsIG1lNyAtIG1lNiwgbWUxMSAtIG1lMTAsIG1lMTUgLSBtZTE0ICkubm9ybWFsaXplKCk7XHJcblx0XHRwbGFuZXNbIDUgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTIsIG1lNyArIG1lNiwgbWUxMSArIG1lMTAsIG1lMTUgKyBtZTE0ICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGludGVyc2VjdHNPYmplY3Q6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHQvLyB0aGlzIG1ldGhvZCBpcyBleHBhbmRlZCBpbmxpbmVkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLlxyXG5cclxuXHRcdFx0dmFyIG1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHRcdFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xyXG5cdFx0XHR2YXIgbmVnUmFkaXVzID0gLSBvYmplY3QuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUucmFkaXVzICogbWF0cml4LmdldE1heFNjYWxlT25BeGlzKCk7XHJcblxyXG5cdFx0XHRjZW50ZXIuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBkaXN0YW5jZSA9IHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICk7XHJcblxyXG5cdFx0XHRcdGlmICggZGlzdGFuY2UgPCBuZWdSYWRpdXMgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcclxuXHRcdHZhciBjZW50ZXIgPSBzcGhlcmUuY2VudGVyO1xyXG5cdFx0dmFyIG5lZ1JhZGl1cyA9IC1zcGhlcmUucmFkaXVzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgZGlzdGFuY2UgPSBwbGFuZXNbIGkgXS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApO1xyXG5cclxuXHRcdFx0aWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcclxuXHJcblx0XHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIDwgMCApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLkZydXN0dW0oKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vZXhvY29ydGV4LmNvbVxyXG4gKi9cclxuXHJcblRIUkVFLlBsYW5lID0gZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xyXG5cclxuXHR0aGlzLm5vcm1hbCA9ICggbm9ybWFsICE9PSB1bmRlZmluZWQgKSA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAwLCAwICk7XHJcblx0dGhpcy5jb25zdGFudCA9ICggY29uc3RhbnQgIT09IHVuZGVmaW5lZCApID8gY29uc3RhbnQgOiAwO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuUGxhbmUucHJvdG90eXBlLCB7XHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBub3JtYWwsIGNvbnN0YW50ICkge1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIG5vcm1hbCApO1xyXG5cdFx0dGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzZXRDb21wb25lbnRzOiBmdW5jdGlvbiAoIHgsIHksIHosIHcgKSB7XHJcblxyXG5cdFx0dGhpcy5ub3JtYWwuc2V0KCB4LCB5LCB6ICk7XHJcblx0XHR0aGlzLmNvbnN0YW50ID0gdztcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggbm9ybWFsLCBwb2ludCApIHtcclxuXHJcblx0XHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgPSAtIHBvaW50LmRvdCggdGhpcy5ub3JtYWwgKTtcdC8vIG11c3QgYmUgdGhpcy5ub3JtYWwsIG5vdCBub3JtYWwsIGFzIHRoaXMubm9ybWFsIGlzIG5vcm1hbGl6ZWRcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbUNvcGxhbmFyUG9pbnRzOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbCA9IHYxLnN1YlZlY3RvcnMoIGMsIGIgKS5jcm9zcyggdjIuc3ViVmVjdG9ycyggYSwgYiApICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHQvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xyXG5cclxuXHRcdFx0dGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbm9ybWFsLCBhICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cclxuXHRjb3B5OiBmdW5jdGlvbiAoIHBsYW5lICkge1xyXG5cclxuXHRcdHRoaXMubm9ybWFsLmNvcHkoIHBsYW5lLm5vcm1hbCApO1xyXG5cdFx0dGhpcy5jb25zdGFudCA9IHBsYW5lLmNvbnN0YW50O1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cclxuXHJcblx0XHR2YXIgaW52ZXJzZU5vcm1hbExlbmd0aCA9IDEuMCAvIHRoaXMubm9ybWFsLmxlbmd0aCgpO1xyXG5cdFx0dGhpcy5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIGludmVyc2VOb3JtYWxMZW5ndGggKTtcclxuXHRcdHRoaXMuY29uc3RhbnQgKj0gaW52ZXJzZU5vcm1hbExlbmd0aDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5jb25zdGFudCAqPSAtMTtcclxuXHRcdHRoaXMubm9ybWFsLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3RhbmNlVG9TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIC0gc3BoZXJlLnJhZGl1cztcclxuXHJcblx0fSxcclxuXHJcblx0cHJvamVjdFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5vcnRob1BvaW50KCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKS5zdWIoIHBvaW50ICkubmVnYXRlKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdG9ydGhvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciBwZXJwZW5kaWN1bGFyTWFnbml0dWRlID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHBvaW50ICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMubm9ybWFsICkubXVsdGlwbHlTY2FsYXIoIHBlcnBlbmRpY3VsYXJNYWduaXR1ZGUgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aXNJbnRlcnNlY3Rpb25MaW5lOiBmdW5jdGlvbiAoIGxpbmUgKSB7XHJcblxyXG5cdFx0Ly8gTm90ZTogdGhpcyB0ZXN0cyBpZiBhIGxpbmUgaW50ZXJzZWN0cyB0aGUgcGxhbmUsIG5vdCB3aGV0aGVyIGl0IChvciBpdHMgZW5kLXBvaW50cykgYXJlIGNvcGxhbmFyIHdpdGggaXQuXHJcblxyXG5cdFx0dmFyIHN0YXJ0U2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICk7XHJcblx0XHR2YXIgZW5kU2lnbiA9IHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLmVuZCApO1xyXG5cclxuXHRcdHJldHVybiAoIHN0YXJ0U2lnbiA8IDAgJiYgZW5kU2lnbiA+IDAgKSB8fCAoIGVuZFNpZ24gPCAwICYmIHN0YXJ0U2lnbiA+IDAgKTtcclxuXHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0TGluZTogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIHYxID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IGxpbmUuZGVsdGEoIHYxICk7XHJcblxyXG5cdFx0XHR2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xyXG5cclxuXHRcdFx0aWYgKCBkZW5vbWluYXRvciA9PSAwICkge1xyXG5cclxuXHRcdFx0XHQvLyBsaW5lIGlzIGNvcGxhbmFyLCByZXR1cm4gb3JpZ2luXHJcblx0XHRcdFx0aWYoIHRoaXMuZGlzdGFuY2VUb1BvaW50KCBsaW5lLnN0YXJ0ICkgPT0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0LmNvcHkoIGxpbmUuc3RhcnQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBVbnN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBtZXRob2QgdG8gaGFuZGxlIHRoaXMgY2FzZS5cclxuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHQgPSAtICggbGluZS5zdGFydC5kb3QoIHRoaXMubm9ybWFsICkgKyB0aGlzLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcclxuXHJcblx0XHRcdGlmKCB0IDwgMCB8fCB0ID4gMSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiByZXN1bHQuY29weSggZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIGxpbmUuc3RhcnQgKTtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cclxuXHRjb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm5vcm1hbCApLm11bHRpcGx5U2NhbGFyKCAtIHRoaXMuY29uc3RhbnQgKTtcclxuXHJcblx0fSxcclxuXHJcblx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIHYyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCBtYXRyaXgsIG9wdGlvbmFsTm9ybWFsTWF0cml4ICkge1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSBuZXcgbm9ybWFsIGJhc2VkIG9uIHRoZW9yeSBoZXJlOlxyXG5cdFx0XHQvLyBodHRwOi8vd3d3LnNvbmdoby5jYS9vcGVuZ2wvZ2xfbm9ybWFsdHJhbnNmb3JtLmh0bWxcclxuXHRcdFx0b3B0aW9uYWxOb3JtYWxNYXRyaXggPSBvcHRpb25hbE5vcm1hbE1hdHJpeCB8fCBuZXcgVEhSRUUuTWF0cml4MygpLmdldEludmVyc2UoIG1hdHJpeCApLnRyYW5zcG9zZSgpO1xyXG5cdFx0XHR2YXIgbmV3Tm9ybWFsID0gdjEuY29weSggdGhpcy5ub3JtYWwgKS5hcHBseU1hdHJpeDMoIG9wdGlvbmFsTm9ybWFsTWF0cml4ICk7XHJcblxyXG5cdFx0XHR2YXIgbmV3Q29wbGFuYXJQb2ludCA9IHRoaXMuY29wbGFuYXJQb2ludCggdjIgKTtcclxuXHRcdFx0bmV3Q29wbGFuYXJQb2ludC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdFx0dGhpcy5zZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCggbmV3Tm9ybWFsLCBuZXdDb3BsYW5hclBvaW50ICk7XHJcblxyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KCksXHJcblxyXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XHJcblxyXG5cdFx0dGhpcy5jb25zdGFudCA9IHRoaXMuY29uc3RhbnQgLSBvZmZzZXQuZG90KCB0aGlzLm5vcm1hbCApO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggcGxhbmUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHBsYW5lLm5vcm1hbC5lcXVhbHMoIHRoaXMubm9ybWFsICkgJiYgKCBwbGFuZS5jb25zdGFudCA9PSB0aGlzLmNvbnN0YW50ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5QbGFuZSgpLmNvcHkoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NYXRoID0ge1xyXG5cclxuXHQvLyBDbGFtcCB2YWx1ZSB0byByYW5nZSA8YSwgYj5cclxuXHJcblx0Y2xhbXA6IGZ1bmN0aW9uICggeCwgYSwgYiApIHtcclxuXHJcblx0XHRyZXR1cm4gKCB4IDwgYSApID8gYSA6ICggKCB4ID4gYiApID8gYiA6IHggKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gQ2xhbXAgdmFsdWUgdG8gcmFuZ2UgPGEsIGluZilcclxuXHJcblx0Y2xhbXBCb3R0b206IGZ1bmN0aW9uICggeCwgYSApIHtcclxuXHJcblx0XHRyZXR1cm4geCA8IGEgPyBhIDogeDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gTGluZWFyIG1hcHBpbmcgZnJvbSByYW5nZSA8YTEsIGEyPiB0byByYW5nZSA8YjEsIGIyPlxyXG5cclxuXHRtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU21vb3Roc3RlcFxyXG5cclxuXHRzbW9vdGhzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcclxuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcclxuXHJcblx0XHR4ID0gKCB4IC0gbWluICkvKCBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRyZXR1cm4geCp4KigzIC0gMip4KTtcclxuXHJcblx0fSxcclxuXHJcblx0c21vb3RoZXJzdGVwOiBmdW5jdGlvbiAoIHgsIG1pbiwgbWF4ICkge1xyXG5cclxuXHRcdGlmICggeCA8PSBtaW4gKSByZXR1cm4gMDtcclxuXHRcdGlmICggeCA+PSBtYXggKSByZXR1cm4gMTtcclxuXHJcblx0XHR4ID0gKCB4IC0gbWluICkvKCBtYXggLSBtaW4gKTtcclxuXHJcblx0XHRyZXR1cm4geCp4KngqKHgqKHgqNiAtIDE1KSArIDEwKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPDAsIDE+IHdpdGggMTYgYml0cyBvZiByYW5kb21uZXNzXHJcblx0Ly8gKHN0YW5kYXJkIE1hdGgucmFuZG9tKCkgY3JlYXRlcyByZXBldGl0aXZlIHBhdHRlcm5zIHdoZW4gYXBwbGllZCBvdmVyIGxhcmdlciBzcGFjZSlcclxuXHJcblx0cmFuZG9tMTY6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gKCA2NTI4MCAqIE1hdGgucmFuZG9tKCkgKyAyNTUgKiBNYXRoLnJhbmRvbSgpICkgLyA2NTUzNTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gUmFuZG9tIGludGVnZXIgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5cclxuXHRyYW5kSW50OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcclxuXHJcblx0XHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8bG93LCBoaWdoPiBpbnRlcnZhbFxyXG5cclxuXHRyYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xyXG5cclxuXHRcdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIFJhbmRvbSBmbG9hdCBmcm9tIDwtcmFuZ2UvMiwgcmFuZ2UvMj4gaW50ZXJ2YWxcclxuXHJcblx0cmFuZEZsb2F0U3ByZWFkOiBmdW5jdGlvbiAoIHJhbmdlICkge1xyXG5cclxuXHRcdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRzaWduOiBmdW5jdGlvbiAoIHggKSB7XHJcblxyXG5cdFx0cmV0dXJuICggeCA8IDAgKSA/IC0xIDogKCAoIHggPiAwICkgPyAxIDogMCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRkZWdUb1JhZDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0dmFyIGRlZ3JlZVRvUmFkaWFuc0ZhY3RvciA9IE1hdGguUEkgLyAxODA7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICggZGVncmVlcyApIHtcclxuXHJcblx0XHRcdHJldHVybiBkZWdyZWVzICogZGVncmVlVG9SYWRpYW5zRmFjdG9yO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0cmFkVG9EZWc6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciByYWRpYW5Ub0RlZ3JlZXNGYWN0b3IgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoIHJhZGlhbnMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmFkaWFucyAqIHJhZGlhblRvRGVncmVlc0ZhY3RvcjtcclxuXHJcblx0XHR9O1xyXG5cclxuXHR9KClcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBTcGxpbmUgZnJvbSBUd2Vlbi5qcywgc2xpZ2h0bHkgb3B0aW1pemVkIChhbmQgdHJhc2hlZClcclxuICogaHR0cDovL3NvbGUuZ2l0aHViLmNvbS90d2Vlbi5qcy9leGFtcGxlcy8wNV9zcGxpbmUuaHRtbFxyXG4gKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNwbGluZSA9IGZ1bmN0aW9uICggcG9pbnRzICkge1xyXG5cclxuXHR0aGlzLnBvaW50cyA9IHBvaW50cztcclxuXHJcblx0dmFyIGMgPSBbXSwgdjMgPSB7IHg6IDAsIHk6IDAsIHo6IDAgfSxcclxuXHRwb2ludCwgaW50UG9pbnQsIHdlaWdodCwgdzIsIHczLFxyXG5cdHBhLCBwYiwgcGMsIHBkO1xyXG5cclxuXHR0aGlzLmluaXRGcm9tQXJyYXkgPSBmdW5jdGlvbiggYSApIHtcclxuXHJcblx0XHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBvaW50c1sgaSBdID0geyB4OiBhWyBpIF1bIDAgXSwgeTogYVsgaSBdWyAxIF0sIHo6IGFbIGkgXVsgMiBdIH07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldFBvaW50ID0gZnVuY3Rpb24gKCBrICkge1xyXG5cclxuXHRcdHBvaW50ID0gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICkgKiBrO1xyXG5cdFx0aW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG5cdFx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcblx0XHRjWyAwIF0gPSBpbnRQb2ludCA9PT0gMCA/IGludFBvaW50IDogaW50UG9pbnQgLSAxO1xyXG5cdFx0Y1sgMSBdID0gaW50UG9pbnQ7XHJcblx0XHRjWyAyIF0gPSBpbnRQb2ludCAgPiB0aGlzLnBvaW50cy5sZW5ndGggLSAyID8gdGhpcy5wb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcclxuXHRcdGNbIDMgXSA9IGludFBvaW50ICA+IHRoaXMucG9pbnRzLmxlbmd0aCAtIDMgPyB0aGlzLnBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyO1xyXG5cclxuXHRcdHBhID0gdGhpcy5wb2ludHNbIGNbIDAgXSBdO1xyXG5cdFx0cGIgPSB0aGlzLnBvaW50c1sgY1sgMSBdIF07XHJcblx0XHRwYyA9IHRoaXMucG9pbnRzWyBjWyAyIF0gXTtcclxuXHRcdHBkID0gdGhpcy5wb2ludHNbIGNbIDMgXSBdO1xyXG5cclxuXHRcdHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xyXG5cdFx0dzMgPSB3ZWlnaHQgKiB3MjtcclxuXHJcblx0XHR2My54ID0gaW50ZXJwb2xhdGUoIHBhLngsIHBiLngsIHBjLngsIHBkLngsIHdlaWdodCwgdzIsIHczICk7XHJcblx0XHR2My55ID0gaW50ZXJwb2xhdGUoIHBhLnksIHBiLnksIHBjLnksIHBkLnksIHdlaWdodCwgdzIsIHczICk7XHJcblx0XHR2My56ID0gaW50ZXJwb2xhdGUoIHBhLnosIHBiLnosIHBjLnosIHBkLnosIHdlaWdodCwgdzIsIHczICk7XHJcblxyXG5cdFx0cmV0dXJuIHYzO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmdldENvbnRyb2xQb2ludHNBcnJheSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaSwgcCwgbCA9IHRoaXMucG9pbnRzLmxlbmd0aCxcclxuXHRcdFx0Y29vcmRzID0gW107XHJcblxyXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0cCA9IHRoaXMucG9pbnRzWyBpIF07XHJcblx0XHRcdGNvb3Jkc1sgaSBdID0gWyBwLngsIHAueSwgcC56IF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb29yZHM7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIGFwcHJveGltYXRlIGxlbmd0aCBieSBzdW1taW5nIGxpbmVhciBzZWdtZW50c1xyXG5cclxuXHR0aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uICggblN1YkRpdmlzaW9ucyApIHtcclxuXHJcblx0XHR2YXIgaSwgaW5kZXgsIG5TYW1wbGVzLCBwb3NpdGlvbixcclxuXHRcdFx0cG9pbnQgPSAwLCBpbnRQb2ludCA9IDAsIG9sZEludFBvaW50ID0gMCxcclxuXHRcdFx0b2xkUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHR0bXBWZWMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRjaHVua0xlbmd0aHMgPSBbXSxcclxuXHRcdFx0dG90YWxMZW5ndGggPSAwO1xyXG5cclxuXHRcdC8vIGZpcnN0IHBvaW50IGhhcyAwIGxlbmd0aFxyXG5cclxuXHRcdGNodW5rTGVuZ3Roc1sgMCBdID0gMDtcclxuXHJcblx0XHRpZiAoICFuU3ViRGl2aXNpb25zICkgblN1YkRpdmlzaW9ucyA9IDEwMDtcclxuXHJcblx0XHRuU2FtcGxlcyA9IHRoaXMucG9pbnRzLmxlbmd0aCAqIG5TdWJEaXZpc2lvbnM7XHJcblxyXG5cdFx0b2xkUG9zaXRpb24uY29weSggdGhpcy5wb2ludHNbIDAgXSApO1xyXG5cclxuXHRcdGZvciAoIGkgPSAxOyBpIDwgblNhbXBsZXM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpbmRleCA9IGkgLyBuU2FtcGxlcztcclxuXHJcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5nZXRQb2ludCggaW5kZXggKTtcclxuXHRcdFx0dG1wVmVjLmNvcHkoIHBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHR0b3RhbExlbmd0aCArPSB0bXBWZWMuZGlzdGFuY2VUbyggb2xkUG9zaXRpb24gKTtcclxuXHJcblx0XHRcdG9sZFBvc2l0aW9uLmNvcHkoIHBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRwb2ludCA9ICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApICogaW5kZXg7XHJcblx0XHRcdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHJcblx0XHRcdGlmICggaW50UG9pbnQgIT0gb2xkSW50UG9pbnQgKSB7XHJcblxyXG5cdFx0XHRcdGNodW5rTGVuZ3Roc1sgaW50UG9pbnQgXSA9IHRvdGFsTGVuZ3RoO1xyXG5cdFx0XHRcdG9sZEludFBvaW50ID0gaW50UG9pbnQ7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGxhc3QgcG9pbnQgZW5kcyB3aXRoIHRvdGFsIGxlbmd0aFxyXG5cclxuXHRcdGNodW5rTGVuZ3Roc1sgY2h1bmtMZW5ndGhzLmxlbmd0aCBdID0gdG90YWxMZW5ndGg7XHJcblxyXG5cdFx0cmV0dXJuIHsgY2h1bmtzOiBjaHVua0xlbmd0aHMsIHRvdGFsOiB0b3RhbExlbmd0aCB9O1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnJlcGFyYW1ldHJpemVCeUFyY0xlbmd0aCA9IGZ1bmN0aW9uICggc2FtcGxpbmdDb2VmICkge1xyXG5cclxuXHRcdHZhciBpLCBqLFxyXG5cdFx0XHRpbmRleCwgaW5kZXhDdXJyZW50LCBpbmRleE5leHQsXHJcblx0XHRcdGxpbmVhckRpc3RhbmNlLCByZWFsRGlzdGFuY2UsXHJcblx0XHRcdHNhbXBsaW5nLCBwb3NpdGlvbixcclxuXHRcdFx0bmV3cG9pbnRzID0gW10sXHJcblx0XHRcdHRtcFZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdHNsID0gdGhpcy5nZXRMZW5ndGgoKTtcclxuXHJcblx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyAwIF0gKS5jbG9uZSgpICk7XHJcblxyXG5cdFx0Zm9yICggaSA9IDE7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKyApIHtcclxuXHJcblx0XHRcdC8vdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIC0gMSBdICk7XHJcblx0XHRcdC8vbGluZWFyRGlzdGFuY2UgPSB0bXBWZWMuZGlzdGFuY2VUbyggdGhpcy5wb2ludHNbIGkgXSApO1xyXG5cclxuXHRcdFx0cmVhbERpc3RhbmNlID0gc2wuY2h1bmtzWyBpIF0gLSBzbC5jaHVua3NbIGkgLSAxIF07XHJcblxyXG5cdFx0XHRzYW1wbGluZyA9IE1hdGguY2VpbCggc2FtcGxpbmdDb2VmICogcmVhbERpc3RhbmNlIC8gc2wudG90YWwgKTtcclxuXHJcblx0XHRcdGluZGV4Q3VycmVudCA9ICggaSAtIDEgKSAvICggdGhpcy5wb2ludHMubGVuZ3RoIC0gMSApO1xyXG5cdFx0XHRpbmRleE5leHQgPSBpIC8gKCB0aGlzLnBvaW50cy5sZW5ndGggLSAxICk7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8IHNhbXBsaW5nIC0gMTsgaisrICkge1xyXG5cclxuXHRcdFx0XHRpbmRleCA9IGluZGV4Q3VycmVudCArIGogKiAoIDEgLyBzYW1wbGluZyApICogKCBpbmRleE5leHQgLSBpbmRleEN1cnJlbnQgKTtcclxuXHJcblx0XHRcdFx0cG9zaXRpb24gPSB0aGlzLmdldFBvaW50KCBpbmRleCApO1xyXG5cdFx0XHRcdG5ld3BvaW50cy5wdXNoKCB0bXBWZWMuY29weSggcG9zaXRpb24gKS5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRuZXdwb2ludHMucHVzaCggdG1wVmVjLmNvcHkoIHRoaXMucG9pbnRzWyBpIF0gKS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gbmV3cG9pbnRzO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBDYXRtdWxsLVJvbVxyXG5cclxuXHRmdW5jdGlvbiBpbnRlcnBvbGF0ZSggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcclxuXHJcblx0XHR2YXIgdjAgPSAoIHAyIC0gcDAgKSAqIDAuNSxcclxuXHRcdFx0djEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcclxuXHJcblx0XHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcclxuXHJcblx0fTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5UcmlhbmdsZSA9IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcclxuXHJcblx0dGhpcy5hID0gKCBhICE9PSB1bmRlZmluZWQgKSA/IGEgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLmMgPSAoIGMgIT09IHVuZGVmaW5lZCApID8gYyA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVHJpYW5nbGUubm9ybWFsID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiggYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0cmVzdWx0LnN1YlZlY3RvcnMoIGMsIGIgKTtcclxuXHRcdHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcclxuXHRcdHJlc3VsdC5jcm9zcyggdjAgKTtcclxuXHJcblx0XHR2YXIgcmVzdWx0TGVuZ3RoU3EgPSByZXN1bHQubGVuZ3RoU3EoKTtcclxuXHRcdGlmKCByZXN1bHRMZW5ndGhTcSA+IDAgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0Lm11bHRpcGx5U2NhbGFyKCAxIC8gTWF0aC5zcXJ0KCByZXN1bHRMZW5ndGhTcSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdH07XHJcblxyXG59KCk7XHJcblxyXG4vLyBzdGF0aWMvaW5zdGFuY2UgbWV0aG9kIHRvIGNhbGN1bGF0ZSBiYXJ5Y29vcmRpbmF0ZXNcclxuLy8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcclxuVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHR2MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHR2MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiAoIHBvaW50LCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcclxuXHJcblx0XHR2MC5zdWJWZWN0b3JzKCBjLCBhICk7XHJcblx0XHR2MS5zdWJWZWN0b3JzKCBiLCBhICk7XHJcblx0XHR2Mi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xyXG5cclxuXHRcdHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcclxuXHRcdHZhciBkb3QwMSA9IHYwLmRvdCggdjEgKTtcclxuXHRcdHZhciBkb3QwMiA9IHYwLmRvdCggdjIgKTtcclxuXHRcdHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcclxuXHRcdHZhciBkb3QxMiA9IHYxLmRvdCggdjIgKTtcclxuXHJcblx0XHR2YXIgZGVub20gPSAoIGRvdDAwICogZG90MTEgLSBkb3QwMSAqIGRvdDAxICk7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0Ly8gY29saW5lYXIgb3Igc2luZ3VsYXIgdHJpYW5nbGVcclxuXHRcdGlmKCBkZW5vbSA9PSAwICkge1xyXG5cdFx0XHQvLyBhcmJpdHJhcnkgbG9jYXRpb24gb3V0c2lkZSBvZiB0cmlhbmdsZT9cclxuXHRcdFx0Ly8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0LnNldCggLTIsIC0xLCAtMSApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcclxuXHRcdHZhciB1ID0gKCBkb3QxMSAqIGRvdDAyIC0gZG90MDEgKiBkb3QxMiApICogaW52RGVub207XHJcblx0XHR2YXIgdiA9ICggZG90MDAgKiBkb3QxMiAtIGRvdDAxICogZG90MDIgKSAqIGludkRlbm9tO1xyXG5cclxuXHRcdC8vIGJhcnljb29yZGluYXRlcyBtdXN0IGFsd2F5cyBzdW0gdG8gMVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5zZXQoIDEgLSB1IC0gdiwgdiwgdSApO1xyXG5cclxuXHR9O1xyXG5cclxufSgpO1xyXG5cclxuVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKCBwb2ludCwgYSwgYiwgYyApIHtcclxuXHJcblx0XHR2YXIgcmVzdWx0ID0gVEhSRUUuVHJpYW5nbGUuYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgYSwgYiwgYywgdjEgKTtcclxuXHJcblx0XHRyZXR1cm4gKCByZXN1bHQueCA+PSAwICkgJiYgKCByZXN1bHQueSA+PSAwICkgJiYgKCAoIHJlc3VsdC54ICsgcmVzdWx0LnkgKSA8PSAxICk7XHJcblxyXG5cdH07XHJcblxyXG59KCk7XHJcblxyXG5USFJFRS5leHRlbmQoIFRIUkVFLlRyaWFuZ2xlLnByb3RvdHlwZSwge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVHJpYW5nbGUsXHJcblxyXG5cdHNldDogZnVuY3Rpb24gKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdHRoaXMuYS5jb3B5KCBhICk7XHJcblx0XHR0aGlzLmIuY29weSggYiApO1xyXG5cdFx0dGhpcy5jLmNvcHkoIGMgKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0c2V0RnJvbVBvaW50c0FuZEluZGljZXM6IGZ1bmN0aW9uICggcG9pbnRzLCBpMCwgaTEsIGkyICkge1xyXG5cclxuXHRcdHRoaXMuYS5jb3B5KCBwb2ludHNbaTBdICk7XHJcblx0XHR0aGlzLmIuY29weSggcG9pbnRzW2kxXSApO1xyXG5cdFx0dGhpcy5jLmNvcHkoIHBvaW50c1tpMl0gKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHJcblx0fSxcclxuXHJcblx0Y29weTogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcclxuXHJcblx0XHR0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xyXG5cdFx0dGhpcy5iLmNvcHkoIHRyaWFuZ2xlLmIgKTtcclxuXHRcdHRoaXMuYy5jb3B5KCB0cmlhbmdsZS5jICk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGFyZWE6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdHZhciB2MCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2MC5zdWJWZWN0b3JzKCB0aGlzLmMsIHRoaXMuYiApO1xyXG5cdFx0XHR2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xyXG5cclxuXHRcdFx0cmV0dXJuIHYwLmNyb3NzKCB2MSApLmxlbmd0aCgpICogMC41O1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH0oKSxcclxuXHJcblx0bWlkcG9pbnQ6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICkuYWRkKCB0aGlzLmMgKS5tdWx0aXBseVNjYWxhciggMSAvIDMgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bm9ybWFsOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5ub3JtYWwoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIG9wdGlvbmFsVGFyZ2V0ICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHBsYW5lOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVEhSRUUuUGxhbmUoKTtcclxuXHJcblx0XHRyZXR1cm4gcmVzdWx0LnNldEZyb21Db3BsYW5hclBvaW50cyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRiYXJ5Y29vcmRGcm9tUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xyXG5cclxuXHRcdHJldHVybiBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBwb2ludCwgdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uICggdHJpYW5nbGUgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRyaWFuZ2xlLmEuZXF1YWxzKCB0aGlzLmEgKSAmJiB0cmlhbmdsZS5iLmVxdWFscyggdGhpcy5iICkgJiYgdHJpYW5nbGUuYy5lcXVhbHMoIHRoaXMuYyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVHJpYW5nbGUoKS5jb3B5KCB0aGlzICk7XHJcblxyXG5cdH1cclxuXHJcbn0gKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVmVydGV4ID0gZnVuY3Rpb24gKCB2ICkge1xyXG5cclxuXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZXJ0ZXggaGFzIGJlZW4gREVQUkVDQVRFRC4gVXNlIFRIUkVFLlZlY3RvcjMgaW5zdGVhZC4nKVxyXG5cdHJldHVybiB2O1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuVVYgPSBmdW5jdGlvbiAoIHUsIHYgKSB7XHJcblxyXG5cdGNvbnNvbGUud2FybiggJ1RIUkVFLlVWIGhhcyBiZWVuIERFUFJFQ0FURUQuIFVzZSBUSFJFRS5WZWN0b3IyIGluc3RlYWQuJylcclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkNsb2NrID0gZnVuY3Rpb24gKCBhdXRvU3RhcnQgKSB7XHJcblxyXG5cdHRoaXMuYXV0b1N0YXJ0ID0gKCBhdXRvU3RhcnQgIT09IHVuZGVmaW5lZCApID8gYXV0b1N0YXJ0IDogdHJ1ZTtcclxuXHJcblx0dGhpcy5zdGFydFRpbWUgPSAwO1xyXG5cdHRoaXMub2xkVGltZSA9IDA7XHJcblx0dGhpcy5lbGFwc2VkVGltZSA9IDA7XHJcblxyXG5cdHRoaXMucnVubmluZyA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLmV4dGVuZCggVEhSRUUuQ2xvY2sucHJvdG90eXBlLCB7XHJcblxyXG5cdHN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5zdGFydFRpbWUgPSB3aW5kb3cucGVyZm9ybWFuY2UgIT09IHVuZGVmaW5lZCAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHRcdD8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpXHJcblx0XHRcdFx0XHQ6IERhdGUubm93KCk7XHJcblxyXG5cdFx0dGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XHJcblx0XHR0aGlzLnJ1bm5pbmcgPSB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdHN0b3A6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmdldEVsYXBzZWRUaW1lKCk7XHJcblx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0RWxhcHNlZFRpbWU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmdldERlbHRhKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5lbGFwc2VkVGltZTtcclxuXHJcblx0fSxcclxuXHJcblx0Z2V0RGVsdGE6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZGlmZiA9IDA7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF1dG9TdGFydCAmJiAhIHRoaXMucnVubmluZyApIHtcclxuXHJcblx0XHRcdHRoaXMuc3RhcnQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XHJcblxyXG5cdFx0XHR2YXIgbmV3VGltZSA9IHdpbmRvdy5wZXJmb3JtYW5jZSAhPT0gdW5kZWZpbmVkICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgIT09IHVuZGVmaW5lZFxyXG5cdFx0XHRcdFx0PyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcclxuXHRcdFx0XHRcdDogRGF0ZS5ub3coKTtcclxuXHJcblx0XHRcdGRpZmYgPSAwLjAwMSAqICggbmV3VGltZSAtIHRoaXMub2xkVGltZSApO1xyXG5cdFx0XHR0aGlzLm9sZFRpbWUgPSBuZXdUaW1lO1xyXG5cclxuXHRcdFx0dGhpcy5lbGFwc2VkVGltZSArPSBkaWZmO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGlmZjtcclxuXHJcblx0fVxyXG5cclxufSApO1xyXG4vKipcclxuICogaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi9ldmVudGRpc3BhdGNoZXIuanMvXHJcbiAqL1xyXG5cclxuVEhSRUUuRXZlbnREaXNwYXRjaGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbGlzdGVuZXJzID0ge307XHJcblxyXG5cdHRoaXMuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XHJcblxyXG5cdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bGlzdGVuZXJzWyB0eXBlIF0gPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApID09PSAtIDEgKSB7XHJcblxyXG5cdFx0XHRsaXN0ZW5lcnNbIHR5cGUgXS5wdXNoKCBsaXN0ZW5lciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSBsaXN0ZW5lcnNbIHR5cGUgXS5pbmRleE9mKCBsaXN0ZW5lciApO1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcclxuXHJcblx0XHRcdGxpc3RlbmVyc1sgdHlwZSBdLnNwbGljZSggaW5kZXgsIDEgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIGV2ZW50LnR5cGUgXTtcclxuXHJcblx0XHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGV2ZW50LnRhcmdldCA9IHRoaXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBsaXN0ZW5lckFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGxpc3RlbmVyQXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb20vXHJcbiAqL1xyXG5cclxuKCBmdW5jdGlvbiAoIFRIUkVFICkge1xyXG5cclxuXHRUSFJFRS5SYXljYXN0ZXIgPSBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFx0dGhpcy5yYXkgPSBuZXcgVEhSRUUuUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xyXG5cclxuXHRcdC8vIG5vcm1hbGl6ZWQgcmF5LmRpcmVjdGlvbiByZXF1aXJlZCBmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zXHJcblx0XHRpZiggdGhpcy5yYXkuZGlyZWN0aW9uLmxlbmd0aFNxKCkgPiAwICkge1xyXG5cclxuXHRcdFx0dGhpcy5yYXkuZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm5lYXIgPSBuZWFyIHx8IDA7XHJcblx0XHR0aGlzLmZhciA9IGZhciB8fCBJbmZpbml0eTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHNwaGVyZSA9IG5ldyBUSFJFRS5TcGhlcmUoKTtcclxuXHR2YXIgbG9jYWxSYXkgPSBuZXcgVEhSRUUuUmF5KCk7XHJcblx0dmFyIGZhY2VQbGFuZSA9IG5ldyBUSFJFRS5QbGFuZSgpO1xyXG5cdHZhciBpbnRlcnNlY3RQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIG1hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHR2YXIgZGVzY1NvcnQgPSBmdW5jdGlvbiAoIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGEuZGlzdGFuY2UgLSBiLmRpc3RhbmNlO1xyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgaW50ZXJzZWN0T2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QsIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlICkge1xyXG5cclxuXHRcdFx0bWF0cml4UG9zaXRpb24uZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5kaXN0YW5jZVRvUG9pbnQoIG1hdHJpeFBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRpZiAoIGRpc3RhbmNlID4gb2JqZWN0LnNjYWxlLnggKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aW50ZXJzZWN0cy5wdXNoKCB7XHJcblxyXG5cdFx0XHRcdGRpc3RhbmNlOiBkaXN0YW5jZSxcclxuXHRcdFx0XHRwb2ludDogb2JqZWN0LnBvc2l0aW9uLFxyXG5cdFx0XHRcdGZhY2U6IG51bGwsXHJcblx0XHRcdFx0b2JqZWN0OiBvYmplY3RcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0Ly8gQ2hlY2tpbmcgYm91bmRpbmdTcGhlcmUgZGlzdGFuY2UgdG8gcmF5XHJcblx0XHRcdG1hdHJpeFBvc2l0aW9uLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdHNwaGVyZS5zZXQoXHJcblx0XHRcdFx0bWF0cml4UG9zaXRpb24sXHJcblx0XHRcdFx0b2JqZWN0Lmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlLnJhZGl1cyAqIG9iamVjdC5tYXRyaXhXb3JsZC5nZXRNYXhTY2FsZU9uQXhpcygpICk7XHJcblxyXG5cdFx0XHRpZiAoICEgcmF5Y2FzdGVyLnJheS5pc0ludGVyc2VjdGlvblNwaGVyZSggc3BoZXJlICkgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBpbnRlcnNlY3RzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQ2hlY2tpbmcgZmFjZXNcclxuXHJcblx0XHRcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHRcdFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XHJcblxyXG5cdFx0XHR2YXIgaXNGYWNlTWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsO1xyXG5cdFx0XHR2YXIgb2JqZWN0TWF0ZXJpYWxzID0gaXNGYWNlTWF0ZXJpYWwgPT09IHRydWUgPyBvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzIDogbnVsbDtcclxuXHJcblx0XHRcdHZhciBzaWRlID0gb2JqZWN0Lm1hdGVyaWFsLnNpZGU7XHJcblxyXG5cdFx0XHR2YXIgYSwgYiwgYywgZDtcclxuXHRcdFx0dmFyIHByZWNpc2lvbiA9IHJheWNhc3Rlci5wcmVjaXNpb247XHJcblxyXG5cdFx0XHRvYmplY3QubWF0cml4Um90YXRpb25Xb3JsZC5leHRyYWN0Um90YXRpb24oIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdGxvY2FsUmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBmID0gMCwgZmwgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGZhY2UgPSBnZW9tZXRyeS5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZSA/IG9iamVjdE1hdGVyaWFsc1sgZmFjZS5tYXRlcmlhbEluZGV4IF0gOiBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRmYWNlUGxhbmUuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIGZhY2Uubm9ybWFsLCB2ZXJ0aWNlc1tmYWNlLmFdICk7XHJcblxyXG5cdFx0XHRcdHZhciBwbGFuZURpc3RhbmNlID0gbG9jYWxSYXkuZGlzdGFuY2VUb1BsYW5lKCBmYWNlUGxhbmUgKTtcclxuXHJcblx0XHRcdFx0Ly8gYmFpbCBpZiByYXljYXN0ZXIgYW5kIHBsYW5lIGFyZSBwYXJhbGxlbFxyXG5cdFx0XHRcdGlmICggTWF0aC5hYnMoIHBsYW5lRGlzdGFuY2UgKSA8IHByZWNpc2lvbiApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHQvLyBpZiBuZWdhdGl2ZSBkaXN0YW5jZSwgdGhlbiBwbGFuZSBpcyBiZWhpbmQgcmF5Y2FzdGVyXHJcblx0XHRcdFx0aWYgKCBwbGFuZURpc3RhbmNlIDwgMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHQvLyBjaGVjayBpZiB3ZSBoaXQgdGhlIHdyb25nIHNpZGUgb2YgYSBzaW5nbGUgc2lkZWQgZmFjZVxyXG5cdFx0XHRcdHNpZGUgPSBtYXRlcmlhbC5zaWRlO1xyXG5cdFx0XHRcdGlmKCBzaWRlICE9PSBUSFJFRS5Eb3VibGVTaWRlICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBwbGFuZVNpZ24gPSBsb2NhbFJheS5kaXJlY3Rpb24uZG90KCBmYWNlUGxhbmUubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0aWYoICEgKCBzaWRlID09PSBUSFJFRS5Gcm9udFNpZGUgPyBwbGFuZVNpZ24gPCAwIDogcGxhbmVTaWduID4gMCApICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gdGhpcyBjYW4gYmUgZG9uZSB1c2luZyB0aGUgcGxhbmVEaXN0YW5jZSBmcm9tIGxvY2FsUmF5IGJlY2F1c2UgbG9jYWxSYXkgd2Fzbid0IG5vcm1hbGl6ZWQsIGJ1dCByYXkgd2FzXHJcblx0XHRcdFx0aWYgKCBwbGFuZURpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgcGxhbmVEaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0aW50ZXJzZWN0UG9pbnQgPSBsb2NhbFJheS5hdCggcGxhbmVEaXN0YW5jZSwgaW50ZXJzZWN0UG9pbnQgKTsgLy8gcGFzc2luZyBpbiBpbnRlcnNlY3RQb2ludCBhdm9pZHMgYSBjb3B5XHJcblxyXG5cdFx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0XHRcdGEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRiID0gdmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0YyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgVEhSRUUuVHJpYW5nbGUuY29udGFpbnNQb2ludCggaW50ZXJzZWN0UG9pbnQsIGEsIGIsIGMgKSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XHJcblxyXG5cdFx0XHRcdFx0YSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdGIgPSB2ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0XHRjID0gdmVydGljZXNbIGZhY2UuYyBdO1xyXG5cdFx0XHRcdFx0ZCA9IHZlcnRpY2VzWyBmYWNlLmQgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICggISBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBpbnRlcnNlY3RQb2ludCwgYSwgYiwgZCApICkgJiZcclxuXHRcdFx0XHRcdFx0ICggISBUSFJFRS5UcmlhbmdsZS5jb250YWluc1BvaW50KCBpbnRlcnNlY3RQb2ludCwgYiwgYywgZCApICkgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGFkZGVkIGJlY2F1c2UgaWYgd2UgY2FsbCBvdXQgb2YgdGhpcyBpZi9lbHNlIGdyb3VwIHdoZW4gbm9uZSBvZiB0aGUgY2FzZXNcclxuXHRcdFx0XHRcdC8vICAgIG1hdGNoIGl0IHdpbGwgYWRkIGEgcG9pbnQgdG8gdGhlIGludGVyc2VjdGlvbiBsaXN0IGVycm9uZW91c2x5LlxyXG5cdFx0XHRcdFx0dGhyb3cgRXJyb3IoIFwiZmFjZSB0eXBlIG5vdCBzdXBwb3J0ZWRcIiApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCgge1xyXG5cclxuXHRcdFx0XHRcdGRpc3RhbmNlOiBwbGFuZURpc3RhbmNlLFx0Ly8gdGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBvcmlnaW5hbCByYXkgd2FzIG5vcm1hbGl6ZWQsIGFuZCB0aGUgdHJhbnNmb3JtZWQgbG9jYWxSYXkgd2Fzbid0XHJcblx0XHRcdFx0XHRwb2ludDogcmF5Y2FzdGVyLnJheS5hdCggcGxhbmVEaXN0YW5jZSApLFxyXG5cdFx0XHRcdFx0ZmFjZTogZmFjZSxcclxuXHRcdFx0XHRcdGZhY2VJbmRleDogZixcclxuXHRcdFx0XHRcdG9iamVjdDogb2JqZWN0XHJcblxyXG5cdFx0XHRcdH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBpbnRlcnNlY3REZXNjZW5kYW50cyA9IGZ1bmN0aW9uICggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XHJcblxyXG5cdFx0dmFyIGRlc2NlbmRhbnRzID0gb2JqZWN0LmdldERlc2NlbmRhbnRzKCk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZGVzY2VuZGFudHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGludGVyc2VjdE9iamVjdCggZGVzY2VuZGFudHNbIGkgXSwgcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XHJcblxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdFRIUkVFLlJheWNhc3Rlci5wcm90b3R5cGUucHJlY2lzaW9uID0gMC4wMDAxO1xyXG5cclxuXHRUSFJFRS5SYXljYXN0ZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XHJcblxyXG5cdFx0dGhpcy5yYXkuc2V0KCBvcmlnaW4sIGRpcmVjdGlvbiApO1xyXG5cclxuXHRcdC8vIG5vcm1hbGl6ZWQgcmF5LmRpcmVjdGlvbiByZXF1aXJlZCBmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zXHJcblx0XHRpZiggdGhpcy5yYXkuZGlyZWN0aW9uLmxlbmd0aCgpID4gMCApIHtcclxuXHJcblx0XHRcdHRoaXMucmF5LmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdFRIUkVFLlJheWNhc3Rlci5wcm90b3R5cGUuaW50ZXJzZWN0T2JqZWN0ID0gZnVuY3Rpb24gKCBvYmplY3QsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xyXG5cclxuXHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0aW50ZXJzZWN0RGVzY2VuZGFudHMoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdCwgdGhpcywgaW50ZXJzZWN0cyApO1xyXG5cclxuXHRcdGludGVyc2VjdHMuc29ydCggZGVzY1NvcnQgKTtcclxuXHJcblx0XHRyZXR1cm4gaW50ZXJzZWN0cztcclxuXHJcblx0fTtcclxuXHJcblx0VEhSRUUuUmF5Y2FzdGVyLnByb3RvdHlwZS5pbnRlcnNlY3RPYmplY3RzID0gZnVuY3Rpb24gKCBvYmplY3RzLCByZWN1cnNpdmUgKSB7XHJcblxyXG5cdFx0dmFyIGludGVyc2VjdHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cyApO1xyXG5cclxuXHRcdFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdGludGVyc2VjdERlc2NlbmRhbnRzKCBvYmplY3RzWyBpIF0sIHRoaXMsIGludGVyc2VjdHMgKTtcclxuXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpbnRlcnNlY3RzLnNvcnQoIGRlc2NTb3J0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGludGVyc2VjdHM7XHJcblxyXG5cdH07XHJcblxyXG59KCBUSFJFRSApICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk9iamVjdDNEID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLmlkID0gVEhSRUUuT2JqZWN0M0RJZENvdW50ICsrO1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHR0aGlzLnByb3BlcnRpZXMgPSB7fTtcclxuXHJcblx0dGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcblx0dGhpcy5jaGlsZHJlbiA9IFtdO1xyXG5cclxuXHR0aGlzLnVwID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKTtcclxuXHJcblx0dGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5yb3RhdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5ldWxlck9yZGVyID0gVEhSRUUuT2JqZWN0M0QuZGVmYXVsdEV1bGVyT3JkZXI7XHJcblx0dGhpcy5zY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICk7XHJcblxyXG5cdHRoaXMucmVuZGVyRGVwdGggPSBudWxsO1xyXG5cclxuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdHRoaXMubWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHR0aGlzLm1hdHJpeFdvcmxkID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHR0aGlzLm1hdHJpeFJvdGF0aW9uV29ybGQgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdHRoaXMucXVhdGVybmlvbiA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblx0dGhpcy51c2VRdWF0ZXJuaW9uID0gZmFsc2U7XHJcblxyXG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG5cdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xyXG5cdHRoaXMucmVjZWl2ZVNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xyXG5cclxuXHR0aGlzLl92ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5PYmplY3QzRC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5PYmplY3QzRCxcclxuXHJcblx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xyXG5cclxuXHRcdHRoaXMubWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHR0aGlzLnNjYWxlLmdldFNjYWxlRnJvbU1hdHJpeCggdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHR2YXIgbWF0ID0gbmV3IFRIUkVFLk1hdHJpeDQoKS5leHRyYWN0Um90YXRpb24oIHRoaXMubWF0cml4ICk7XHJcblx0XHR0aGlzLnJvdGF0aW9uLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCBtYXQsIHRoaXMuZXVsZXJPcmRlciApO1xyXG5cclxuXHRcdHRoaXMucG9zaXRpb24uZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggZGlzdGFuY2UsIGF4aXMgKSB7XHJcblxyXG5cdFx0dGhpcy5tYXRyaXgucm90YXRlQXhpcyggYXhpcyApO1xyXG5cdFx0dGhpcy5wb3NpdGlvbi5hZGQoIGF4aXMubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0dHJhbnNsYXRlWDogZnVuY3Rpb24gKCBkaXN0YW5jZSApIHtcclxuXHJcblx0XHR0aGlzLnRyYW5zbGF0ZSggZGlzdGFuY2UsIHRoaXMuX3ZlY3Rvci5zZXQoIDEsIDAsIDAgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR0cmFuc2xhdGVZOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdHRoaXMudHJhbnNsYXRlKCBkaXN0YW5jZSwgdGhpcy5fdmVjdG9yLnNldCggMCwgMSwgMCApICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyYW5zbGF0ZVo6IGZ1bmN0aW9uICggZGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0dGhpcy50cmFuc2xhdGUoIGRpc3RhbmNlLCB0aGlzLl92ZWN0b3Iuc2V0KCAwLCAwLCAxICkgKTtcclxuXHJcblx0fSxcclxuXHJcblx0bG9jYWxUb1dvcmxkOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcclxuXHJcblx0XHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcy5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHR3b3JsZFRvTG9jYWw6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBUSFJFRS5PYmplY3QzRC5fX20xLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRsb29rQXQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHRcdC8vIFRPRE86IEFkZCBoaWVyYXJjaHkgc3VwcG9ydC5cclxuXHJcblx0XHR0aGlzLm1hdHJpeC5sb29rQXQoIHZlY3RvciwgdGhpcy5wb3NpdGlvbiwgdGhpcy51cCApO1xyXG5cclxuXHRcdGlmICggdGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudXNlUXVhdGVybmlvbiA9PT0gZmFsc2UgKSAge1xyXG5cclxuXHRcdFx0XHR0aGlzLnJvdGF0aW9uLnNldEV1bGVyRnJvbVJvdGF0aW9uTWF0cml4KCB0aGlzLm1hdHJpeCwgdGhpcy5ldWxlck9yZGVyICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLnF1YXRlcm5pb24uY29weSggdGhpcy5tYXRyaXguZGVjb21wb3NlKClbIDEgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0YWRkOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNELmFkZDogQW4gb2JqZWN0IGNhblxcJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuJyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuT2JqZWN0M0QgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2JqZWN0LnBhcmVudCA9IHRoaXM7XHJcblx0XHRcdHRoaXMuY2hpbGRyZW4ucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHQvLyBhZGQgdG8gc2NlbmVcclxuXHJcblx0XHRcdHZhciBzY2VuZSA9IHRoaXM7XHJcblxyXG5cdFx0XHR3aGlsZSAoIHNjZW5lLnBhcmVudCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzY2VuZSA9IHNjZW5lLnBhcmVudDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggc2NlbmUgIT09IHVuZGVmaW5lZCAmJiBzY2VuZSBpbnN0YW5jZW9mIFRIUkVFLlNjZW5lICkgIHtcclxuXHJcblx0XHRcdFx0c2NlbmUuX19hZGRPYmplY3QoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmICggaW5kZXggIT09IC0gMSApIHtcclxuXHJcblx0XHRcdG9iamVjdC5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcblx0XHRcdHRoaXMuY2hpbGRyZW4uc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuXHRcdFx0Ly8gcmVtb3ZlIGZyb20gc2NlbmVcclxuXHJcblx0XHRcdHZhciBzY2VuZSA9IHRoaXM7XHJcblxyXG5cdFx0XHR3aGlsZSAoIHNjZW5lLnBhcmVudCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRzY2VuZSA9IHNjZW5lLnBhcmVudDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggc2NlbmUgIT09IHVuZGVmaW5lZCAmJiBzY2VuZSBpbnN0YW5jZW9mIFRIUkVFLlNjZW5lICkge1xyXG5cclxuXHRcdFx0XHRzY2VuZS5fX3JlbW92ZU9iamVjdCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHR0cmF2ZXJzZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcclxuXHJcblx0XHRjYWxsYmFjayggdGhpcyApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW5bIGkgXS50cmF2ZXJzZSggY2FsbGJhY2sgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGdldENoaWxkQnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUsIHJlY3Vyc2l2ZSApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGNoaWxkLm5hbWUgPT09IG5hbWUgKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRjaGlsZCA9IGNoaWxkLmdldENoaWxkQnlOYW1lKCBuYW1lLCByZWN1cnNpdmUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBjaGlsZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBjaGlsZDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXREZXNjZW5kYW50czogZnVuY3Rpb24gKCBhcnJheSApIHtcclxuXHJcblx0XHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xyXG5cclxuXHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBhcnJheSwgdGhpcy5jaGlsZHJlbiApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW5bIGkgXS5nZXREZXNjZW5kYW50cyggYXJyYXkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGFycmF5O1xyXG5cclxuXHR9LFxyXG5cclxuXHR1cGRhdGVNYXRyaXg6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLm1hdHJpeC5zZXRQb3NpdGlvbiggdGhpcy5wb3NpdGlvbiApO1xyXG5cclxuXHRcdGlmICggdGhpcy51c2VRdWF0ZXJuaW9uID09PSBmYWxzZSApICB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeC5zZXRSb3RhdGlvbkZyb21FdWxlciggdGhpcy5yb3RhdGlvbiwgdGhpcy5ldWxlck9yZGVyICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4LnNldFJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHRoaXMucXVhdGVybmlvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHRoaXMuc2NhbGUueCAhPT0gMSB8fCB0aGlzLnNjYWxlLnkgIT09IDEgfHwgdGhpcy5zY2FsZS56ICE9PSAxICkge1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXguc2NhbGUoIHRoaXMuc2NhbGUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlTWF0cml4V29ybGQ6IGZ1bmN0aW9uICggZm9yY2UgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPT09IHRydWUgKSB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xyXG5cclxuXHRcdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID09PSB0cnVlIHx8IGZvcmNlID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHRmb3JjZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBjaGlsZHJlblxyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuY2hpbGRyZW5bIGkgXS51cGRhdGVNYXRyaXhXb3JsZCggZm9yY2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdFx0b2JqZWN0Lm5hbWUgPSB0aGlzLm5hbWU7XHJcblxyXG5cdFx0b2JqZWN0LnVwLmNvcHkoIHRoaXMudXAgKTtcclxuXHJcblx0XHRvYmplY3QucG9zaXRpb24uY29weSggdGhpcy5wb3NpdGlvbiApO1xyXG5cdFx0aWYgKCBvYmplY3Qucm90YXRpb24gaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICkgb2JqZWN0LnJvdGF0aW9uLmNvcHkoIHRoaXMucm90YXRpb24gKTsgLy8gYmVjYXVzZSBvZiBTcHJpdGUgbWFkbmVzc1xyXG5cdFx0b2JqZWN0LmV1bGVyT3JkZXIgPSB0aGlzLmV1bGVyT3JkZXI7XHJcblx0XHRvYmplY3Quc2NhbGUuY29weSggdGhpcy5zY2FsZSApO1xyXG5cclxuXHRcdG9iamVjdC5yZW5kZXJEZXB0aCA9IHRoaXMucmVuZGVyRGVwdGg7XHJcblxyXG5cdFx0b2JqZWN0LnJvdGF0aW9uQXV0b1VwZGF0ZSA9IHRoaXMucm90YXRpb25BdXRvVXBkYXRlO1xyXG5cclxuXHRcdG9iamVjdC5tYXRyaXguY29weSggdGhpcy5tYXRyaXggKTtcclxuXHRcdG9iamVjdC5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeFdvcmxkICk7XHJcblx0XHRvYmplY3QubWF0cml4Um90YXRpb25Xb3JsZC5jb3B5KCB0aGlzLm1hdHJpeFJvdGF0aW9uV29ybGQgKTtcclxuXHJcblx0XHRvYmplY3QubWF0cml4QXV0b1VwZGF0ZSA9IHRoaXMubWF0cml4QXV0b1VwZGF0ZTtcclxuXHRcdG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlO1xyXG5cclxuXHRcdG9iamVjdC5xdWF0ZXJuaW9uLmNvcHkoIHRoaXMucXVhdGVybmlvbiApO1xyXG5cdFx0b2JqZWN0LnVzZVF1YXRlcm5pb24gPSB0aGlzLnVzZVF1YXRlcm5pb247XHJcblxyXG5cdFx0b2JqZWN0LnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcblxyXG5cdFx0b2JqZWN0LmNhc3RTaGFkb3cgPSB0aGlzLmNhc3RTaGFkb3c7XHJcblx0XHRvYmplY3QucmVjZWl2ZVNoYWRvdyA9IHRoaXMucmVjZWl2ZVNoYWRvdztcclxuXHJcblx0XHRvYmplY3QuZnJ1c3R1bUN1bGxlZCA9IHRoaXMuZnJ1c3R1bUN1bGxlZDtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcclxuXHRcdFx0b2JqZWN0LmFkZCggY2hpbGQuY2xvbmUoKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gb2JqZWN0O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuT2JqZWN0M0QuX19tMSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblRIUkVFLk9iamVjdDNELmRlZmF1bHRFdWxlck9yZGVyID0gJ1hZWicsXHJcblxyXG5USFJFRS5PYmplY3QzRElkQ291bnQgPSAwO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBzdXBlcmVnZ2JlcnQgLyBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9cclxuICogQGF1dGhvciBqdWxpYW53YSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWxpYW53YVxyXG4gKi9cclxuXHJcblRIUkVFLlByb2plY3RvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIF9vYmplY3QsIF9vYmplY3RDb3VudCwgX29iamVjdFBvb2wgPSBbXSwgX29iamVjdFBvb2xMZW5ndGggPSAwLFxyXG5cdF92ZXJ0ZXgsIF92ZXJ0ZXhDb3VudCwgX3ZlcnRleFBvb2wgPSBbXSwgX3ZlcnRleFBvb2xMZW5ndGggPSAwLFxyXG5cdF9mYWNlLCBfZmFjZTNDb3VudCwgX2ZhY2UzUG9vbCA9IFtdLCBfZmFjZTNQb29sTGVuZ3RoID0gMCxcclxuXHRfZmFjZTRDb3VudCwgX2ZhY2U0UG9vbCA9IFtdLCBfZmFjZTRQb29sTGVuZ3RoID0gMCxcclxuXHRfbGluZSwgX2xpbmVDb3VudCwgX2xpbmVQb29sID0gW10sIF9saW5lUG9vbExlbmd0aCA9IDAsXHJcblx0X3BhcnRpY2xlLCBfcGFydGljbGVDb3VudCwgX3BhcnRpY2xlUG9vbCA9IFtdLCBfcGFydGljbGVQb29sTGVuZ3RoID0gMCxcclxuXHJcblx0X3JlbmRlckRhdGEgPSB7IG9iamVjdHM6IFtdLCBzcHJpdGVzOiBbXSwgbGlnaHRzOiBbXSwgZWxlbWVudHM6IFtdIH0sXHJcblxyXG5cdF92ZWN0b3IzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRfdmVjdG9yNCA9IG5ldyBUSFJFRS5WZWN0b3I0KCksXHJcblxyXG5cdF9jbGlwQm94ID0gbmV3IFRIUkVFLkJveDMoIG5ldyBUSFJFRS5WZWN0b3IzKCAtMSwgLTEsIC0xICksIG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICkgKSxcclxuXHRfYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm94MygpLFxyXG5cdF9wb2ludHMzID0gbmV3IEFycmF5KCAzICksXHJcblx0X3BvaW50czQgPSBuZXcgQXJyYXkoIDQgKSxcclxuXHJcblx0X3ZpZXdNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cdF92aWV3UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXHJcblxyXG5cdF9tb2RlbE1hdHJpeCxcclxuXHRfbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCksXHJcblxyXG5cdF9ub3JtYWxNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4MygpLFxyXG5cdF9ub3JtYWxWaWV3TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKSxcclxuXHJcblx0X2NlbnRyb2lkID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcblx0X2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxyXG5cclxuXHRfY2xpcHBlZFZlcnRleDFQb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCksXHJcblx0X2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4gPSBuZXcgVEhSRUUuVmVjdG9yNCgpO1xyXG5cclxuXHR0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuXHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0X3ZpZXdQcm9qZWN0aW9uTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIF92aWV3UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnVucHJvamVjdFZlY3RvciA9IGZ1bmN0aW9uICggdmVjdG9yLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0X3ZpZXdQcm9qZWN0aW9uTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZCwgY2FtZXJhLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlY3Rvci5hcHBseVByb2plY3Rpb24oIF92aWV3UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnBpY2tpbmdSYXkgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xyXG5cclxuXHRcdC8vIHNldCB0d28gdmVjdG9ycyB3aXRoIG9wcG9zaW5nIHogdmFsdWVzXHJcblx0XHR2ZWN0b3IueiA9IC0xLjA7XHJcblx0XHR2YXIgZW5kID0gbmV3IFRIUkVFLlZlY3RvcjMoIHZlY3Rvci54LCB2ZWN0b3IueSwgMS4wICk7XHJcblxyXG5cdFx0dGhpcy51bnByb2plY3RWZWN0b3IoIHZlY3RvciwgY2FtZXJhICk7XHJcblx0XHR0aGlzLnVucHJvamVjdFZlY3RvciggZW5kLCBjYW1lcmEgKTtcclxuXHJcblx0XHQvLyBmaW5kIGRpcmVjdGlvbiBmcm9tIHZlY3RvciB0byBlbmRcclxuXHRcdGVuZC5zdWIoIHZlY3RvciApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuUmF5Y2FzdGVyKCB2ZWN0b3IsIGVuZCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgcHJvamVjdEdyYXBoID0gZnVuY3Rpb24gKCByb290LCBzb3J0T2JqZWN0cyApIHtcclxuXHJcblx0XHRfb2JqZWN0Q291bnQgPSAwO1xyXG5cclxuXHRcdF9yZW5kZXJEYXRhLm9iamVjdHMubGVuZ3RoID0gMDtcclxuXHRcdF9yZW5kZXJEYXRhLnNwcml0ZXMubGVuZ3RoID0gMDtcclxuXHRcdF9yZW5kZXJEYXRhLmxpZ2h0cy5sZW5ndGggPSAwO1xyXG5cclxuXHRcdHZhciBwcm9qZWN0T2JqZWN0ID0gZnVuY3Rpb24gKCBwYXJlbnQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgYyA9IDAsIGNsID0gcGFyZW50LmNoaWxkcmVuLmxlbmd0aDsgYyA8IGNsOyBjICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgb2JqZWN0ID0gcGFyZW50LmNoaWxkcmVuWyBjIF07XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3JlbmRlckRhdGEubGlnaHRzLnB1c2goIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCA9PT0gZmFsc2UgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfb2JqZWN0ID0gZ2V0TmV4dE9iamVjdEluUG9vbCgpO1xyXG5cdFx0XHRcdFx0XHRfb2JqZWN0Lm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggb2JqZWN0LnJlbmRlckRlcHRoICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfb2JqZWN0LnogPSBvYmplY3QucmVuZGVyRGVwdGg7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3ZpZXdQcm9qZWN0aW9uTWF0cml4ICk7XHJcblx0XHRcdFx0XHRcdFx0X29iamVjdC56ID0gX3ZlY3RvcjMuejtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdF9yZW5kZXJEYXRhLm9iamVjdHMucHVzaCggX29iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlICkge1xyXG5cclxuXHRcdFx0XHRcdF9vYmplY3QgPSBnZXROZXh0T2JqZWN0SW5Qb29sKCk7XHJcblx0XHRcdFx0XHRfb2JqZWN0Lm9iamVjdCA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0XHQvLyBUT0RPOiBGaW5kIGFuIGVsZWdhbnQgYW5kIHBlcmZvcm1hbnQgc29sdXRpb24gYW5kIHJlbW92ZSB0aGlzIGR1cGUgY29kZS5cclxuXHJcblx0XHRcdFx0XHRpZiAoIG9iamVjdC5yZW5kZXJEZXB0aCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9vYmplY3QueiA9IG9iamVjdC5yZW5kZXJEZXB0aDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0X3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdFx0X3ZlY3RvcjMuYXBwbHlQcm9qZWN0aW9uKCBfdmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHRcdFx0XHRcdFx0X29iamVjdC56ID0gX3ZlY3RvcjMuejtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0X3JlbmRlckRhdGEuc3ByaXRlcy5wdXNoKCBfb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X29iamVjdCA9IGdldE5leHRPYmplY3RJblBvb2woKTtcclxuXHRcdFx0XHRcdF9vYmplY3Qub2JqZWN0ID0gb2JqZWN0O1xyXG5cclxuXHRcdFx0XHRcdGlmICggb2JqZWN0LnJlbmRlckRlcHRoICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X29iamVjdC56ID0gb2JqZWN0LnJlbmRlckRlcHRoO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfdmVjdG9yMy5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0XHRfdmVjdG9yMy5hcHBseVByb2plY3Rpb24oIF92aWV3UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cdFx0XHRcdFx0XHRfb2JqZWN0LnogPSBfdmVjdG9yMy56O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfcmVuZGVyRGF0YS5vYmplY3RzLnB1c2goIF9vYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRwcm9qZWN0T2JqZWN0KCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9O1xyXG5cclxuXHRcdHByb2plY3RPYmplY3QoIHJvb3QgKTtcclxuXHJcblx0XHRpZiAoIHNvcnRPYmplY3RzID09PSB0cnVlICkgX3JlbmRlckRhdGEub2JqZWN0cy5zb3J0KCBwYWludGVyU29ydCApO1xyXG5cclxuXHRcdHJldHVybiBfcmVuZGVyRGF0YTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5wcm9qZWN0U2NlbmUgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHNvcnRPYmplY3RzLCBzb3J0RWxlbWVudHMgKSB7XHJcblxyXG5cdFx0dmFyIHZpc2libGUgPSBmYWxzZSxcclxuXHRcdG8sIG9sLCB2LCB2bCwgZiwgZmwsIG4sIG5sLCBjLCBjbCwgdSwgdWwsIG9iamVjdCxcclxuXHRcdGdlb21ldHJ5LCB2ZXJ0aWNlcywgZmFjZXMsIGZhY2UsIGZhY2VWZXJ0ZXhOb3JtYWxzLCBmYWNlVmVydGV4VXZzLCB1dnMsXHJcblx0XHR2MSwgdjIsIHYzLCB2NCwgaXNGYWNlTWF0ZXJpYWwsIG9iamVjdE1hdGVyaWFscztcclxuXHJcblx0XHRfZmFjZTNDb3VudCA9IDA7XHJcblx0XHRfZmFjZTRDb3VudCA9IDA7XHJcblx0XHRfbGluZUNvdW50ID0gMDtcclxuXHRcdF9wYXJ0aWNsZUNvdW50ID0gMDtcclxuXHJcblx0XHRfcmVuZGVyRGF0YS5lbGVtZW50cy5sZW5ndGggPSAwO1xyXG5cclxuXHRcdHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0aWYgKCBjYW1lcmEucGFyZW50ID09PSB1bmRlZmluZWQgKSBjYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRfdmlld01hdHJpeC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlLmdldEludmVyc2UoIGNhbWVyYS5tYXRyaXhXb3JsZCApICk7XHJcblx0XHRfdmlld1Byb2plY3Rpb25NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIF92aWV3TWF0cml4ICk7XHJcblxyXG5cdFx0X25vcm1hbFZpZXdNYXRyaXguZ2V0SW52ZXJzZSggX3ZpZXdNYXRyaXggKTtcclxuXHRcdF9ub3JtYWxWaWV3TWF0cml4LnRyYW5zcG9zZSgpO1xyXG5cclxuXHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF92aWV3UHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHRcdF9yZW5kZXJEYXRhID0gcHJvamVjdEdyYXBoKCBzY2VuZSwgc29ydE9iamVjdHMgKTtcclxuXHJcblx0XHRmb3IgKCBvID0gMCwgb2wgPSBfcmVuZGVyRGF0YS5vYmplY3RzLmxlbmd0aDsgbyA8IG9sOyBvICsrICkge1xyXG5cclxuXHRcdFx0b2JqZWN0ID0gX3JlbmRlckRhdGEub2JqZWN0c1sgbyBdLm9iamVjdDtcclxuXHJcblx0XHRcdF9tb2RlbE1hdHJpeCA9IG9iamVjdC5tYXRyaXhXb3JsZDtcclxuXHJcblx0XHRcdF92ZXJ0ZXhDb3VudCA9IDA7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xyXG5cdFx0XHRcdGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XHJcblx0XHRcdFx0ZmFjZVZlcnRleFV2cyA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnM7XHJcblxyXG5cdFx0XHRcdF9ub3JtYWxNYXRyaXguZ2V0SW52ZXJzZSggX21vZGVsTWF0cml4ICk7XHJcblx0XHRcdFx0X25vcm1hbE1hdHJpeC50cmFuc3Bvc2UoKTtcclxuXHJcblx0XHRcdFx0aXNGYWNlTWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsO1xyXG5cdFx0XHRcdG9iamVjdE1hdGVyaWFscyA9IGlzRmFjZU1hdGVyaWFsID09PSB0cnVlID8gb2JqZWN0Lm1hdGVyaWFsIDogbnVsbDtcclxuXHJcblx0XHRcdFx0Zm9yICggdiA9IDAsIHZsID0gdmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3ZlcnRleCA9IGdldE5leHRWZXJ0ZXhJblBvb2woKTtcclxuXHJcblx0XHRcdFx0XHRfdmVydGV4LnBvc2l0aW9uV29ybGQuY29weSggdmVydGljZXNbIHYgXSApLmFwcGx5TWF0cml4NCggX21vZGVsTWF0cml4ICk7XHJcblx0XHRcdFx0XHRfdmVydGV4LnBvc2l0aW9uU2NyZWVuLmNvcHkoIF92ZXJ0ZXgucG9zaXRpb25Xb3JsZCApLmFwcGx5TWF0cml4NCggX3ZpZXdQcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0X3ZlcnRleC5wb3NpdGlvblNjcmVlbi54IC89IF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4udztcclxuXHRcdFx0XHRcdF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4ueSAvPSBfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnc7XHJcblx0XHRcdFx0XHRfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnogLz0gX3ZlcnRleC5wb3NpdGlvblNjcmVlbi53O1xyXG5cclxuXHRcdFx0XHRcdF92ZXJ0ZXgudmlzaWJsZSA9ICEgKCBfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnggPCAtMSB8fCBfdmVydGV4LnBvc2l0aW9uU2NyZWVuLnggPiAxIHx8XHJcblx0XHRcdFx0XHRcdFx0ICAgICAgX3ZlcnRleC5wb3NpdGlvblNjcmVlbi55IDwgLTEgfHwgX3ZlcnRleC5wb3NpdGlvblNjcmVlbi55ID4gMSB8fFxyXG5cdFx0XHRcdFx0XHRcdCAgICAgIF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4ueiA8IC0xIHx8IF92ZXJ0ZXgucG9zaXRpb25TY3JlZW4ueiA+IDEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBmYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlID0gZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0XHR2YXIgbWF0ZXJpYWwgPSBpc0ZhY2VNYXRlcmlhbCA9PT0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHQ/IG9iamVjdE1hdGVyaWFscy5tYXRlcmlhbHNbIGZhY2UubWF0ZXJpYWxJbmRleCBdXHJcblx0XHRcdFx0XHRcdDogb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdHZhciBzaWRlID0gbWF0ZXJpYWwuc2lkZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHYxID0gX3ZlcnRleFBvb2xbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0XHR2MiA9IF92ZXJ0ZXhQb29sWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdFx0djMgPSBfdmVydGV4UG9vbFsgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdFx0XHRfcG9pbnRzM1sgMCBdID0gdjEucG9zaXRpb25TY3JlZW47XHJcblx0XHRcdFx0XHRcdF9wb2ludHMzWyAxIF0gPSB2Mi5wb3NpdGlvblNjcmVlbjtcclxuXHRcdFx0XHRcdFx0X3BvaW50czNbIDIgXSA9IHYzLnBvc2l0aW9uU2NyZWVuO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB2MS52aXNpYmxlID09PSB0cnVlIHx8IHYyLnZpc2libGUgPT09IHRydWUgfHwgdjMudmlzaWJsZSA9PT0gdHJ1ZSB8fFxyXG5cdFx0XHRcdFx0XHRcdF9jbGlwQm94LmlzSW50ZXJzZWN0aW9uQm94KCBfYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyggX3BvaW50czMgKSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2aXNpYmxlID0gKCAoIHYzLnBvc2l0aW9uU2NyZWVuLnggLSB2MS5wb3NpdGlvblNjcmVlbi54ICkgKiAoIHYyLnBvc2l0aW9uU2NyZWVuLnkgLSB2MS5wb3NpdGlvblNjcmVlbi55ICkgLVxyXG5cdFx0XHRcdFx0XHRcdFx0KCB2My5wb3NpdGlvblNjcmVlbi55IC0gdjEucG9zaXRpb25TY3JlZW4ueSApICogKCB2Mi5wb3NpdGlvblNjcmVlbi54IC0gdjEucG9zaXRpb25TY3JlZW4ueCApICkgPCAwO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIHNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUgfHwgdmlzaWJsZSA9PT0gKCBzaWRlID09PSBUSFJFRS5Gcm9udFNpZGUgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRfZmFjZSA9IGdldE5leHRGYWNlM0luUG9vbCgpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdF9mYWNlLnYxLmNvcHkoIHYxICk7XHJcblx0XHRcdFx0XHRcdFx0XHRfZmFjZS52Mi5jb3B5KCB2MiApO1xyXG5cdFx0XHRcdFx0XHRcdFx0X2ZhY2UudjMuY29weSggdjMgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0djEgPSBfdmVydGV4UG9vbFsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdHYyID0gX3ZlcnRleFBvb2xbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHR2MyA9IF92ZXJ0ZXhQb29sWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRcdFx0djQgPSBfdmVydGV4UG9vbFsgZmFjZS5kIF07XHJcblxyXG5cdFx0XHRcdFx0XHRfcG9pbnRzNFsgMCBdID0gdjEucG9zaXRpb25TY3JlZW47XHJcblx0XHRcdFx0XHRcdF9wb2ludHM0WyAxIF0gPSB2Mi5wb3NpdGlvblNjcmVlbjtcclxuXHRcdFx0XHRcdFx0X3BvaW50czRbIDIgXSA9IHYzLnBvc2l0aW9uU2NyZWVuO1xyXG5cdFx0XHRcdFx0XHRfcG9pbnRzNFsgMyBdID0gdjQucG9zaXRpb25TY3JlZW47XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHYxLnZpc2libGUgPT09IHRydWUgfHwgdjIudmlzaWJsZSA9PT0gdHJ1ZSB8fCB2My52aXNpYmxlID09PSB0cnVlIHx8IHY0LnZpc2libGUgPT09IHRydWUgfHxcclxuXHRcdFx0XHRcdFx0XHRfY2xpcEJveC5pc0ludGVyc2VjdGlvbkJveCggX2JvdW5kaW5nQm94LnNldEZyb21Qb2ludHMoIF9wb2ludHM0ICkgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmlzaWJsZSA9ICggdjQucG9zaXRpb25TY3JlZW4ueCAtIHYxLnBvc2l0aW9uU2NyZWVuLnggKSAqICggdjIucG9zaXRpb25TY3JlZW4ueSAtIHYxLnBvc2l0aW9uU2NyZWVuLnkgKSAtXHJcblx0XHRcdFx0XHRcdFx0XHQoIHY0LnBvc2l0aW9uU2NyZWVuLnkgLSB2MS5wb3NpdGlvblNjcmVlbi55ICkgKiAoIHYyLnBvc2l0aW9uU2NyZWVuLnggLSB2MS5wb3NpdGlvblNjcmVlbi54ICkgPCAwIHx8XHJcblx0XHRcdFx0XHRcdFx0XHQoIHYyLnBvc2l0aW9uU2NyZWVuLnggLSB2My5wb3NpdGlvblNjcmVlbi54ICkgKiAoIHY0LnBvc2l0aW9uU2NyZWVuLnkgLSB2My5wb3NpdGlvblNjcmVlbi55ICkgLVxyXG5cdFx0XHRcdFx0XHRcdFx0KCB2Mi5wb3NpdGlvblNjcmVlbi55IC0gdjMucG9zaXRpb25TY3JlZW4ueSApICogKCB2NC5wb3NpdGlvblNjcmVlbi54IC0gdjMucG9zaXRpb25TY3JlZW4ueCApIDwgMDtcclxuXHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSB8fCB2aXNpYmxlID09PSAoIHNpZGUgPT09IFRIUkVFLkZyb250U2lkZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdF9mYWNlID0gZ2V0TmV4dEZhY2U0SW5Qb29sKCk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0X2ZhY2UudjEuY29weSggdjEgKTtcclxuXHRcdFx0XHRcdFx0XHRcdF9mYWNlLnYyLmNvcHkoIHYyICk7XHJcblx0XHRcdFx0XHRcdFx0XHRfZmFjZS52My5jb3B5KCB2MyApO1xyXG5cdFx0XHRcdFx0XHRcdFx0X2ZhY2UudjQuY29weSggdjQgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdF9mYWNlLm5vcm1hbE1vZGVsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB2aXNpYmxlID09PSBmYWxzZSAmJiAoIHNpZGUgPT09IFRIUkVFLkJhY2tTaWRlIHx8IHNpZGUgPT09IFRIUkVFLkRvdWJsZVNpZGUgKSApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9mYWNlLm5vcm1hbE1vZGVsLm5lZ2F0ZSgpO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZmFjZS5ub3JtYWxNb2RlbC5hcHBseU1hdHJpeDMoIF9ub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0XHRfZmFjZS5ub3JtYWxNb2RlbFZpZXcuY29weSggX2ZhY2Uubm9ybWFsTW9kZWwgKS5hcHBseU1hdHJpeDMoIF9ub3JtYWxWaWV3TWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdFx0X2ZhY2UuY2VudHJvaWRNb2RlbC5jb3B5KCBmYWNlLmNlbnRyb2lkICkuYXBwbHlNYXRyaXg0KCBfbW9kZWxNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBuID0gMCwgbmwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IG4gPCBubDsgbiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBub3JtYWxNb2RlbCA9IF9mYWNlLnZlcnRleE5vcm1hbHNNb2RlbFsgbiBdO1xyXG5cdFx0XHRcdFx0XHRub3JtYWxNb2RlbC5jb3B5KCBmYWNlVmVydGV4Tm9ybWFsc1sgbiBdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIHZpc2libGUgPT09IGZhbHNlICYmICggc2lkZSA9PT0gVEhSRUUuQmFja1NpZGUgfHwgc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRub3JtYWxNb2RlbC5uZWdhdGUoKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbE1vZGVsLmFwcGx5TWF0cml4MyggX25vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG5vcm1hbE1vZGVsVmlldyA9IF9mYWNlLnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbIG4gXTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsTW9kZWxWaWV3LmNvcHkoIG5vcm1hbE1vZGVsICkuYXBwbHlNYXRyaXgzKCBfbm9ybWFsVmlld01hdHJpeCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZmFjZS52ZXJ0ZXhOb3JtYWxzTGVuZ3RoID0gZmFjZVZlcnRleE5vcm1hbHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGMgPSAwLCBjbCA9IGZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBjIDwgY2w7IGMgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1dnMgPSBmYWNlVmVydGV4VXZzWyBjIF1bIGYgXTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggdXZzID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHUgPSAwLCB1bCA9IHV2cy5sZW5ndGg7IHUgPCB1bDsgdSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0X2ZhY2UudXZzWyBjIF1bIHUgXSA9IHV2c1sgdSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZmFjZS5jb2xvciA9IGZhY2UuY29sb3I7XHJcblx0XHRcdFx0XHRfZmFjZS5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRcdF9jZW50cm9pZC5jb3B5KCBfZmFjZS5jZW50cm9pZE1vZGVsICkuYXBwbHlQcm9qZWN0aW9uKCBfdmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHRfZmFjZS56ID0gX2NlbnRyb2lkLno7XHJcblxyXG5cdFx0XHRcdFx0X3JlbmRlckRhdGEuZWxlbWVudHMucHVzaCggX2ZhY2UgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcclxuXHJcblx0XHRcdFx0X21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggX3ZpZXdQcm9qZWN0aW9uTWF0cml4LCBfbW9kZWxNYXRyaXggKTtcclxuXHJcblx0XHRcdFx0dmVydGljZXMgPSBvYmplY3QuZ2VvbWV0cnkudmVydGljZXM7XHJcblxyXG5cdFx0XHRcdHYxID0gZ2V0TmV4dFZlcnRleEluUG9vbCgpO1xyXG5cdFx0XHRcdHYxLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHZlcnRpY2VzWyAwIF0gKS5hcHBseU1hdHJpeDQoIF9tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICk7XHJcblxyXG5cdFx0XHRcdC8vIEhhbmRsZSBMaW5lU3RyaXAgYW5kIExpbmVQaWVjZXNcclxuXHRcdFx0XHR2YXIgc3RlcCA9IG9iamVjdC50eXBlID09PSBUSFJFRS5MaW5lUGllY2VzID8gMiA6IDE7XHJcblxyXG5cdFx0XHRcdGZvciAoIHYgPSAxLCB2bCA9IHZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHYxID0gZ2V0TmV4dFZlcnRleEluUG9vbCgpO1xyXG5cdFx0XHRcdFx0djEucG9zaXRpb25TY3JlZW4uY29weSggdmVydGljZXNbIHYgXSApLmFwcGx5TWF0cml4NCggX21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICggdiArIDEgKSAlIHN0ZXAgPiAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0djIgPSBfdmVydGV4UG9vbFsgX3ZlcnRleENvdW50IC0gMiBdO1xyXG5cclxuXHRcdFx0XHRcdF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuLmNvcHkoIHYxLnBvc2l0aW9uU2NyZWVuICk7XHJcblx0XHRcdFx0XHRfY2xpcHBlZFZlcnRleDJQb3NpdGlvblNjcmVlbi5jb3B5KCB2Mi5wb3NpdGlvblNjcmVlbiApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY2xpcExpbmUoIF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuLCBfY2xpcHBlZFZlcnRleDJQb3NpdGlvblNjcmVlbiApID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gUGVyZm9ybSB0aGUgcGVyc3BlY3RpdmUgZGl2aWRlXHJcblx0XHRcdFx0XHRcdF9jbGlwcGVkVmVydGV4MVBvc2l0aW9uU2NyZWVuLm11bHRpcGx5U2NhbGFyKCAxIC8gX2NsaXBwZWRWZXJ0ZXgxUG9zaXRpb25TY3JlZW4udyApO1xyXG5cdFx0XHRcdFx0XHRfY2xpcHBlZFZlcnRleDJQb3NpdGlvblNjcmVlbi5tdWx0aXBseVNjYWxhciggMSAvIF9jbGlwcGVkVmVydGV4MlBvc2l0aW9uU2NyZWVuLncgKTtcclxuXHJcblx0XHRcdFx0XHRcdF9saW5lID0gZ2V0TmV4dExpbmVJblBvb2woKTtcclxuXHRcdFx0XHRcdFx0X2xpbmUudjEucG9zaXRpb25TY3JlZW4uY29weSggX2NsaXBwZWRWZXJ0ZXgxUG9zaXRpb25TY3JlZW4gKTtcclxuXHRcdFx0XHRcdFx0X2xpbmUudjIucG9zaXRpb25TY3JlZW4uY29weSggX2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4gKTtcclxuXHJcblx0XHRcdFx0XHRcdF9saW5lLnogPSBNYXRoLm1heCggX2NsaXBwZWRWZXJ0ZXgxUG9zaXRpb25TY3JlZW4ueiwgX2NsaXBwZWRWZXJ0ZXgyUG9zaXRpb25TY3JlZW4ueiApO1xyXG5cclxuXHRcdFx0XHRcdFx0X2xpbmUubWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdFx0XHRfcmVuZGVyRGF0YS5lbGVtZW50cy5wdXNoKCBfbGluZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBvID0gMCwgb2wgPSBfcmVuZGVyRGF0YS5zcHJpdGVzLmxlbmd0aDsgbyA8IG9sOyBvKysgKSB7XHJcblxyXG5cdFx0XHRvYmplY3QgPSBfcmVuZGVyRGF0YS5zcHJpdGVzWyBvIF0ub2JqZWN0O1xyXG5cclxuXHRcdFx0X21vZGVsTWF0cml4ID0gb2JqZWN0Lm1hdHJpeFdvcmxkO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZSApIHtcclxuXHJcblx0XHRcdFx0X3ZlY3RvcjQuc2V0KCBfbW9kZWxNYXRyaXguZWxlbWVudHNbMTJdLCBfbW9kZWxNYXRyaXguZWxlbWVudHNbMTNdLCBfbW9kZWxNYXRyaXguZWxlbWVudHNbMTRdLCAxICk7XHJcblx0XHRcdFx0X3ZlY3RvcjQuYXBwbHlNYXRyaXg0KCBfdmlld1Byb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0X3ZlY3RvcjQueiAvPSBfdmVjdG9yNC53O1xyXG5cclxuXHRcdFx0XHRpZiAoIF92ZWN0b3I0LnogPiAwICYmIF92ZWN0b3I0LnogPCAxICkge1xyXG5cclxuXHRcdFx0XHRcdF9wYXJ0aWNsZSA9IGdldE5leHRQYXJ0aWNsZUluUG9vbCgpO1xyXG5cdFx0XHRcdFx0X3BhcnRpY2xlLm9iamVjdCA9IG9iamVjdDtcclxuXHRcdFx0XHRcdF9wYXJ0aWNsZS54ID0gX3ZlY3RvcjQueCAvIF92ZWN0b3I0Lnc7XHJcblx0XHRcdFx0XHRfcGFydGljbGUueSA9IF92ZWN0b3I0LnkgLyBfdmVjdG9yNC53O1xyXG5cdFx0XHRcdFx0X3BhcnRpY2xlLnogPSBfdmVjdG9yNC56O1xyXG5cclxuXHRcdFx0XHRcdF9wYXJ0aWNsZS5yb3RhdGlvbiA9IG9iamVjdC5yb3RhdGlvbi56O1xyXG5cclxuXHRcdFx0XHRcdF9wYXJ0aWNsZS5zY2FsZS54ID0gb2JqZWN0LnNjYWxlLnggKiBNYXRoLmFicyggX3BhcnRpY2xlLnggLSAoIF92ZWN0b3I0LnggKyBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1swXSApIC8gKCBfdmVjdG9yNC53ICsgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMTJdICkgKTtcclxuXHRcdFx0XHRcdF9wYXJ0aWNsZS5zY2FsZS55ID0gb2JqZWN0LnNjYWxlLnkgKiBNYXRoLmFicyggX3BhcnRpY2xlLnkgLSAoIF92ZWN0b3I0LnkgKyBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50c1s1XSApIC8gKCBfdmVjdG9yNC53ICsgY2FtZXJhLnByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbMTNdICkgKTtcclxuXHJcblx0XHRcdFx0XHRfcGFydGljbGUubWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdFx0X3JlbmRlckRhdGEuZWxlbWVudHMucHVzaCggX3BhcnRpY2xlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzb3J0RWxlbWVudHMgPT09IHRydWUgKSBfcmVuZGVyRGF0YS5lbGVtZW50cy5zb3J0KCBwYWludGVyU29ydCApO1xyXG5cclxuXHRcdHJldHVybiBfcmVuZGVyRGF0YTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gUG9vbHNcclxuXHJcblx0ZnVuY3Rpb24gZ2V0TmV4dE9iamVjdEluUG9vbCgpIHtcclxuXHJcblx0XHRpZiAoIF9vYmplY3RDb3VudCA9PT0gX29iamVjdFBvb2xMZW5ndGggKSB7XHJcblxyXG5cdFx0XHR2YXIgb2JqZWN0ID0gbmV3IFRIUkVFLlJlbmRlcmFibGVPYmplY3QoKTtcclxuXHRcdFx0X29iamVjdFBvb2wucHVzaCggb2JqZWN0ICk7XHJcblx0XHRcdF9vYmplY3RQb29sTGVuZ3RoICsrO1xyXG5cdFx0XHRfb2JqZWN0Q291bnQgKys7XHJcblx0XHRcdHJldHVybiBvYmplY3Q7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBfb2JqZWN0UG9vbFsgX29iamVjdENvdW50ICsrIF07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0TmV4dFZlcnRleEluUG9vbCgpIHtcclxuXHJcblx0XHRpZiAoIF92ZXJ0ZXhDb3VudCA9PT0gX3ZlcnRleFBvb2xMZW5ndGggKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKTtcclxuXHRcdFx0X3ZlcnRleFBvb2wucHVzaCggdmVydGV4ICk7XHJcblx0XHRcdF92ZXJ0ZXhQb29sTGVuZ3RoICsrO1xyXG5cdFx0XHRfdmVydGV4Q291bnQgKys7XHJcblx0XHRcdHJldHVybiB2ZXJ0ZXg7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBfdmVydGV4UG9vbFsgX3ZlcnRleENvdW50ICsrIF07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0TmV4dEZhY2UzSW5Qb29sKCkge1xyXG5cclxuXHRcdGlmICggX2ZhY2UzQ291bnQgPT09IF9mYWNlM1Bvb2xMZW5ndGggKSB7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlRmFjZTMoKTtcclxuXHRcdFx0X2ZhY2UzUG9vbC5wdXNoKCBmYWNlICk7XHJcblx0XHRcdF9mYWNlM1Bvb2xMZW5ndGggKys7XHJcblx0XHRcdF9mYWNlM0NvdW50ICsrO1xyXG5cdFx0XHRyZXR1cm4gZmFjZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIF9mYWNlM1Bvb2xbIF9mYWNlM0NvdW50ICsrIF07XHJcblxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldE5leHRGYWNlNEluUG9vbCgpIHtcclxuXHJcblx0XHRpZiAoIF9mYWNlNENvdW50ID09PSBfZmFjZTRQb29sTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZUZhY2U0KCk7XHJcblx0XHRcdF9mYWNlNFBvb2wucHVzaCggZmFjZSApO1xyXG5cdFx0XHRfZmFjZTRQb29sTGVuZ3RoICsrO1xyXG5cdFx0XHRfZmFjZTRDb3VudCArKztcclxuXHRcdFx0cmV0dXJuIGZhY2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBfZmFjZTRQb29sWyBfZmFjZTRDb3VudCArKyBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldE5leHRMaW5lSW5Qb29sKCkge1xyXG5cclxuXHRcdGlmICggX2xpbmVDb3VudCA9PT0gX2xpbmVQb29sTGVuZ3RoICkge1xyXG5cclxuXHRcdFx0dmFyIGxpbmUgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZUxpbmUoKTtcclxuXHRcdFx0X2xpbmVQb29sLnB1c2goIGxpbmUgKTtcclxuXHRcdFx0X2xpbmVQb29sTGVuZ3RoICsrO1xyXG5cdFx0XHRfbGluZUNvdW50ICsrXHJcblx0XHRcdHJldHVybiBsaW5lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gX2xpbmVQb29sWyBfbGluZUNvdW50ICsrIF07XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0TmV4dFBhcnRpY2xlSW5Qb29sKCkge1xyXG5cclxuXHRcdGlmICggX3BhcnRpY2xlQ291bnQgPT09IF9wYXJ0aWNsZVBvb2xMZW5ndGggKSB7XHJcblxyXG5cdFx0XHR2YXIgcGFydGljbGUgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVBhcnRpY2xlKCk7XHJcblx0XHRcdF9wYXJ0aWNsZVBvb2wucHVzaCggcGFydGljbGUgKTtcclxuXHRcdFx0X3BhcnRpY2xlUG9vbExlbmd0aCArKztcclxuXHRcdFx0X3BhcnRpY2xlQ291bnQgKytcclxuXHRcdFx0cmV0dXJuIHBhcnRpY2xlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gX3BhcnRpY2xlUG9vbFsgX3BhcnRpY2xlQ291bnQgKysgXTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBwYWludGVyU29ydCggYSwgYiApIHtcclxuXHJcblx0XHRyZXR1cm4gYi56IC0gYS56O1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGNsaXBMaW5lKCBzMSwgczIgKSB7XHJcblxyXG5cdFx0dmFyIGFscGhhMSA9IDAsIGFscGhhMiA9IDEsXHJcblxyXG5cdFx0Ly8gQ2FsY3VsYXRlIHRoZSBib3VuZGFyeSBjb29yZGluYXRlIG9mIGVhY2ggdmVydGV4IGZvciB0aGUgbmVhciBhbmQgZmFyIGNsaXAgcGxhbmVzLFxyXG5cdFx0Ly8gWiA9IC0xIGFuZCBaID0gKzEsIHJlc3BlY3RpdmVseS5cclxuXHRcdGJjMW5lYXIgPSAgczEueiArIHMxLncsXHJcblx0XHRiYzJuZWFyID0gIHMyLnogKyBzMi53LFxyXG5cdFx0YmMxZmFyID0gIC0gczEueiArIHMxLncsXHJcblx0XHRiYzJmYXIgPSAgLSBzMi56ICsgczIudztcclxuXHJcblx0XHRpZiAoIGJjMW5lYXIgPj0gMCAmJiBiYzJuZWFyID49IDAgJiYgYmMxZmFyID49IDAgJiYgYmMyZmFyID49IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBCb3RoIHZlcnRpY2VzIGxpZSBlbnRpcmVseSB3aXRoaW4gYWxsIGNsaXAgcGxhbmVzLlxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCAoIGJjMW5lYXIgPCAwICYmIGJjMm5lYXIgPCAwKSB8fCAoYmMxZmFyIDwgMCAmJiBiYzJmYXIgPCAwICkgKSB7XHJcblxyXG5cdFx0XHQvLyBCb3RoIHZlcnRpY2VzIGxpZSBlbnRpcmVseSBvdXRzaWRlIG9uZSBvZiB0aGUgY2xpcCBwbGFuZXMuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gVGhlIGxpbmUgc2VnbWVudCBzcGFucyBhdCBsZWFzdCBvbmUgY2xpcCBwbGFuZS5cclxuXHJcblx0XHRcdGlmICggYmMxbmVhciA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHYxIGxpZXMgb3V0c2lkZSB0aGUgbmVhciBwbGFuZSwgdjIgaW5zaWRlXHJcblx0XHRcdFx0YWxwaGExID0gTWF0aC5tYXgoIGFscGhhMSwgYmMxbmVhciAvICggYmMxbmVhciAtIGJjMm5lYXIgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmMybmVhciA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHYyIGxpZXMgb3V0c2lkZSB0aGUgbmVhciBwbGFuZSwgdjEgaW5zaWRlXHJcblx0XHRcdFx0YWxwaGEyID0gTWF0aC5taW4oIGFscGhhMiwgYmMxbmVhciAvICggYmMxbmVhciAtIGJjMm5lYXIgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBiYzFmYXIgPCAwICkge1xyXG5cclxuXHRcdFx0XHQvLyB2MSBsaWVzIG91dHNpZGUgdGhlIGZhciBwbGFuZSwgdjIgaW5zaWRlXHJcblx0XHRcdFx0YWxwaGExID0gTWF0aC5tYXgoIGFscGhhMSwgYmMxZmFyIC8gKCBiYzFmYXIgLSBiYzJmYXIgKSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmMyZmFyIDwgMCApIHtcclxuXHJcblx0XHRcdFx0Ly8gdjIgbGllcyBvdXRzaWRlIHRoZSBmYXIgcGxhbmUsIHYyIGluc2lkZVxyXG5cdFx0XHRcdGFscGhhMiA9IE1hdGgubWluKCBhbHBoYTIsIGJjMWZhciAvICggYmMxZmFyIC0gYmMyZmFyICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYWxwaGEyIDwgYWxwaGExICkge1xyXG5cclxuXHRcdFx0XHQvLyBUaGUgbGluZSBzZWdtZW50IHNwYW5zIHR3byBib3VuZGFyaWVzLCBidXQgaXMgb3V0c2lkZSBib3RoIG9mIHRoZW0uXHJcblx0XHRcdFx0Ly8gKFRoaXMgY2FuJ3QgaGFwcGVuIHdoZW4gd2UncmUgb25seSBjbGlwcGluZyBhZ2FpbnN0IGp1c3QgbmVhci9mYXIgYnV0IGdvb2RcclxuXHRcdFx0XHQvLyAgdG8gbGVhdmUgdGhlIGNoZWNrIGhlcmUgZm9yIGZ1dHVyZSB1c2FnZSBpZiBvdGhlciBjbGlwIHBsYW5lcyBhcmUgYWRkZWQuKVxyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgczEgYW5kIHMyIHZlcnRpY2VzIHRvIG1hdGNoIHRoZSBjbGlwcGVkIGxpbmUgc2VnbWVudC5cclxuXHRcdFx0XHRzMS5sZXJwKCBzMiwgYWxwaGExICk7XHJcblx0XHRcdFx0czIubGVycCggczEsIDEgLSBhbHBoYTIgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5GYWNlMyA9IGZ1bmN0aW9uICggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApIHtcclxuXHJcblx0dGhpcy5hID0gYTtcclxuXHR0aGlzLmIgPSBiO1xyXG5cdHRoaXMuYyA9IGM7XHJcblxyXG5cdHRoaXMubm9ybWFsID0gbm9ybWFsIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMyA/IG5vcm1hbCA6IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy52ZXJ0ZXhOb3JtYWxzID0gbm9ybWFsIGluc3RhbmNlb2YgQXJyYXkgPyBub3JtYWwgOiBbIF07XHJcblxyXG5cdHRoaXMuY29sb3IgPSBjb2xvciBpbnN0YW5jZW9mIFRIUkVFLkNvbG9yID8gY29sb3IgOiBuZXcgVEhSRUUuQ29sb3IoKTtcclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IGNvbG9yIGluc3RhbmNlb2YgQXJyYXkgPyBjb2xvciA6IFtdO1xyXG5cclxuXHR0aGlzLnZlcnRleFRhbmdlbnRzID0gW107XHJcblxyXG5cdHRoaXMubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXggIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsSW5kZXggOiAwO1xyXG5cclxuXHR0aGlzLmNlbnRyb2lkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5GYWNlMy5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yOiBUSFJFRS5GYWNlMyxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggdGhpcy5hLCB0aGlzLmIsIHRoaXMuYyApO1xyXG5cclxuXHRcdGZhY2Uubm9ybWFsLmNvcHkoIHRoaXMubm9ybWFsICk7XHJcblx0XHRmYWNlLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHRcdGZhY2UuY2VudHJvaWQuY29weSggdGhpcy5jZW50cm9pZCApO1xyXG5cclxuXHRcdGZhY2UubWF0ZXJpYWxJbmRleCA9IHRoaXMubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHR2YXIgaSwgaWw7XHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSA9IHRoaXMudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRleENvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIGZhY2UudmVydGV4Q29sb3JzWyBpIF0gPSB0aGlzLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRleFRhbmdlbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkgZmFjZS52ZXJ0ZXhUYW5nZW50c1sgaSBdID0gdGhpcy52ZXJ0ZXhUYW5nZW50c1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZhY2U7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZhY2U0ID0gZnVuY3Rpb24gKCBhLCBiLCBjLCBkLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHR0aGlzLmEgPSBhO1xyXG5cdHRoaXMuYiA9IGI7XHJcblx0dGhpcy5jID0gYztcclxuXHR0aGlzLmQgPSBkO1xyXG5cclxuXHR0aGlzLm5vcm1hbCA9IG5vcm1hbCBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgPyBub3JtYWwgOiBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMudmVydGV4Tm9ybWFscyA9IG5vcm1hbCBpbnN0YW5jZW9mIEFycmF5ID8gbm9ybWFsIDogWyBdO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gY29sb3IgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciA/IGNvbG9yIDogbmV3IFRIUkVFLkNvbG9yKCk7XHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBjb2xvciBpbnN0YW5jZW9mIEFycmF5ID8gY29sb3IgOiBbXTtcclxuXHJcblx0dGhpcy52ZXJ0ZXhUYW5nZW50cyA9IFtdO1xyXG5cclxuXHR0aGlzLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMDtcclxuXHJcblx0dGhpcy5jZW50cm9pZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRmFjZTQucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuRmFjZTQsXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTQoIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMsIHRoaXMuZCApO1xyXG5cclxuXHRcdGZhY2Uubm9ybWFsLmNvcHkoIHRoaXMubm9ybWFsICk7XHJcblx0XHRmYWNlLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHRcdGZhY2UuY2VudHJvaWQuY29weSggdGhpcy5jZW50cm9pZCApO1xyXG5cclxuXHRcdGZhY2UubWF0ZXJpYWxJbmRleCA9IHRoaXMubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHR2YXIgaSwgaWw7XHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSA9IHRoaXMudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRleENvbG9ycy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIGZhY2UudmVydGV4Q29sb3JzWyBpIF0gPSB0aGlzLnZlcnRleENvbG9yc1sgaSBdLmNsb25lKCk7XHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLnZlcnRleFRhbmdlbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkgZmFjZS52ZXJ0ZXhUYW5nZW50c1sgaSBdID0gdGhpcy52ZXJ0ZXhUYW5nZW50c1sgaSBdLmNsb25lKCk7XHJcblxyXG5cdFx0cmV0dXJuIGZhY2U7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGtpbGUgLyBodHRwOi8va2lsZS5zdHJhdmFnYW56YS5vcmcvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9leG9jb3J0ZXguY29tXHJcbiAqL1xyXG5cclxuVEhSRUUuR2VvbWV0cnkgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuaWQgPSBUSFJFRS5HZW9tZXRyeUlkQ291bnQgKys7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzID0gW107XHJcblx0dGhpcy5jb2xvcnMgPSBbXTsgIC8vIG9uZS10by1vbmUgdmVydGV4IGNvbG9ycywgdXNlZCBpbiBQYXJ0aWNsZVN5c3RlbSwgTGluZSBhbmQgUmliYm9uXHJcblx0dGhpcy5ub3JtYWxzID0gW107IC8vIG9uZS10by1vbmUgdmVydGV4IG5vcm1hbHMsIHVzZWQgaW4gUmliYm9uXHJcblxyXG5cdHRoaXMuZmFjZXMgPSBbXTtcclxuXHJcblx0dGhpcy5mYWNlVXZzID0gW1tdXTtcclxuXHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbW11dO1xyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IFtdO1xyXG5cdHRoaXMubW9ycGhDb2xvcnMgPSBbXTtcclxuXHR0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xyXG5cclxuXHR0aGlzLnNraW5XZWlnaHRzID0gW107XHJcblx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xyXG5cclxuXHR0aGlzLmxpbmVEaXN0YW5jZXMgPSBbXTtcclxuXHJcblx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG5cdHRoaXMuaGFzVGFuZ2VudHMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5keW5hbWljID0gdHJ1ZTsgLy8gdGhlIGludGVybWVkaWF0ZSB0eXBlZCBhcnJheXMgd2lsbCBiZSBkZWxldGVkIHdoZW4gc2V0IHRvIGZhbHNlXHJcblxyXG5cdC8vIHVwZGF0ZSBmbGFnc1xyXG5cclxuXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy51dnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMudGFuZ2VudHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0dGhpcy5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLmJ1ZmZlcnNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuR2VvbWV0cnksXHJcblxyXG5cdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKS5nZXRJbnZlcnNlKCBtYXRyaXggKS50cmFuc3Bvc2UoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XHJcblx0XHRcdHZlcnRleC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xyXG5cdFx0XHRmYWNlLm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzWyBqIF0uYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZhY2UuY2VudHJvaWQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVDZW50cm9pZHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZiwgZmwsIGZhY2U7XHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblx0XHRcdGZhY2UuY2VudHJvaWQuc2V0KCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5hZGQoIHRoaXMudmVydGljZXNbIGZhY2UuYSBdICk7XHJcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5hZGQoIHRoaXMudmVydGljZXNbIGZhY2UuYiBdICk7XHJcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5hZGQoIHRoaXMudmVydGljZXNbIGZhY2UuYyBdICk7XHJcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5kaXZpZGVTY2FsYXIoIDMgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5hZGQoIHRoaXMudmVydGljZXNbIGZhY2UuYSBdICk7XHJcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5hZGQoIHRoaXMudmVydGljZXNbIGZhY2UuYiBdICk7XHJcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5hZGQoIHRoaXMudmVydGljZXNbIGZhY2UuYyBdICk7XHJcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5hZGQoIHRoaXMudmVydGljZXNbIGZhY2UuZCBdICk7XHJcblx0XHRcdFx0ZmFjZS5jZW50cm9pZC5kaXZpZGVTY2FsYXIoIDQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVGYWNlTm9ybWFsczogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBjYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0dmFyIHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdHZhciB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHR2YXIgdkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xyXG5cdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcclxuXHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRjYi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlVmVydGV4Tm9ybWFsczogZnVuY3Rpb24gKCBhcmVhV2VpZ2h0ZWQgKSB7XHJcblxyXG5cdFx0dmFyIHYsIHZsLCBmLCBmbCwgZmFjZSwgdmVydGljZXM7XHJcblxyXG5cdFx0Ly8gY3JlYXRlIGludGVybmFsIGJ1ZmZlcnMgZm9yIHJldXNlIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCByZXBlYXRlZGx5XHJcblx0XHQvLyAob3RoZXJ3aXNlIG1lbW9yeSBhbGxvY2F0aW9uIC8gZGVhbGxvY2F0aW9uIGV2ZXJ5IGZyYW1lIGlzIGJpZyByZXNvdXJjZSBob2cpXHJcblxyXG5cdFx0aWYgKCB0aGlzLl9fdG1wVmVydGljZXMgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHRoaXMuX190bXBWZXJ0aWNlcyA9IG5ldyBBcnJheSggdGhpcy52ZXJ0aWNlcy5sZW5ndGggKTtcclxuXHRcdFx0dmVydGljZXMgPSB0aGlzLl9fdG1wVmVydGljZXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlc1sgdiBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFscyA9IFsgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzID0gWyBuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMygpIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmVydGljZXMgPSB0aGlzLl9fdG1wVmVydGljZXM7XHJcblxyXG5cdFx0XHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0aWNlc1sgdiBdLnNldCggMCwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGFyZWFXZWlnaHRlZCApIHtcclxuXHJcblx0XHRcdC8vIHZlcnRleCBub3JtYWxzIHdlaWdodGVkIGJ5IHRyaWFuZ2xlIGFyZWFzXHJcblx0XHRcdC8vIGh0dHA6Ly93d3cuaXF1aWxlemxlcy5vcmcvd3d3L2FydGljbGVzL25vcm1hbHMvbm9ybWFscy5odG1cclxuXHJcblx0XHRcdHZhciB2QSwgdkIsIHZDLCB2RDtcclxuXHRcdFx0dmFyIGNiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgYWIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRcdGRiID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgZGMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBiYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdFx0XHR2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0dkIgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XHJcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcclxuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGNiICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBjYiApO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggY2IgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHRcdHZBID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0XHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0dkMgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRcdHZEID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5kIF07XHJcblxyXG5cdFx0XHRcdFx0Ly8gYWJkXHJcblxyXG5cdFx0XHRcdFx0ZGIuc3ViVmVjdG9ycyggdkQsIHZCICk7XHJcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCB2QSwgdkIgKTtcclxuXHRcdFx0XHRcdGRiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGRiICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBkYiApO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuZCBdLmFkZCggZGIgKTtcclxuXHJcblx0XHRcdFx0XHQvLyBiY2RcclxuXHJcblx0XHRcdFx0XHRkYy5zdWJWZWN0b3JzKCB2RCwgdkMgKTtcclxuXHRcdFx0XHRcdGJjLnN1YlZlY3RvcnMoIHZCLCB2QyApO1xyXG5cdFx0XHRcdFx0ZGMuY3Jvc3MoIGJjICk7XHJcblxyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYiBdLmFkZCggZGMgKTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGRjICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5kIF0uYWRkKCBkYyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmEgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblx0XHRcdFx0XHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xyXG5cdFx0XHRcdFx0dmVydGljZXNbIGZhY2UuYyBdLmFkZCggZmFjZS5ub3JtYWwgKTtcclxuXHRcdFx0XHRcdHZlcnRpY2VzWyBmYWNlLmQgXS5hZGQoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmEgXSApO1xyXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmIgXSApO1xyXG5cdFx0XHRcdGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcclxuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDEgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5iIF0gKTtcclxuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDIgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcclxuXHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHNbIDMgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5kIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVNb3JwaE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgaSwgaWwsIGYsIGZsLCBmYWNlO1xyXG5cclxuXHRcdC8vIHNhdmUgb3JpZ2luYWwgbm9ybWFsc1xyXG5cdFx0Ly8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXHJcblx0XHQvLyAgIG90aGVyd2lzZSBqdXN0IGNvcHkgKGZvciBmYXN0ZXIgcmVwZWF0ZWQgY2FsbHMpXHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICEgZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscyApIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXSApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gPSBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVzZSB0ZW1wIGdlb21ldHJ5IHRvIGNvbXB1dGUgZmFjZSBhbmQgdmVydGV4IG5vcm1hbHMgZm9yIGVhY2ggbW9ycGhcclxuXHJcblx0XHR2YXIgdG1wR2VvID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0XHR0bXBHZW8uZmFjZXMgPSB0aGlzLmZhY2VzO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Ly8gY3JlYXRlIG9uIGZpcnN0IGFjY2Vzc1xyXG5cclxuXHRcdFx0aWYgKCAhIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gPSB7fTtcclxuXHRcdFx0XHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzID0gW107XHJcblx0XHRcdFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzID0gW107XHJcblxyXG5cdFx0XHRcdHZhciBkc3ROb3JtYWxzRmFjZSA9IHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHM7XHJcblx0XHRcdFx0dmFyIGRzdE5vcm1hbHNWZXJ0ZXggPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHM7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XHJcblxyXG5cdFx0XHRcdFx0ZmFjZU5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzID0geyBhOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBiOiBuZXcgVEhSRUUuVmVjdG9yMygpLCBjOiBuZXcgVEhSRUUuVmVjdG9yMygpIH07XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHZlcnRleE5vcm1hbHMgPSB7IGE6IG5ldyBUSFJFRS5WZWN0b3IzKCksIGI6IG5ldyBUSFJFRS5WZWN0b3IzKCksIGM6IG5ldyBUSFJFRS5WZWN0b3IzKCksIGQ6IG5ldyBUSFJFRS5WZWN0b3IzKCkgfTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0ZHN0Tm9ybWFsc0ZhY2UucHVzaCggZmFjZU5vcm1hbCApO1xyXG5cdFx0XHRcdFx0ZHN0Tm9ybWFsc1ZlcnRleC5wdXNoKCB2ZXJ0ZXhOb3JtYWxzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBtb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdO1xyXG5cclxuXHRcdFx0Ly8gc2V0IHZlcnRpY2VzIHRvIG1vcnBoIHRhcmdldFxyXG5cclxuXHRcdFx0dG1wR2VvLnZlcnRpY2VzID0gdGhpcy5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcclxuXHJcblx0XHRcdC8vIGNvbXB1dGUgbW9ycGggbm9ybWFsc1xyXG5cclxuXHRcdFx0dG1wR2VvLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdFx0XHR0bXBHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0XHRcdC8vIHN0b3JlIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHRcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdFx0ZmFjZU5vcm1hbCA9IG1vcnBoTm9ybWFscy5mYWNlTm9ybWFsc1sgZiBdO1xyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBtb3JwaE5vcm1hbHMudmVydGV4Tm9ybWFsc1sgZiBdO1xyXG5cclxuXHRcdFx0XHRmYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMuYS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDAgXSApO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscy5iLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdICk7XHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmMuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAyIF0gKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmEuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAwIF0gKTtcclxuXHRcdFx0XHRcdHZlcnRleE5vcm1hbHMuYi5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIDEgXSApO1xyXG5cdFx0XHRcdFx0dmVydGV4Tm9ybWFscy5jLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdICk7XHJcblx0XHRcdFx0XHR2ZXJ0ZXhOb3JtYWxzLmQuY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyAzIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdGZhY2Uubm9ybWFsID0gZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbDtcclxuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzID0gZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFscztcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVUYW5nZW50czogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cudGVyYXRob24uY29tL2NvZGUvdGFuZ2VudC5odG1sXHJcblx0XHQvLyB0YW5nZW50cyBnbyB0byB2ZXJ0aWNlc1xyXG5cclxuXHRcdHZhciBmLCBmbCwgdiwgdmwsIGksIGlsLCB2ZXJ0ZXhJbmRleCxcclxuXHRcdFx0ZmFjZSwgdXYsIHZBLCB2QiwgdkMsIHV2QSwgdXZCLCB1dkMsXHJcblx0XHRcdHgxLCB4MiwgeTEsIHkyLCB6MSwgejIsXHJcblx0XHRcdHMxLCBzMiwgdDEsIHQyLCByLCB0LCB0ZXN0LFxyXG5cdFx0XHR0YW4xID0gW10sIHRhbjIgPSBbXSxcclxuXHRcdFx0c2RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHR0bXAgPSBuZXcgVEhSRUUuVmVjdG9yMygpLCB0bXAyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0biA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHc7XHJcblxyXG5cdFx0Zm9yICggdiA9IDAsIHZsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IHYgPCB2bDsgdiArKyApIHtcclxuXHJcblx0XHRcdHRhbjFbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdHRhbjJbIHYgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRyaWFuZ2xlKCBjb250ZXh0LCBhLCBiLCBjLCB1YSwgdWIsIHVjICkge1xyXG5cclxuXHRcdFx0dkEgPSBjb250ZXh0LnZlcnRpY2VzWyBhIF07XHJcblx0XHRcdHZCID0gY29udGV4dC52ZXJ0aWNlc1sgYiBdO1xyXG5cdFx0XHR2QyA9IGNvbnRleHQudmVydGljZXNbIGMgXTtcclxuXHJcblx0XHRcdHV2QSA9IHV2WyB1YSBdO1xyXG5cdFx0XHR1dkIgPSB1dlsgdWIgXTtcclxuXHRcdFx0dXZDID0gdXZbIHVjIF07XHJcblxyXG5cdFx0XHR4MSA9IHZCLnggLSB2QS54O1xyXG5cdFx0XHR4MiA9IHZDLnggLSB2QS54O1xyXG5cdFx0XHR5MSA9IHZCLnkgLSB2QS55O1xyXG5cdFx0XHR5MiA9IHZDLnkgLSB2QS55O1xyXG5cdFx0XHR6MSA9IHZCLnogLSB2QS56O1xyXG5cdFx0XHR6MiA9IHZDLnogLSB2QS56O1xyXG5cclxuXHRcdFx0czEgPSB1dkIueCAtIHV2QS54O1xyXG5cdFx0XHRzMiA9IHV2Qy54IC0gdXZBLng7XHJcblx0XHRcdHQxID0gdXZCLnkgLSB1dkEueTtcclxuXHRcdFx0dDIgPSB1dkMueSAtIHV2QS55O1xyXG5cclxuXHRcdFx0ciA9IDEuMCAvICggczEgKiB0MiAtIHMyICogdDEgKTtcclxuXHRcdFx0c2Rpci5zZXQoICggdDIgKiB4MSAtIHQxICogeDIgKSAqIHIsXHJcblx0XHRcdFx0XHQgICggdDIgKiB5MSAtIHQxICogeTIgKSAqIHIsXHJcblx0XHRcdFx0XHQgICggdDIgKiB6MSAtIHQxICogejIgKSAqIHIgKTtcclxuXHRcdFx0dGRpci5zZXQoICggczEgKiB4MiAtIHMyICogeDEgKSAqIHIsXHJcblx0XHRcdFx0XHQgICggczEgKiB5MiAtIHMyICogeTEgKSAqIHIsXHJcblx0XHRcdFx0XHQgICggczEgKiB6MiAtIHMyICogejEgKSAqIHIgKTtcclxuXHJcblx0XHRcdHRhbjFbIGEgXS5hZGQoIHNkaXIgKTtcclxuXHRcdFx0dGFuMVsgYiBdLmFkZCggc2RpciApO1xyXG5cdFx0XHR0YW4xWyBjIF0uYWRkKCBzZGlyICk7XHJcblxyXG5cdFx0XHR0YW4yWyBhIF0uYWRkKCB0ZGlyICk7XHJcblx0XHRcdHRhbjJbIGIgXS5hZGQoIHRkaXIgKTtcclxuXHRcdFx0dGFuMlsgYyBdLmFkZCggdGRpciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcclxuXHRcdFx0dXYgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXVsgZiBdOyAvLyB1c2UgVVYgbGF5ZXIgMCBmb3IgdGFuZ2VudHNcclxuXHJcblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0XHRoYW5kbGVUcmlhbmdsZSggdGhpcywgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYywgMCwgMSwgMiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHRoYW5kbGVUcmlhbmdsZSggdGhpcywgZmFjZS5hLCBmYWNlLmIsIGZhY2UuZCwgMCwgMSwgMyApO1xyXG5cdFx0XHRcdGhhbmRsZVRyaWFuZ2xlKCB0aGlzLCBmYWNlLmIsIGZhY2UuYywgZmFjZS5kLCAxLCAyLCAzICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmYWNlSW5kZXggPSBbICdhJywgJ2InLCAnYycsICdkJyBdO1xyXG5cclxuXHRcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmYWNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdFx0XHRcdG4uY29weSggZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0dmVydGV4SW5kZXggPSBmYWNlWyBmYWNlSW5kZXhbIGkgXSBdO1xyXG5cclxuXHRcdFx0XHR0ID0gdGFuMVsgdmVydGV4SW5kZXggXTtcclxuXHJcblx0XHRcdFx0Ly8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcclxuXHJcblx0XHRcdFx0dG1wLmNvcHkoIHQgKTtcclxuXHRcdFx0XHR0bXAuc3ViKCBuLm11bHRpcGx5U2NhbGFyKCBuLmRvdCggdCApICkgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcclxuXHJcblx0XHRcdFx0dG1wMi5jcm9zc1ZlY3RvcnMoIGZhY2UudmVydGV4Tm9ybWFsc1sgaSBdLCB0ICk7XHJcblx0XHRcdFx0dGVzdCA9IHRtcDIuZG90KCB0YW4yWyB2ZXJ0ZXhJbmRleCBdICk7XHJcblx0XHRcdFx0dyA9ICh0ZXN0IDwgMC4wKSA/IC0xLjAgOiAxLjA7XHJcblxyXG5cdFx0XHRcdGZhY2UudmVydGV4VGFuZ2VudHNbIGkgXSA9IG5ldyBUSFJFRS5WZWN0b3I0KCB0bXAueCwgdG1wLnksIHRtcC56LCB3ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuaGFzVGFuZ2VudHMgPSB0cnVlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlTGluZURpc3RhbmNlczogZnVuY3Rpb24gKCApIHtcclxuXHJcblx0XHR2YXIgZCA9IDA7XHJcblx0XHR2YXIgdmVydGljZXMgPSB0aGlzLnZlcnRpY2VzO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGlmICggaSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGQgKz0gdmVydGljZXNbIGkgXS5kaXN0YW5jZVRvKCB2ZXJ0aWNlc1sgaSAtIDEgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5saW5lRGlzdGFuY2VzWyBpIF0gPSBkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBUSFJFRS5Cb3gzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuYm91bmRpbmdCb3guc2V0RnJvbVBvaW50cyggdGhpcy52ZXJ0aWNlcyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbmV3IFRIUkVFLlNwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmJvdW5kaW5nU3BoZXJlLnNldEZyb21DZW50ZXJBbmRQb2ludHMoIHRoaXMuYm91bmRpbmdTcGhlcmUuY2VudGVyLCB0aGlzLnZlcnRpY2VzICk7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8qXHJcblx0ICogQ2hlY2tzIGZvciBkdXBsaWNhdGUgdmVydGljZXMgd2l0aCBoYXNobWFwLlxyXG5cdCAqIER1cGxpY2F0ZWQgdmVydGljZXMgYXJlIHJlbW92ZWRcclxuXHQgKiBhbmQgZmFjZXMnIHZlcnRpY2VzIGFyZSB1cGRhdGVkLlxyXG5cdCAqL1xyXG5cclxuXHRtZXJnZVZlcnRpY2VzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzTWFwID0ge307IC8vIEhhc2htYXAgZm9yIGxvb2tpbmcgdXAgdmVydGljZSBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcclxuXHRcdHZhciB1bmlxdWUgPSBbXSwgY2hhbmdlcyA9IFtdO1xyXG5cclxuXHRcdHZhciB2LCBrZXk7XHJcblx0XHR2YXIgcHJlY2lzaW9uUG9pbnRzID0gNDsgLy8gbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzLCBlZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcclxuXHRcdHZhciBwcmVjaXNpb24gPSBNYXRoLnBvdyggMTAsIHByZWNpc2lvblBvaW50cyApO1xyXG5cdFx0dmFyIGksaWwsIGZhY2U7XHJcblx0XHR2YXIgaW5kaWNlcywgaywgaiwgamwsIHU7XHJcblxyXG5cdFx0Ly8gcmVzZXQgY2FjaGUgb2YgdmVydGljZXMgYXMgaXQgbm93IHdpbGwgYmUgY2hhbmdpbmcuXHJcblx0XHR0aGlzLl9fdG1wVmVydGljZXMgPSB1bmRlZmluZWQ7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHYgPSB0aGlzLnZlcnRpY2VzWyBpIF07XHJcblx0XHRcdGtleSA9IFsgTWF0aC5yb3VuZCggdi54ICogcHJlY2lzaW9uICksIE1hdGgucm91bmQoIHYueSAqIHByZWNpc2lvbiApLCBNYXRoLnJvdW5kKCB2LnogKiBwcmVjaXNpb24gKSBdLmpvaW4oICdfJyApO1xyXG5cclxuXHRcdFx0aWYgKCB2ZXJ0aWNlc01hcFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmVydGljZXNNYXBbIGtleSBdID0gaTtcclxuXHRcdFx0XHR1bmlxdWUucHVzaCggdGhpcy52ZXJ0aWNlc1sgaSBdICk7XHJcblx0XHRcdFx0Y2hhbmdlc1sgaSBdID0gdW5pcXVlLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCdEdXBsaWNhdGUgdmVydGV4IGZvdW5kLiAnLCBpLCAnIGNvdWxkIGJlIHVzaW5nICcsIHZlcnRpY2VzTWFwW2tleV0pO1xyXG5cdFx0XHRcdGNoYW5nZXNbIGkgXSA9IGNoYW5nZXNbIHZlcnRpY2VzTWFwWyBrZXkgXSBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH07XHJcblxyXG5cclxuXHRcdC8vIGlmIGZhY2VzIGFyZSBjb21wbGV0ZWx5IGRlZ2VuZXJhdGUgYWZ0ZXIgbWVyZ2luZyB2ZXJ0aWNlcywgd2VcclxuXHRcdC8vIGhhdmUgdG8gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZ2VvbWV0cnkuXHJcblx0XHR2YXIgZmFjZUluZGljZXNUb1JlbW92ZSA9IFtdO1xyXG5cclxuXHRcdGZvciggaSA9IDAsIGlsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSB0aGlzLmZhY2VzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlMyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZS5hID0gY2hhbmdlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0ZmFjZS5iID0gY2hhbmdlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0ZmFjZS5jID0gY2hhbmdlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdGluZGljZXMgPSBbIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0dmFyIGR1cEluZGV4ID0gLTE7XHJcblxyXG5cdFx0XHRcdC8vIGlmIGFueSBkdXBsaWNhdGUgdmVydGljZXMgYXJlIGZvdW5kIGluIGEgRmFjZTNcclxuXHRcdFx0XHQvLyB3ZSBoYXZlIHRvIHJlbW92ZSB0aGUgZmFjZSBhcyBub3RoaW5nIGNhbiBiZSBzYXZlZFxyXG5cdFx0XHRcdGZvciAoIHZhciBuID0gMDsgbiA8IDM7IG4gKysgKSB7XHJcblx0XHRcdFx0XHRpZiAoIGluZGljZXNbIG4gXSA9PSBpbmRpY2VzWyAoIG4gKyAxICkgJSAzIF0gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRkdXBJbmRleCA9IG47XHJcblx0XHRcdFx0XHRcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xyXG5cdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHRmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRmYWNlLmIgPSBjaGFuZ2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRmYWNlLmMgPSBjaGFuZ2VzWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRmYWNlLmQgPSBjaGFuZ2VzWyBmYWNlLmQgXTtcclxuXHJcblx0XHRcdFx0Ly8gY2hlY2sgZHVwcyBpbiAoYSwgYiwgYywgZCkgYW5kIGNvbnZlcnQgdG8gLT4gZmFjZTNcclxuXHJcblx0XHRcdFx0aW5kaWNlcyA9IFsgZmFjZS5hLCBmYWNlLmIsIGZhY2UuYywgZmFjZS5kIF07XHJcblxyXG5cdFx0XHRcdHZhciBkdXBJbmRleCA9IC0xO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgbiA9IDA7IG4gPCA0OyBuICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggaW5kaWNlc1sgbiBdID09IGluZGljZXNbICggbiArIDEgKSAlIDQgXSApIHtcclxuXHJcblx0XHRcdFx0XHRcdC8vIGlmIG1vcmUgdGhhbiBvbmUgZHVwbGljYXRlZCB2ZXJ0ZXggaXMgZm91bmRcclxuXHRcdFx0XHRcdFx0Ly8gd2UgY2FuJ3QgZ2VuZXJhdGUgYW55IHZhbGlkIEZhY2UzJ3MsIHRodXNcclxuXHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byByZW1vdmUgdGhpcyBmYWNlIGNvbXBsZXRlLlxyXG5cdFx0XHRcdFx0XHRpZiAoIGR1cEluZGV4ID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0ZHVwSW5kZXggPSBuO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggZHVwSW5kZXggPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRpbmRpY2VzLnNwbGljZSggZHVwSW5kZXgsIDEgKTtcclxuXHJcblx0XHRcdFx0XHR2YXIgbmV3RmFjZSA9IG5ldyBUSFJFRS5GYWNlMyggaW5kaWNlc1swXSwgaW5kaWNlc1sxXSwgaW5kaWNlc1syXSwgZmFjZS5ub3JtYWwsIGZhY2UuY29sb3IsIGZhY2UubWF0ZXJpYWxJbmRleCApO1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IHRoaXMuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHUgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGogXVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCB1ICkge1xyXG5cdFx0XHRcdFx0XHRcdHUuc3BsaWNlKCBkdXBJbmRleCwgMSApO1xyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmKCBmYWNlLnZlcnRleE5vcm1hbHMgJiYgZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA+IDApIHtcclxuXHJcblx0XHRcdFx0XHRcdG5ld0ZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcclxuXHRcdFx0XHRcdFx0bmV3RmFjZS52ZXJ0ZXhOb3JtYWxzLnNwbGljZSggZHVwSW5kZXgsIDEgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYoIGZhY2UudmVydGV4Q29sb3JzICYmIGZhY2UudmVydGV4Q29sb3JzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRuZXdGYWNlLnZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cdFx0XHRcdFx0XHRuZXdGYWNlLnZlcnRleENvbG9ycy5zcGxpY2UoIGR1cEluZGV4LCAxICk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5mYWNlc1sgaSBdID0gbmV3RmFjZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGkgPSBmYWNlSW5kaWNlc1RvUmVtb3ZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtLSApIHtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMuc3BsaWNlKCBpLCAxICk7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMCwgamwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgaiBdLnNwbGljZSggaSwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBVc2UgdW5pcXVlIHNldCBvZiB2ZXJ0aWNlc1xyXG5cclxuXHRcdHZhciBkaWZmID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSB1bmlxdWUubGVuZ3RoO1xyXG5cdFx0dGhpcy52ZXJ0aWNlcyA9IHVuaXF1ZTtcclxuXHRcdHJldHVybiBkaWZmO1xyXG5cclxuXHR9LFxyXG5cclxuXHRjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuXHRcdHZhciB2ZXJ0aWNlcyA9IHRoaXMudmVydGljZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggdmVydGljZXNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZXNbIGkgXS5jbG9uZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB1dnMgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdXZzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHV2ID0gdXZzWyBpIF0sIHV2Q29weSA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHV2Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR1dkNvcHkucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHV2WyBqIF0ueCwgdXZbIGogXS55ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dkNvcHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGdlb21ldHJ5O1xyXG5cclxuXHR9LFxyXG5cclxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5HZW9tZXRyeUlkQ291bnQgPSAwO1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuRXZlbnREaXNwYXRjaGVyLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5pZCA9IFRIUkVFLkdlb21ldHJ5SWRDb3VudCArKztcclxuXHJcblx0Ly8gYXR0cmlidXRlc1xyXG5cclxuXHR0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHJcblx0Ly8gYXR0cmlidXRlcyB0eXBlZCBhcnJheXMgYXJlIGtlcHQgb25seSBpZiBkeW5hbWljIGZsYWcgaXMgc2V0XHJcblxyXG5cdHRoaXMuZHluYW1pYyA9IGZhbHNlO1xyXG5cclxuXHQvLyBvZmZzZXRzIGZvciBjaHVua3Mgd2hlbiB1c2luZyBpbmRleGVkIGVsZW1lbnRzXHJcblxyXG5cdHRoaXMub2Zmc2V0cyA9IFtdO1xyXG5cclxuXHQvLyBib3VuZGluZ3NcclxuXHJcblx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XHJcblx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XHJcblxyXG5cdHRoaXMuaGFzVGFuZ2VudHMgPSBmYWxzZTtcclxuXHJcblx0Ly8gZm9yIGNvbXBhdGliaWxpdHlcclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yIDogVEhSRUUuQnVmZmVyR2VvbWV0cnksXHJcblxyXG5cdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb25BcnJheTtcclxuXHRcdHZhciBub3JtYWxBcnJheTtcclxuXHJcblx0XHRpZiAoIHRoaXMuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF0gKSBwb3NpdGlvbkFycmF5ID0gdGhpcy5hdHRyaWJ1dGVzWyBcInBvc2l0aW9uXCIgXS5hcnJheTtcclxuXHRcdGlmICggdGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0gKSBub3JtYWxBcnJheSA9IHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdLmFycmF5O1xyXG5cclxuXHRcdGlmICggcG9zaXRpb25BcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bWF0cml4Lm11bHRpcGx5VmVjdG9yM0FycmF5KCBwb3NpdGlvbkFycmF5ICk7XHJcblx0XHRcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBub3JtYWxBcnJheSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XHJcblx0XHRcdG5vcm1hbE1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXggKS50cmFuc3Bvc2UoKTtcclxuXHJcblx0XHRcdG5vcm1hbE1hdHJpeC5tdWx0aXBseVZlY3RvcjNBcnJheSggbm9ybWFsQXJyYXkgKTtcclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xyXG5cclxuXHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFRIUkVFLkJveDMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9ucyA9IHRoaXMuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF0uYXJyYXk7XHJcblxyXG5cdFx0aWYgKCBwb3NpdGlvbnMgKSB7XHJcblxyXG5cdFx0XHR2YXIgYmIgPSB0aGlzLmJvdW5kaW5nQm94O1xyXG5cdFx0XHR2YXIgeCwgeSwgejtcclxuXHJcblx0XHRcdGlmKCBwb3NpdGlvbnMubGVuZ3RoID49IDMgKSB7XHJcblx0XHRcdFx0YmIubWluLnggPSBiYi5tYXgueCA9IHBvc2l0aW9uc1sgMCBdO1xyXG5cdFx0XHRcdGJiLm1pbi55ID0gYmIubWF4LnkgPSBwb3NpdGlvbnNbIDEgXTtcclxuXHRcdFx0XHRiYi5taW4ueiA9IGJiLm1heC56ID0gcG9zaXRpb25zWyAyIF07XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMywgaWwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0eCA9IHBvc2l0aW9uc1sgaSBdO1xyXG5cdFx0XHRcdHkgPSBwb3NpdGlvbnNbIGkgKyAxIF07XHJcblx0XHRcdFx0eiA9IHBvc2l0aW9uc1sgaSArIDIgXTtcclxuXHJcblx0XHRcdFx0Ly8gYm91bmRpbmcgYm94XHJcblxyXG5cdFx0XHRcdGlmICggeCA8IGJiLm1pbi54ICkge1xyXG5cclxuXHRcdFx0XHRcdGJiLm1pbi54ID0geDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggeCA+IGJiLm1heC54ICkge1xyXG5cclxuXHRcdFx0XHRcdGJiLm1heC54ID0geDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHkgPCBiYi5taW4ueSApIHtcclxuXHJcblx0XHRcdFx0XHRiYi5taW4ueSA9IHk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHkgPiBiYi5tYXgueSApIHtcclxuXHJcblx0XHRcdFx0XHRiYi5tYXgueSA9IHk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB6IDwgYmIubWluLnogKSB7XHJcblxyXG5cdFx0XHRcdFx0YmIubWluLnogPSB6O1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB6ID4gYmIubWF4LnogKSB7XHJcblxyXG5cdFx0XHRcdFx0YmIubWF4LnogPSB6O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggcG9zaXRpb25zID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25zLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdCb3gubWluLnNldCggMCwgMCwgMCApO1xyXG5cdFx0XHR0aGlzLmJvdW5kaW5nQm94Lm1heC5zZXQoIDAsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdLmFycmF5O1xyXG5cclxuXHRcdGlmICggcG9zaXRpb25zICkge1xyXG5cclxuXHRcdFx0dmFyIHJhZGl1c1NxLCBtYXhSYWRpdXNTcSA9IDA7XHJcblx0XHRcdHZhciB4LCB5LCB6O1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0XHR4ID0gcG9zaXRpb25zWyBpIF07XHJcblx0XHRcdFx0eSA9IHBvc2l0aW9uc1sgaSArIDEgXTtcclxuXHRcdFx0XHR6ID0gcG9zaXRpb25zWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0XHRyYWRpdXNTcSA9ICB4ICogeCArIHkgKiB5ICsgeiAqIHo7XHJcblx0XHRcdFx0aWYgKCByYWRpdXNTcSA+IG1heFJhZGl1c1NxICkgbWF4UmFkaXVzU3EgPSByYWRpdXNTcTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF0gKSB7XHJcblxyXG5cdFx0XHR2YXIgaSwgaWw7XHJcblx0XHRcdHZhciBqLCBqbDtcclxuXHJcblx0XHRcdHZhciBuVmVydGV4RWxlbWVudHMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdLmFycmF5Lmxlbmd0aDtcclxuXHJcblx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0gPSB7XHJcblxyXG5cdFx0XHRcdFx0aXRlbVNpemU6IDMsXHJcblx0XHRcdFx0XHRhcnJheTogbmV3IEZsb2F0MzJBcnJheSggblZlcnRleEVsZW1lbnRzICksXHJcblx0XHRcdFx0XHRudW1JdGVtczogblZlcnRleEVsZW1lbnRzXHJcblxyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyByZXNldCBleGlzdGluZyBub3JtYWxzIHRvIHplcm9cclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0uYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0uYXJyYXlbIGkgXSA9IDA7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwb3NpdGlvbnMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdLmFycmF5O1xyXG5cdFx0XHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlc1sgXCJub3JtYWxcIiBdLmFycmF5O1xyXG5cclxuXHRcdFx0dmFyIHZBLCB2QiwgdkMsIHgsIHksIHosXHJcblxyXG5cdFx0XHRwQSA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRcdHBCID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdFx0cEMgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cclxuXHRcdFx0Y2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHRhYiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0XHQvLyBpbmRleGVkIGVsZW1lbnRzXHJcblxyXG5cdFx0XHRpZiAoIHRoaXMuYXR0cmlidXRlc1sgXCJpbmRleFwiIF0gKSB7XHJcblxyXG5cdFx0XHRcdHZhciBpbmRpY2VzID0gdGhpcy5hdHRyaWJ1dGVzWyBcImluZGV4XCIgXS5hcnJheTtcclxuXHJcblx0XHRcdFx0dmFyIG9mZnNldHMgPSB0aGlzLm9mZnNldHM7XHJcblxyXG5cdFx0XHRcdGZvciAoIGogPSAwLCBqbCA9IG9mZnNldHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHN0YXJ0ID0gb2Zmc2V0c1sgaiBdLnN0YXJ0O1xyXG5cdFx0XHRcdFx0dmFyIGNvdW50ID0gb2Zmc2V0c1sgaiBdLmNvdW50O1xyXG5cdFx0XHRcdFx0dmFyIGluZGV4ID0gb2Zmc2V0c1sgaiBdLmluZGV4O1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZBID0gaW5kZXggKyBpbmRpY2VzWyBpIF07XHJcblx0XHRcdFx0XHRcdHZCID0gaW5kZXggKyBpbmRpY2VzWyBpICsgMSBdO1xyXG5cdFx0XHRcdFx0XHR2QyA9IGluZGV4ICsgaW5kaWNlc1sgaSArIDIgXTtcclxuXHJcblx0XHRcdFx0XHRcdHggPSBwb3NpdGlvbnNbIHZBICogMyBdO1xyXG5cdFx0XHRcdFx0XHR5ID0gcG9zaXRpb25zWyB2QSAqIDMgKyAxIF07XHJcblx0XHRcdFx0XHRcdHogPSBwb3NpdGlvbnNbIHZBICogMyArIDIgXTtcclxuXHRcdFx0XHRcdFx0cEEuc2V0KCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHRcdFx0XHR4ID0gcG9zaXRpb25zWyB2QiAqIDMgXTtcclxuXHRcdFx0XHRcdFx0eSA9IHBvc2l0aW9uc1sgdkIgKiAzICsgMSBdO1xyXG5cdFx0XHRcdFx0XHR6ID0gcG9zaXRpb25zWyB2QiAqIDMgKyAyIF07XHJcblx0XHRcdFx0XHRcdHBCLnNldCggeCwgeSwgeiApO1xyXG5cclxuXHRcdFx0XHRcdFx0eCA9IHBvc2l0aW9uc1sgdkMgKiAzIF07XHJcblx0XHRcdFx0XHRcdHkgPSBwb3NpdGlvbnNbIHZDICogMyArIDEgXTtcclxuXHRcdFx0XHRcdFx0eiA9IHBvc2l0aW9uc1sgdkMgKiAzICsgMiBdO1xyXG5cdFx0XHRcdFx0XHRwQy5zZXQoIHgsIHksIHogKTtcclxuXHJcblx0XHRcdFx0XHRcdGNiLnN1YlZlY3RvcnMoIHBDLCBwQiApO1xyXG5cdFx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuXHRcdFx0XHRcdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QSAqIDMgXSAgICAgKz0gY2IueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkEgKiAzICsgMSBdICs9IGNiLnk7XHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZBICogMyArIDIgXSArPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkIgKiAzIF0gICAgICs9IGNiLng7XHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZCICogMyArIDEgXSArPSBjYi55O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QiAqIDMgKyAyIF0gKz0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbHNbIHZDICogMyBdICAgICArPSBjYi54O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxzWyB2QyAqIDMgKyAxIF0gKz0gY2IueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsc1sgdkMgKiAzICsgMiBdICs9IGNiLno7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBub24taW5kZXhlZCBlbGVtZW50cyAodW5jb25uZWN0ZWQgdHJpYW5nbGUgc291cClcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSA5ICkge1xyXG5cclxuXHRcdFx0XHRcdHggPSBwb3NpdGlvbnNbIGkgXTtcclxuXHRcdFx0XHRcdHkgPSBwb3NpdGlvbnNbIGkgKyAxIF07XHJcblx0XHRcdFx0XHR6ID0gcG9zaXRpb25zWyBpICsgMiBdO1xyXG5cdFx0XHRcdFx0cEEuc2V0KCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHRcdFx0eCA9IHBvc2l0aW9uc1sgaSArIDMgXTtcclxuXHRcdFx0XHRcdHkgPSBwb3NpdGlvbnNbIGkgKyA0IF07XHJcblx0XHRcdFx0XHR6ID0gcG9zaXRpb25zWyBpICsgNSBdO1xyXG5cdFx0XHRcdFx0cEIuc2V0KCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHRcdFx0eCA9IHBvc2l0aW9uc1sgaSArIDYgXTtcclxuXHRcdFx0XHRcdHkgPSBwb3NpdGlvbnNbIGkgKyA3IF07XHJcblx0XHRcdFx0XHR6ID0gcG9zaXRpb25zWyBpICsgOCBdO1xyXG5cdFx0XHRcdFx0cEMuc2V0KCB4LCB5LCB6ICk7XHJcblxyXG5cdFx0XHRcdFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XHJcblx0XHRcdFx0XHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcclxuXHRcdFx0XHRcdGNiLmNyb3NzKCBhYiApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgXSBcdCA9IGNiLng7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgMSBdID0gY2IueTtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAyIF0gPSBjYi56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyAzIF0gPSBjYi54O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDQgXSA9IGNiLnk7XHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcclxuXHJcblx0XHRcdFx0XHRub3JtYWxzWyBpICsgNiBdID0gY2IueDtcclxuXHRcdFx0XHRcdG5vcm1hbHNbIGkgKyA3IF0gPSBjYi55O1xyXG5cdFx0XHRcdFx0bm9ybWFsc1sgaSArIDggXSA9IGNiLno7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xyXG5cclxuXHRcdFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXNbIFwibm9ybWFsXCIgXS5hcnJheTtcclxuXHJcblx0XHR2YXIgeCwgeSwgeiwgbjtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbm9ybWFscy5sZW5ndGg7IGkgPCBpbDsgaSArPSAzICkge1xyXG5cclxuXHRcdFx0eCA9IG5vcm1hbHNbIGkgXTtcclxuXHRcdFx0eSA9IG5vcm1hbHNbIGkgKyAxIF07XHJcblx0XHRcdHogPSBub3JtYWxzWyBpICsgMiBdO1xyXG5cclxuXHRcdFx0biA9IDEuMCAvIE1hdGguc3FydCggeCAqIHggKyB5ICogeSArIHogKiB6ICk7XHJcblxyXG5cdFx0XHRub3JtYWxzWyBpIF0gXHQgKj0gbjtcclxuXHRcdFx0bm9ybWFsc1sgaSArIDEgXSAqPSBuO1xyXG5cdFx0XHRub3JtYWxzWyBpICsgMiBdICo9IG47XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9LFxyXG5cclxuXHRjb21wdXRlVGFuZ2VudHM6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHQvLyBiYXNlZCBvbiBodHRwOi8vd3d3LnRlcmF0aG9uLmNvbS9jb2RlL3RhbmdlbnQuaHRtbFxyXG5cdFx0Ly8gKHBlciB2ZXJ0ZXggdGFuZ2VudHMpXHJcblxyXG5cdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZXNbIFwiaW5kZXhcIiBdID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0IHRoaXMuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF0gPT09IHVuZGVmaW5lZCB8fFxyXG5cdFx0XHQgdGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0gPT09IHVuZGVmaW5lZCB8fFxyXG5cdFx0XHQgdGhpcy5hdHRyaWJ1dGVzWyBcInV2XCIgXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCBcIk1pc3NpbmcgcmVxdWlyZWQgYXR0cmlidXRlcyAoaW5kZXgsIHBvc2l0aW9uLCBub3JtYWwgb3IgdXYpIGluIEJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpXCIgKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaW5kaWNlcyA9IHRoaXMuYXR0cmlidXRlc1sgXCJpbmRleFwiIF0uYXJyYXk7XHJcblx0XHR2YXIgcG9zaXRpb25zID0gdGhpcy5hdHRyaWJ1dGVzWyBcInBvc2l0aW9uXCIgXS5hcnJheTtcclxuXHRcdHZhciBub3JtYWxzID0gdGhpcy5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF0uYXJyYXk7XHJcblx0XHR2YXIgdXZzID0gdGhpcy5hdHRyaWJ1dGVzWyBcInV2XCIgXS5hcnJheTtcclxuXHJcblx0XHR2YXIgblZlcnRpY2VzID0gcG9zaXRpb25zLmxlbmd0aCAvIDM7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZXNbIFwidGFuZ2VudFwiIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBuVGFuZ2VudEVsZW1lbnRzID0gNCAqIG5WZXJ0aWNlcztcclxuXHJcblx0XHRcdHRoaXMuYXR0cmlidXRlc1sgXCJ0YW5nZW50XCIgXSA9IHtcclxuXHJcblx0XHRcdFx0aXRlbVNpemU6IDQsXHJcblx0XHRcdFx0YXJyYXk6IG5ldyBGbG9hdDMyQXJyYXkoIG5UYW5nZW50RWxlbWVudHMgKSxcclxuXHRcdFx0XHRudW1JdGVtczogblRhbmdlbnRFbGVtZW50c1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRhbmdlbnRzID0gdGhpcy5hdHRyaWJ1dGVzWyBcInRhbmdlbnRcIiBdLmFycmF5O1xyXG5cclxuXHRcdHZhciB0YW4xID0gW10sIHRhbjIgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBuVmVydGljZXM7IGsgKysgKSB7XHJcblxyXG5cdFx0XHR0YW4xWyBrIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHR0YW4yWyBrIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgeEEsIHlBLCB6QSxcclxuXHRcdFx0eEIsIHlCLCB6QixcclxuXHRcdFx0eEMsIHlDLCB6QyxcclxuXHJcblx0XHRcdHVBLCB2QSxcclxuXHRcdFx0dUIsIHZCLFxyXG5cdFx0XHR1QywgdkMsXHJcblxyXG5cdFx0XHR4MSwgeDIsIHkxLCB5MiwgejEsIHoyLFxyXG5cdFx0XHRzMSwgczIsIHQxLCB0MiwgcjtcclxuXHJcblx0XHR2YXIgc2RpciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRkaXIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGhhbmRsZVRyaWFuZ2xlKCBhLCBiLCBjICkge1xyXG5cclxuXHRcdFx0eEEgPSBwb3NpdGlvbnNbIGEgKiAzIF07XHJcblx0XHRcdHlBID0gcG9zaXRpb25zWyBhICogMyArIDEgXTtcclxuXHRcdFx0ekEgPSBwb3NpdGlvbnNbIGEgKiAzICsgMiBdO1xyXG5cclxuXHRcdFx0eEIgPSBwb3NpdGlvbnNbIGIgKiAzIF07XHJcblx0XHRcdHlCID0gcG9zaXRpb25zWyBiICogMyArIDEgXTtcclxuXHRcdFx0ekIgPSBwb3NpdGlvbnNbIGIgKiAzICsgMiBdO1xyXG5cclxuXHRcdFx0eEMgPSBwb3NpdGlvbnNbIGMgKiAzIF07XHJcblx0XHRcdHlDID0gcG9zaXRpb25zWyBjICogMyArIDEgXTtcclxuXHRcdFx0ekMgPSBwb3NpdGlvbnNbIGMgKiAzICsgMiBdO1xyXG5cclxuXHRcdFx0dUEgPSB1dnNbIGEgKiAyIF07XHJcblx0XHRcdHZBID0gdXZzWyBhICogMiArIDEgXTtcclxuXHJcblx0XHRcdHVCID0gdXZzWyBiICogMiBdO1xyXG5cdFx0XHR2QiA9IHV2c1sgYiAqIDIgKyAxIF07XHJcblxyXG5cdFx0XHR1QyA9IHV2c1sgYyAqIDIgXTtcclxuXHRcdFx0dkMgPSB1dnNbIGMgKiAyICsgMSBdO1xyXG5cclxuXHRcdFx0eDEgPSB4QiAtIHhBO1xyXG5cdFx0XHR4MiA9IHhDIC0geEE7XHJcblxyXG5cdFx0XHR5MSA9IHlCIC0geUE7XHJcblx0XHRcdHkyID0geUMgLSB5QTtcclxuXHJcblx0XHRcdHoxID0gekIgLSB6QTtcclxuXHRcdFx0ejIgPSB6QyAtIHpBO1xyXG5cclxuXHRcdFx0czEgPSB1QiAtIHVBO1xyXG5cdFx0XHRzMiA9IHVDIC0gdUE7XHJcblxyXG5cdFx0XHR0MSA9IHZCIC0gdkE7XHJcblx0XHRcdHQyID0gdkMgLSB2QTtcclxuXHJcblx0XHRcdHIgPSAxLjAgLyAoIHMxICogdDIgLSBzMiAqIHQxICk7XHJcblxyXG5cdFx0XHRzZGlyLnNldChcclxuXHRcdFx0XHQoIHQyICogeDEgLSB0MSAqIHgyICkgKiByLFxyXG5cdFx0XHRcdCggdDIgKiB5MSAtIHQxICogeTIgKSAqIHIsXHJcblx0XHRcdFx0KCB0MiAqIHoxIC0gdDEgKiB6MiApICogclxyXG5cdFx0XHQpO1xyXG5cclxuXHRcdFx0dGRpci5zZXQoXHJcblx0XHRcdFx0KCBzMSAqIHgyIC0gczIgKiB4MSApICogcixcclxuXHRcdFx0XHQoIHMxICogeTIgLSBzMiAqIHkxICkgKiByLFxyXG5cdFx0XHRcdCggczEgKiB6MiAtIHMyICogejEgKSAqIHJcclxuXHRcdFx0KTtcclxuXHJcblx0XHRcdHRhbjFbIGEgXS5hZGQoIHNkaXIgKTtcclxuXHRcdFx0dGFuMVsgYiBdLmFkZCggc2RpciApO1xyXG5cdFx0XHR0YW4xWyBjIF0uYWRkKCBzZGlyICk7XHJcblxyXG5cdFx0XHR0YW4yWyBhIF0uYWRkKCB0ZGlyICk7XHJcblx0XHRcdHRhbjJbIGIgXS5hZGQoIHRkaXIgKTtcclxuXHRcdFx0dGFuMlsgYyBdLmFkZCggdGRpciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgaSwgaWw7XHJcblx0XHR2YXIgaiwgamw7XHJcblx0XHR2YXIgaUEsIGlCLCBpQztcclxuXHJcblx0XHR2YXIgb2Zmc2V0cyA9IHRoaXMub2Zmc2V0cztcclxuXHJcblx0XHRmb3IgKCBqID0gMCwgamwgPSBvZmZzZXRzLmxlbmd0aDsgaiA8IGpsOyArKyBqICkge1xyXG5cclxuXHRcdFx0dmFyIHN0YXJ0ID0gb2Zmc2V0c1sgaiBdLnN0YXJ0O1xyXG5cdFx0XHR2YXIgY291bnQgPSBvZmZzZXRzWyBqIF0uY291bnQ7XHJcblx0XHRcdHZhciBpbmRleCA9IG9mZnNldHNbIGogXS5pbmRleDtcclxuXHJcblx0XHRcdGZvciAoIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0aUEgPSBpbmRleCArIGluZGljZXNbIGkgXTtcclxuXHRcdFx0XHRpQiA9IGluZGV4ICsgaW5kaWNlc1sgaSArIDEgXTtcclxuXHRcdFx0XHRpQyA9IGluZGV4ICsgaW5kaWNlc1sgaSArIDIgXTtcclxuXHJcblx0XHRcdFx0aGFuZGxlVHJpYW5nbGUoIGlBLCBpQiwgaUMgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRtcCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHRtcDIgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpLCBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgdywgdCwgdGVzdDtcclxuXHJcblx0XHRmdW5jdGlvbiBoYW5kbGVWZXJ0ZXgoIHYgKSB7XHJcblxyXG5cdFx0XHRuLnggPSBub3JtYWxzWyB2ICogMyBdO1xyXG5cdFx0XHRuLnkgPSBub3JtYWxzWyB2ICogMyArIDEgXTtcclxuXHRcdFx0bi56ID0gbm9ybWFsc1sgdiAqIDMgKyAyIF07XHJcblxyXG5cdFx0XHRuMi5jb3B5KCBuICk7XHJcblxyXG5cdFx0XHR0ID0gdGFuMVsgdiBdO1xyXG5cclxuXHRcdFx0Ly8gR3JhbS1TY2htaWR0IG9ydGhvZ29uYWxpemVcclxuXHJcblx0XHRcdHRtcC5jb3B5KCB0ICk7XHJcblx0XHRcdHRtcC5zdWIoIG4ubXVsdGlwbHlTY2FsYXIoIG4uZG90KCB0ICkgKSApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0Ly8gQ2FsY3VsYXRlIGhhbmRlZG5lc3NcclxuXHJcblx0XHRcdHRtcDIuY3Jvc3NWZWN0b3JzKCBuMiwgdCApO1xyXG5cdFx0XHR0ZXN0ID0gdG1wMi5kb3QoIHRhbjJbIHYgXSApO1xyXG5cdFx0XHR3ID0gKCB0ZXN0IDwgMC4wICkgPyAtMS4wIDogMS4wO1xyXG5cclxuXHRcdFx0dGFuZ2VudHNbIHYgKiA0IF0gXHQgID0gdG1wLng7XHJcblx0XHRcdHRhbmdlbnRzWyB2ICogNCArIDEgXSA9IHRtcC55O1xyXG5cdFx0XHR0YW5nZW50c1sgdiAqIDQgKyAyIF0gPSB0bXAuejtcclxuXHRcdFx0dGFuZ2VudHNbIHYgKiA0ICsgMyBdID0gdztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaiA9IDAsIGpsID0gb2Zmc2V0cy5sZW5ndGg7IGogPCBqbDsgKysgaiApIHtcclxuXHJcblx0XHRcdHZhciBzdGFydCA9IG9mZnNldHNbIGogXS5zdGFydDtcclxuXHRcdFx0dmFyIGNvdW50ID0gb2Zmc2V0c1sgaiBdLmNvdW50O1xyXG5cdFx0XHR2YXIgaW5kZXggPSBvZmZzZXRzWyBqIF0uaW5kZXg7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gc3RhcnQsIGlsID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsOyBpICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdGlBID0gaW5kZXggKyBpbmRpY2VzWyBpIF07XHJcblx0XHRcdFx0aUIgPSBpbmRleCArIGluZGljZXNbIGkgKyAxIF07XHJcblx0XHRcdFx0aUMgPSBpbmRleCArIGluZGljZXNbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdGhhbmRsZVZlcnRleCggaUEgKTtcclxuXHRcdFx0XHRoYW5kbGVWZXJ0ZXgoIGlCICk7XHJcblx0XHRcdFx0aGFuZGxlVmVydGV4KCBpQyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmhhc1RhbmdlbnRzID0gdHJ1ZTtcclxuXHRcdHRoaXMudGFuZ2VudHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fSxcclxuXHJcblx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqL1xyXG5cclxuVEhSRUUuQ2FtZXJhID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubWF0cml4V29ybGRJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHR0aGlzLnByb2plY3Rpb25NYXRyaXhJbnZlcnNlID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5DYW1lcmEucHJvdG90eXBlLmxvb2tBdCA9IGZ1bmN0aW9uICggdmVjdG9yICkge1xyXG5cclxuXHQvLyBUT0RPOiBBZGQgaGllcmFyY2h5IHN1cHBvcnQuXHJcblxyXG5cdHRoaXMubWF0cml4Lmxvb2tBdCggdGhpcy5wb3NpdGlvbiwgdmVjdG9yLCB0aGlzLnVwICk7XHJcblxyXG5cdGlmICggdGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnVzZVF1YXRlcm5pb24gPT09IGZhbHNlICkgIHtcclxuXHJcblx0XHRcdHRoaXMucm90YXRpb24uc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXgoIHRoaXMubWF0cml4LCB0aGlzLmV1bGVyT3JkZXIgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHRoaXMubWF0cml4LmRlY29tcG9zZSgpWyAxIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYSA9IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGVmdCA9IGxlZnQ7XHJcblx0dGhpcy5yaWdodCA9IHJpZ2h0O1xyXG5cdHRoaXMudG9wID0gdG9wO1xyXG5cdHRoaXMuYm90dG9tID0gYm90dG9tO1xyXG5cclxuXHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDAuMTtcclxuXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDIwMDA7XHJcblxyXG5cdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5PcnRob2dyYXBoaWNDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlT3J0aG9ncmFwaGljKCB0aGlzLmxlZnQsIHRoaXMucmlnaHQsIHRoaXMudG9wLCB0aGlzLmJvdHRvbSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqL1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEgPSBmdW5jdGlvbiAoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdFRIUkVFLkNhbWVyYS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcclxuXHR0aGlzLmFzcGVjdCA9IGFzcGVjdCAhPT0gdW5kZWZpbmVkID8gYXNwZWN0IDogMTtcclxuXHR0aGlzLm5lYXIgPSBuZWFyICE9PSB1bmRlZmluZWQgPyBuZWFyIDogMC4xO1xyXG5cdHRoaXMuZmFyID0gZmFyICE9PSB1bmRlZmluZWQgPyBmYXIgOiAyMDAwO1xyXG5cclxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DYW1lcmEucHJvdG90eXBlICk7XHJcblxyXG5cclxuLyoqXHJcbiAqIFVzZXMgRm9jYWwgTGVuZ3RoIChpbiBtbSkgdG8gZXN0aW1hdGUgYW5kIHNldCBGT1ZcclxuICogMzVtbSAoZnVsbGZyYW1lKSBjYW1lcmEgaXMgdXNlZCBpZiBmcmFtZSBzaXplIGlzIG5vdCBzcGVjaWZpZWQ7XHJcbiAqIEZvcm11bGEgYmFzZWQgb24gaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcclxuICovXHJcblxyXG5USFJFRS5QZXJzcGVjdGl2ZUNhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xyXG5cclxuXHRpZiAoIGZyYW1lSGVpZ2h0ID09PSB1bmRlZmluZWQgKSBmcmFtZUhlaWdodCA9IDI0O1xyXG5cclxuXHR0aGlzLmZvdiA9IDIgKiBUSFJFRS5NYXRoLnJhZFRvRGVnKCBNYXRoLmF0YW4oIGZyYW1lSGVpZ2h0IC8gKCBmb2NhbExlbmd0aCAqIDIgKSApICk7XHJcblx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFNldHMgYW4gb2Zmc2V0IGluIGEgbGFyZ2VyIGZydXN0dW0uIFRoaXMgaXMgdXNlZnVsIGZvciBtdWx0aS13aW5kb3cgb3JcclxuICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cclxuICpcclxuICogRm9yIGV4YW1wbGUsIGlmIHlvdSBoYXZlIDN4MiBtb25pdG9ycyBhbmQgZWFjaCBtb25pdG9yIGlzIDE5MjB4MTA4MCBhbmRcclxuICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xyXG4gKlxyXG4gKiAgICstLS0rLS0tKy0tLStcclxuICogICB8IEEgfCBCIHwgQyB8XHJcbiAqICAgKy0tLSstLS0rLS0tK1xyXG4gKiAgIHwgRCB8IEUgfCBGIHxcclxuICogICArLS0tKy0tLSstLS0rXHJcbiAqXHJcbiAqIHRoZW4gZm9yIGVhY2ggbW9uaXRvciB5b3Ugd291bGQgY2FsbCBpdCBsaWtlIHRoaXNcclxuICpcclxuICogICB2YXIgdyA9IDE5MjA7XHJcbiAqICAgdmFyIGggPSAxMDgwO1xyXG4gKiAgIHZhciBmdWxsV2lkdGggPSB3ICogMztcclxuICogICB2YXIgZnVsbEhlaWdodCA9IGggKiAyO1xyXG4gKlxyXG4gKiAgIC0tQS0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDAsIHcsIGggKTtcclxuICogICAtLUItLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XHJcbiAqICAgLS1DLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMCwgdywgaCApO1xyXG4gKiAgIC0tRC0tXHJcbiAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMCwgaCAqIDEsIHcsIGggKTtcclxuICogICAtLUUtLVxyXG4gKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XHJcbiAqICAgLS1GLS1cclxuICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAyLCBoICogMSwgdywgaCApO1xyXG4gKlxyXG4gKiAgIE5vdGUgdGhlcmUgaXMgbm8gcmVhc29uIG1vbml0b3JzIGhhdmUgdG8gYmUgdGhlIHNhbWUgc2l6ZSBvciBpbiBhIGdyaWQuXHJcbiAqL1xyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldFZpZXdPZmZzZXQgPSBmdW5jdGlvbiAoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0dGhpcy5mdWxsV2lkdGggPSBmdWxsV2lkdGg7XHJcblx0dGhpcy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcclxuXHR0aGlzLnggPSB4O1xyXG5cdHRoaXMueSA9IHk7XHJcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdGlmICggdGhpcy5mdWxsV2lkdGggKSB7XHJcblxyXG5cdFx0dmFyIGFzcGVjdCA9IHRoaXMuZnVsbFdpZHRoIC8gdGhpcy5mdWxsSGVpZ2h0O1xyXG5cdFx0dmFyIHRvcCA9IE1hdGgudGFuKCBUSFJFRS5NYXRoLmRlZ1RvUmFkKCB0aGlzLmZvdiAqIDAuNSApICkgKiB0aGlzLm5lYXI7XHJcblx0XHR2YXIgYm90dG9tID0gLXRvcDtcclxuXHRcdHZhciBsZWZ0ID0gYXNwZWN0ICogYm90dG9tO1xyXG5cdFx0dmFyIHJpZ2h0ID0gYXNwZWN0ICogdG9wO1xyXG5cdFx0dmFyIHdpZHRoID0gTWF0aC5hYnMoIHJpZ2h0IC0gbGVmdCApO1xyXG5cdFx0dmFyIGhlaWdodCA9IE1hdGguYWJzKCB0b3AgLSBib3R0b20gKTtcclxuXHJcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZUZydXN0dW0oXHJcblx0XHRcdGxlZnQgKyB0aGlzLnggKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxyXG5cdFx0XHRsZWZ0ICsgKCB0aGlzLnggKyB0aGlzLndpZHRoICkgKiB3aWR0aCAvIHRoaXMuZnVsbFdpZHRoLFxyXG5cdFx0XHR0b3AgLSAoIHRoaXMueSArIHRoaXMuaGVpZ2h0ICkgKiBoZWlnaHQgLyB0aGlzLmZ1bGxIZWlnaHQsXHJcblx0XHRcdHRvcCAtIHRoaXMueSAqIGhlaWdodCAvIHRoaXMuZnVsbEhlaWdodCxcclxuXHRcdFx0dGhpcy5uZWFyLFxyXG5cdFx0XHR0aGlzLmZhclxyXG5cdFx0KTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLnByb2plY3Rpb25NYXRyaXgubWFrZVBlcnNwZWN0aXZlKCB0aGlzLmZvdiwgdGhpcy5hc3BlY3QsIHRoaXMubmVhciwgdGhpcy5mYXIgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG4gXHJcblRIUkVFLkxpZ2h0ID0gZnVuY3Rpb24gKCBoZXggKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggaGV4ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkFtYmllbnRMaWdodCA9IGZ1bmN0aW9uICggaGV4ICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBoZXggKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbWJpZW50TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIE1QYW5rbmluIC8gaHR0cDovL3d3dy5yZWRwbGFudC5kZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5BcmVhTGlnaHQgPSBmdW5jdGlvbiAoIGhleCwgaW50ZW5zaXR5ICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBoZXggKTtcclxuXHJcblx0dGhpcy5ub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLTEsIDAgKTtcclxuXHR0aGlzLnJpZ2h0ID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKTtcclxuXHJcblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xyXG5cclxuXHR0aGlzLndpZHRoID0gMS4wO1xyXG5cdHRoaXMuaGVpZ2h0ID0gMS4wO1xyXG5cclxuXHR0aGlzLmNvbnN0YW50QXR0ZW51YXRpb24gPSAxLjU7XHJcblx0dGhpcy5saW5lYXJBdHRlbnVhdGlvbiA9IDAuNTtcclxuXHR0aGlzLnF1YWRyYXRpY0F0dGVudWF0aW9uID0gMC4xO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFyZWFMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgPSBmdW5jdGlvbiAoIGhleCwgaW50ZW5zaXR5ICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBoZXggKTtcclxuXHJcblx0dGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xyXG5cclxuXHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcclxuXHR0aGlzLm9ubHlTaGFkb3cgPSBmYWxzZTtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5zaGFkb3dDYW1lcmFOZWFyID0gNTA7XHJcblx0dGhpcy5zaGFkb3dDYW1lcmFGYXIgPSA1MDAwO1xyXG5cclxuXHR0aGlzLnNoYWRvd0NhbWVyYUxlZnQgPSAtNTAwO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhUmlnaHQgPSA1MDA7XHJcblx0dGhpcy5zaGFkb3dDYW1lcmFUb3AgPSA1MDA7XHJcblx0dGhpcy5zaGFkb3dDYW1lcmFCb3R0b20gPSAtNTAwO1xyXG5cclxuXHR0aGlzLnNoYWRvd0NhbWVyYVZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zaGFkb3dCaWFzID0gMDtcclxuXHR0aGlzLnNoYWRvd0RhcmtuZXNzID0gMC41O1xyXG5cclxuXHR0aGlzLnNoYWRvd01hcFdpZHRoID0gNTEyO1xyXG5cdHRoaXMuc2hhZG93TWFwSGVpZ2h0ID0gNTEyO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLnNoYWRvd0Nhc2NhZGUgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlT2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIC0xMDAwICk7XHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlQ291bnQgPSAyO1xyXG5cclxuXHR0aGlzLnNoYWRvd0Nhc2NhZGVCaWFzID0gWyAwLCAwLCAwIF07XHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlV2lkdGggPSBbIDUxMiwgNTEyLCA1MTIgXTtcclxuXHR0aGlzLnNoYWRvd0Nhc2NhZGVIZWlnaHQgPSBbIDUxMiwgNTEyLCA1MTIgXTtcclxuXHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlTmVhclogPSBbIC0xLjAwMCwgMC45OTAsIDAuOTk4IF07XHJcblx0dGhpcy5zaGFkb3dDYXNjYWRlRmFyWiAgPSBbICAwLjk5MCwgMC45OTgsIDEuMDAwIF07XHJcblxyXG5cdHRoaXMuc2hhZG93Q2FzY2FkZUFycmF5ID0gW107XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMuc2hhZG93TWFwID0gbnVsbDtcclxuXHR0aGlzLnNoYWRvd01hcFNpemUgPSBudWxsO1xyXG5cdHRoaXMuc2hhZG93Q2FtZXJhID0gbnVsbDtcclxuXHR0aGlzLnNoYWRvd01hdHJpeCA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ID0gZnVuY3Rpb24gKCBza3lDb2xvckhleCwgZ3JvdW5kQ29sb3JIZXgsIGludGVuc2l0eSApIHtcclxuXHJcblx0VEhSRUUuTGlnaHQuY2FsbCggdGhpcywgc2t5Q29sb3JIZXggKTtcclxuXHJcblx0dGhpcy5ncm91bmRDb2xvciA9IG5ldyBUSFJFRS5Db2xvciggZ3JvdW5kQ29sb3JIZXggKTtcclxuXHJcblx0dGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxMDAsIDAgKTtcclxuXHJcblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkhlbWlzcGhlcmVMaWdodC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaWdodC5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodCA9IGZ1bmN0aW9uICggaGV4LCBpbnRlbnNpdHksIGRpc3RhbmNlICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBoZXggKTtcclxuXHJcblx0dGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICk7XHJcblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xyXG5cdHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxpZ2h0LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcG90TGlnaHQgPSBmdW5jdGlvbiAoIGhleCwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIGV4cG9uZW50ICkge1xyXG5cclxuXHRUSFJFRS5MaWdodC5jYWxsKCB0aGlzLCBoZXggKTtcclxuXHJcblx0dGhpcy5wb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcblx0dGhpcy5pbnRlbnNpdHkgPSAoIGludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBpbnRlbnNpdHkgOiAxO1xyXG5cdHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcclxuXHR0aGlzLmFuZ2xlID0gKCBhbmdsZSAhPT0gdW5kZWZpbmVkICkgPyBhbmdsZSA6IE1hdGguUEkgLyAyO1xyXG5cdHRoaXMuZXhwb25lbnQgPSAoIGV4cG9uZW50ICE9PSB1bmRlZmluZWQgKSA/IGV4cG9uZW50IDogMTA7XHJcblxyXG5cdHRoaXMuY2FzdFNoYWRvdyA9IGZhbHNlO1xyXG5cdHRoaXMub25seVNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLnNoYWRvd0NhbWVyYU5lYXIgPSA1MDtcclxuXHR0aGlzLnNoYWRvd0NhbWVyYUZhciA9IDUwMDA7XHJcblx0dGhpcy5zaGFkb3dDYW1lcmFGb3YgPSA1MDtcclxuXHJcblx0dGhpcy5zaGFkb3dDYW1lcmFWaXNpYmxlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc2hhZG93QmlhcyA9IDA7XHJcblx0dGhpcy5zaGFkb3dEYXJrbmVzcyA9IDAuNTtcclxuXHJcblx0dGhpcy5zaGFkb3dNYXBXaWR0aCA9IDUxMjtcclxuXHR0aGlzLnNoYWRvd01hcEhlaWdodCA9IDUxMjtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5zaGFkb3dNYXAgPSBudWxsO1xyXG5cdHRoaXMuc2hhZG93TWFwU2l6ZSA9IG51bGw7XHJcblx0dGhpcy5zaGFkb3dDYW1lcmEgPSBudWxsO1xyXG5cdHRoaXMuc2hhZG93TWF0cml4ID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcG90TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGlnaHQucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxvYWRlciA9IGZ1bmN0aW9uICggc2hvd1N0YXR1cyApIHtcclxuXHJcblx0dGhpcy5zaG93U3RhdHVzID0gc2hvd1N0YXR1cztcclxuXHR0aGlzLnN0YXR1c0RvbUVsZW1lbnQgPSBzaG93U3RhdHVzID8gVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5hZGRTdGF0dXNFbGVtZW50KCkgOiBudWxsO1xyXG5cclxuXHR0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cdHRoaXMub25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Mb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuTG9hZGVyLFxyXG5cclxuXHRjcm9zc09yaWdpbjogJ2Fub255bW91cycsXHJcblxyXG5cdGFkZFN0YXR1c0VsZW1lbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcclxuXHJcblx0XHRlLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xyXG5cdFx0ZS5zdHlsZS5yaWdodCA9IFwiMHB4XCI7XHJcblx0XHRlLnN0eWxlLnRvcCA9IFwiMHB4XCI7XHJcblx0XHRlLnN0eWxlLmZvbnRTaXplID0gXCIwLjhlbVwiO1xyXG5cdFx0ZS5zdHlsZS50ZXh0QWxpZ24gPSBcImxlZnRcIjtcclxuXHRcdGUuc3R5bGUuYmFja2dyb3VuZCA9IFwicmdiYSgwLDAsMCwwLjI1KVwiO1xyXG5cdFx0ZS5zdHlsZS5jb2xvciA9IFwiI2ZmZlwiO1xyXG5cdFx0ZS5zdHlsZS53aWR0aCA9IFwiMTIwcHhcIjtcclxuXHRcdGUuc3R5bGUucGFkZGluZyA9IFwiMC41ZW0gMC41ZW0gMC41ZW0gMC41ZW1cIjtcclxuXHRcdGUuc3R5bGUuekluZGV4ID0gMTAwMDtcclxuXHJcblx0XHRlLmlubmVySFRNTCA9IFwiTG9hZGluZyAuLi5cIjtcclxuXHJcblx0XHRyZXR1cm4gZTtcclxuXHJcblx0fSxcclxuXHJcblx0dXBkYXRlUHJvZ3Jlc3M6IGZ1bmN0aW9uICggcHJvZ3Jlc3MgKSB7XHJcblxyXG5cdFx0dmFyIG1lc3NhZ2UgPSBcIkxvYWRlZCBcIjtcclxuXHJcblx0XHRpZiAoIHByb2dyZXNzLnRvdGFsICkge1xyXG5cclxuXHRcdFx0bWVzc2FnZSArPSAoIDEwMCAqIHByb2dyZXNzLmxvYWRlZCAvIHByb2dyZXNzLnRvdGFsICkudG9GaXhlZCgwKSArIFwiJVwiO1xyXG5cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bWVzc2FnZSArPSAoIHByb2dyZXNzLmxvYWRlZCAvIDEwMDAgKS50b0ZpeGVkKDIpICsgXCIgS0JcIjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zdGF0dXNEb21FbGVtZW50LmlubmVySFRNTCA9IG1lc3NhZ2U7XHJcblxyXG5cdH0sXHJcblxyXG5cdGV4dHJhY3RVcmxCYXNlOiBmdW5jdGlvbiAoIHVybCApIHtcclxuXHJcblx0XHR2YXIgcGFydHMgPSB1cmwuc3BsaXQoICcvJyApO1xyXG5cdFx0cGFydHMucG9wKCk7XHJcblx0XHRyZXR1cm4gKCBwYXJ0cy5sZW5ndGggPCAxID8gJy4nIDogcGFydHMuam9pbiggJy8nICkgKSArICcvJztcclxuXHJcblx0fSxcclxuXHJcblx0aW5pdE1hdGVyaWFsczogZnVuY3Rpb24gKCBtYXRlcmlhbHMsIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHRcdHZhciBhcnJheSA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7ICsrIGkgKSB7XHJcblxyXG5cdFx0XHRhcnJheVsgaSBdID0gVEhSRUUuTG9hZGVyLnByb3RvdHlwZS5jcmVhdGVNYXRlcmlhbCggbWF0ZXJpYWxzWyBpIF0sIHRleHR1cmVQYXRoICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBhcnJheTtcclxuXHJcblx0fSxcclxuXHJcblx0bmVlZHNUYW5nZW50czogZnVuY3Rpb24gKCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0Zm9yKCB2YXIgaSA9IDAsIGlsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIG0gPSBtYXRlcmlhbHNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggbSBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsICkgcmV0dXJuIHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0fSxcclxuXHJcblx0Y3JlYXRlTWF0ZXJpYWw6IGZ1bmN0aW9uICggbSwgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdFx0dmFyIF90aGlzID0gdGhpcztcclxuXHJcblx0XHRmdW5jdGlvbiBpc19wb3cyKCBuICkge1xyXG5cclxuXHRcdFx0dmFyIGwgPSBNYXRoLmxvZyggbiApIC8gTWF0aC5MTjI7XHJcblx0XHRcdHJldHVybiBNYXRoLmZsb29yKCBsICkgPT0gbDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gbmVhcmVzdF9wb3cyKCBuICkge1xyXG5cclxuXHRcdFx0dmFyIGwgPSBNYXRoLmxvZyggbiApIC8gTWF0aC5MTjI7XHJcblx0XHRcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5yb3VuZCggIGwgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBsb2FkX2ltYWdlKCB3aGVyZSwgdXJsICkge1xyXG5cclxuXHRcdFx0dmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG5cdFx0XHRpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGlmICggIWlzX3BvdzIoIHRoaXMud2lkdGggKSB8fCAhaXNfcG93MiggdGhpcy5oZWlnaHQgKSApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgd2lkdGggPSBuZWFyZXN0X3BvdzIoIHRoaXMud2lkdGggKTtcclxuXHRcdFx0XHRcdHZhciBoZWlnaHQgPSBuZWFyZXN0X3BvdzIoIHRoaXMuaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0d2hlcmUuaW1hZ2Uud2lkdGggPSB3aWR0aDtcclxuXHRcdFx0XHRcdHdoZXJlLmltYWdlLmhlaWdodCA9IGhlaWdodDtcclxuXHRcdFx0XHRcdHdoZXJlLmltYWdlLmdldENvbnRleHQoICcyZCcgKS5kcmF3SW1hZ2UoIHRoaXMsIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR3aGVyZS5pbWFnZSA9IHRoaXM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0d2hlcmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGltYWdlLmNyb3NzT3JpZ2luID0gX3RoaXMuY3Jvc3NPcmlnaW47XHJcblx0XHRcdGltYWdlLnNyYyA9IHVybDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gY3JlYXRlX3RleHR1cmUoIHdoZXJlLCBuYW1lLCBzb3VyY2VGaWxlLCByZXBlYXQsIG9mZnNldCwgd3JhcCwgYW5pc290cm9weSApIHtcclxuXHJcblx0XHRcdHZhciBpc0NvbXByZXNzZWQgPSAvXFwuZGRzJC9pLnRlc3QoIHNvdXJjZUZpbGUgKTtcclxuXHRcdFx0dmFyIGZ1bGxQYXRoID0gdGV4dHVyZVBhdGggKyBcIi9cIiArIHNvdXJjZUZpbGU7XHJcblxyXG5cdFx0XHRpZiAoIGlzQ29tcHJlc3NlZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIHRleHR1cmUgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZSggZnVsbFBhdGggKTtcclxuXHJcblx0XHRcdFx0d2hlcmVbIG5hbWUgXSA9IHRleHR1cmU7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR2YXIgdGV4dHVyZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblxyXG5cdFx0XHRcdHdoZXJlWyBuYW1lIF0gPSBuZXcgVEhSRUUuVGV4dHVyZSggdGV4dHVyZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2hlcmVbIG5hbWUgXS5zb3VyY2VGaWxlID0gc291cmNlRmlsZTtcclxuXHJcblx0XHRcdGlmKCByZXBlYXQgKSB7XHJcblxyXG5cdFx0XHRcdHdoZXJlWyBuYW1lIF0ucmVwZWF0LnNldCggcmVwZWF0WyAwIF0sIHJlcGVhdFsgMSBdICk7XHJcblxyXG5cdFx0XHRcdGlmICggcmVwZWF0WyAwIF0gIT09IDEgKSB3aGVyZVsgbmFtZSBdLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblx0XHRcdFx0aWYgKCByZXBlYXRbIDEgXSAhPT0gMSApIHdoZXJlWyBuYW1lIF0ud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHR3aGVyZVsgbmFtZSBdLm9mZnNldC5zZXQoIG9mZnNldFsgMCBdLCBvZmZzZXRbIDEgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCB3cmFwICkge1xyXG5cclxuXHRcdFx0XHR2YXIgd3JhcE1hcCA9IHtcclxuXHRcdFx0XHRcdFwicmVwZWF0XCI6IFRIUkVFLlJlcGVhdFdyYXBwaW5nLFxyXG5cdFx0XHRcdFx0XCJtaXJyb3JcIjogVEhSRUUuTWlycm9yZWRSZXBlYXRXcmFwcGluZ1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB3cmFwTWFwWyB3cmFwWyAwIF0gXSAhPT0gdW5kZWZpbmVkICkgd2hlcmVbIG5hbWUgXS53cmFwUyA9IHdyYXBNYXBbIHdyYXBbIDAgXSBdO1xyXG5cdFx0XHRcdGlmICggd3JhcE1hcFsgd3JhcFsgMSBdIF0gIT09IHVuZGVmaW5lZCApIHdoZXJlWyBuYW1lIF0ud3JhcFQgPSB3cmFwTWFwWyB3cmFwWyAxIF0gXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggYW5pc290cm9weSApIHtcclxuXHJcblx0XHRcdFx0d2hlcmVbIG5hbWUgXS5hbmlzb3Ryb3B5ID0gYW5pc290cm9weTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggISBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG5cdFx0XHRcdGxvYWRfaW1hZ2UoIHdoZXJlWyBuYW1lIF0sIGZ1bGxQYXRoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJnYjJoZXgoIHJnYiApIHtcclxuXHJcblx0XHRcdHJldHVybiAoIHJnYlsgMCBdICogMjU1IDw8IDE2ICkgKyAoIHJnYlsgMSBdICogMjU1IDw8IDggKSArIHJnYlsgMiBdICogMjU1O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBkZWZhdWx0c1xyXG5cclxuXHRcdHZhciBtdHlwZSA9IFwiTWVzaExhbWJlcnRNYXRlcmlhbFwiO1xyXG5cdFx0dmFyIG1wYXJzID0geyBjb2xvcjogMHhlZWVlZWUsIG9wYWNpdHk6IDEuMCwgbWFwOiBudWxsLCBsaWdodE1hcDogbnVsbCwgbm9ybWFsTWFwOiBudWxsLCBidW1wTWFwOiBudWxsLCB3aXJlZnJhbWU6IGZhbHNlIH07XHJcblxyXG5cdFx0Ly8gcGFyYW1ldGVycyBmcm9tIG1vZGVsIGZpbGVcclxuXHJcblx0XHRpZiAoIG0uc2hhZGluZyApIHtcclxuXHJcblx0XHRcdHZhciBzaGFkaW5nID0gbS5zaGFkaW5nLnRvTG93ZXJDYXNlKCk7XHJcblxyXG5cdFx0XHRpZiAoIHNoYWRpbmcgPT09IFwicGhvbmdcIiApIG10eXBlID0gXCJNZXNoUGhvbmdNYXRlcmlhbFwiO1xyXG5cdFx0XHRlbHNlIGlmICggc2hhZGluZyA9PT0gXCJiYXNpY1wiICkgbXR5cGUgPSBcIk1lc2hCYXNpY01hdGVyaWFsXCI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5ibGVuZGluZyAhPT0gdW5kZWZpbmVkICYmIFRIUkVFWyBtLmJsZW5kaW5nIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1wYXJzLmJsZW5kaW5nID0gVEhSRUVbIG0uYmxlbmRpbmcgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLnRyYW5zcGFyZW50ICE9PSB1bmRlZmluZWQgfHwgbS5vcGFjaXR5IDwgMS4wICkge1xyXG5cclxuXHRcdFx0bXBhcnMudHJhbnNwYXJlbnQgPSBtLnRyYW5zcGFyZW50O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5kZXB0aFRlc3QgPSBtLmRlcHRoVGVzdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLmRlcHRoV3JpdGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1wYXJzLmRlcHRoV3JpdGUgPSBtLmRlcHRoV3JpdGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS52aXNpYmxlICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtcGFycy52aXNpYmxlID0gbS52aXNpYmxlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uZmxpcFNpZGVkICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5zaWRlID0gVEhSRUUuQmFja1NpZGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5kb3VibGVTaWRlZCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0bXBhcnMuc2lkZSA9IFRIUkVFLkRvdWJsZVNpZGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS53aXJlZnJhbWUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdG1wYXJzLndpcmVmcmFtZSA9IG0ud2lyZWZyYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG0udmVydGV4Q29sb3JzID09PSBcImZhY2VcIiApIHtcclxuXHJcblx0XHRcdFx0bXBhcnMudmVydGV4Q29sb3JzID0gVEhSRUUuRmFjZUNvbG9ycztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG0udmVydGV4Q29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRtcGFycy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5WZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNvbG9yc1xyXG5cclxuXHRcdGlmICggbS5jb2xvckRpZmZ1c2UgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5jb2xvciA9IHJnYjJoZXgoIG0uY29sb3JEaWZmdXNlICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbS5EYmdDb2xvciApIHtcclxuXHJcblx0XHRcdG1wYXJzLmNvbG9yID0gbS5EYmdDb2xvcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLmNvbG9yU3BlY3VsYXIgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5zcGVjdWxhciA9IHJnYjJoZXgoIG0uY29sb3JTcGVjdWxhciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0uY29sb3JBbWJpZW50ICkge1xyXG5cclxuXHRcdFx0bXBhcnMuYW1iaWVudCA9IHJnYjJoZXgoIG0uY29sb3JBbWJpZW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG1vZGlmaWVyc1xyXG5cclxuXHRcdGlmICggbS50cmFuc3BhcmVuY3kgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5vcGFjaXR5ID0gbS50cmFuc3BhcmVuY3k7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5zcGVjdWxhckNvZWYgKSB7XHJcblxyXG5cdFx0XHRtcGFycy5zaGluaW5lc3MgPSBtLnNwZWN1bGFyQ29lZjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdGV4dHVyZXNcclxuXHJcblx0XHRpZiAoIG0ubWFwRGlmZnVzZSAmJiB0ZXh0dXJlUGF0aCApIHtcclxuXHJcblx0XHRcdGNyZWF0ZV90ZXh0dXJlKCBtcGFycywgXCJtYXBcIiwgbS5tYXBEaWZmdXNlLCBtLm1hcERpZmZ1c2VSZXBlYXQsIG0ubWFwRGlmZnVzZU9mZnNldCwgbS5tYXBEaWZmdXNlV3JhcCwgbS5tYXBEaWZmdXNlQW5pc290cm9weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0ubWFwTGlnaHQgJiYgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdFx0XHRjcmVhdGVfdGV4dHVyZSggbXBhcnMsIFwibGlnaHRNYXBcIiwgbS5tYXBMaWdodCwgbS5tYXBMaWdodFJlcGVhdCwgbS5tYXBMaWdodE9mZnNldCwgbS5tYXBMaWdodFdyYXAsIG0ubWFwTGlnaHRBbmlzb3Ryb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbS5tYXBCdW1wICYmIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCBcImJ1bXBNYXBcIiwgbS5tYXBCdW1wLCBtLm1hcEJ1bXBSZXBlYXQsIG0ubWFwQnVtcE9mZnNldCwgbS5tYXBCdW1wV3JhcCwgbS5tYXBCdW1wQW5pc290cm9weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0ubWFwTm9ybWFsICYmIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHRcdFx0Y3JlYXRlX3RleHR1cmUoIG1wYXJzLCBcIm5vcm1hbE1hcFwiLCBtLm1hcE5vcm1hbCwgbS5tYXBOb3JtYWxSZXBlYXQsIG0ubWFwTm9ybWFsT2Zmc2V0LCBtLm1hcE5vcm1hbFdyYXAsIG0ubWFwTm9ybWFsQW5pc290cm9weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG0ubWFwU3BlY3VsYXIgJiYgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdFx0XHRjcmVhdGVfdGV4dHVyZSggbXBhcnMsIFwic3BlY3VsYXJNYXBcIiwgbS5tYXBTcGVjdWxhciwgbS5tYXBTcGVjdWxhclJlcGVhdCwgbS5tYXBTcGVjdWxhck9mZnNldCwgbS5tYXBTcGVjdWxhcldyYXAsIG0ubWFwU3BlY3VsYXJBbmlzb3Ryb3B5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0aWYgKCBtLm1hcEJ1bXBTY2FsZSApIHtcclxuXHJcblx0XHRcdG1wYXJzLmJ1bXBTY2FsZSA9IG0ubWFwQnVtcFNjYWxlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzcGVjaWFsIGNhc2UgZm9yIG5vcm1hbCBtYXBwZWQgbWF0ZXJpYWxcclxuXHJcblx0XHRpZiAoIG0ubWFwTm9ybWFsICkge1xyXG5cclxuXHRcdFx0dmFyIHNoYWRlciA9IFRIUkVFLlNoYWRlckxpYlsgXCJub3JtYWxtYXBcIiBdO1xyXG5cdFx0XHR2YXIgdW5pZm9ybXMgPSBUSFJFRS5Vbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXIudW5pZm9ybXMgKTtcclxuXHJcblx0XHRcdHVuaWZvcm1zWyBcInROb3JtYWxcIiBdLnZhbHVlID0gbXBhcnMubm9ybWFsTWFwO1xyXG5cclxuXHRcdFx0aWYgKCBtLm1hcE5vcm1hbEZhY3RvciApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidU5vcm1hbFNjYWxlXCIgXS52YWx1ZS5zZXQoIG0ubWFwTm9ybWFsRmFjdG9yLCBtLm1hcE5vcm1hbEZhY3RvciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtcGFycy5tYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInREaWZmdXNlXCIgXS52YWx1ZSA9IG1wYXJzLm1hcDtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVEaWZmdXNlXCIgXS52YWx1ZSA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1wYXJzLnNwZWN1bGFyTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0U3BlY3VsYXJcIiBdLnZhbHVlID0gbXBhcnMuc3BlY3VsYXJNYXA7XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlU3BlY3VsYXJcIiBdLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbXBhcnMubGlnaHRNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInRBT1wiIF0udmFsdWUgPSBtcGFycy5saWdodE1hcDtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVBT1wiIF0udmFsdWUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gZm9yIHRoZSBtb21lbnQgZG9uJ3QgaGFuZGxlIGRpc3BsYWNlbWVudCB0ZXh0dXJlXHJcblxyXG5cdFx0XHR1bmlmb3Jtc1sgXCJ1RGlmZnVzZUNvbG9yXCIgXS52YWx1ZS5zZXRIZXgoIG1wYXJzLmNvbG9yICk7XHJcblx0XHRcdHVuaWZvcm1zWyBcInVTcGVjdWxhckNvbG9yXCIgXS52YWx1ZS5zZXRIZXgoIG1wYXJzLnNwZWN1bGFyICk7XHJcblx0XHRcdHVuaWZvcm1zWyBcInVBbWJpZW50Q29sb3JcIiBdLnZhbHVlLnNldEhleCggbXBhcnMuYW1iaWVudCApO1xyXG5cclxuXHRcdFx0dW5pZm9ybXNbIFwidVNoaW5pbmVzc1wiIF0udmFsdWUgPSBtcGFycy5zaGluaW5lc3M7XHJcblxyXG5cdFx0XHRpZiAoIG1wYXJzLm9wYWNpdHkgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidU9wYWNpdHlcIiBdLnZhbHVlID0gbXBhcnMub3BhY2l0eTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwYXJhbWV0ZXJzID0geyBmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiB1bmlmb3JtcywgbGlnaHRzOiB0cnVlLCBmb2c6IHRydWUgfTtcclxuXHRcdFx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0XHRpZiAoIG1wYXJzLnRyYW5zcGFyZW50ICkge1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRVsgbXR5cGUgXSggbXBhcnMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtLkRiZ05hbWUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm5hbWUgPSBtLkRiZ05hbWU7XHJcblxyXG5cdFx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5JbWFnZUxvYWRlciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuRXZlbnREaXNwYXRjaGVyLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jcm9zc09yaWdpbiA9IG51bGw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSW1hZ2VMb2FkZXIucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuSW1hZ2VMb2FkZXIsXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBpbWFnZSApIHtcclxuXHJcblx0XHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHRcdGlmICggaW1hZ2UgPT09IHVuZGVmaW5lZCApIGltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG5cdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdsb2FkJywgY29udGVudDogaW1hZ2UgfSApO1xyXG5cclxuXHRcdH0sIGZhbHNlICk7XHJcblxyXG5cdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0c2NvcGUuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZXJyb3InLCBtZXNzYWdlOiAnQ291bGRuXFwndCBsb2FkIFVSTCBbJyArIHVybCArICddJyB9ICk7XHJcblxyXG5cdFx0fSwgZmFsc2UgKTtcclxuXHJcblx0XHRpZiAoIHNjb3BlLmNyb3NzT3JpZ2luICkgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBzY29wZS5jcm9zc09yaWdpbjtcclxuXHJcblx0XHRpbWFnZS5zcmMgPSB1cmw7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSlNPTkxvYWRlciA9IGZ1bmN0aW9uICggc2hvd1N0YXR1cyApIHtcclxuXHJcblx0VEhSRUUuTG9hZGVyLmNhbGwoIHRoaXMsIHNob3dTdGF0dXMgKTtcclxuXHJcblx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5KU09OTG9hZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkxvYWRlci5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoICkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHQvLyB0b2RvOiB1bmlmeSBsb2FkIEFQSSB0byBmb3IgZWFzaWVyIFNjZW5lTG9hZGVyIHVzZVxyXG5cclxuXHR0ZXh0dXJlUGF0aCA9IHRleHR1cmVQYXRoICYmICggdHlwZW9mIHRleHR1cmVQYXRoID09PSBcInN0cmluZ1wiICkgPyB0ZXh0dXJlUGF0aCA6IHRoaXMuZXh0cmFjdFVybEJhc2UoIHVybCApO1xyXG5cclxuXHR0aGlzLm9uTG9hZFN0YXJ0KCk7XHJcblx0dGhpcy5sb2FkQWpheEpTT04oIHRoaXMsIHVybCwgY2FsbGJhY2ssIHRleHR1cmVQYXRoICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuSlNPTkxvYWRlci5wcm90b3R5cGUubG9hZEFqYXhKU09OID0gZnVuY3Rpb24gKCBjb250ZXh0LCB1cmwsIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCwgY2FsbGJhY2tQcm9ncmVzcyApIHtcclxuXHJcblx0dmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG5cclxuXHR2YXIgbGVuZ3RoID0gMDtcclxuXHJcblx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSB4aHIuRE9ORSApIHtcclxuXHJcblx0XHRcdGlmICggeGhyLnN0YXR1cyA9PT0gMjAwIHx8IHhoci5zdGF0dXMgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggeGhyLnJlc3BvbnNlVGV4dCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIganNvbiA9IEpTT04ucGFyc2UoIHhoci5yZXNwb25zZVRleHQgKTtcclxuXHRcdFx0XHRcdGNvbnRleHQuY3JlYXRlTW9kZWwoIGpzb24sIGNhbGxiYWNrLCB0ZXh0dXJlUGF0aCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJUSFJFRS5KU09OTG9hZGVyOiBbXCIgKyB1cmwgKyBcIl0gc2VlbXMgdG8gYmUgdW5yZWFjaGFibGUgb3IgZmlsZSB0aGVyZSBpcyBlbXB0eVwiICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gaW4gY29udGV4dCBvZiBtb3JlIGNvbXBsZXggYXNzZXQgaW5pdGlhbGl6YXRpb25cclxuXHRcdFx0XHQvLyBkbyBub3QgYmxvY2sgb24gc2luZ2xlIGZhaWxlZCBmaWxlXHJcblx0XHRcdFx0Ly8gbWF5YmUgc2hvdWxkIGdvIGV2ZW4gb25lIG1vcmUgbGV2ZWwgdXBcclxuXHJcblx0XHRcdFx0Y29udGV4dC5vbkxvYWRDb21wbGV0ZSgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5KU09OTG9hZGVyOiBDb3VsZG4ndCBsb2FkIFtcIiArIHVybCArIFwiXSBbXCIgKyB4aHIuc3RhdHVzICsgXCJdXCIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0geGhyLkxPQURJTkcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGNhbGxiYWNrUHJvZ3Jlc3MgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdGxlbmd0aCA9IHhoci5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LUxlbmd0aFwiICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Y2FsbGJhY2tQcm9ncmVzcyggeyB0b3RhbDogbGVuZ3RoLCBsb2FkZWQ6IHhoci5yZXNwb25zZVRleHQubGVuZ3RoIH0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0geGhyLkhFQURFUlNfUkVDRUlWRUQgKSB7XHJcblxyXG5cdFx0XHRsZW5ndGggPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1MZW5ndGhcIiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0eGhyLm9wZW4oIFwiR0VUXCIsIHVybCwgdHJ1ZSApO1xyXG5cdHhoci53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcclxuXHR4aHIuc2VuZCggbnVsbCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkpTT05Mb2FkZXIucHJvdG90eXBlLmNyZWF0ZU1vZGVsID0gZnVuY3Rpb24gKCBqc29uLCBjYWxsYmFjaywgdGV4dHVyZVBhdGggKSB7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXMsXHJcblx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKSxcclxuXHRzY2FsZSA9ICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkgPyAxLjAgLyBqc29uLnNjYWxlIDogMS4wO1xyXG5cclxuXHRwYXJzZU1vZGVsKCBzY2FsZSApO1xyXG5cclxuXHRwYXJzZVNraW4oKTtcclxuXHRwYXJzZU1vcnBoaW5nKCBzY2FsZSApO1xyXG5cclxuXHRnZW9tZXRyeS5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0Z2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlTW9kZWwoIHNjYWxlICkge1xyXG5cclxuXHRcdGZ1bmN0aW9uIGlzQml0U2V0KCB2YWx1ZSwgcG9zaXRpb24gKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmFsdWUgJiAoIDEgPDwgcG9zaXRpb24gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGksIGosIGZpLFxyXG5cclxuXHRcdG9mZnNldCwgekxlbmd0aCwgblZlcnRpY2VzLFxyXG5cclxuXHRcdGNvbG9ySW5kZXgsIG5vcm1hbEluZGV4LCB1dkluZGV4LCBtYXRlcmlhbEluZGV4LFxyXG5cclxuXHRcdHR5cGUsXHJcblx0XHRpc1F1YWQsXHJcblx0XHRoYXNNYXRlcmlhbCxcclxuXHRcdGhhc0ZhY2VVdiwgaGFzRmFjZVZlcnRleFV2LFxyXG5cdFx0aGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCxcclxuXHRcdGhhc0ZhY2VDb2xvciwgaGFzRmFjZVZlcnRleENvbG9yLFxyXG5cclxuXHRcdHZlcnRleCwgZmFjZSwgY29sb3IsIG5vcm1hbCxcclxuXHJcblx0XHR1dkxheWVyLCB1dnMsIHUsIHYsXHJcblxyXG5cdFx0ZmFjZXMgPSBqc29uLmZhY2VzLFxyXG5cdFx0dmVydGljZXMgPSBqc29uLnZlcnRpY2VzLFxyXG5cdFx0bm9ybWFscyA9IGpzb24ubm9ybWFscyxcclxuXHRcdGNvbG9ycyA9IGpzb24uY29sb3JzLFxyXG5cclxuXHRcdG5VdkxheWVycyA9IDA7XHJcblxyXG5cdFx0Ly8gZGlzcmVnYXJkIGVtcHR5IGFycmF5c1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwganNvbi51dnMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGpzb24udXZzWyBpIF0ubGVuZ3RoICkgblV2TGF5ZXJzICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSsrICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuZmFjZVV2c1sgaSBdID0gW107XHJcblx0XHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRvZmZzZXQgPSAwO1xyXG5cdFx0ekxlbmd0aCA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHR3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcclxuXHRcdFx0dmVydGV4LnkgPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcclxuXHRcdFx0dmVydGV4LnogPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcclxuXHJcblx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRvZmZzZXQgPSAwO1xyXG5cdFx0ekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcclxuXHJcblx0XHR3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XHJcblxyXG5cdFx0XHR0eXBlID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHJcblx0XHRcdGlzUXVhZCAgICAgICAgICBcdD0gaXNCaXRTZXQoIHR5cGUsIDAgKTtcclxuXHRcdFx0aGFzTWF0ZXJpYWwgICAgICAgICA9IGlzQml0U2V0KCB0eXBlLCAxICk7XHJcblx0XHRcdGhhc0ZhY2VVdiAgICAgICAgICAgPSBpc0JpdFNldCggdHlwZSwgMiApO1xyXG5cdFx0XHRoYXNGYWNlVmVydGV4VXYgICAgID0gaXNCaXRTZXQoIHR5cGUsIDMgKTtcclxuXHRcdFx0aGFzRmFjZU5vcm1hbCAgICAgICA9IGlzQml0U2V0KCB0eXBlLCA0ICk7XHJcblx0XHRcdGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNSApO1xyXG5cdFx0XHRoYXNGYWNlQ29sb3JcdCAgICA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XHJcblx0XHRcdGhhc0ZhY2VWZXJ0ZXhDb2xvciAgPSBpc0JpdFNldCggdHlwZSwgNyApO1xyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhcInR5cGVcIiwgdHlwZSwgXCJiaXRzXCIsIGlzUXVhZCwgaGFzTWF0ZXJpYWwsIGhhc0ZhY2VVdiwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XHJcblxyXG5cdFx0XHRpZiAoIGlzUXVhZCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IG5ldyBUSFJFRS5GYWNlNCgpO1xyXG5cclxuXHRcdFx0XHRmYWNlLmEgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0ZmFjZS5iID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cdFx0XHRcdGZhY2UuYyA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRmYWNlLmQgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdG5WZXJ0aWNlcyA9IDQ7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCk7XHJcblxyXG5cdFx0XHRcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRmYWNlLmIgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblx0XHRcdFx0ZmFjZS5jID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRuVmVydGljZXMgPSAzO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHRcdFx0XHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdG8gZ2V0IGZhY2UgPD0+IHV2IGluZGV4IGNvcnJlc3BvbmRlbmNlXHJcblxyXG5cdFx0XHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVV2ICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdHV2TGF5ZXIgPSBqc29uLnV2c1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdFx0dSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XHJcblx0XHRcdFx0XHR2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVV2c1sgaSBdWyBmaSBdID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgblV2TGF5ZXJzOyBpKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dXZMYXllciA9IGpzb24udXZzWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0dXZzID0gW107XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggaiA9IDA7IGogPCBuVmVydGljZXM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR1dkluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0dSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XHJcblx0XHRcdFx0XHRcdHYgPSB1dkxheWVyWyB1dkluZGV4ICogMiArIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdHV2c1sgaiBdID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIHYgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdWyBmaSBdID0gdXZzO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VOb3JtYWwgKSB7XHJcblxyXG5cdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcblx0XHRcdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdFx0bm9ybWFsLnggPSBub3JtYWxzWyBub3JtYWxJbmRleCArKyBdO1xyXG5cdFx0XHRcdG5vcm1hbC55ID0gbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXTtcclxuXHRcdFx0XHRub3JtYWwueiA9IG5vcm1hbHNbIG5vcm1hbEluZGV4IF07XHJcblxyXG5cdFx0XHRcdGZhY2Uubm9ybWFsID0gbm9ybWFsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5WZXJ0aWNlczsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcclxuXHJcblx0XHRcdFx0XHRub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbC54ID0gbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXTtcclxuXHRcdFx0XHRcdG5vcm1hbC55ID0gbm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXTtcclxuXHRcdFx0XHRcdG5vcm1hbC56ID0gbm9ybWFsc1sgbm9ybWFsSW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRmYWNlLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcclxuXHJcblx0XHRcdFx0Y29sb3JJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcclxuXHJcblx0XHRcdFx0Y29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XHJcblx0XHRcdFx0ZmFjZS5jb2xvciA9IGNvbG9yO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IG5WZXJ0aWNlczsgaSsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XHJcblxyXG5cdFx0XHRcdFx0Y29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XHJcblx0XHRcdFx0XHRmYWNlLnZlcnRleENvbG9ycy5wdXNoKCBjb2xvciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBwYXJzZVNraW4oKSB7XHJcblxyXG5cdFx0dmFyIGksIGwsIHgsIHksIHosIHcsIGEsIGIsIGMsIGQ7XHJcblxyXG5cdFx0aWYgKCBqc29uLnNraW5XZWlnaHRzICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBqc29uLnNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcclxuXHJcblx0XHRcdFx0eCA9IGpzb24uc2tpbldlaWdodHNbIGkgICAgIF07XHJcblx0XHRcdFx0eSA9IGpzb24uc2tpbldlaWdodHNbIGkgKyAxIF07XHJcblx0XHRcdFx0eiA9IDA7XHJcblx0XHRcdFx0dyA9IDA7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnNraW5XZWlnaHRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCB4LCB5LCB6LCB3ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBqc29uLnNraW5JbmRpY2VzICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBqc29uLnNraW5JbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMiApIHtcclxuXHJcblx0XHRcdFx0YSA9IGpzb24uc2tpbkluZGljZXNbIGkgICAgIF07XHJcblx0XHRcdFx0YiA9IGpzb24uc2tpbkluZGljZXNbIGkgKyAxIF07XHJcblx0XHRcdFx0YyA9IDA7XHJcblx0XHRcdFx0ZCA9IDA7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnNraW5JbmRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3I0KCBhLCBiLCBjLCBkICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkuYm9uZXMgPSBqc29uLmJvbmVzO1xyXG5cdFx0Z2VvbWV0cnkuYW5pbWF0aW9uID0ganNvbi5hbmltYXRpb247XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHBhcnNlTW9ycGhpbmcoIHNjYWxlICkge1xyXG5cclxuXHRcdGlmICgganNvbi5tb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBpLCBsLCB2LCB2bCwgZHN0VmVydGljZXMsIHNyY1ZlcnRpY2VzO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBqc29uLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXSA9IHt9O1xyXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPSBqc29uLm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWU7XHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgPSBbXTtcclxuXHJcblx0XHRcdFx0ZHN0VmVydGljZXMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcclxuXHRcdFx0XHRzcmNWZXJ0aWNlcyA9IGpzb24ubW9ycGhUYXJnZXRzIFsgaSBdLnZlcnRpY2VzO1xyXG5cclxuXHRcdFx0XHRmb3IoIHYgPSAwLCB2bCA9IHNyY1ZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICs9IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdFx0XHR2ZXJ0ZXgueCA9IHNyY1ZlcnRpY2VzWyB2IF0gKiBzY2FsZTtcclxuXHRcdFx0XHRcdHZlcnRleC55ID0gc3JjVmVydGljZXNbIHYgKyAxIF0gKiBzY2FsZTtcclxuXHRcdFx0XHRcdHZlcnRleC56ID0gc3JjVmVydGljZXNbIHYgKyAyIF0gKiBzY2FsZTtcclxuXHJcblx0XHRcdFx0XHRkc3RWZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGpzb24ubW9ycGhDb2xvcnMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBpLCBsLCBjLCBjbCwgZHN0Q29sb3JzLCBzcmNDb2xvcnMsIGNvbG9yO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBqc29uLm1vcnBoQ29sb3JzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkubW9ycGhDb2xvcnNbIGkgXSA9IHt9O1xyXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0ubmFtZSA9IGpzb24ubW9ycGhDb2xvcnNbIGkgXS5uYW1lO1xyXG5cdFx0XHRcdGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzID0gW107XHJcblxyXG5cdFx0XHRcdGRzdENvbG9ycyA9IGdlb21ldHJ5Lm1vcnBoQ29sb3JzWyBpIF0uY29sb3JzO1xyXG5cdFx0XHRcdHNyY0NvbG9ycyA9IGpzb24ubW9ycGhDb2xvcnMgWyBpIF0uY29sb3JzO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBjID0gMCwgY2wgPSBzcmNDb2xvcnMubGVuZ3RoOyBjIDwgY2w7IGMgKz0gMyApIHtcclxuXHJcblx0XHRcdFx0XHRjb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmFhMDAgKTtcclxuXHRcdFx0XHRcdGNvbG9yLnNldFJHQiggc3JjQ29sb3JzWyBjIF0sIHNyY0NvbG9yc1sgYyArIDEgXSwgc3JjQ29sb3JzWyBjICsgMiBdICk7XHJcblx0XHRcdFx0XHRkc3RDb2xvcnMucHVzaCggY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dmFyIG1hdGVyaWFscyA9IHRoaXMuaW5pdE1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVQYXRoICk7XHJcblxyXG5cdGlmICggdGhpcy5uZWVkc1RhbmdlbnRzKCBtYXRlcmlhbHMgKSApIGdlb21ldHJ5LmNvbXB1dGVUYW5nZW50cygpO1xyXG5cclxuXHRjYWxsYmFjayggZ2VvbWV0cnksIG1hdGVyaWFscyApO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTG9hZGluZ01vbml0b3IgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHZhciBsb2FkZWQgPSAwO1xyXG5cdHZhciB0b3RhbCA9IDA7XHJcblxyXG5cdHZhciBvbkxvYWQgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdGxvYWRlZCArKztcclxuXHJcblx0XHRzY29wZS5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdwcm9ncmVzcycsIGxvYWRlZDogbG9hZGVkLCB0b3RhbDogdG90YWwgfSApO1xyXG5cclxuXHRcdGlmICggbG9hZGVkID09PSB0b3RhbCApIHtcclxuXHJcblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2xvYWQnIH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuYWRkID0gZnVuY3Rpb24gKCBsb2FkZXIgKSB7XHJcblxyXG5cdFx0dG90YWwgKys7XHJcblxyXG5cdFx0bG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgb25Mb2FkLCBmYWxzZSApO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuU2NlbmVMb2FkZXIgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMub25Mb2FkU3RhcnQgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHR0aGlzLm9uTG9hZFByb2dyZXNzID0gZnVuY3Rpb24oKSB7fTtcclxuXHR0aGlzLm9uTG9hZENvbXBsZXRlID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5cdHRoaXMuY2FsbGJhY2tTeW5jID0gZnVuY3Rpb24gKCkge307XHJcblx0dGhpcy5jYWxsYmFja1Byb2dyZXNzID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnlIYW5kbGVyTWFwID0ge307XHJcblx0dGhpcy5oaWVyYXJjaHlIYW5kbGVyTWFwID0ge307XHJcblxyXG5cdHRoaXMuYWRkR2VvbWV0cnlIYW5kbGVyKCBcImFzY2lpXCIsIFRIUkVFLkpTT05Mb2FkZXIgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TY2VuZUxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUSFJFRS5TY2VuZUxvYWRlcjtcclxuXHJcblRIUkVFLlNjZW5lTG9hZGVyLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCB1cmwsIGNhbGxiYWNrRmluaXNoZWQgKSB7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xyXG5cclxuXHRcdFx0aWYgKCB4aHIuc3RhdHVzID09PSAyMDAgfHwgeGhyLnN0YXR1cyA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0dmFyIGpzb24gPSBKU09OLnBhcnNlKCB4aHIucmVzcG9uc2VUZXh0ICk7XHJcblx0XHRcdFx0c2NvcGUucGFyc2UoIGpzb24sIGNhbGxiYWNrRmluaXNoZWQsIHVybCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJUSFJFRS5TY2VuZUxvYWRlcjogQ291bGRuJ3QgbG9hZCBbXCIgKyB1cmwgKyBcIl0gW1wiICsgeGhyLnN0YXR1cyArIFwiXVwiICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR4aHIub3BlbiggXCJHRVRcIiwgdXJsLCB0cnVlICk7XHJcblx0eGhyLnNlbmQoIG51bGwgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TY2VuZUxvYWRlci5wcm90b3R5cGUuYWRkR2VvbWV0cnlIYW5kbGVyID0gZnVuY3Rpb24gKCB0eXBlSUQsIGxvYWRlckNsYXNzICkge1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5SGFuZGxlck1hcFsgdHlwZUlEIF0gPSB7IFwibG9hZGVyQ2xhc3NcIjogbG9hZGVyQ2xhc3MgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TY2VuZUxvYWRlci5wcm90b3R5cGUuYWRkSGllcmFyY2h5SGFuZGxlciA9IGZ1bmN0aW9uICggdHlwZUlELCBsb2FkZXJDbGFzcyApIHtcclxuXHJcblx0dGhpcy5oaWVyYXJjaHlIYW5kbGVyTWFwWyB0eXBlSUQgXSA9IHsgXCJsb2FkZXJDbGFzc1wiOiBsb2FkZXJDbGFzcyB9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNjZW5lTG9hZGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICgganNvbiwgY2FsbGJhY2tGaW5pc2hlZCwgdXJsICkge1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR2YXIgdXJsQmFzZSA9IFRIUkVFLkxvYWRlci5wcm90b3R5cGUuZXh0cmFjdFVybEJhc2UoIHVybCApO1xyXG5cclxuXHR2YXIgZ2VvbWV0cnksIG1hdGVyaWFsLCBjYW1lcmEsIGZvZyxcclxuXHRcdHRleHR1cmUsIGltYWdlcywgY29sb3IsXHJcblx0XHRsaWdodCwgaGV4LCBpbnRlbnNpdHksXHJcblx0XHRjb3VudGVyX21vZGVscywgY291bnRlcl90ZXh0dXJlcyxcclxuXHRcdHRvdGFsX21vZGVscywgdG90YWxfdGV4dHVyZXMsXHJcblx0XHRyZXN1bHQ7XHJcblxyXG5cdHZhciB0YXJnZXRfYXJyYXkgPSBbXTtcclxuXHJcblx0dmFyIGRhdGEgPSBqc29uO1xyXG5cclxuXHQvLyBhc3luYyBnZW9tZXRyeSBsb2FkZXJzXHJcblxyXG5cdGZvciAoIHZhciB0eXBlSUQgaW4gdGhpcy5nZW9tZXRyeUhhbmRsZXJNYXAgKSB7XHJcblxyXG5cdFx0dmFyIGxvYWRlckNsYXNzID0gdGhpcy5nZW9tZXRyeUhhbmRsZXJNYXBbIHR5cGVJRCBdWyBcImxvYWRlckNsYXNzXCIgXTtcclxuXHRcdHRoaXMuZ2VvbWV0cnlIYW5kbGVyTWFwWyB0eXBlSUQgXVsgXCJsb2FkZXJPYmplY3RcIiBdID0gbmV3IGxvYWRlckNsYXNzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gYXN5bmMgaGllcmFjaHkgbG9hZGVyc1xyXG5cclxuXHRmb3IgKCB2YXIgdHlwZUlEIGluIHRoaXMuaGllcmFyY2h5SGFuZGxlck1hcCApIHtcclxuXHJcblx0XHR2YXIgbG9hZGVyQ2xhc3MgPSB0aGlzLmhpZXJhcmNoeUhhbmRsZXJNYXBbIHR5cGVJRCBdWyBcImxvYWRlckNsYXNzXCIgXTtcclxuXHRcdHRoaXMuaGllcmFyY2h5SGFuZGxlck1hcFsgdHlwZUlEIF1bIFwibG9hZGVyT2JqZWN0XCIgXSA9IG5ldyBsb2FkZXJDbGFzcygpO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvdW50ZXJfbW9kZWxzID0gMDtcclxuXHRjb3VudGVyX3RleHR1cmVzID0gMDtcclxuXHJcblx0cmVzdWx0ID0ge1xyXG5cclxuXHRcdHNjZW5lOiBuZXcgVEhSRUUuU2NlbmUoKSxcclxuXHRcdGdlb21ldHJpZXM6IHt9LFxyXG5cdFx0ZmFjZV9tYXRlcmlhbHM6IHt9LFxyXG5cdFx0bWF0ZXJpYWxzOiB7fSxcclxuXHRcdHRleHR1cmVzOiB7fSxcclxuXHRcdG9iamVjdHM6IHt9LFxyXG5cdFx0Y2FtZXJhczoge30sXHJcblx0XHRsaWdodHM6IHt9LFxyXG5cdFx0Zm9nczoge30sXHJcblx0XHRlbXB0aWVzOiB7fSxcclxuXHRcdGdyb3Vwczoge31cclxuXHJcblx0fTtcclxuXHJcblx0aWYgKCBkYXRhLnRyYW5zZm9ybSApIHtcclxuXHJcblx0XHR2YXIgcG9zaXRpb24gPSBkYXRhLnRyYW5zZm9ybS5wb3NpdGlvbixcclxuXHRcdFx0cm90YXRpb24gPSBkYXRhLnRyYW5zZm9ybS5yb3RhdGlvbixcclxuXHRcdFx0c2NhbGUgPSBkYXRhLnRyYW5zZm9ybS5zY2FsZTtcclxuXHJcblx0XHRpZiAoIHBvc2l0aW9uIClcclxuXHRcdFx0cmVzdWx0LnNjZW5lLnBvc2l0aW9uLnNldCggcG9zaXRpb25bIDAgXSwgcG9zaXRpb25bIDEgXSwgcG9zaXRpb24gWyAyIF0gKTtcclxuXHJcblx0XHRpZiAoIHJvdGF0aW9uIClcclxuXHRcdFx0cmVzdWx0LnNjZW5lLnJvdGF0aW9uLnNldCggcm90YXRpb25bIDAgXSwgcm90YXRpb25bIDEgXSwgcm90YXRpb24gWyAyIF0gKTtcclxuXHJcblx0XHRpZiAoIHNjYWxlIClcclxuXHRcdFx0cmVzdWx0LnNjZW5lLnNjYWxlLnNldCggc2NhbGVbIDAgXSwgc2NhbGVbIDEgXSwgc2NhbGUgWyAyIF0gKTtcclxuXHJcblx0XHRpZiAoIHBvc2l0aW9uIHx8IHJvdGF0aW9uIHx8IHNjYWxlICkge1xyXG5cclxuXHRcdFx0cmVzdWx0LnNjZW5lLnVwZGF0ZU1hdHJpeCgpO1xyXG5cdFx0XHRyZXN1bHQuc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0X3VybCggc291cmNlX3VybCwgdXJsX3R5cGUgKSB7XHJcblxyXG5cdFx0aWYgKCB1cmxfdHlwZSA9PSBcInJlbGF0aXZlVG9IVE1MXCIgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gc291cmNlX3VybDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIHVybEJhc2UgKyBcIi9cIiArIHNvdXJjZV91cmw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyB0b3BsZXZlbCBsb2FkZXIgZnVuY3Rpb24sIGRlbGVnYXRlcyB0byBoYW5kbGVfY2hpbGRyZW5cclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlX29iamVjdHMoKSB7XHJcblxyXG5cdFx0aGFuZGxlX2NoaWxkcmVuKCByZXN1bHQuc2NlbmUsIGRhdGEub2JqZWN0cyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGhhbmRsZSBhbGwgdGhlIGNoaWxkcmVuIGZyb20gdGhlIGxvYWRlZCBqc29uIGFuZCBhdHRhY2ggdGhlbSB0byBnaXZlbiBwYXJlbnRcclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlX2NoaWxkcmVuKCBwYXJlbnQsIGNoaWxkcmVuICkge1xyXG5cclxuXHRcdHZhciBtYXQsIGRzdCwgcG9zLCByb3QsIHNjbCwgcXVhdDtcclxuXHJcblx0XHRmb3IgKCB2YXIgb2JqSUQgaW4gY2hpbGRyZW4gKSB7XHJcblxyXG5cdFx0XHQvLyBjaGVjayBieSBpZCBpZiBjaGlsZCBoYXMgYWxyZWFkeSBiZWVuIGhhbmRsZWQsXHJcblx0XHRcdC8vIGlmIG5vdCwgY3JlYXRlIG5ldyBvYmplY3RcclxuXHJcblx0XHRcdGlmICggcmVzdWx0Lm9iamVjdHNbIG9iaklEIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0dmFyIG9iakpTT04gPSBjaGlsZHJlblsgb2JqSUQgXTtcclxuXHJcblx0XHRcdFx0dmFyIG9iamVjdCA9IG51bGw7XHJcblxyXG5cdFx0XHRcdC8vIG1lc2hlc1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iakpTT04udHlwZSAmJiAoIG9iakpTT04udHlwZSBpbiBzY29wZS5oaWVyYXJjaHlIYW5kbGVyTWFwICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmpKU09OLmxvYWRpbmcgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciByZXNlcnZlZFR5cGVzID0geyBcInR5cGVcIjogMSwgXCJ1cmxcIjogMSwgXCJtYXRlcmlhbFwiOiAxLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBcInBvc2l0aW9uXCI6IDEsIFwicm90YXRpb25cIjogMSwgXCJzY2FsZVwiIDogMSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgXCJ2aXNpYmxlXCI6IDEsIFwiY2hpbGRyZW5cIjogMSwgXCJwcm9wZXJ0aWVzXCI6IDEsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIFwic2tpblwiOiAxLCBcIm1vcnBoXCI6IDEsIFwibWlycm9yZWRMb29wXCI6IDEsIFwiZHVyYXRpb25cIjogMSB9O1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGxvYWRlclBhcmFtZXRlcnMgPSB7fTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBwYXJUeXBlIGluIG9iakpTT04gKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggISAoIHBhclR5cGUgaW4gcmVzZXJ2ZWRUeXBlcyApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGxvYWRlclBhcmFtZXRlcnNbIHBhclR5cGUgXSA9IG9iakpTT05bIHBhclR5cGUgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSByZXN1bHQubWF0ZXJpYWxzWyBvYmpKU09OLm1hdGVyaWFsIF07XHJcblxyXG5cdFx0XHRcdFx0XHRvYmpKU09OLmxvYWRpbmcgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGxvYWRlciA9IHNjb3BlLmhpZXJhcmNoeUhhbmRsZXJNYXBbIG9iakpTT04udHlwZSBdWyBcImxvYWRlck9iamVjdFwiIF07XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBDb2xsYWRhTG9hZGVyXHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGxvYWRlci5vcHRpb25zICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRsb2FkZXIubG9hZCggZ2V0X3VybCggb2JqSlNPTi51cmwsIGRhdGEudXJsQmFzZVR5cGUgKSwgY3JlYXRlX2NhbGxiYWNrX2hpZXJhY2h5KCBvYmpJRCwgcGFyZW50LCBtYXRlcmlhbCwgb2JqSlNPTiApICk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBVVEY4TG9hZGVyXHJcblx0XHRcdFx0XHRcdC8vIE9CSkxvYWRlclxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bG9hZGVyLmxvYWQoIGdldF91cmwoIG9iakpTT04udXJsLCBkYXRhLnVybEJhc2VUeXBlICksIGNyZWF0ZV9jYWxsYmFja19oaWVyYWNoeSggb2JqSUQsIHBhcmVudCwgbWF0ZXJpYWwsIG9iakpTT04gKSwgbG9hZGVyUGFyYW1ldGVycyApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggb2JqSlNPTi5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5ID0gcmVzdWx0Lmdlb21ldHJpZXNbIG9iakpTT04uZ2VvbWV0cnkgXTtcclxuXHJcblx0XHRcdFx0XHQvLyBnZW9tZXRyeSBhbHJlYWR5IGxvYWRlZFxyXG5cclxuXHRcdFx0XHRcdGlmICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgbmVlZHNUYW5nZW50cyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSByZXN1bHQubWF0ZXJpYWxzWyBvYmpKU09OLm1hdGVyaWFsIF07XHJcblx0XHRcdFx0XHRcdG5lZWRzVGFuZ2VudHMgPSBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHRcdFx0cG9zID0gb2JqSlNPTi5wb3NpdGlvbjtcclxuXHRcdFx0XHRcdFx0cm90ID0gb2JqSlNPTi5yb3RhdGlvbjtcclxuXHRcdFx0XHRcdFx0c2NsID0gb2JqSlNPTi5zY2FsZTtcclxuXHRcdFx0XHRcdFx0bWF0ID0gb2JqSlNPTi5tYXRyaXg7XHJcblx0XHRcdFx0XHRcdHF1YXQgPSBvYmpKU09OLnF1YXRlcm5pb247XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB1c2UgbWF0ZXJpYWxzIGZyb20gdGhlIG1vZGVsIGZpbGVcclxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgbm8gbWF0ZXJpYWwgc3BlY2lmaWVkIGluIHRoZSBvYmplY3RcclxuXHJcblx0XHRcdFx0XHRcdGlmICggISBvYmpKU09OLm1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKCByZXN1bHQuZmFjZV9tYXRlcmlhbHNbIG9iakpTT04uZ2VvbWV0cnkgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gdXNlIG1hdGVyaWFscyBmcm9tIHRoZSBtb2RlbCBmaWxlXHJcblx0XHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGp1c3QgZW1wdHkgZmFjZSBtYXRlcmlhbFxyXG5cdFx0XHRcdFx0XHQvLyAobXVzdCBjcmVhdGUgbmV3IG1hdGVyaWFsIGFzIGVhY2ggbW9kZWwgaGFzIGl0cyBvd24gZmFjZSBtYXRlcmlhbClcclxuXHJcblx0XHRcdFx0XHRcdGlmICggKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSAmJiBtYXRlcmlhbC5tYXRlcmlhbHMubGVuZ3RoID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKCByZXN1bHQuZmFjZV9tYXRlcmlhbHNbIG9iakpTT04uZ2VvbWV0cnkgXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFsLm1hdGVyaWFscy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0bmVlZHNUYW5nZW50cyA9IG5lZWRzVGFuZ2VudHMgfHwgKCBtYXRlcmlhbC5tYXRlcmlhbHNbIGkgXSBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICggbmVlZHNUYW5nZW50cyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIG9iakpTT04uc2tpbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0ID0gbmV3IFRIUkVFLlNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIG9iakpTT04ubW9ycGggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5Nb3JwaEFuaW1NZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBvYmpKU09OLmR1cmF0aW9uICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2JqZWN0LmR1cmF0aW9uID0gb2JqSlNPTi5kdXJhdGlvbjtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIG9iakpTT04udGltZSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdC50aW1lID0gb2JqSlNPTi50aW1lO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggb2JqSlNPTi5taXJyb3JlZExvb3AgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3QubWlycm9yZWRMb29wID0gb2JqSlNPTi5taXJyb3JlZExvb3A7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuY29tcHV0ZU1vcnBoTm9ybWFscygpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvYmplY3QgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QubmFtZSA9IG9iaklEO1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBtYXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0Lm1hdHJpeC5zZXQoXHJcblx0XHRcdFx0XHRcdFx0XHRtYXRbMF0sICBtYXRbMV0sICBtYXRbMl0sICBtYXRbM10sXHJcblx0XHRcdFx0XHRcdFx0XHRtYXRbNF0sICBtYXRbNV0sICBtYXRbNl0sICBtYXRbN10sXHJcblx0XHRcdFx0XHRcdFx0XHRtYXRbOF0sICBtYXRbOV0sICBtYXRbMTBdLCBtYXRbMTFdLFxyXG5cdFx0XHRcdFx0XHRcdFx0bWF0WzEyXSwgbWF0WzEzXSwgbWF0WzE0XSwgbWF0WzE1XVxyXG5cdFx0XHRcdFx0XHRcdCk7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvYmplY3QucG9zaXRpb24uc2V0KCBwb3NbMF0sIHBvc1sxXSwgcG9zWzJdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGlmICggcXVhdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5zZXQoIHF1YXRbMF0sIHF1YXRbMV0sIHF1YXRbMl0sIHF1YXRbM10gKTtcclxuXHRcdFx0XHRcdFx0XHRcdG9iamVjdC51c2VRdWF0ZXJuaW9uID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvYmplY3Qucm90YXRpb24uc2V0KCByb3RbMF0sIHJvdFsxXSwgcm90WzJdICk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdFx0b2JqZWN0LnNjYWxlLnNldCggc2NsWzBdLCBzY2xbMV0sIHNjbFsyXSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0LnZpc2libGUgPSBvYmpKU09OLnZpc2libGU7XHJcblx0XHRcdFx0XHRcdG9iamVjdC5jYXN0U2hhZG93ID0gb2JqSlNPTi5jYXN0U2hhZG93O1xyXG5cdFx0XHRcdFx0XHRvYmplY3QucmVjZWl2ZVNoYWRvdyA9IG9iakpTT04ucmVjZWl2ZVNoYWRvdztcclxuXHJcblx0XHRcdFx0XHRcdHBhcmVudC5hZGQoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0cmVzdWx0Lm9iamVjdHNbIG9iaklEIF0gPSBvYmplY3Q7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyBsaWdodHNcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggb2JqSlNPTi50eXBlID09PSBcIkRpcmVjdGlvbmFsTGlnaHRcIiB8fCBvYmpKU09OLnR5cGUgPT09IFwiUG9pbnRMaWdodFwiIHx8IG9iakpTT04udHlwZSA9PT0gXCJBbWJpZW50TGlnaHRcIiApIHtcclxuXHJcblx0XHRcdFx0XHRoZXggPSAoIG9iakpTT04uY29sb3IgIT09IHVuZGVmaW5lZCApID8gb2JqSlNPTi5jb2xvciA6IDB4ZmZmZmZmO1xyXG5cdFx0XHRcdFx0aW50ZW5zaXR5ID0gKCBvYmpKU09OLmludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBvYmpKU09OLmludGVuc2l0eSA6IDE7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmpKU09OLnR5cGUgPT09IFwiRGlyZWN0aW9uYWxMaWdodFwiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cG9zID0gb2JqSlNPTi5kaXJlY3Rpb247XHJcblxyXG5cdFx0XHRcdFx0XHRsaWdodCA9IG5ldyBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0KCBoZXgsIGludGVuc2l0eSApO1xyXG5cdFx0XHRcdFx0XHRsaWdodC5wb3NpdGlvbi5zZXQoIHBvc1swXSwgcG9zWzFdLCBwb3NbMl0gKTtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggb2JqSlNPTi50YXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHRhcmdldF9hcnJheS5wdXNoKCB7IFwib2JqZWN0XCI6IGxpZ2h0LCBcInRhcmdldE5hbWVcIiA6IG9iakpTT04udGFyZ2V0IH0gKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8ga2lsbCBleGlzdGluZyBkZWZhdWx0IHRhcmdldFxyXG5cdFx0XHRcdFx0XHRcdC8vIG90aGVyd2lzZSBpdCBnZXRzIGFkZGVkIHRvIHNjZW5lIHdoZW4gcGFyZW50IGdldHMgYWRkZWRcclxuXHJcblx0XHRcdFx0XHRcdFx0bGlnaHQudGFyZ2V0ID0gbnVsbDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBvYmpKU09OLnR5cGUgPT09IFwiUG9pbnRMaWdodFwiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0cG9zID0gb2JqSlNPTi5wb3NpdGlvbjtcclxuXHRcdFx0XHRcdFx0ZHN0ID0gb2JqSlNPTi5kaXN0YW5jZTtcclxuXHJcblx0XHRcdFx0XHRcdGxpZ2h0ID0gbmV3IFRIUkVFLlBvaW50TGlnaHQoIGhleCwgaW50ZW5zaXR5LCBkc3QgKTtcclxuXHRcdFx0XHRcdFx0bGlnaHQucG9zaXRpb24uc2V0KCBwb3NbMF0sIHBvc1sxXSwgcG9zWzJdICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggb2JqSlNPTi50eXBlID09PSBcIkFtYmllbnRMaWdodFwiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bGlnaHQgPSBuZXcgVEhSRUUuQW1iaWVudExpZ2h0KCBoZXggKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cGFyZW50LmFkZCggbGlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHRsaWdodC5uYW1lID0gb2JqSUQ7XHJcblx0XHRcdFx0XHRyZXN1bHQubGlnaHRzWyBvYmpJRCBdID0gbGlnaHQ7XHJcblx0XHRcdFx0XHRyZXN1bHQub2JqZWN0c1sgb2JqSUQgXSA9IGxpZ2h0O1xyXG5cclxuXHRcdFx0XHQvLyBjYW1lcmFzXHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG9iakpTT04udHlwZSA9PT0gXCJQZXJzcGVjdGl2ZUNhbWVyYVwiIHx8IG9iakpTT04udHlwZSA9PT0gXCJPcnRob2dyYXBoaWNDYW1lcmFcIiApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9iakpTT04udHlwZSA9PT0gXCJQZXJzcGVjdGl2ZUNhbWVyYVwiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBvYmpKU09OLmZvdiwgb2JqSlNPTi5hc3BlY3QsIG9iakpTT04ubmVhciwgb2JqSlNPTi5mYXIgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBvYmpKU09OLnR5cGUgPT09IFwiT3J0aG9ncmFwaGljQ2FtZXJhXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCBvYmpKU09OLmxlZnQsIG9iakpTT04ucmlnaHQsIG9iakpTT04udG9wLCBvYmpKU09OLmJvdHRvbSwgb2JqSlNPTi5uZWFyLCBvYmpKU09OLmZhciApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRwb3MgPSBvYmpKU09OLnBvc2l0aW9uO1xyXG5cdFx0XHRcdFx0Y2FtZXJhLnBvc2l0aW9uLnNldCggcG9zWzBdLCBwb3NbMV0sIHBvc1syXSApO1xyXG5cdFx0XHRcdFx0cGFyZW50LmFkZCggY2FtZXJhICk7XHJcblxyXG5cdFx0XHRcdFx0Y2FtZXJhLm5hbWUgPSBvYmpJRDtcclxuXHRcdFx0XHRcdHJlc3VsdC5jYW1lcmFzWyBvYmpJRCBdID0gY2FtZXJhO1xyXG5cdFx0XHRcdFx0cmVzdWx0Lm9iamVjdHNbIG9iaklEIF0gPSBjYW1lcmE7XHJcblxyXG5cdFx0XHRcdC8vIHB1cmUgT2JqZWN0M0RcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRwb3MgPSBvYmpKU09OLnBvc2l0aW9uO1xyXG5cdFx0XHRcdFx0cm90ID0gb2JqSlNPTi5yb3RhdGlvbjtcclxuXHRcdFx0XHRcdHNjbCA9IG9iakpTT04uc2NhbGU7XHJcblx0XHRcdFx0XHRxdWF0ID0gb2JqSlNPTi5xdWF0ZXJuaW9uO1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xyXG5cdFx0XHRcdFx0b2JqZWN0Lm5hbWUgPSBvYmpJRDtcclxuXHRcdFx0XHRcdG9iamVjdC5wb3NpdGlvbi5zZXQoIHBvc1swXSwgcG9zWzFdLCBwb3NbMl0gKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHF1YXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3QucXVhdGVybmlvbi5zZXQoIHF1YXRbMF0sIHF1YXRbMV0sIHF1YXRbMl0sIHF1YXRbM10gKTtcclxuXHRcdFx0XHRcdFx0b2JqZWN0LnVzZVF1YXRlcm5pb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRvYmplY3Qucm90YXRpb24uc2V0KCByb3RbMF0sIHJvdFsxXSwgcm90WzJdICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5zY2FsZS5zZXQoIHNjbFswXSwgc2NsWzFdLCBzY2xbMl0gKTtcclxuXHRcdFx0XHRcdG9iamVjdC52aXNpYmxlID0gKCBvYmpKU09OLnZpc2libGUgIT09IHVuZGVmaW5lZCApID8gb2JqSlNPTi52aXNpYmxlIDogZmFsc2U7XHJcblxyXG5cdFx0XHRcdFx0cGFyZW50LmFkZCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0cmVzdWx0Lm9iamVjdHNbIG9iaklEIF0gPSBvYmplY3Q7XHJcblx0XHRcdFx0XHRyZXN1bHQuZW1wdGllc1sgb2JqSUQgXSA9IG9iamVjdDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdCApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9iakpTT04ucHJvcGVydGllcyAhPT0gdW5kZWZpbmVkICkgIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gb2JqSlNPTi5wcm9wZXJ0aWVzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBvYmpKU09OLnByb3BlcnRpZXNbIGtleSBdO1xyXG5cdFx0XHRcdFx0XHRcdG9iamVjdC5wcm9wZXJ0aWVzWyBrZXkgXSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIG9iakpTT04uZ3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmpKU09OLmdyb3Vwcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBncm91cElEID0gb2JqSlNPTi5ncm91cHNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCByZXN1bHQuZ3JvdXBzWyBncm91cElEIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHQuZ3JvdXBzWyBncm91cElEIF0gPSBbXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHRyZXN1bHQuZ3JvdXBzWyBncm91cElEIF0ucHVzaCggb2JqSUQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBvYmpKU09OLmNoaWxkcmVuICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRoYW5kbGVfY2hpbGRyZW4oIG9iamVjdCwgb2JqSlNPTi5jaGlsZHJlbiApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gaGFuZGxlX21lc2goIGdlbywgbWF0LCBpZCApIHtcclxuXHJcblx0XHRyZXN1bHQuZ2VvbWV0cmllc1sgaWQgXSA9IGdlbztcclxuXHRcdHJlc3VsdC5mYWNlX21hdGVyaWFsc1sgaWQgXSA9IG1hdDtcclxuXHRcdGhhbmRsZV9vYmplY3RzKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGhhbmRsZV9oaWVyYXJjaHkoIG5vZGUsIGlkLCBwYXJlbnQsIG1hdGVyaWFsLCBvYmogKSB7XHJcblxyXG5cdFx0dmFyIHAgPSBvYmoucG9zaXRpb247XHJcblx0XHR2YXIgciA9IG9iai5yb3RhdGlvbjtcclxuXHRcdHZhciBxID0gb2JqLnF1YXRlcm5pb247XHJcblx0XHR2YXIgcyA9IG9iai5zY2FsZTtcclxuXHJcblx0XHRub2RlLnBvc2l0aW9uLnNldCggcFswXSwgcFsxXSwgcFsyXSApO1xyXG5cclxuXHRcdGlmICggcSApIHtcclxuXHJcblx0XHRcdG5vZGUucXVhdGVybmlvbi5zZXQoIHFbMF0sIHFbMV0sIHFbMl0sIHFbM10gKTtcclxuXHRcdFx0bm9kZS51c2VRdWF0ZXJuaW9uID0gdHJ1ZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bm9kZS5yb3RhdGlvbi5zZXQoIHJbMF0sIHJbMV0sIHJbMl0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bm9kZS5zY2FsZS5zZXQoIHNbMF0sIHNbMV0sIHNbMl0gKTtcclxuXHJcblx0XHQvLyBvdmVycmlkZSBjaGlsZHJlbiBtYXRlcmlhbHNcclxuXHRcdC8vIGlmIG9iamVjdCBtYXRlcmlhbCB3YXMgc3BlY2lmaWVkIGluIEpTT04gZXhwbGljaXRseVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRub2RlLnRyYXZlcnNlKCBmdW5jdGlvbiAoIGNoaWxkICkgIHtcclxuXHJcblx0XHRcdFx0Y2hpbGQubWF0ZXJpYWwgPSBtYXRlcmlhbDtcclxuXHJcblx0XHRcdH0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gb3ZlcnJpZGUgY2hpbGRyZW4gdmlzaWJpbGl0eVxyXG5cdFx0Ly8gd2l0aCByb290IG5vZGUgdmlzaWJpbGl0eSBhcyBzcGVjaWZpZWQgaW4gSlNPTlxyXG5cclxuXHRcdHZhciB2aXNpYmxlID0gKCBvYmoudmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgPyBvYmoudmlzaWJsZSA6IHRydWU7XHJcblxyXG5cdFx0bm9kZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBjaGlsZCApICB7XHJcblxyXG5cdFx0XHRjaGlsZC52aXNpYmxlID0gdmlzaWJsZTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0cGFyZW50LmFkZCggbm9kZSApO1xyXG5cclxuXHRcdG5vZGUubmFtZSA9IGlkO1xyXG5cclxuXHRcdHJlc3VsdC5vYmplY3RzWyBpZCBdID0gbm9kZTtcclxuXHRcdGhhbmRsZV9vYmplY3RzKCk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZV9jYWxsYmFja19nZW9tZXRyeSggaWQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBnZW8sIG1hdCApIHtcclxuXHJcblx0XHRcdGhhbmRsZV9tZXNoKCBnZW8sIG1hdCwgaWQgKTtcclxuXHJcblx0XHRcdGNvdW50ZXJfbW9kZWxzIC09IDE7XHJcblxyXG5cdFx0XHRzY29wZS5vbkxvYWRDb21wbGV0ZSgpO1xyXG5cclxuXHRcdFx0YXN5bmNfY2FsbGJhY2tfZ2F0ZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlX2NhbGxiYWNrX2hpZXJhY2h5KCBpZCwgcGFyZW50LCBtYXRlcmlhbCwgb2JqICkge1xyXG5cclxuXHRcdHJldHVybiBmdW5jdGlvbiggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0O1xyXG5cclxuXHRcdFx0Ly8gbG9hZGVycyB3aGljaCB1c2UgRXZlbnREaXNwYXRjaGVyXHJcblxyXG5cdFx0XHRpZiAoIGV2ZW50LmNvbnRlbnQgKSB7XHJcblxyXG5cdFx0XHRcdHJlc3VsdCA9IGV2ZW50LmNvbnRlbnQ7XHJcblxyXG5cdFx0XHQvLyBDb2xsYWRhTG9hZGVyXHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBldmVudC5kYWUgKSB7XHJcblxyXG5cdFx0XHRcdHJlc3VsdCA9IGV2ZW50LnNjZW5lO1xyXG5cclxuXHJcblx0XHRcdC8vIFVURjhMb2FkZXJcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHJlc3VsdCA9IGV2ZW50O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aGFuZGxlX2hpZXJhcmNoeSggcmVzdWx0LCBpZCwgcGFyZW50LCBtYXRlcmlhbCwgb2JqICk7XHJcblxyXG5cdFx0XHRjb3VudGVyX21vZGVscyAtPSAxO1xyXG5cclxuXHRcdFx0c2NvcGUub25Mb2FkQ29tcGxldGUoKTtcclxuXHJcblx0XHRcdGFzeW5jX2NhbGxiYWNrX2dhdGUoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZV9jYWxsYmFja19lbWJlZCggaWQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBnZW8sIG1hdCApIHtcclxuXHJcblx0XHRcdHJlc3VsdC5nZW9tZXRyaWVzWyBpZCBdID0gZ2VvO1xyXG5cdFx0XHRyZXN1bHQuZmFjZV9tYXRlcmlhbHNbIGlkIF0gPSBtYXQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBhc3luY19jYWxsYmFja19nYXRlKCkge1xyXG5cclxuXHRcdHZhciBwcm9ncmVzcyA9IHtcclxuXHJcblx0XHRcdHRvdGFsTW9kZWxzIDogdG90YWxfbW9kZWxzLFxyXG5cdFx0XHR0b3RhbFRleHR1cmVzIDogdG90YWxfdGV4dHVyZXMsXHJcblx0XHRcdGxvYWRlZE1vZGVscyA6IHRvdGFsX21vZGVscyAtIGNvdW50ZXJfbW9kZWxzLFxyXG5cdFx0XHRsb2FkZWRUZXh0dXJlcyA6IHRvdGFsX3RleHR1cmVzIC0gY291bnRlcl90ZXh0dXJlc1xyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0c2NvcGUuY2FsbGJhY2tQcm9ncmVzcyggcHJvZ3Jlc3MsIHJlc3VsdCApO1xyXG5cclxuXHRcdHNjb3BlLm9uTG9hZFByb2dyZXNzKCk7XHJcblxyXG5cdFx0aWYgKCBjb3VudGVyX21vZGVscyA9PT0gMCAmJiBjb3VudGVyX3RleHR1cmVzID09PSAwICkge1xyXG5cclxuXHRcdFx0ZmluYWxpemUoKTtcclxuXHRcdFx0Y2FsbGJhY2tGaW5pc2hlZCggcmVzdWx0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBmaW5hbGl6ZSgpIHtcclxuXHJcblx0XHQvLyB0YWtlIGNhcmUgb2YgdGFyZ2V0cyB3aGljaCBjb3VsZCBiZSBhc3luY2hyb25vdXNseSBsb2FkZWQgb2JqZWN0c1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IHRhcmdldF9hcnJheS5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdGEgPSB0YXJnZXRfYXJyYXlbIGkgXTtcclxuXHJcblx0XHRcdHZhciB0YXJnZXQgPSByZXN1bHQub2JqZWN0c1sgdGEudGFyZ2V0TmFtZSBdO1xyXG5cclxuXHRcdFx0aWYgKCB0YXJnZXQgKSB7XHJcblxyXG5cdFx0XHRcdHRhLm9iamVjdC50YXJnZXQgPSB0YXJnZXQ7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0aGVyZSB3YXMgZXJyb3IgYW5kIHRhcmdldCBvZiBzcGVjaWZpZWQgbmFtZSBkb2Vzbid0IGV4aXN0IGluIHRoZSBzY2VuZSBmaWxlXHJcblx0XHRcdFx0Ly8gY3JlYXRlIGluc3RlYWQgZHVtbXkgdGFyZ2V0XHJcblx0XHRcdFx0Ly8gKHRhcmdldCBtdXN0IGJlIGFkZGVkIHRvIHNjZW5lIGV4cGxpY2l0bHkgYXMgcGFyZW50IGlzIGFscmVhZHkgYWRkZWQpXHJcblxyXG5cdFx0XHRcdHRhLm9iamVjdC50YXJnZXQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHRcdFx0XHRyZXN1bHQuc2NlbmUuYWRkKCB0YS5vYmplY3QudGFyZ2V0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0YS5vYmplY3QudGFyZ2V0LnByb3BlcnRpZXMudGFyZ2V0SW52ZXJzZSA9IHRhLm9iamVjdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBjYWxsYmFja1RleHR1cmUgPSBmdW5jdGlvbiAoIGNvdW50ICkge1xyXG5cclxuXHRcdGNvdW50ZXJfdGV4dHVyZXMgLT0gY291bnQ7XHJcblx0XHRhc3luY19jYWxsYmFja19nYXRlKCk7XHJcblxyXG5cdFx0c2NvcGUub25Mb2FkQ29tcGxldGUoKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gbXVzdCB1c2UgdGhpcyBpbnN0ZWFkIG9mIGp1c3QgZGlyZWN0bHkgY2FsbGluZyBjYWxsYmFja1RleHR1cmVcclxuXHQvLyBiZWNhdXNlIG9mIGNsb3N1cmUgaW4gdGhlIGNhbGxpbmcgY29udGV4dCBsb29wXHJcblxyXG5cdHZhciBnZW5lcmF0ZVRleHR1cmVDYWxsYmFjayA9IGZ1bmN0aW9uICggY291bnQgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0Y2FsbGJhY2tUZXh0dXJlKCBjb3VudCApO1xyXG5cclxuXHRcdH07XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIGZpcnN0IGdvIHN5bmNocm9ub3VzIGVsZW1lbnRzXHJcblxyXG5cdC8vIGZvZ3NcclxuXHJcblx0dmFyIGZvZ0lELCBmb2dKU09OO1xyXG5cclxuXHRmb3IgKCBmb2dJRCBpbiBkYXRhLmZvZ3MgKSB7XHJcblxyXG5cdFx0Zm9nSlNPTiA9IGRhdGEuZm9nc1sgZm9nSUQgXTtcclxuXHJcblx0XHRpZiAoIGZvZ0pTT04udHlwZSA9PT0gXCJsaW5lYXJcIiApIHtcclxuXHJcblx0XHRcdGZvZyA9IG5ldyBUSFJFRS5Gb2coIDB4MDAwMDAwLCBmb2dKU09OLm5lYXIsIGZvZ0pTT04uZmFyICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZm9nSlNPTi50eXBlID09PSBcImV4cDJcIiApIHtcclxuXHJcblx0XHRcdGZvZyA9IG5ldyBUSFJFRS5Gb2dFeHAyKCAweDAwMDAwMCwgZm9nSlNPTi5kZW5zaXR5ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbG9yID0gZm9nSlNPTi5jb2xvcjtcclxuXHRcdGZvZy5jb2xvci5zZXRSR0IoIGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0gKTtcclxuXHJcblx0XHRyZXN1bHQuZm9nc1sgZm9nSUQgXSA9IGZvZztcclxuXHJcblx0fVxyXG5cclxuXHQvLyBub3cgY29tZSBwb3RlbnRpYWxseSBhc3luY2hyb25vdXMgZWxlbWVudHNcclxuXHJcblx0Ly8gZ2VvbWV0cmllc1xyXG5cclxuXHQvLyBjb3VudCBob3cgbWFueSBnZW9tZXRyaWVzIHdpbGwgYmUgbG9hZGVkIGFzeW5jaHJvbm91c2x5XHJcblxyXG5cdHZhciBnZW9JRCwgZ2VvSlNPTjtcclxuXHJcblx0Zm9yICggZ2VvSUQgaW4gZGF0YS5nZW9tZXRyaWVzICkge1xyXG5cclxuXHRcdGdlb0pTT04gPSBkYXRhLmdlb21ldHJpZXNbIGdlb0lEIF07XHJcblxyXG5cdFx0aWYgKCBnZW9KU09OLnR5cGUgaW4gdGhpcy5nZW9tZXRyeUhhbmRsZXJNYXAgKSB7XHJcblxyXG5cdFx0XHRjb3VudGVyX21vZGVscyArPSAxO1xyXG5cclxuXHRcdFx0c2NvcGUub25Mb2FkU3RhcnQoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gY291bnQgaG93IG1hbnkgaGllcmFyY2hpZXMgd2lsbCBiZSBsb2FkZWQgYXN5bmNocm9ub3VzbHlcclxuXHJcblx0dmFyIG9iaklELCBvYmpKU09OO1xyXG5cclxuXHRmb3IgKCBvYmpJRCBpbiBkYXRhLm9iamVjdHMgKSB7XHJcblxyXG5cdFx0b2JqSlNPTiA9IGRhdGEub2JqZWN0c1sgb2JqSUQgXTtcclxuXHJcblx0XHRpZiAoIG9iakpTT04udHlwZSAmJiAoIG9iakpTT04udHlwZSBpbiB0aGlzLmhpZXJhcmNoeUhhbmRsZXJNYXAgKSApIHtcclxuXHJcblx0XHRcdGNvdW50ZXJfbW9kZWxzICs9IDE7XHJcblxyXG5cdFx0XHRzY29wZS5vbkxvYWRTdGFydCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0b3RhbF9tb2RlbHMgPSBjb3VudGVyX21vZGVscztcclxuXHJcblx0Zm9yICggZ2VvSUQgaW4gZGF0YS5nZW9tZXRyaWVzICkge1xyXG5cclxuXHRcdGdlb0pTT04gPSBkYXRhLmdlb21ldHJpZXNbIGdlb0lEIF07XHJcblxyXG5cdFx0aWYgKCBnZW9KU09OLnR5cGUgPT09IFwiY3ViZVwiICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KCBnZW9KU09OLndpZHRoLCBnZW9KU09OLmhlaWdodCwgZ2VvSlNPTi5kZXB0aCwgZ2VvSlNPTi53aWR0aFNlZ21lbnRzLCBnZW9KU09OLmhlaWdodFNlZ21lbnRzLCBnZW9KU09OLmRlcHRoU2VnbWVudHMgKTtcclxuXHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGdlb0lEIF0gPSBnZW9tZXRyeTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBnZW9KU09OLnR5cGUgPT09IFwicGxhbmVcIiApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlBsYW5lR2VvbWV0cnkoIGdlb0pTT04ud2lkdGgsIGdlb0pTT04uaGVpZ2h0LCBnZW9KU09OLndpZHRoU2VnbWVudHMsIGdlb0pTT04uaGVpZ2h0U2VnbWVudHMgKTtcclxuXHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGdlb0lEIF0gPSBnZW9tZXRyeTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBnZW9KU09OLnR5cGUgPT09IFwic3BoZXJlXCIgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggZ2VvSlNPTi5yYWRpdXMsIGdlb0pTT04ud2lkdGhTZWdtZW50cywgZ2VvSlNPTi5oZWlnaHRTZWdtZW50cyApO1xyXG5cdFx0XHRyZXN1bHQuZ2VvbWV0cmllc1sgZ2VvSUQgXSA9IGdlb21ldHJ5O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGdlb0pTT04udHlwZSA9PT0gXCJjeWxpbmRlclwiICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggZ2VvSlNPTi50b3BSYWQsIGdlb0pTT04uYm90UmFkLCBnZW9KU09OLmhlaWdodCwgZ2VvSlNPTi5yYWRTZWdzLCBnZW9KU09OLmhlaWdodFNlZ3MgKTtcclxuXHRcdFx0cmVzdWx0Lmdlb21ldHJpZXNbIGdlb0lEIF0gPSBnZW9tZXRyeTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBnZW9KU09OLnR5cGUgPT09IFwidG9ydXNcIiApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5ID0gbmV3IFRIUkVFLlRvcnVzR2VvbWV0cnkoIGdlb0pTT04ucmFkaXVzLCBnZW9KU09OLnR1YmUsIGdlb0pTT04uc2VnbWVudHNSLCBnZW9KU09OLnNlZ21lbnRzVCApO1xyXG5cdFx0XHRyZXN1bHQuZ2VvbWV0cmllc1sgZ2VvSUQgXSA9IGdlb21ldHJ5O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGdlb0pTT04udHlwZSA9PT0gXCJpY29zYWhlZHJvblwiICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggZ2VvSlNPTi5yYWRpdXMsIGdlb0pTT04uc3ViZGl2aXNpb25zICk7XHJcblx0XHRcdHJlc3VsdC5nZW9tZXRyaWVzWyBnZW9JRCBdID0gZ2VvbWV0cnk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZ2VvSlNPTi50eXBlIGluIHRoaXMuZ2VvbWV0cnlIYW5kbGVyTWFwICkge1xyXG5cclxuXHRcdFx0dmFyIGxvYWRlclBhcmFtZXRlcnMgPSB7fTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBwYXJUeXBlIGluIGdlb0pTT04gKSB7XHJcblxyXG5cdFx0XHRcdGlmICggcGFyVHlwZSAhPT0gXCJ0eXBlXCIgJiYgcGFyVHlwZSAhPT0gXCJ1cmxcIiApIHtcclxuXHJcblx0XHRcdFx0XHRsb2FkZXJQYXJhbWV0ZXJzWyBwYXJUeXBlIF0gPSBnZW9KU09OWyBwYXJUeXBlIF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBsb2FkZXIgPSB0aGlzLmdlb21ldHJ5SGFuZGxlck1hcFsgZ2VvSlNPTi50eXBlIF1bIFwibG9hZGVyT2JqZWN0XCIgXTtcclxuXHRcdFx0bG9hZGVyLmxvYWQoIGdldF91cmwoIGdlb0pTT04udXJsLCBkYXRhLnVybEJhc2VUeXBlICksIGNyZWF0ZV9jYWxsYmFja19nZW9tZXRyeSggZ2VvSUQgKSwgbG9hZGVyUGFyYW1ldGVycyApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGdlb0pTT04udHlwZSA9PT0gXCJlbWJlZGRlZFwiICkge1xyXG5cclxuXHRcdFx0dmFyIG1vZGVsSnNvbiA9IGRhdGEuZW1iZWRzWyBnZW9KU09OLmlkIF0sXHJcblx0XHRcdFx0dGV4dHVyZV9wYXRoID0gXCJcIjtcclxuXHJcblx0XHRcdC8vIHBhc3MgbWV0YWRhdGEgYWxvbmcgdG8ganNvbkxvYWRlciBzbyBpdCBrbm93cyB0aGUgZm9ybWF0IHZlcnNpb25cclxuXHJcblx0XHRcdG1vZGVsSnNvbi5tZXRhZGF0YSA9IGRhdGEubWV0YWRhdGE7XHJcblxyXG5cdFx0XHRpZiAoIG1vZGVsSnNvbiApIHtcclxuXHJcblx0XHRcdFx0dmFyIGpzb25Mb2FkZXIgPSB0aGlzLmdlb21ldHJ5SGFuZGxlck1hcFsgXCJhc2NpaVwiIF1bIFwibG9hZGVyT2JqZWN0XCIgXTtcclxuXHRcdFx0XHRqc29uTG9hZGVyLmNyZWF0ZU1vZGVsKCBtb2RlbEpzb24sIGNyZWF0ZV9jYWxsYmFja19lbWJlZCggZ2VvSUQgKSwgdGV4dHVyZV9wYXRoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIHRleHR1cmVzXHJcblxyXG5cdC8vIGNvdW50IGhvdyBtYW55IHRleHR1cmVzIHdpbGwgYmUgbG9hZGVkIGFzeW5jaHJvbm91c2x5XHJcblxyXG5cdHZhciB0ZXh0dXJlSUQsIHRleHR1cmVKU09OO1xyXG5cclxuXHRmb3IgKCB0ZXh0dXJlSUQgaW4gZGF0YS50ZXh0dXJlcyApIHtcclxuXHJcblx0XHR0ZXh0dXJlSlNPTiA9IGRhdGEudGV4dHVyZXNbIHRleHR1cmVJRCBdO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZUpTT04udXJsIGluc3RhbmNlb2YgQXJyYXkgKSB7XHJcblxyXG5cdFx0XHRjb3VudGVyX3RleHR1cmVzICs9IHRleHR1cmVKU09OLnVybC5sZW5ndGg7XHJcblxyXG5cdFx0XHRmb3IoIHZhciBuID0gMDsgbiA8IHRleHR1cmVKU09OLnVybC5sZW5ndGg7IG4gKysgKSB7XHJcblxyXG5cdFx0XHRcdHNjb3BlLm9uTG9hZFN0YXJ0KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGNvdW50ZXJfdGV4dHVyZXMgKz0gMTtcclxuXHJcblx0XHRcdHNjb3BlLm9uTG9hZFN0YXJ0KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRvdGFsX3RleHR1cmVzID0gY291bnRlcl90ZXh0dXJlcztcclxuXHJcblx0Zm9yICggdGV4dHVyZUlEIGluIGRhdGEudGV4dHVyZXMgKSB7XHJcblxyXG5cdFx0dGV4dHVyZUpTT04gPSBkYXRhLnRleHR1cmVzWyB0ZXh0dXJlSUQgXTtcclxuXHJcblx0XHRpZiAoIHRleHR1cmVKU09OLm1hcHBpbmcgIT09IHVuZGVmaW5lZCAmJiBUSFJFRVsgdGV4dHVyZUpTT04ubWFwcGluZyBdICE9PSB1bmRlZmluZWQgICkge1xyXG5cclxuXHRcdFx0dGV4dHVyZUpTT04ubWFwcGluZyA9IG5ldyBUSFJFRVsgdGV4dHVyZUpTT04ubWFwcGluZyBdKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGV4dHVyZUpTT04udXJsIGluc3RhbmNlb2YgQXJyYXkgKSB7XHJcblxyXG5cdFx0XHR2YXIgY291bnQgPSB0ZXh0dXJlSlNPTi51cmwubGVuZ3RoO1xyXG5cdFx0XHR2YXIgdXJsX2FycmF5ID0gW107XHJcblxyXG5cdFx0XHRmb3IoIHZhciBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR1cmxfYXJyYXlbIGkgXSA9IGdldF91cmwoIHRleHR1cmVKU09OLnVybFsgaSBdLCBkYXRhLnVybEJhc2VUeXBlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgaXNDb21wcmVzc2VkID0gL1xcLmRkcyQvaS50ZXN0KCB1cmxfYXJyYXlbIDAgXSApO1xyXG5cclxuXHRcdFx0aWYgKCBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUoIHVybF9hcnJheSwgdGV4dHVyZUpTT04ubWFwcGluZywgZ2VuZXJhdGVUZXh0dXJlQ2FsbGJhY2soIGNvdW50ICkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlQ3ViZSggdXJsX2FycmF5LCB0ZXh0dXJlSlNPTi5tYXBwaW5nLCBnZW5lcmF0ZVRleHR1cmVDYWxsYmFjayggY291bnQgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR2YXIgaXNDb21wcmVzc2VkID0gL1xcLmRkcyQvaS50ZXN0KCB0ZXh0dXJlSlNPTi51cmwgKTtcclxuXHRcdFx0dmFyIGZ1bGxVcmwgPSBnZXRfdXJsKCB0ZXh0dXJlSlNPTi51cmwsIGRhdGEudXJsQmFzZVR5cGUgKTtcclxuXHRcdFx0dmFyIHRleHR1cmVDYWxsYmFjayA9IGdlbmVyYXRlVGV4dHVyZUNhbGxiYWNrKCAxICk7XHJcblxyXG5cdFx0XHRpZiAoIGlzQ29tcHJlc3NlZCApIHtcclxuXHJcblx0XHRcdFx0dGV4dHVyZSA9IFRIUkVFLkltYWdlVXRpbHMubG9hZENvbXByZXNzZWRUZXh0dXJlKCBmdWxsVXJsLCB0ZXh0dXJlSlNPTi5tYXBwaW5nLCB0ZXh0dXJlQ2FsbGJhY2sgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKCBmdWxsVXJsLCB0ZXh0dXJlSlNPTi5tYXBwaW5nLCB0ZXh0dXJlQ2FsbGJhY2sgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggVEhSRUVbIHRleHR1cmVKU09OLm1pbkZpbHRlciBdICE9PSB1bmRlZmluZWQgKVxyXG5cdFx0XHRcdHRleHR1cmUubWluRmlsdGVyID0gVEhSRUVbIHRleHR1cmVKU09OLm1pbkZpbHRlciBdO1xyXG5cclxuXHRcdFx0aWYgKCBUSFJFRVsgdGV4dHVyZUpTT04ubWFnRmlsdGVyIF0gIT09IHVuZGVmaW5lZCApXHJcblx0XHRcdFx0dGV4dHVyZS5tYWdGaWx0ZXIgPSBUSFJFRVsgdGV4dHVyZUpTT04ubWFnRmlsdGVyIF07XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmVKU09OLmFuaXNvdHJvcHkgKSB0ZXh0dXJlLmFuaXNvdHJvcHkgPSB0ZXh0dXJlSlNPTi5hbmlzb3Ryb3B5O1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlSlNPTi5yZXBlYXQgKSB7XHJcblxyXG5cdFx0XHRcdHRleHR1cmUucmVwZWF0LnNldCggdGV4dHVyZUpTT04ucmVwZWF0WyAwIF0sIHRleHR1cmVKU09OLnJlcGVhdFsgMSBdICk7XHJcblxyXG5cdFx0XHRcdGlmICggdGV4dHVyZUpTT04ucmVwZWF0WyAwIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBTID0gVEhSRUUuUmVwZWF0V3JhcHBpbmc7XHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlSlNPTi5yZXBlYXRbIDEgXSAhPT0gMSApIHRleHR1cmUud3JhcFQgPSBUSFJFRS5SZXBlYXRXcmFwcGluZztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggdGV4dHVyZUpTT04ub2Zmc2V0ICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLm9mZnNldC5zZXQoIHRleHR1cmVKU09OLm9mZnNldFsgMCBdLCB0ZXh0dXJlSlNPTi5vZmZzZXRbIDEgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gaGFuZGxlIHdyYXAgYWZ0ZXIgcmVwZWF0IHNvIHRoYXQgZGVmYXVsdCByZXBlYXQgY2FuIGJlIG92ZXJyaWRlblxyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlSlNPTi53cmFwICkge1xyXG5cclxuXHRcdFx0XHR2YXIgd3JhcE1hcCA9IHtcclxuXHRcdFx0XHRcInJlcGVhdFwiIFx0OiBUSFJFRS5SZXBlYXRXcmFwcGluZyxcclxuXHRcdFx0XHRcIm1pcnJvclwiXHQ6IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggd3JhcE1hcFsgdGV4dHVyZUpTT04ud3JhcFsgMCBdIF0gIT09IHVuZGVmaW5lZCApIHRleHR1cmUud3JhcFMgPSB3cmFwTWFwWyB0ZXh0dXJlSlNPTi53cmFwWyAwIF0gXTtcclxuXHRcdFx0XHRpZiAoIHdyYXBNYXBbIHRleHR1cmVKU09OLndyYXBbIDEgXSBdICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLndyYXBUID0gd3JhcE1hcFsgdGV4dHVyZUpTT04ud3JhcFsgMSBdIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlc3VsdC50ZXh0dXJlc1sgdGV4dHVyZUlEIF0gPSB0ZXh0dXJlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIG1hdGVyaWFsc1xyXG5cclxuXHR2YXIgbWF0SUQsIG1hdEpTT047XHJcblx0dmFyIHBhcklEO1xyXG5cclxuXHRmb3IgKCBtYXRJRCBpbiBkYXRhLm1hdGVyaWFscyApIHtcclxuXHJcblx0XHRtYXRKU09OID0gZGF0YS5tYXRlcmlhbHNbIG1hdElEIF07XHJcblxyXG5cdFx0Zm9yICggcGFySUQgaW4gbWF0SlNPTi5wYXJhbWV0ZXJzICkge1xyXG5cclxuXHRcdFx0aWYgKCBwYXJJRCA9PT0gXCJlbnZNYXBcIiB8fCBwYXJJRCA9PT0gXCJtYXBcIiB8fCBwYXJJRCA9PT0gXCJsaWdodE1hcFwiIHx8IHBhcklEID09PSBcImJ1bXBNYXBcIiApIHtcclxuXHJcblx0XHRcdFx0bWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID0gcmVzdWx0LnRleHR1cmVzWyBtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gXTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHBhcklEID09PSBcInNoYWRpbmdcIiApIHtcclxuXHJcblx0XHRcdFx0bWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID0gKCBtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPT09IFwiZmxhdFwiICkgPyBUSFJFRS5GbGF0U2hhZGluZyA6IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXJJRCA9PT0gXCJzaWRlXCIgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID09IFwiZG91YmxlXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID0gVEhSRUUuRG91YmxlU2lkZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID09IFwiYmFja1wiICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IFRIUkVFLkJhY2tTaWRlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IFRIUkVFLkZyb250U2lkZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcGFySUQgPT09IFwiYmxlbmRpbmdcIiApIHtcclxuXHJcblx0XHRcdFx0bWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID0gbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdIGluIFRIUkVFID8gVEhSRUVbIG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSBdIDogVEhSRUUuTm9ybWFsQmxlbmRpbmc7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBwYXJJRCA9PT0gXCJjb21iaW5lXCIgKSB7XHJcblxyXG5cdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSBpbiBUSFJFRSA/IFRIUkVFWyBtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gXSA6IFRIUkVFLk11bHRpcGx5T3BlcmF0aW9uO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggcGFySUQgPT09IFwidmVydGV4Q29sb3JzXCIgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdID09IFwiZmFjZVwiICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IFRIUkVFLkZhY2VDb2xvcnM7XHJcblxyXG5cdFx0XHRcdC8vIGRlZmF1bHQgdG8gdmVydGV4IGNvbG9ycyBpZiBcInZlcnRleENvbG9yc1wiIGlzIGFueXRoaW5nIGVsc2UgZmFjZSBjb2xvcnMgb3IgMCAvIG51bGwgLyBmYWxzZVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gKSAgIHtcclxuXHJcblx0XHRcdFx0XHRtYXRKU09OLnBhcmFtZXRlcnNbIHBhcklEIF0gPSBUSFJFRS5WZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHBhcklEID09PSBcIndyYXBSR0JcIiApIHtcclxuXHJcblx0XHRcdFx0dmFyIHYzID0gbWF0SlNPTi5wYXJhbWV0ZXJzWyBwYXJJRCBdO1xyXG5cdFx0XHRcdG1hdEpTT04ucGFyYW1ldGVyc1sgcGFySUQgXSA9IG5ldyBUSFJFRS5WZWN0b3IzKCB2M1sgMCBdLCB2M1sgMSBdLCB2M1sgMiBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzLm9wYWNpdHkgIT09IHVuZGVmaW5lZCAmJiBtYXRKU09OLnBhcmFtZXRlcnMub3BhY2l0eSA8IDEuMCApIHtcclxuXHJcblx0XHRcdG1hdEpTT04ucGFyYW1ldGVycy50cmFuc3BhcmVudCA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzLm5vcm1hbE1hcCApIHtcclxuXHJcblx0XHRcdHZhciBzaGFkZXIgPSBUSFJFRS5TaGFkZXJMaWJbIFwibm9ybWFsbWFwXCIgXTtcclxuXHRcdFx0dmFyIHVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG5cdFx0XHR2YXIgZGlmZnVzZSA9IG1hdEpTT04ucGFyYW1ldGVycy5jb2xvcjtcclxuXHRcdFx0dmFyIHNwZWN1bGFyID0gbWF0SlNPTi5wYXJhbWV0ZXJzLnNwZWN1bGFyO1xyXG5cdFx0XHR2YXIgYW1iaWVudCA9IG1hdEpTT04ucGFyYW1ldGVycy5hbWJpZW50O1xyXG5cdFx0XHR2YXIgc2hpbmluZXNzID0gbWF0SlNPTi5wYXJhbWV0ZXJzLnNoaW5pbmVzcztcclxuXHJcblx0XHRcdHVuaWZvcm1zWyBcInROb3JtYWxcIiBdLnZhbHVlID0gcmVzdWx0LnRleHR1cmVzWyBtYXRKU09OLnBhcmFtZXRlcnMubm9ybWFsTWFwIF07XHJcblxyXG5cdFx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5ub3JtYWxTY2FsZSApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidU5vcm1hbFNjYWxlXCIgXS52YWx1ZS5zZXQoIG1hdEpTT04ucGFyYW1ldGVycy5ub3JtYWxTY2FsZVsgMCBdLCBtYXRKU09OLnBhcmFtZXRlcnMubm9ybWFsU2NhbGVbIDEgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMubWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0RGlmZnVzZVwiIF0udmFsdWUgPSBtYXRKU09OLnBhcmFtZXRlcnMubWFwO1xyXG5cdFx0XHRcdHVuaWZvcm1zWyBcImVuYWJsZURpZmZ1c2VcIiBdLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzLmVudk1hcCApIHtcclxuXHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidEN1YmVcIiBdLnZhbHVlID0gbWF0SlNPTi5wYXJhbWV0ZXJzLmVudk1hcDtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVSZWZsZWN0aW9uXCIgXS52YWx1ZSA9IHRydWU7XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwidVJlZmxlY3Rpdml0eVwiIF0udmFsdWUgPSBtYXRKU09OLnBhcmFtZXRlcnMucmVmbGVjdGl2aXR5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMubGlnaHRNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHVuaWZvcm1zWyBcInRBT1wiIF0udmFsdWUgPSBtYXRKU09OLnBhcmFtZXRlcnMubGlnaHRNYXA7XHJcblx0XHRcdFx0dW5pZm9ybXNbIFwiZW5hYmxlQU9cIiBdLnZhbHVlID0gdHJ1ZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzLnNwZWN1bGFyTWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0U3BlY3VsYXJcIiBdLnZhbHVlID0gcmVzdWx0LnRleHR1cmVzWyBtYXRKU09OLnBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgXTtcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJlbmFibGVTcGVjdWxhclwiIF0udmFsdWUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRKU09OLnBhcmFtZXRlcnMuZGlzcGxhY2VtZW50TWFwICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ0RGlzcGxhY2VtZW50XCIgXS52YWx1ZSA9IHJlc3VsdC50ZXh0dXJlc1sgbWF0SlNPTi5wYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcCBdO1xyXG5cdFx0XHRcdHVuaWZvcm1zWyBcImVuYWJsZURpc3BsYWNlbWVudFwiIF0udmFsdWUgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ1RGlzcGxhY2VtZW50Qmlhc1wiIF0udmFsdWUgPSBtYXRKU09OLnBhcmFtZXRlcnMuZGlzcGxhY2VtZW50QmlhcztcclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ1RGlzcGxhY2VtZW50U2NhbGVcIiBdLnZhbHVlID0gbWF0SlNPTi5wYXJhbWV0ZXJzLmRpc3BsYWNlbWVudFNjYWxlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dW5pZm9ybXNbIFwidURpZmZ1c2VDb2xvclwiIF0udmFsdWUuc2V0SGV4KCBkaWZmdXNlICk7XHJcblx0XHRcdHVuaWZvcm1zWyBcInVTcGVjdWxhckNvbG9yXCIgXS52YWx1ZS5zZXRIZXgoIHNwZWN1bGFyICk7XHJcblx0XHRcdHVuaWZvcm1zWyBcInVBbWJpZW50Q29sb3JcIiBdLnZhbHVlLnNldEhleCggYW1iaWVudCApO1xyXG5cclxuXHRcdFx0dW5pZm9ybXNbIFwidVNoaW5pbmVzc1wiIF0udmFsdWUgPSBzaGluaW5lc3M7XHJcblxyXG5cdFx0XHRpZiAoIG1hdEpTT04ucGFyYW1ldGVycy5vcGFjaXR5ICkge1xyXG5cclxuXHRcdFx0XHR1bmlmb3Jtc1sgXCJ1T3BhY2l0eVwiIF0udmFsdWUgPSBtYXRKU09OLnBhcmFtZXRlcnMub3BhY2l0eTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBwYXJhbWV0ZXJzID0geyBmcmFnbWVudFNoYWRlcjogc2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsIHVuaWZvcm1zOiB1bmlmb3JtcywgbGlnaHRzOiB0cnVlLCBmb2c6IHRydWUgfTtcclxuXHJcblx0XHRcdG1hdGVyaWFsID0gbmV3IFRIUkVFLlNoYWRlck1hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsID0gbmV3IFRIUkVFWyBtYXRKU09OLnR5cGUgXSggbWF0SlNPTi5wYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJlc3VsdC5tYXRlcmlhbHNbIG1hdElEIF0gPSBtYXRlcmlhbDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBzZWNvbmQgcGFzcyB0aHJvdWdoIGFsbCBtYXRlcmlhbHMgdG8gaW5pdGlhbGl6ZSBNZXNoRmFjZU1hdGVyaWFsc1xyXG5cdC8vIHRoYXQgY291bGQgYmUgcmVmZXJyaW5nIHRvIG90aGVyIG1hdGVyaWFscyBvdXQgb2Ygb3JkZXJcclxuXHJcblx0Zm9yICggbWF0SUQgaW4gZGF0YS5tYXRlcmlhbHMgKSB7XHJcblxyXG5cdFx0bWF0SlNPTiA9IGRhdGEubWF0ZXJpYWxzWyBtYXRJRCBdO1xyXG5cclxuXHRcdGlmICggbWF0SlNPTi5wYXJhbWV0ZXJzLm1hdGVyaWFscyApIHtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbEFycmF5ID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtYXRKU09OLnBhcmFtZXRlcnMubWF0ZXJpYWxzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGxhYmVsID0gbWF0SlNPTi5wYXJhbWV0ZXJzLm1hdGVyaWFsc1sgaSBdO1xyXG5cdFx0XHRcdG1hdGVyaWFsQXJyYXkucHVzaCggcmVzdWx0Lm1hdGVyaWFsc1sgbGFiZWwgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmVzdWx0Lm1hdGVyaWFsc1sgbWF0SUQgXS5tYXRlcmlhbHMgPSBtYXRlcmlhbEFycmF5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBvYmplY3RzICggc3luY2hyb25vdXMgaW5pdCBvZiBwcm9jZWR1cmFsIHByaW1pdGl2ZXMgKVxyXG5cclxuXHRoYW5kbGVfb2JqZWN0cygpO1xyXG5cclxuXHQvLyBkZWZhdWx0c1xyXG5cclxuXHRpZiAoIHJlc3VsdC5jYW1lcmFzICYmIGRhdGEuZGVmYXVsdHMuY2FtZXJhICkge1xyXG5cclxuXHRcdHJlc3VsdC5jdXJyZW50Q2FtZXJhID0gcmVzdWx0LmNhbWVyYXNbIGRhdGEuZGVmYXVsdHMuY2FtZXJhIF07XHJcblxyXG5cdH1cclxuXHJcblx0aWYgKCByZXN1bHQuZm9ncyAmJiBkYXRhLmRlZmF1bHRzLmZvZyApIHtcclxuXHJcblx0XHRyZXN1bHQuc2NlbmUuZm9nID0gcmVzdWx0LmZvZ3NbIGRhdGEuZGVmYXVsdHMuZm9nIF07XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gc3luY2hyb25vdXMgY2FsbGJhY2tcclxuXHJcblx0c2NvcGUuY2FsbGJhY2tTeW5jKCByZXN1bHQgKTtcclxuXHJcblx0Ly8ganVzdCBpbiBjYXNlIHRoZXJlIGFyZSBubyBhc3luYyBlbGVtZW50c1xyXG5cclxuXHRhc3luY19jYWxsYmFja19nYXRlKCk7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5UZXh0dXJlTG9hZGVyID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5FdmVudERpc3BhdGNoZXIuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmNyb3NzT3JpZ2luID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5UZXh0dXJlTG9hZGVyLnByb3RvdHlwZSA9IHtcclxuXHJcblx0Y29uc3RydWN0b3I6IFRIUkVFLlRleHR1cmVMb2FkZXIsXHJcblxyXG5cdGxvYWQ6IGZ1bmN0aW9uICggdXJsICkge1xyXG5cclxuXHRcdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcblxyXG5cdFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBpbWFnZSApO1xyXG5cdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2xvYWQnLCBjb250ZW50OiB0ZXh0dXJlIH0gKTtcclxuXHJcblx0XHR9LCBmYWxzZSApO1xyXG5cclxuXHRcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdHNjb3BlLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Vycm9yJywgbWVzc2FnZTogJ0NvdWxkblxcJ3QgbG9hZCBVUkwgWycgKyB1cmwgKyAnXScgfSApO1xyXG5cclxuXHRcdH0sIGZhbHNlICk7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5jcm9zc09yaWdpbiApIGltYWdlLmNyb3NzT3JpZ2luID0gc2NvcGUuY3Jvc3NPcmlnaW47XHJcblxyXG5cdFx0aW1hZ2Uuc3JjID0gdXJsO1xyXG5cclxuXHR9XHJcblxyXG59XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLk1hdGVyaWFsID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5FdmVudERpc3BhdGNoZXIuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmlkID0gVEhSRUUuTWF0ZXJpYWxJZENvdW50ICsrO1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHJcblx0dGhpcy5zaWRlID0gVEhSRUUuRnJvbnRTaWRlO1xyXG5cclxuXHR0aGlzLm9wYWNpdHkgPSAxO1xyXG5cdHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5ibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xyXG5cclxuXHR0aGlzLmJsZW5kU3JjID0gVEhSRUUuU3JjQWxwaGFGYWN0b3I7XHJcblx0dGhpcy5ibGVuZERzdCA9IFRIUkVFLk9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XHJcblx0dGhpcy5ibGVuZEVxdWF0aW9uID0gVEhSRUUuQWRkRXF1YXRpb247XHJcblxyXG5cdHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcclxuXHR0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcclxuXHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xyXG5cdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcclxuXHJcblx0dGhpcy5hbHBoYVRlc3QgPSAwO1xyXG5cclxuXHR0aGlzLm92ZXJkcmF3ID0gZmFsc2U7IC8vIEJvb2xlYW4gZm9yIGZpeGluZyBhbnRpYWxpYXNpbmcgZ2FwcyBpbiBDYW52YXNSZW5kZXJlclxyXG5cclxuXHR0aGlzLnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuc2V0VmFsdWVzID0gZnVuY3Rpb24gKCB2YWx1ZXMgKSB7XHJcblxyXG5cdGlmICggdmFsdWVzID09PSB1bmRlZmluZWQgKSByZXR1cm47XHJcblxyXG5cdGZvciAoIHZhciBrZXkgaW4gdmFsdWVzICkge1xyXG5cclxuXHRcdHZhciBuZXdWYWx1ZSA9IHZhbHVlc1sga2V5IF07XHJcblxyXG5cdFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWw6IFxcJycgKyBrZXkgKyAnXFwnIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuJyApO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBrZXkgaW4gdGhpcyApIHtcclxuXHJcblx0XHRcdHZhciBjdXJyZW50VmFsdWUgPSB0aGlzWyBrZXkgXTtcclxuXHJcblx0XHRcdGlmICggY3VycmVudFZhbHVlIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgJiYgbmV3VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudFZhbHVlLmNvcHkoIG5ld1ZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBjdXJyZW50VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5Db2xvciApIHtcclxuXHJcblx0XHRcdFx0Y3VycmVudFZhbHVlLnNldCggbmV3VmFsdWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGN1cnJlbnRWYWx1ZSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgJiYgbmV3VmFsdWUgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzICkge1xyXG5cclxuXHRcdFx0XHRjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHRoaXNbIGtleSBdID0gbmV3VmFsdWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBtYXRlcmlhbCApIHtcclxuXHJcblx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWF0ZXJpYWwoKTtcclxuXHJcblx0bWF0ZXJpYWwubmFtZSA9IHRoaXMubmFtZTtcclxuXHJcblx0bWF0ZXJpYWwuc2lkZSA9IHRoaXMuc2lkZTtcclxuXHJcblx0bWF0ZXJpYWwub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuXHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XHJcblxyXG5cdG1hdGVyaWFsLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcclxuXHJcblx0bWF0ZXJpYWwuYmxlbmRTcmMgPSB0aGlzLmJsZW5kU3JjO1xyXG5cdG1hdGVyaWFsLmJsZW5kRHN0ID0gdGhpcy5ibGVuZERzdDtcclxuXHRtYXRlcmlhbC5ibGVuZEVxdWF0aW9uID0gdGhpcy5ibGVuZEVxdWF0aW9uO1xyXG5cclxuXHRtYXRlcmlhbC5kZXB0aFRlc3QgPSB0aGlzLmRlcHRoVGVzdDtcclxuXHRtYXRlcmlhbC5kZXB0aFdyaXRlID0gdGhpcy5kZXB0aFdyaXRlO1xyXG5cclxuXHRtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gdGhpcy5wb2x5Z29uT2Zmc2V0O1xyXG5cdG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSB0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3I7XHJcblx0bWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzID0gdGhpcy5wb2x5Z29uT2Zmc2V0VW5pdHM7XHJcblxyXG5cdG1hdGVyaWFsLmFscGhhVGVzdCA9IHRoaXMuYWxwaGFUZXN0O1xyXG5cclxuXHRtYXRlcmlhbC5vdmVyZHJhdyA9IHRoaXMub3ZlcmRyYXc7XHJcblxyXG5cdG1hdGVyaWFsLnZpc2libGUgPSB0aGlzLnZpc2libGU7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWF0ZXJpYWxJZENvdW50ID0gMDtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqICBsaW5lY2FwOiBcInJvdW5kXCIsXHJcbiAqICBsaW5lam9pbjogXCJyb3VuZFwiLFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiA8Ym9vbD5cclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5MaW5lQmFzaWNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cclxuXHR0aGlzLmxpbmV3aWR0aCA9IDE7XHJcblx0dGhpcy5saW5lY2FwID0gJ3JvdW5kJztcclxuXHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0bWF0ZXJpYWwubGluZXdpZHRoID0gdGhpcy5saW5ld2lkdGg7XHJcblx0bWF0ZXJpYWwubGluZWNhcCA9IHRoaXMubGluZWNhcDtcclxuXHRtYXRlcmlhbC5saW5lam9pbiA9IHRoaXMubGluZWpvaW47XHJcblxyXG5cdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xyXG5cclxuXHRtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzY2FsZTogPGZsb2F0PixcclxuICogIGRhc2hTaXplOiA8ZmxvYXQ+LFxyXG4gKiAgZ2FwU2l6ZTogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogPGJvb2w+XHJcbiAqXHJcbiAqICBmb2c6IDxib29sPlxyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblxyXG5cdHRoaXMubGluZXdpZHRoID0gMTtcclxuXHJcblx0dGhpcy5zY2FsZSA9IDE7XHJcblx0dGhpcy5kYXNoU2l6ZSA9IDM7XHJcblx0dGhpcy5nYXBTaXplID0gMTtcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkxpbmVEYXNoZWRNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0bWF0ZXJpYWwubGluZXdpZHRoID0gdGhpcy5saW5ld2lkdGg7XHJcblxyXG5cdG1hdGVyaWFsLnNjYWxlID0gdGhpcy5zY2FsZTtcclxuXHRtYXRlcmlhbC5kYXNoU2l6ZSA9IHRoaXMuZGFzaFNpemU7XHJcblx0bWF0ZXJpYWwuZ2FwU2l6ZSA9IHRoaXMuZ2FwU2l6ZTtcclxuXHJcblx0bWF0ZXJpYWwudmVydGV4Q29sb3JzID0gdGhpcy52ZXJ0ZXhDb2xvcnM7XHJcblxyXG5cdG1hdGVyaWFsLmZvZyA9IHRoaXMuZm9nO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBsaWdodE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxyXG4gKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXHJcbiAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXHJcbiAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIHZlcnRleENvbG9yczogVEhSRUUuTm9Db2xvcnMgLyBUSFJFRS5WZXJ0ZXhDb2xvcnMgLyBUSFJFRS5GYWNlQ29sb3JzLFxyXG4gKlxyXG4gKiAgc2tpbm5pbmc6IDxib29sPixcclxuICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxyXG4gKlxyXG4gKiAgZm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXHJcblxyXG5cdHRoaXMubWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5saWdodE1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmVudk1hcCA9IG51bGw7XHJcblx0dGhpcy5jb21iaW5lID0gVEhSRUUuTXVsdGlwbHlPcGVyYXRpb247XHJcblx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xyXG5cdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xyXG5cclxuXHR0aGlzLnZlcnRleENvbG9ycyA9IFRIUkVFLk5vQ29sb3JzO1xyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xyXG5cclxuXHRtYXRlcmlhbC5saWdodE1hcCA9IHRoaXMubGlnaHRNYXA7XHJcblxyXG5cdG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcDtcclxuXHJcblx0bWF0ZXJpYWwuZW52TWFwID0gdGhpcy5lbnZNYXA7XHJcblx0bWF0ZXJpYWwuY29tYmluZSA9IHRoaXMuY29tYmluZTtcclxuXHRtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcclxuXHRtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSB0aGlzLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XHJcblxyXG5cdG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XHJcblxyXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHJcblx0bWF0ZXJpYWwuc2tpbm5pbmcgPSB0aGlzLnNraW5uaW5nO1xyXG5cdG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIGFtYmllbnQ6IDxoZXg+LFxyXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXHJcbiAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcclxuICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcclxuICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcclxuICpcclxuICogIHNoYWRpbmc6IFRIUkVFLlNtb290aFNoYWRpbmcsXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXHJcbiAqXHJcbiAqICBza2lubmluZzogPGJvb2w+LFxyXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcclxuICpcclxuICpcdGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcclxuXHR0aGlzLmFtYmllbnQgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcclxuXHJcblx0dGhpcy53cmFwQXJvdW5kID0gZmFsc2U7XHJcblx0dGhpcy53cmFwUkdCID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuZW52TWFwID0gbnVsbDtcclxuXHR0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcclxuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XHJcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xyXG5cclxuXHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XHJcblxyXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xyXG5cdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdG1hdGVyaWFsLmFtYmllbnQuY29weSggdGhpcy5hbWJpZW50ICk7XHJcblx0bWF0ZXJpYWwuZW1pc3NpdmUuY29weSggdGhpcy5lbWlzc2l2ZSApO1xyXG5cclxuXHRtYXRlcmlhbC53cmFwQXJvdW5kID0gdGhpcy53cmFwQXJvdW5kO1xyXG5cdG1hdGVyaWFsLndyYXBSR0IuY29weSggdGhpcy53cmFwUkdCICk7XHJcblxyXG5cdG1hdGVyaWFsLm1hcCA9IHRoaXMubWFwO1xyXG5cclxuXHRtYXRlcmlhbC5saWdodE1hcCA9IHRoaXMubGlnaHRNYXA7XHJcblxyXG5cdG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcDtcclxuXHJcblx0bWF0ZXJpYWwuZW52TWFwID0gdGhpcy5lbnZNYXA7XHJcblx0bWF0ZXJpYWwuY29tYmluZSA9IHRoaXMuY29tYmluZTtcclxuXHRtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcclxuXHRtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSB0aGlzLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XHJcblxyXG5cdG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XHJcblxyXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHJcblx0bWF0ZXJpYWwuc2tpbm5pbmcgPSB0aGlzLnNraW5uaW5nO1xyXG5cdG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xyXG5cdG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIGFtYmllbnQ6IDxoZXg+LFxyXG4gKiAgZW1pc3NpdmU6IDxoZXg+LFxyXG4gKiAgc3BlY3VsYXI6IDxoZXg+LFxyXG4gKiAgc2hpbmluZXNzOiA8ZmxvYXQ+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICpcclxuICogIG1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIGJ1bXBTY2FsZTogPGZsb2F0PixcclxuICpcclxuICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXHJcbiAqXHJcbiAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcclxuICpcclxuICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcclxuICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxyXG4gKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxyXG4gKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZyxcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZyxcclxuICogIGRlcHRoVGVzdDogPGJvb2w+LFxyXG4gKiAgZGVwdGhXcml0ZTogPGJvb2w+LFxyXG4gKlxyXG4gKiAgd2lyZWZyYW1lOiA8Ym9vbGVhbj4sXHJcbiAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IFRIUkVFLk5vQ29sb3JzIC8gVEhSRUUuVmVydGV4Q29sb3JzIC8gVEhSRUUuRmFjZUNvbG9ycyxcclxuICpcclxuICogIHNraW5uaW5nOiA8Ym9vbD4sXHJcbiAqICBtb3JwaFRhcmdldHM6IDxib29sPixcclxuICogIG1vcnBoTm9ybWFsczogPGJvb2w+LFxyXG4gKlxyXG4gKlx0Zm9nOiA8Ym9vbD5cclxuICogfVxyXG4gKi9cclxuXHJcblRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcclxuXHR0aGlzLmFtYmllbnQgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKTtcclxuXHR0aGlzLnNwZWN1bGFyID0gbmV3IFRIUkVFLkNvbG9yKCAweDExMTExMSApO1xyXG5cdHRoaXMuc2hpbmluZXNzID0gMzA7XHJcblxyXG5cdHRoaXMubWV0YWwgPSBmYWxzZTtcclxuXHR0aGlzLnBlclBpeGVsID0gdHJ1ZTtcclxuXHJcblx0dGhpcy53cmFwQXJvdW5kID0gZmFsc2U7XHJcblx0dGhpcy53cmFwUkdCID0gbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDEsIDEgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcclxuXHJcblx0dGhpcy5idW1wTWFwID0gbnVsbDtcclxuXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XHJcblxyXG5cdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcclxuXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0dGhpcy5zcGVjdWxhck1hcCA9IG51bGw7XHJcblxyXG5cdHRoaXMuZW52TWFwID0gbnVsbDtcclxuXHR0aGlzLmNvbWJpbmUgPSBUSFJFRS5NdWx0aXBseU9wZXJhdGlvbjtcclxuXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XHJcblx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xyXG5cclxuXHR0aGlzLmZvZyA9IHRydWU7XHJcblxyXG5cdHRoaXMuc2hhZGluZyA9IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdHRoaXMudmVydGV4Q29sb3JzID0gVEhSRUUuTm9Db2xvcnM7XHJcblxyXG5cdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcclxuXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xyXG5cdHRoaXMubW9ycGhOb3JtYWxzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5NZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdG1hdGVyaWFsLmFtYmllbnQuY29weSggdGhpcy5hbWJpZW50ICk7XHJcblx0bWF0ZXJpYWwuZW1pc3NpdmUuY29weSggdGhpcy5lbWlzc2l2ZSApO1xyXG5cdG1hdGVyaWFsLnNwZWN1bGFyLmNvcHkoIHRoaXMuc3BlY3VsYXIgKTtcclxuXHRtYXRlcmlhbC5zaGluaW5lc3MgPSB0aGlzLnNoaW5pbmVzcztcclxuXHJcblx0bWF0ZXJpYWwubWV0YWwgPSB0aGlzLm1ldGFsO1xyXG5cdG1hdGVyaWFsLnBlclBpeGVsID0gdGhpcy5wZXJQaXhlbDtcclxuXHJcblx0bWF0ZXJpYWwud3JhcEFyb3VuZCA9IHRoaXMud3JhcEFyb3VuZDtcclxuXHRtYXRlcmlhbC53cmFwUkdCLmNvcHkoIHRoaXMud3JhcFJHQiApO1xyXG5cclxuXHRtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcclxuXHJcblx0bWF0ZXJpYWwubGlnaHRNYXAgPSB0aGlzLmxpZ2h0TWFwO1xyXG5cclxuXHRtYXRlcmlhbC5idW1wTWFwID0gdGhpcy5idW1wTWFwO1xyXG5cdG1hdGVyaWFsLmJ1bXBTY2FsZSA9IHRoaXMuYnVtcFNjYWxlO1xyXG5cclxuXHRtYXRlcmlhbC5ub3JtYWxNYXAgPSB0aGlzLm5vcm1hbE1hcDtcclxuXHRtYXRlcmlhbC5ub3JtYWxTY2FsZS5jb3B5KCB0aGlzLm5vcm1hbFNjYWxlICk7XHJcblxyXG5cdG1hdGVyaWFsLnNwZWN1bGFyTWFwID0gdGhpcy5zcGVjdWxhck1hcDtcclxuXHJcblx0bWF0ZXJpYWwuZW52TWFwID0gdGhpcy5lbnZNYXA7XHJcblx0bWF0ZXJpYWwuY29tYmluZSA9IHRoaXMuY29tYmluZTtcclxuXHRtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTtcclxuXHRtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW8gPSB0aGlzLnJlZnJhY3Rpb25SYXRpbztcclxuXHJcblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XHJcblxyXG5cdG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XHJcblxyXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAgPSB0aGlzLndpcmVmcmFtZUxpbmVjYXA7XHJcblx0bWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xyXG5cclxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHJcblx0bWF0ZXJpYWwuc2tpbm5pbmcgPSB0aGlzLnNraW5uaW5nO1xyXG5cdG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyA9IHRoaXMubW9ycGhUYXJnZXRzO1xyXG5cdG1hdGVyaWFsLm1vcnBoTm9ybWFscyA9IHRoaXMubW9ycGhOb3JtYWxzO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIG1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgc2hhZGluZzogVEhSRUUuRmxhdFNoYWRpbmcsXHJcbiAqICBibGVuZGluZzogVEhSRUUuTm9ybWFsQmxlbmRpbmcsXHJcbiAqICBkZXB0aFRlc3Q6IDxib29sPixcclxuICogIGRlcHRoV3JpdGU6IDxib29sPixcclxuICpcclxuICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxyXG4gKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMsIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0dGhpcy5zaGFkaW5nID0gVEhSRUUuRmxhdFNoYWRpbmc7XHJcblxyXG5cdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XHJcblx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLnNoYWRpbmcgPSB0aGlzLnNoYWRpbmc7XHJcblxyXG5cdG1hdGVyaWFsLndpcmVmcmFtZSA9IHRoaXMud2lyZWZyYW1lO1xyXG5cdG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xyXG5cclxuXHRyZXR1cm4gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NZXNoRmFjZU1hdGVyaWFsID0gZnVuY3Rpb24gKCBtYXRlcmlhbHMgKSB7XHJcblxyXG5cdHRoaXMubWF0ZXJpYWxzID0gbWF0ZXJpYWxzIGluc3RhbmNlb2YgQXJyYXkgPyBtYXRlcmlhbHMgOiBbXTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoRmFjZU1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKCB0aGlzLm1hdGVyaWFscy5zbGljZSggMCApICk7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIGNvbG9yOiA8aGV4PixcclxuICogIG9wYWNpdHk6IDxmbG9hdD4sXHJcbiAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXHJcbiAqXHJcbiAqICBzaXplOiA8ZmxvYXQ+LFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB2ZXJ0ZXhDb2xvcnM6IDxib29sPixcclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKTtcclxuXHJcblx0dGhpcy5tYXAgPSBudWxsO1xyXG5cclxuXHR0aGlzLnNpemUgPSAxO1xyXG5cdHRoaXMuc2l6ZUF0dGVudWF0aW9uID0gdHJ1ZTtcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBmYWxzZTtcclxuXHJcblx0dGhpcy5mb2cgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5QYXJ0aWNsZUJhc2ljTWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0bWF0ZXJpYWwubWFwID0gdGhpcy5tYXA7XHJcblxyXG5cdG1hdGVyaWFsLnNpemUgPSB0aGlzLnNpemU7XHJcblx0bWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uID0gdGhpcy5zaXplQXR0ZW51YXRpb247XHJcblxyXG5cdG1hdGVyaWFsLnZlcnRleENvbG9ycyA9IHRoaXMudmVydGV4Q29sb3JzO1xyXG5cclxuXHRtYXRlcmlhbC5mb2cgPSB0aGlzLmZvZztcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBwcm9ncmFtOiA8ZnVuY3Rpb24+LFxyXG4gKiAgb3BhY2l0eTogPGZsb2F0PixcclxuICogIGJsZW5kaW5nOiBUSFJFRS5Ob3JtYWxCbGVuZGluZ1xyXG4gKiB9XHJcbiAqL1xyXG5cclxuVEhSRUUuUGFydGljbGVDYW52YXNNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cdHRoaXMucHJvZ3JhbSA9IGZ1bmN0aW9uICggY29udGV4dCwgY29sb3IgKSB7fTtcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXJ0aWNsZUNhbnZhc01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuUGFydGljbGVDYW52YXNNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5QYXJ0aWNsZUNhbnZhc01hdGVyaWFsKCk7XHJcblxyXG5cdFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBtYXRlcmlhbCApO1xyXG5cclxuXHRtYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblx0bWF0ZXJpYWwucHJvZ3JhbSA9IHRoaXMucHJvZ3JhbTtcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBmcmFnbWVudFNoYWRlcjogPHN0cmluZz4sXHJcbiAqICB2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxyXG4gKlxyXG4gKiAgdW5pZm9ybXM6IHsgXCJwYXJhbWV0ZXIxXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSwgXCJwYXJhbWV0ZXIyXCI6IHsgdHlwZTogXCJpXCIgdmFsdWUyOiAyIH0gfSxcclxuICpcclxuICogIGRlZmluZXM6IHsgXCJsYWJlbFwiIDogXCJ2YWx1ZVwiIH0sXHJcbiAqXHJcbiAqICBzaGFkaW5nOiBUSFJFRS5TbW9vdGhTaGFkaW5nLFxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcclxuICogIHdpcmVmcmFtZUxpbmV3aWR0aDogPGZsb2F0PixcclxuICpcclxuICogIGxpZ2h0czogPGJvb2w+LFxyXG4gKlxyXG4gKiAgdmVydGV4Q29sb3JzOiBUSFJFRS5Ob0NvbG9ycyAvIFRIUkVFLlZlcnRleENvbG9ycyAvIFRIUkVFLkZhY2VDb2xvcnMsXHJcbiAqXHJcbiAqICBza2lubmluZzogPGJvb2w+LFxyXG4gKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXHJcbiAqICBtb3JwaE5vcm1hbHM6IDxib29sPixcclxuICpcclxuICpcdGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5TaGFkZXJNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmZyYWdtZW50U2hhZGVyID0gXCJ2b2lkIG1haW4oKSB7fVwiO1xyXG5cdHRoaXMudmVydGV4U2hhZGVyID0gXCJ2b2lkIG1haW4oKSB7fVwiO1xyXG5cdHRoaXMudW5pZm9ybXMgPSB7fTtcclxuXHR0aGlzLmRlZmluZXMgPSB7fTtcclxuXHR0aGlzLmF0dHJpYnV0ZXMgPSBudWxsO1xyXG5cclxuXHR0aGlzLnNoYWRpbmcgPSBUSFJFRS5TbW9vdGhTaGFkaW5nO1xyXG5cclxuXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xyXG5cdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcclxuXHJcblx0dGhpcy5mb2cgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBmb2dcclxuXHJcblx0dGhpcy5saWdodHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBzY2VuZSBsaWdodHNcclxuXHJcblx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBUSFJFRS5Ob0NvbG9yczsgLy8gc2V0IHRvIHVzZSBcImNvbG9yXCIgYXR0cmlidXRlIHN0cmVhbVxyXG5cclxuXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcclxuXHJcblx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCB0YXJnZXRzXHJcblx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTsgLy8gc2V0IHRvIHVzZSBtb3JwaCBub3JtYWxzXHJcblxyXG5cdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5TaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCgpO1xyXG5cclxuXHRUSFJFRS5NYXRlcmlhbC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0bWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgPSB0aGlzLmZyYWdtZW50U2hhZGVyO1xyXG5cdG1hdGVyaWFsLnZlcnRleFNoYWRlciA9IHRoaXMudmVydGV4U2hhZGVyO1xyXG5cclxuXHRtYXRlcmlhbC51bmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIHRoaXMudW5pZm9ybXMgKTtcclxuXHJcblx0bWF0ZXJpYWwuYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcclxuXHRtYXRlcmlhbC5kZWZpbmVzID0gdGhpcy5kZWZpbmVzO1xyXG5cclxuXHRtYXRlcmlhbC5zaGFkaW5nID0gdGhpcy5zaGFkaW5nO1xyXG5cclxuXHRtYXRlcmlhbC53aXJlZnJhbWUgPSB0aGlzLndpcmVmcmFtZTtcclxuXHRtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aDtcclxuXHJcblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XHJcblxyXG5cdG1hdGVyaWFsLmxpZ2h0cyA9IHRoaXMubGlnaHRzO1xyXG5cclxuXHRtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcclxuXHJcblx0bWF0ZXJpYWwuc2tpbm5pbmcgPSB0aGlzLnNraW5uaW5nO1xyXG5cclxuXHRtYXRlcmlhbC5tb3JwaFRhcmdldHMgPSB0aGlzLm1vcnBoVGFyZ2V0cztcclxuXHRtYXRlcmlhbC5tb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFscztcclxuXHJcblx0cmV0dXJuIG1hdGVyaWFsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqICBjb2xvcjogPGhleD4sXHJcbiAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxyXG4gKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxyXG4gKlxyXG4gKiAgYmxlbmRpbmc6IFRIUkVFLk5vcm1hbEJsZW5kaW5nLFxyXG4gKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXHJcbiAqICBkZXB0aFdyaXRlOiA8Ym9vbD4sXHJcbiAqXHJcbiAqICB1c2VTY3JlZW5Db29yZGluYXRlczogPGJvb2w+LFxyXG4gKiAgc2l6ZUF0dGVudWF0aW9uOiA8Ym9vbD4sXHJcbiAqICBzY2FsZUJ5Vmlld3BvcnQ6IDxib29sPixcclxuICogIGFsaWdubWVudDogVEhSRUUuU3ByaXRlQWxpZ25tZW50LmNlbnRlcixcclxuICpcclxuICpcdHV2T2Zmc2V0OiBuZXcgVEhSRUUuVmVjdG9yMigpLFxyXG4gKlx0dXZTY2FsZTogbmV3IFRIUkVFLlZlY3RvcjIoKSxcclxuICpcclxuICogIGZvZzogPGJvb2w+XHJcbiAqIH1cclxuICovXHJcblxyXG5USFJFRS5TcHJpdGVNYXRlcmlhbCA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xyXG5cclxuXHQvLyBkZWZhdWx0c1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApO1xyXG5cdHRoaXMubWFwID0gbmV3IFRIUkVFLlRleHR1cmUoKTtcclxuXHJcblx0dGhpcy51c2VTY3JlZW5Db29yZGluYXRlcyA9IHRydWU7XHJcblx0dGhpcy5kZXB0aFRlc3QgPSAhdGhpcy51c2VTY3JlZW5Db29yZGluYXRlcztcclxuXHR0aGlzLnNpemVBdHRlbnVhdGlvbiA9ICF0aGlzLnVzZVNjcmVlbkNvb3JkaW5hdGVzO1xyXG5cdHRoaXMuc2NhbGVCeVZpZXdwb3J0ID0gIXRoaXMuc2l6ZUF0dGVudWF0aW9uO1xyXG5cdHRoaXMuYWxpZ25tZW50ID0gVEhSRUUuU3ByaXRlQWxpZ25tZW50LmNlbnRlci5jbG9uZSgpO1xyXG5cclxuXHR0aGlzLmZvZyA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnV2T2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcclxuXHR0aGlzLnV2U2NhbGUgID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0Ly8gc2V0IHBhcmFtZXRlcnNcclxuXHJcblx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcclxuXHJcblx0Ly8gb3ZlcnJpZGUgY291cGxlZCBkZWZhdWx0cyBpZiBub3Qgc3BlY2lmaWVkIGV4cGxpY2l0bHkgYnkgcGFyYW1ldGVyc1xyXG5cclxuXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcclxuXHJcblx0aWYgKCBwYXJhbWV0ZXJzLmRlcHRoVGVzdCA9PT0gdW5kZWZpbmVkICkgdGhpcy5kZXB0aFRlc3QgPSAhdGhpcy51c2VTY3JlZW5Db29yZGluYXRlcztcclxuXHRpZiAoIHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID09PSB1bmRlZmluZWQgKSB0aGlzLnNpemVBdHRlbnVhdGlvbiA9ICF0aGlzLnVzZVNjcmVlbkNvb3JkaW5hdGVzO1xyXG5cdGlmICggcGFyYW1ldGVycy5zY2FsZUJ5Vmlld3BvcnQgPT09IHVuZGVmaW5lZCApIHRoaXMuc2NhbGVCeVZpZXdwb3J0ID0gIXRoaXMuc2l6ZUF0dGVudWF0aW9uO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk1hdGVyaWFsLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuU3ByaXRlTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuU3ByaXRlTWF0ZXJpYWwoKTtcclxuXHJcblx0VEhSRUUuTWF0ZXJpYWwucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdG1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHRtYXRlcmlhbC5tYXAgPSB0aGlzLm1hcDtcclxuXHJcblx0bWF0ZXJpYWwudXNlU2NyZWVuQ29vcmRpbmF0ZXMgPSB0aGlzLnVzZVNjcmVlbkNvb3JkaW5hdGVzO1xyXG5cdG1hdGVyaWFsLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xyXG5cdG1hdGVyaWFsLnNjYWxlQnlWaWV3cG9ydCA9IHRoaXMuc2NhbGVCeVZpZXdwb3J0O1xyXG5cdG1hdGVyaWFsLmFsaWdubWVudC5jb3B5KCB0aGlzLmFsaWdubWVudCApO1xyXG5cclxuXHRtYXRlcmlhbC51dk9mZnNldC5jb3B5KCB0aGlzLnV2T2Zmc2V0ICk7XHJcblx0bWF0ZXJpYWwudXZTY2FsZS5jb3B5KCB0aGlzLnV2U2NhbGUgKTtcclxuXHJcblx0bWF0ZXJpYWwuZm9nID0gdGhpcy5mb2c7XHJcblxyXG5cdHJldHVybiBtYXRlcmlhbDtcclxuXHJcbn07XHJcblxyXG4vLyBBbGlnbm1lbnQgZW51bXNcclxuXHJcblRIUkVFLlNwcml0ZUFsaWdubWVudCA9IHt9O1xyXG5USFJFRS5TcHJpdGVBbGlnbm1lbnQudG9wTGVmdCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAtMSApO1xyXG5USFJFRS5TcHJpdGVBbGlnbm1lbnQudG9wQ2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIC0xICk7XHJcblRIUkVFLlNwcml0ZUFsaWdubWVudC50b3BSaWdodCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAtMSwgLTEgKTtcclxuVEhSRUUuU3ByaXRlQWxpZ25tZW50LmNlbnRlckxlZnQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMCApO1xyXG5USFJFRS5TcHJpdGVBbGlnbm1lbnQuY2VudGVyID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKTtcclxuVEhSRUUuU3ByaXRlQWxpZ25tZW50LmNlbnRlclJpZ2h0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIC0xLCAwICk7XHJcblRIUkVFLlNwcml0ZUFsaWdubWVudC5ib3R0b21MZWZ0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcclxuVEhSRUUuU3ByaXRlQWxpZ25tZW50LmJvdHRvbUNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAxICk7XHJcblRIUkVFLlNwcml0ZUFsaWdubWVudC5ib3R0b21SaWdodCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAtMSwgMSApO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xyXG4gKi9cclxuXHJcblRIUkVFLlRleHR1cmUgPSBmdW5jdGlvbiAoIGltYWdlLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XHJcblxyXG5cdFRIUkVFLkV2ZW50RGlzcGF0Y2hlci5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuaWQgPSBUSFJFRS5UZXh0dXJlSWRDb3VudCArKztcclxuXHJcblx0dGhpcy5uYW1lID0gJyc7XHJcblxyXG5cdHRoaXMuaW1hZ2UgPSBpbWFnZTtcclxuXHR0aGlzLm1pcG1hcHMgPSBbXTtcclxuXHJcblx0dGhpcy5tYXBwaW5nID0gbWFwcGluZyAhPT0gdW5kZWZpbmVkID8gbWFwcGluZyA6IG5ldyBUSFJFRS5VVk1hcHBpbmcoKTtcclxuXHJcblx0dGhpcy53cmFwUyA9IHdyYXBTICE9PSB1bmRlZmluZWQgPyB3cmFwUyA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblx0dGhpcy53cmFwVCA9IHdyYXBUICE9PSB1bmRlZmluZWQgPyB3cmFwVCA6IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmc7XHJcblxyXG5cdHRoaXMubWFnRmlsdGVyID0gbWFnRmlsdGVyICE9PSB1bmRlZmluZWQgPyBtYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IFRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcclxuXHJcblx0dGhpcy5hbmlzb3Ryb3B5ID0gYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gYW5pc290cm9weSA6IDE7XHJcblxyXG5cdHRoaXMuZm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBUSFJFRS5SR0JBRm9ybWF0O1xyXG5cdHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBUSFJFRS5VbnNpZ25lZEJ5dGVUeXBlO1xyXG5cclxuXHR0aGlzLm9mZnNldCA9IG5ldyBUSFJFRS5WZWN0b3IyKCAwLCAwICk7XHJcblx0dGhpcy5yZXBlYXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApO1xyXG5cclxuXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IHRydWU7XHJcblx0dGhpcy5wcmVtdWx0aXBseUFscGhhID0gZmFsc2U7XHJcblx0dGhpcy5mbGlwWSA9IHRydWU7XHJcblx0dGhpcy51bnBhY2tBbGlnbm1lbnQgPSA0OyAvLyB2YWxpZCB2YWx1ZXM6IDEsIDIsIDQsIDggKHNlZSBodHRwOi8vd3d3Lmtocm9ub3Mub3JnL29wZW5nbGVzL3Nkay9kb2NzL21hbi94aHRtbC9nbFBpeGVsU3RvcmVpLnhtbClcclxuXHJcblx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cdHRoaXMub25VcGRhdGUgPSBudWxsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRleHR1cmUucHJvdG90eXBlID0ge1xyXG5cclxuXHRjb25zdHJ1Y3RvcjogVEhSRUUuVGV4dHVyZSxcclxuXHJcblx0Y2xvbmU6IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUgPT09IHVuZGVmaW5lZCApIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSgpO1xyXG5cclxuXHRcdHRleHR1cmUuaW1hZ2UgPSB0aGlzLmltYWdlO1xyXG5cdFx0dGV4dHVyZS5taXBtYXBzID0gdGhpcy5taXBtYXBzLnNsaWNlKDApO1xyXG5cclxuXHRcdHRleHR1cmUubWFwcGluZyA9IHRoaXMubWFwcGluZztcclxuXHJcblx0XHR0ZXh0dXJlLndyYXBTID0gdGhpcy53cmFwUztcclxuXHRcdHRleHR1cmUud3JhcFQgPSB0aGlzLndyYXBUO1xyXG5cclxuXHRcdHRleHR1cmUubWFnRmlsdGVyID0gdGhpcy5tYWdGaWx0ZXI7XHJcblx0XHR0ZXh0dXJlLm1pbkZpbHRlciA9IHRoaXMubWluRmlsdGVyO1xyXG5cclxuXHRcdHRleHR1cmUuYW5pc290cm9weSA9IHRoaXMuYW5pc290cm9weTtcclxuXHJcblx0XHR0ZXh0dXJlLmZvcm1hdCA9IHRoaXMuZm9ybWF0O1xyXG5cdFx0dGV4dHVyZS50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuXHRcdHRleHR1cmUub2Zmc2V0LmNvcHkoIHRoaXMub2Zmc2V0ICk7XHJcblx0XHR0ZXh0dXJlLnJlcGVhdC5jb3B5KCB0aGlzLnJlcGVhdCApO1xyXG5cclxuXHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gdGhpcy5nZW5lcmF0ZU1pcG1hcHM7XHJcblx0XHR0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgPSB0aGlzLnByZW11bHRpcGx5QWxwaGE7XHJcblx0XHR0ZXh0dXJlLmZsaXBZID0gdGhpcy5mbGlwWTtcclxuXHRcdHRleHR1cmUudW5wYWNrQWxpZ25tZW50ID0gdGhpcy51bnBhY2tBbGlnbm1lbnQ7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH0sXHJcblxyXG5cdGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHR0aGlzLmRpc3BhdGNoRXZlbnQoIHsgdHlwZTogJ2Rpc3Bvc2UnIH0gKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlRleHR1cmVJZENvdW50ID0gMDtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUgPSBmdW5jdGlvbiAoIG1pcG1hcHMsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0dGhpcy5pbWFnZSA9IHsgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cdHRoaXMubWlwbWFwcyA9IG1pcG1hcHM7XHJcblxyXG5cdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7IC8vIFdlYkdMIGN1cnJlbnRseSBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzLCB0aGV5IG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5UZXh0dXJlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQ29tcHJlc3NlZFRleHR1cmUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZSgpO1xyXG5cclxuXHRUSFJFRS5UZXh0dXJlLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCB0ZXh0dXJlICk7XHJcblxyXG5cdHJldHVybiB0ZXh0dXJlO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRGF0YVRleHR1cmUgPSBmdW5jdGlvbiAoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgYW5pc290cm9weSApIHtcclxuXHJcblx0VEhSRUUuVGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcclxuXHJcblx0dGhpcy5pbWFnZSA9IHsgZGF0YTogZGF0YSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkRhdGFUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlRleHR1cmUucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5EYXRhVGV4dHVyZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkRhdGFUZXh0dXJlKCk7XHJcblxyXG5cdFRIUkVFLlRleHR1cmUucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIHRleHR1cmUgKTtcclxuXHJcblx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5QYXJ0aWNsZSA9IGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5tYXRlcmlhbCA9IG1hdGVyaWFsO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhcnRpY2xlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuUGFydGljbGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuUGFydGljbGUoIHRoaXMubWF0ZXJpYWwgKTtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xyXG5cclxuXHRyZXR1cm4gb2JqZWN0O1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUGFydGljbGVTeXN0ZW0gPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcblx0dGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xyXG5cclxuXHR0aGlzLnNvcnRQYXJ0aWNsZXMgPSBmYWxzZTtcclxuXHJcblx0aWYgKCB0aGlzLmdlb21ldHJ5ICkge1xyXG5cclxuXHRcdC8vIGNhbGMgYm91bmQgcmFkaXVzXHJcblxyXG5cdFx0aWYoIHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXJ0aWNsZVN5c3RlbS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlBhcnRpY2xlU3lzdGVtLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLlBhcnRpY2xlU3lzdGVtKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XHJcblx0b2JqZWN0LnNvcnRQYXJ0aWNsZXMgPSB0aGlzLnNvcnRQYXJ0aWNsZXM7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcclxuXHJcblx0cmV0dXJuIG9iamVjdDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxpbmUgPSBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbCwgdHlwZSApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5ID0gZ2VvbWV0cnk7XHJcblx0dGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XHJcblx0dGhpcy50eXBlID0gKCB0eXBlICE9PSB1bmRlZmluZWQgKSA/IHR5cGUgOiBUSFJFRS5MaW5lU3RyaXA7XHJcblxyXG5cdGlmICggdGhpcy5nZW9tZXRyeSApIHtcclxuXHJcblx0XHRpZiAoICEgdGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApIHtcclxuXHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZVN0cmlwID0gMDtcclxuVEhSRUUuTGluZVBpZWNlcyA9IDE7XHJcblxyXG5USFJFRS5MaW5lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTGluZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5MaW5lKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsLCB0aGlzLnR5cGUgKTtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xyXG5cclxuXHRyZXR1cm4gb2JqZWN0O1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5NZXNoID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xyXG5cdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYsIHdpcmVmcmFtZTogdHJ1ZSB9ICk7XHJcblxyXG5cdGlmICggdGhpcy5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5nZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdHRoaXMuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTWVzaC5wcm90b3R5cGUudXBkYXRlTW9ycGhUYXJnZXRzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRpZiAoIHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0dGhpcy5tb3JwaFRhcmdldEJhc2UgPSAtMTtcclxuXHRcdHRoaXMubW9ycGhUYXJnZXRGb3JjZWRPcmRlciA9IFtdO1xyXG5cdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgPSBbXTtcclxuXHRcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XHJcblxyXG5cdFx0Zm9yICggdmFyIG0gPSAwLCBtbCA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMucHVzaCggMCApO1xyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHNbIG0gXS5uYW1lIF0gPSBtO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1lc2gucHJvdG90eXBlLmdldE1vcnBoVGFyZ2V0SW5kZXhCeU5hbWUgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdGlmICggdGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnlbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdO1xyXG5cclxuXHR9XHJcblxyXG5cdGNvbnNvbGUubG9nKCBcIlRIUkVFLk1lc2guZ2V0TW9ycGhUYXJnZXRJbmRleEJ5TmFtZTogbW9ycGggdGFyZ2V0IFwiICsgbmFtZSArIFwiIGRvZXMgbm90IGV4aXN0LiBSZXR1cm5pbmcgMC5cIiApO1xyXG5cclxuXHRyZXR1cm4gMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLk1lc2goIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKTtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QucHJvdG90eXBlLmNsb25lLmNhbGwoIHRoaXMsIG9iamVjdCApO1xyXG5cclxuXHRyZXR1cm4gb2JqZWN0O1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQm9uZSA9IGZ1bmN0aW9uKCBiZWxvbmdzVG9Ta2luICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuc2tpbiA9IGJlbG9uZ3NUb1NraW47XHJcblx0dGhpcy5za2luTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Cb25lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQm9uZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBwYXJlbnRTa2luTWF0cml4LCBmb3JjZVVwZGF0ZSApIHtcclxuXHJcblx0Ly8gdXBkYXRlIGxvY2FsXHJcblxyXG5cdGlmICggdGhpcy5tYXRyaXhBdXRvVXBkYXRlICkge1xyXG5cclxuXHRcdGZvcmNlVXBkYXRlIHw9IHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gdXBkYXRlIHNraW4gbWF0cml4XHJcblxyXG5cdGlmICggZm9yY2VVcGRhdGUgfHwgdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlICkge1xyXG5cclxuXHRcdGlmKCBwYXJlbnRTa2luTWF0cml4ICkge1xyXG5cclxuXHRcdFx0dGhpcy5za2luTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHBhcmVudFNraW5NYXRyaXgsIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHRoaXMuc2tpbk1hdHJpeC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcclxuXHRcdGZvcmNlVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0dmFyIGNoaWxkLCBpLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHR0aGlzLmNoaWxkcmVuWyBpIF0udXBkYXRlKCB0aGlzLnNraW5NYXRyaXgsIGZvcmNlVXBkYXRlICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaCA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsLCB1c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRUSFJFRS5NZXNoLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xyXG5cclxuXHQvL1xyXG5cclxuXHR0aGlzLnVzZVZlcnRleFRleHR1cmUgPSB1c2VWZXJ0ZXhUZXh0dXJlICE9PSB1bmRlZmluZWQgPyB1c2VWZXJ0ZXhUZXh0dXJlIDogdHJ1ZTtcclxuXHJcblx0Ly8gaW5pdCBib25lc1xyXG5cclxuXHR0aGlzLmlkZW50aXR5TWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0dGhpcy5ib25lcyA9IFtdO1xyXG5cdHRoaXMuYm9uZU1hdHJpY2VzID0gW107XHJcblxyXG5cdHZhciBiLCBib25lLCBnYm9uZSwgcCwgcSwgcztcclxuXHJcblx0aWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuYm9uZXMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRmb3IgKCBiID0gMDsgYiA8IHRoaXMuZ2VvbWV0cnkuYm9uZXMubGVuZ3RoOyBiICsrICkge1xyXG5cclxuXHRcdFx0Z2JvbmUgPSB0aGlzLmdlb21ldHJ5LmJvbmVzWyBiIF07XHJcblxyXG5cdFx0XHRwID0gZ2JvbmUucG9zO1xyXG5cdFx0XHRxID0gZ2JvbmUucm90cTtcclxuXHRcdFx0cyA9IGdib25lLnNjbDtcclxuXHJcblx0XHRcdGJvbmUgPSB0aGlzLmFkZEJvbmUoKTtcclxuXHJcblx0XHRcdGJvbmUubmFtZSA9IGdib25lLm5hbWU7XHJcblx0XHRcdGJvbmUucG9zaXRpb24uc2V0KCBwWzBdLCBwWzFdLCBwWzJdICk7XHJcblx0XHRcdGJvbmUucXVhdGVybmlvbi5zZXQoIHFbMF0sIHFbMV0sIHFbMl0sIHFbM10gKTtcclxuXHRcdFx0Ym9uZS51c2VRdWF0ZXJuaW9uID0gdHJ1ZTtcclxuXHJcblx0XHRcdGlmICggcyAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRib25lLnNjYWxlLnNldCggc1swXSwgc1sxXSwgc1syXSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Ym9uZS5zY2FsZS5zZXQoIDEsIDEsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggYiA9IDA7IGIgPCB0aGlzLmJvbmVzLmxlbmd0aDsgYiArKyApIHtcclxuXHJcblx0XHRcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgYiBdO1xyXG5cdFx0XHRib25lID0gdGhpcy5ib25lc1sgYiBdO1xyXG5cclxuXHRcdFx0aWYgKCBnYm9uZS5wYXJlbnQgPT09IC0xICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmFkZCggYm9uZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dGhpcy5ib25lc1sgZ2JvbmUucGFyZW50IF0uYWRkKCBib25lICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0dmFyIG5Cb25lcyA9IHRoaXMuYm9uZXMubGVuZ3RoO1xyXG5cclxuXHRcdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0Ly8gbGF5b3V0ICgxIG1hdHJpeCA9IDQgcGl4ZWxzKVxyXG5cdFx0XHQvL1x0UkdCQSBSR0JBIFJHQkEgUkdCQSAoPT4gY29sdW1uMSwgY29sdW1uMiwgY29sdW1uMywgY29sdW1uNClcclxuXHRcdFx0Ly8gIHdpdGggIDh4OCAgcGl4ZWwgdGV4dHVyZSBtYXggICAxNiBib25lcyAgKDggKiA4ICAvIDQpXHJcblx0XHRcdC8vICBcdCAxNngxNiBwaXhlbCB0ZXh0dXJlIG1heCAgIDY0IGJvbmVzICgxNiAqIDE2IC8gNClcclxuXHRcdFx0Ly8gIFx0IDMyeDMyIHBpeGVsIHRleHR1cmUgbWF4ICAyNTYgYm9uZXMgKDMyICogMzIgLyA0KVxyXG5cdFx0XHQvLyAgXHQgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAoNjQgKiA2NCAvIDQpXHJcblxyXG5cdFx0XHR2YXIgc2l6ZTtcclxuXHJcblx0XHRcdGlmICggbkJvbmVzID4gMjU2IClcclxuXHRcdFx0XHRzaXplID0gNjQ7XHJcblx0XHRcdGVsc2UgaWYgKCBuQm9uZXMgPiA2NCApXHJcblx0XHRcdFx0c2l6ZSA9IDMyO1xyXG5cdFx0XHRlbHNlIGlmICggbkJvbmVzID4gMTYgKVxyXG5cdFx0XHRcdHNpemUgPSAxNjtcclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHNpemUgPSA4O1xyXG5cclxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZVdpZHRoID0gc2l6ZTtcclxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZUhlaWdodCA9IHNpemU7XHJcblxyXG5cdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIHRoaXMuYm9uZVRleHR1cmVXaWR0aCAqIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQgKiA0ICk7IC8vIDQgZmxvYXRzIHBlciBSR0JBIHBpeGVsXHJcblx0XHRcdHRoaXMuYm9uZVRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIHRoaXMuYm9uZU1hdHJpY2VzLCB0aGlzLmJvbmVUZXh0dXJlV2lkdGgsIHRoaXMuYm9uZVRleHR1cmVIZWlnaHQsIFRIUkVFLlJHQkFGb3JtYXQsIFRIUkVFLkZsb2F0VHlwZSApO1xyXG5cdFx0XHR0aGlzLmJvbmVUZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XHJcblx0XHRcdHRoaXMuYm9uZVRleHR1cmUubWFnRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcclxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHRcdFx0dGhpcy5ib25lVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLmJvbmVNYXRyaWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICogbkJvbmVzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucG9zZSgpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlNraW5uZWRNZXNoLnByb3RvdHlwZS5hZGRCb25lID0gZnVuY3Rpb24oIGJvbmUgKSB7XHJcblxyXG5cdGlmICggYm9uZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdGJvbmUgPSBuZXcgVEhSRUUuQm9uZSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuYm9uZXMucHVzaCggYm9uZSApO1xyXG5cclxuXHRyZXR1cm4gYm9uZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbiAoIGZvcmNlICkge1xyXG5cclxuXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgJiYgdGhpcy51cGRhdGVNYXRyaXgoKTtcclxuXHJcblx0Ly8gdXBkYXRlIG1hdHJpeFdvcmxkXHJcblxyXG5cdGlmICggdGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlIHx8IGZvcmNlICkge1xyXG5cclxuXHRcdGlmICggdGhpcy5wYXJlbnQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdGZvcmNlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxuXHQvLyB1cGRhdGUgY2hpbGRyZW5cclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5bIGkgXTtcclxuXHJcblx0XHRpZiAoIGNoaWxkIGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcclxuXHJcblx0XHRcdGNoaWxkLnVwZGF0ZSggdGhpcy5pZGVudGl0eU1hdHJpeCwgZmFsc2UgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y2hpbGQudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gbWFrZSBhIHNuYXBzaG90IG9mIHRoZSBib25lcycgcmVzdCBwb3NpdGlvblxyXG5cclxuXHRpZiAoIHRoaXMuYm9uZUludmVyc2VzID09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBiID0gMCwgYmwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgYiA8IGJsOyBiICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGludmVyc2UgPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cclxuXHRcdFx0aW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLmJvbmVzWyBiIF0uc2tpbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0dGhpcy5ib25lSW52ZXJzZXMucHVzaCggaW52ZXJzZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBmbGF0dGVuIGJvbmUgbWF0cmljZXMgdG8gYXJyYXlcclxuXHJcblx0Zm9yICggdmFyIGIgPSAwLCBibCA9IHRoaXMuYm9uZXMubGVuZ3RoOyBiIDwgYmw7IGIgKysgKSB7XHJcblxyXG5cdFx0Ly8gY29tcHV0ZSB0aGUgb2Zmc2V0IGJldHdlZW4gdGhlIGN1cnJlbnQgYW5kIHRoZSBvcmlnaW5hbCB0cmFuc2Zvcm07XHJcblxyXG5cdFx0Ly9UT0RPOiB3ZSBjb3VsZCBnZXQgcmlkIG9mIHRoaXMgbXVsdGlwbGljYXRpb24gc3RlcCBpZiB0aGUgc2tpbk1hdHJpeFxyXG5cdFx0Ly8gd2FzIGFscmVhZHkgcmVwcmVzZW50aW5nIHRoZSBvZmZzZXQ7IGhvd2V2ZXIsIHRoaXMgcmVxdWlyZXMgc29tZVxyXG5cdFx0Ly8gbWFqb3IgY2hhbmdlcyB0byB0aGUgYW5pbWF0aW9uIHN5c3RlbVxyXG5cclxuXHRcdFRIUkVFLlNraW5uZWRNZXNoLm9mZnNldE1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLmJvbmVzWyBiIF0uc2tpbk1hdHJpeCwgdGhpcy5ib25lSW52ZXJzZXNbIGIgXSApO1xyXG5cclxuXHRcdFRIUkVFLlNraW5uZWRNZXNoLm9mZnNldE1hdHJpeC5mbGF0dGVuVG9BcnJheU9mZnNldCggdGhpcy5ib25lTWF0cmljZXMsIGIgKiAxNiApO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggdGhpcy51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdHRoaXMuYm9uZVRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLnBvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0Ly8gbm9ybWFsaXplIHdlaWdodHNcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLmdlb21ldHJ5LnNraW5XZWlnaHRzWyBpIF07XHJcblxyXG5cdFx0dmFyIHNjYWxlID0gMS4wIC8gc3cubGVuZ3RoTWFuaGF0dGFuKCk7XHJcblxyXG5cdFx0aWYgKCBzY2FsZSAhPT0gSW5maW5pdHkgKSB7XHJcblxyXG5cdFx0XHRzdy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0c3cuc2V0KCAxICk7IC8vIHRoaXMgd2lsbCBiZSBub3JtYWxpemVkIGJ5IHRoZSBzaGFkZXIgYW55d2F5XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2tpbm5lZE1lc2gucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuU2tpbm5lZE1lc2goIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwsIHRoaXMudXNlVmVydGV4VGV4dHVyZSApO1xyXG5cclxuXHRUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcclxuXHJcblx0cmV0dXJuIG9iamVjdDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Ta2lubmVkTWVzaC5vZmZzZXRNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Nb3JwaEFuaW1NZXNoID0gZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdC8vIEFQSVxyXG5cclxuXHR0aGlzLmR1cmF0aW9uID0gMTAwMDsgLy8gbWlsbGlzZWNvbmRzXHJcblx0dGhpcy5taXJyb3JlZExvb3AgPSBmYWxzZTtcclxuXHR0aGlzLnRpbWUgPSAwO1xyXG5cclxuXHQvLyBpbnRlcm5hbHNcclxuXHJcblx0dGhpcy5sYXN0S2V5ZnJhbWUgPSAwO1xyXG5cdHRoaXMuY3VycmVudEtleWZyYW1lID0gMDtcclxuXHJcblx0dGhpcy5kaXJlY3Rpb24gPSAxO1xyXG5cdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuc2V0RnJhbWVSYW5nZSggMCwgdGhpcy5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoIC0gMSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTWVzaC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldEZyYW1lUmFuZ2UgPSBmdW5jdGlvbiAoIHN0YXJ0LCBlbmQgKSB7XHJcblxyXG5cdHRoaXMuc3RhcnRLZXlmcmFtZSA9IHN0YXJ0O1xyXG5cdHRoaXMuZW5kS2V5ZnJhbWUgPSBlbmQ7XHJcblxyXG5cdHRoaXMubGVuZ3RoID0gdGhpcy5lbmRLZXlmcmFtZSAtIHRoaXMuc3RhcnRLZXlmcmFtZSArIDE7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uRm9yd2FyZCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5kaXJlY3Rpb24gPSAxO1xyXG5cdHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuc2V0RGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuZGlyZWN0aW9uID0gLTE7XHJcblx0dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnBhcnNlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcblx0aWYgKCAhIGdlb21ldHJ5LmFuaW1hdGlvbnMgKSBnZW9tZXRyeS5hbmltYXRpb25zID0ge307XHJcblxyXG5cdHZhciBmaXJzdEFuaW1hdGlvbiwgYW5pbWF0aW9ucyA9IGdlb21ldHJ5LmFuaW1hdGlvbnM7XHJcblxyXG5cdHZhciBwYXR0ZXJuID0gLyhbYS16XSspKFxcZCspLztcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgbW9ycGggPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXTtcclxuXHRcdHZhciBwYXJ0cyA9IG1vcnBoLm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcclxuXHJcblx0XHRpZiAoIHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG5cdFx0XHR2YXIgbGFiZWwgPSBwYXJ0c1sgMSBdO1xyXG5cdFx0XHR2YXIgbnVtID0gcGFydHNbIDIgXTtcclxuXHJcblx0XHRcdGlmICggISBhbmltYXRpb25zWyBsYWJlbCBdICkgYW5pbWF0aW9uc1sgbGFiZWwgXSA9IHsgc3RhcnQ6IEluZmluaXR5LCBlbmQ6IC1JbmZpbml0eSB9O1xyXG5cclxuXHRcdFx0dmFyIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnNbIGxhYmVsIF07XHJcblxyXG5cdFx0XHRpZiAoIGkgPCBhbmltYXRpb24uc3RhcnQgKSBhbmltYXRpb24uc3RhcnQgPSBpO1xyXG5cdFx0XHRpZiAoIGkgPiBhbmltYXRpb24uZW5kICkgYW5pbWF0aW9uLmVuZCA9IGk7XHJcblxyXG5cdFx0XHRpZiAoICEgZmlyc3RBbmltYXRpb24gKSBmaXJzdEFuaW1hdGlvbiA9IGxhYmVsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRnZW9tZXRyeS5maXJzdEFuaW1hdGlvbiA9IGZpcnN0QW5pbWF0aW9uO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQW5pbU1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkxhYmVsID0gZnVuY3Rpb24gKCBsYWJlbCwgc3RhcnQsIGVuZCApIHtcclxuXHJcblx0aWYgKCAhIHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9ucyApIHRoaXMuZ2VvbWV0cnkuYW5pbWF0aW9ucyA9IHt9O1xyXG5cclxuXHR0aGlzLmdlb21ldHJ5LmFuaW1hdGlvbnNbIGxhYmVsIF0gPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEFuaW1NZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKCBsYWJlbCwgZnBzICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5nZW9tZXRyeS5hbmltYXRpb25zWyBsYWJlbCBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHR0aGlzLnNldEZyYW1lUmFuZ2UoIGFuaW1hdGlvbi5zdGFydCwgYW5pbWF0aW9uLmVuZCApO1xyXG5cdFx0dGhpcy5kdXJhdGlvbiA9IDEwMDAgKiAoICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gZnBzICk7XHJcblx0XHR0aGlzLnRpbWUgPSAwO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggXCJhbmltYXRpb25bXCIgKyBsYWJlbCArIFwiXSB1bmRlZmluZWRcIiApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUudXBkYXRlQW5pbWF0aW9uID0gZnVuY3Rpb24gKCBkZWx0YSApIHtcclxuXHJcblx0dmFyIGZyYW1lVGltZSA9IHRoaXMuZHVyYXRpb24gLyB0aGlzLmxlbmd0aDtcclxuXHJcblx0dGhpcy50aW1lICs9IHRoaXMuZGlyZWN0aW9uICogZGVsdGE7XHJcblxyXG5cdGlmICggdGhpcy5taXJyb3JlZExvb3AgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLnRpbWUgPiB0aGlzLmR1cmF0aW9uIHx8IHRoaXMudGltZSA8IDAgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRpcmVjdGlvbiAqPSAtMTtcclxuXHJcblx0XHRcdGlmICggdGhpcy50aW1lID4gdGhpcy5kdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0dGhpcy50aW1lID0gdGhpcy5kdXJhdGlvbjtcclxuXHRcdFx0XHR0aGlzLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRoaXMudGltZSA8IDAgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudGltZSA9IDA7XHJcblx0XHRcdFx0dGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy50aW1lID0gdGhpcy50aW1lICUgdGhpcy5kdXJhdGlvbjtcclxuXHJcblx0XHRpZiAoIHRoaXMudGltZSA8IDAgKSB0aGlzLnRpbWUgKz0gdGhpcy5kdXJhdGlvbjtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIga2V5ZnJhbWUgPSB0aGlzLnN0YXJ0S2V5ZnJhbWUgKyBUSFJFRS5NYXRoLmNsYW1wKCBNYXRoLmZsb29yKCB0aGlzLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgdGhpcy5sZW5ndGggLSAxICk7XHJcblxyXG5cdGlmICgga2V5ZnJhbWUgIT09IHRoaXMuY3VycmVudEtleWZyYW1lICkge1xyXG5cclxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyB0aGlzLmxhc3RLZXlmcmFtZSBdID0gMDtcclxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyB0aGlzLmN1cnJlbnRLZXlmcmFtZSBdID0gMTtcclxuXHJcblx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XHJcblxyXG5cdFx0dGhpcy5sYXN0S2V5ZnJhbWUgPSB0aGlzLmN1cnJlbnRLZXlmcmFtZTtcclxuXHRcdHRoaXMuY3VycmVudEtleWZyYW1lID0ga2V5ZnJhbWU7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIG1peCA9ICggdGhpcy50aW1lICUgZnJhbWVUaW1lICkgLyBmcmFtZVRpbWU7XHJcblxyXG5cdGlmICggdGhpcy5kaXJlY3Rpb25CYWNrd2FyZHMgKSB7XHJcblxyXG5cdFx0bWl4ID0gMSAtIG1peDtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5jdXJyZW50S2V5ZnJhbWUgXSA9IG1peDtcclxuXHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgdGhpcy5sYXN0S2V5ZnJhbWUgXSA9IDEgLSBtaXg7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhBbmltTWVzaC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgPT09IHVuZGVmaW5lZCApIG9iamVjdCA9IG5ldyBUSFJFRS5Nb3JwaEFuaW1NZXNoKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICk7XHJcblxyXG5cdG9iamVjdC5kdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XHJcblx0b2JqZWN0Lm1pcnJvcmVkTG9vcCA9IHRoaXMubWlycm9yZWRMb29wO1xyXG5cdG9iamVjdC50aW1lID0gdGhpcy50aW1lO1xyXG5cclxuXHRvYmplY3QubGFzdEtleWZyYW1lID0gdGhpcy5sYXN0S2V5ZnJhbWU7XHJcblx0b2JqZWN0LmN1cnJlbnRLZXlmcmFtZSA9IHRoaXMuY3VycmVudEtleWZyYW1lO1xyXG5cclxuXHRvYmplY3QuZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XHJcblx0b2JqZWN0LmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRoaXMuZGlyZWN0aW9uQmFja3dhcmRzO1xyXG5cclxuXHRUSFJFRS5NZXNoLnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcclxuXHJcblx0cmV0dXJuIG9iamVjdDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlJpYmJvbiA9IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcclxuXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUmliYm9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuUmliYm9uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xyXG5cclxuXHRpZiAoIG9iamVjdCA9PT0gdW5kZWZpbmVkICkgb2JqZWN0ID0gbmV3IFRIUkVFLlJpYmJvbiggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApO1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUuY2xvbmUuY2FsbCggdGhpcywgb2JqZWN0ICk7XHJcblxyXG5cdHJldHVybiBvYmplY3Q7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5MT0QgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5MT0RzID0gW107XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkxPRC5wcm90b3R5cGUuYWRkTGV2ZWwgPSBmdW5jdGlvbiAoIG9iamVjdDNELCB2aXNpYmxlQXREaXN0YW5jZSApIHtcclxuXHJcblx0aWYgKCB2aXNpYmxlQXREaXN0YW5jZSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdHZpc2libGVBdERpc3RhbmNlID0gMDtcclxuXHJcblx0fVxyXG5cclxuXHR2aXNpYmxlQXREaXN0YW5jZSA9IE1hdGguYWJzKCB2aXNpYmxlQXREaXN0YW5jZSApO1xyXG5cclxuXHRmb3IgKCB2YXIgbCA9IDA7IGwgPCB0aGlzLkxPRHMubGVuZ3RoOyBsICsrICkge1xyXG5cclxuXHRcdGlmICggdmlzaWJsZUF0RGlzdGFuY2UgPCB0aGlzLkxPRHNbIGwgXS52aXNpYmxlQXREaXN0YW5jZSApIHtcclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLkxPRHMuc3BsaWNlKCBsLCAwLCB7IHZpc2libGVBdERpc3RhbmNlOiB2aXNpYmxlQXREaXN0YW5jZSwgb2JqZWN0M0Q6IG9iamVjdDNEIH0gKTtcclxuXHR0aGlzLmFkZCggb2JqZWN0M0QgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICggY2FtZXJhICkge1xyXG5cclxuXHRpZiAoIHRoaXMuTE9Ecy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0dmFyIGludmVyc2UgID0gY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZTtcclxuXHRcdHZhciBkaXN0YW5jZSA9IC0oIGludmVyc2UuZWxlbWVudHNbMl0gKiB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEyXSArIGludmVyc2UuZWxlbWVudHNbNl0gKiB0aGlzLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEzXSArIGludmVyc2UuZWxlbWVudHNbMTBdICogdGhpcy5tYXRyaXhXb3JsZC5lbGVtZW50c1sxNF0gKyBpbnZlcnNlLmVsZW1lbnRzWzE0XSApO1xyXG5cclxuXHRcdHRoaXMuTE9Ec1sgMCBdLm9iamVjdDNELnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHRcdGZvciAoIHZhciBsID0gMTsgbCA8IHRoaXMuTE9Ecy5sZW5ndGg7IGwgKysgKSB7XHJcblxyXG5cdFx0XHRpZiggZGlzdGFuY2UgPj0gdGhpcy5MT0RzWyBsIF0udmlzaWJsZUF0RGlzdGFuY2UgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuTE9Ec1sgbCAtIDEgXS5vYmplY3QzRC52aXNpYmxlID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy5MT0RzWyBsICAgICBdLm9iamVjdDNELnZpc2libGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciggOyBsIDwgdGhpcy5MT0RzLmxlbmd0aDsgbCArKyApIHtcclxuXHJcblx0XHRcdHRoaXMuTE9Ec1sgbCBdLm9iamVjdDNELnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5MT0QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHQvLyBUT0RPXHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcHJpdGUgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubWF0ZXJpYWwgPSAoIG1hdGVyaWFsICE9PSB1bmRlZmluZWQgKSA/IG1hdGVyaWFsIDogbmV3IFRIUkVFLlNwcml0ZU1hdGVyaWFsKCk7XHJcblxyXG5cdHRoaXMucm90YXRpb24zZCA9IHRoaXMucm90YXRpb247XHJcblx0dGhpcy5yb3RhdGlvbiA9IDA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuLypcclxuICogQ3VzdG9tIHVwZGF0ZSBtYXRyaXhcclxuICovXHJcblxyXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLnVwZGF0ZU1hdHJpeCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5tYXRyaXguc2V0UG9zaXRpb24oIHRoaXMucG9zaXRpb24gKTtcclxuXHJcblx0dGhpcy5yb3RhdGlvbjNkLnNldCggMCwgMCwgdGhpcy5yb3RhdGlvbiApO1xyXG5cdHRoaXMubWF0cml4LnNldFJvdGF0aW9uRnJvbUV1bGVyKCB0aGlzLnJvdGF0aW9uM2QgKTtcclxuXHJcblx0aWYgKCB0aGlzLnNjYWxlLnggIT09IDEgfHwgdGhpcy5zY2FsZS55ICE9PSAxICkge1xyXG5cclxuXHRcdHRoaXMubWF0cml4LnNjYWxlKCB0aGlzLnNjYWxlICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcHJpdGUucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XHJcblxyXG5cdGlmICggb2JqZWN0ID09PSB1bmRlZmluZWQgKSBvYmplY3QgPSBuZXcgVEhSRUUuU3ByaXRlKCB0aGlzLm1hdGVyaWFsICk7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELnByb3RvdHlwZS5jbG9uZS5jYWxsKCB0aGlzLCBvYmplY3QgKTtcclxuXHJcblx0cmV0dXJuIG9iamVjdDtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TY2VuZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmZvZyA9IG51bGw7XHJcblx0dGhpcy5vdmVycmlkZU1hdGVyaWFsID0gbnVsbDtcclxuXHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHRoaXMuX19vYmplY3RzID0gW107XHJcblx0dGhpcy5fX2xpZ2h0cyA9IFtdO1xyXG5cclxuXHR0aGlzLl9fb2JqZWN0c0FkZGVkID0gW107XHJcblx0dGhpcy5fX29iamVjdHNSZW1vdmVkID0gW107XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuX19hZGRPYmplY3QgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuX19saWdodHMuaW5kZXhPZiggb2JqZWN0ICkgPT09IC0gMSApIHtcclxuXHJcblx0XHRcdHRoaXMuX19saWdodHMucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0LnRhcmdldCAmJiBvYmplY3QudGFyZ2V0LnBhcmVudCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0dGhpcy5hZGQoIG9iamVjdC50YXJnZXQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH0gZWxzZSBpZiAoICEoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkNhbWVyYSB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkgKSB7XHJcblxyXG5cdFx0aWYgKCB0aGlzLl9fb2JqZWN0cy5pbmRleE9mKCBvYmplY3QgKSA9PT0gLSAxICkge1xyXG5cclxuXHRcdFx0dGhpcy5fX29iamVjdHMucHVzaCggb2JqZWN0ICk7XHJcblx0XHRcdHRoaXMuX19vYmplY3RzQWRkZWQucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHQvLyBjaGVjayBpZiBwcmV2aW91c2x5IHJlbW92ZWRcclxuXHJcblx0XHRcdHZhciBpID0gdGhpcy5fX29iamVjdHNSZW1vdmVkLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0aWYgKCBpICE9PSAtMSApIHtcclxuXHJcblx0XHRcdFx0dGhpcy5fX29iamVjdHNSZW1vdmVkLnNwbGljZSggaSwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCB2YXIgYyA9IDA7IGMgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBjICsrICkge1xyXG5cclxuXHRcdHRoaXMuX19hZGRPYmplY3QoIG9iamVjdC5jaGlsZHJlblsgYyBdICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5TY2VuZS5wcm90b3R5cGUuX19yZW1vdmVPYmplY3QgPSBmdW5jdGlvbiAoIG9iamVjdCApIHtcclxuXHJcblx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaWdodCApIHtcclxuXHJcblx0XHR2YXIgaSA9IHRoaXMuX19saWdodHMuaW5kZXhPZiggb2JqZWN0ICk7XHJcblxyXG5cdFx0aWYgKCBpICE9PSAtMSApIHtcclxuXHJcblx0XHRcdHRoaXMuX19saWdodHMuc3BsaWNlKCBpLCAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9IGVsc2UgaWYgKCAhKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEgKSApIHtcclxuXHJcblx0XHR2YXIgaSA9IHRoaXMuX19vYmplY3RzLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuXHRcdGlmKCBpICE9PSAtMSApIHtcclxuXHJcblx0XHRcdHRoaXMuX19vYmplY3RzLnNwbGljZSggaSwgMSApO1xyXG5cdFx0XHR0aGlzLl9fb2JqZWN0c1JlbW92ZWQucHVzaCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHQvLyBjaGVjayBpZiBwcmV2aW91c2x5IGFkZGVkXHJcblxyXG5cdFx0XHR2YXIgYWkgPSB0aGlzLl9fb2JqZWN0c0FkZGVkLmluZGV4T2YoIG9iamVjdCApO1xyXG5cclxuXHRcdFx0aWYgKCBhaSAhPT0gLTEgKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMuX19vYmplY3RzQWRkZWQuc3BsaWNlKCBhaSwgMSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCB2YXIgYyA9IDA7IGMgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBjICsrICkge1xyXG5cclxuXHRcdHRoaXMuX19yZW1vdmVPYmplY3QoIG9iamVjdC5jaGlsZHJlblsgYyBdICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkZvZyA9IGZ1bmN0aW9uICggaGV4LCBuZWFyLCBmYXIgKSB7XHJcblxyXG5cdHRoaXMubmFtZSA9ICcnO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBoZXggKTtcclxuXHJcblx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAxO1xyXG5cdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Gb2cucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLkZvZyggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuRm9nRXhwMiA9IGZ1bmN0aW9uICggaGV4LCBkZW5zaXR5ICkge1xyXG5cclxuXHR0aGlzLm5hbWUgPSAnJztcclxuXHR0aGlzLmNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCBoZXggKTtcclxuXHR0aGlzLmRlbnNpdHkgPSAoIGRlbnNpdHkgIT09IHVuZGVmaW5lZCApID8gZGVuc2l0eSA6IDAuMDAwMjU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRm9nRXhwMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHJldHVybiBuZXcgVEhSRUUuRm9nRXhwMiggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5kZW5zaXR5ICk7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DYW52YXNSZW5kZXJlciA9IGZ1bmN0aW9uICggcGFyYW1ldGVycyApIHtcclxuXHJcblx0Y29uc29sZS5sb2coICdUSFJFRS5DYW52YXNSZW5kZXJlcicsIFRIUkVFLlJFVklTSU9OICk7XHJcblxyXG5cdHZhciBzbW9vdGhzdGVwID0gVEhSRUUuTWF0aC5zbW9vdGhzdGVwO1xyXG5cclxuXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcclxuXHJcblx0dmFyIF90aGlzID0gdGhpcyxcclxuXHRfcmVuZGVyRGF0YSwgX2VsZW1lbnRzLCBfbGlnaHRzLFxyXG5cdF9wcm9qZWN0b3IgPSBuZXcgVEhSRUUuUHJvamVjdG9yKCksXHJcblxyXG5cdF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkXHJcblx0XHRcdD8gcGFyYW1ldGVycy5jYW52YXNcclxuXHRcdFx0OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLFxyXG5cclxuXHRfY2FudmFzV2lkdGgsIF9jYW52YXNIZWlnaHQsIF9jYW52YXNXaWR0aEhhbGYsIF9jYW52YXNIZWlnaHRIYWxmLFxyXG5cdF9jb250ZXh0ID0gX2NhbnZhcy5nZXRDb250ZXh0KCAnMmQnICksXHJcblxyXG5cdF9jbGVhckNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCAweDAwMDAwMCApLFxyXG5cdF9jbGVhck9wYWNpdHkgPSAwLFxyXG5cclxuXHRfY29udGV4dEdsb2JhbEFscGhhID0gMSxcclxuXHRfY29udGV4dEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IDAsXHJcblx0X2NvbnRleHRTdHJva2VTdHlsZSA9IG51bGwsXHJcblx0X2NvbnRleHRGaWxsU3R5bGUgPSBudWxsLFxyXG5cdF9jb250ZXh0TGluZVdpZHRoID0gbnVsbCxcclxuXHRfY29udGV4dExpbmVDYXAgPSBudWxsLFxyXG5cdF9jb250ZXh0TGluZUpvaW4gPSBudWxsLFxyXG5cdF9jb250ZXh0RGFzaFNpemUgPSBudWxsLFxyXG5cdF9jb250ZXh0R2FwU2l6ZSA9IDAsXHJcblxyXG5cdF92MSwgX3YyLCBfdjMsIF92NCxcclxuXHRfdjUgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpLFxyXG5cdF92NiA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCksXHJcblxyXG5cdF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksXHJcblx0X3Y0eCwgX3Y0eSwgX3Y1eCwgX3Y1eSwgX3Y2eCwgX3Y2eSxcclxuXHJcblx0X2NvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X2NvbG9yMSA9IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cdF9jb2xvcjIgPSBuZXcgVEhSRUUuQ29sb3IoKSxcclxuXHRfY29sb3IzID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X2NvbG9yNCA9IG5ldyBUSFJFRS5Db2xvcigpLFxyXG5cclxuXHRfZGlmZnVzZUNvbG9yID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X2VtaXNzaXZlQ29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKSxcclxuXHJcblx0X2xpZ2h0Q29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoKSxcclxuXHJcblx0X3BhdHRlcm5zID0ge30sIF9pbWFnZWRhdGFzID0ge30sXHJcblxyXG5cdF9uZWFyLCBfZmFyLFxyXG5cclxuXHRfaW1hZ2UsIF91dnMsXHJcblx0X3V2MXgsIF91djF5LCBfdXYyeCwgX3V2MnksIF91djN4LCBfdXYzeSxcclxuXHJcblx0X2NsaXBCb3ggPSBuZXcgVEhSRUUuQm94MigpLFxyXG5cdF9jbGVhckJveCA9IG5ldyBUSFJFRS5Cb3gyKCksXHJcblx0X2VsZW1Cb3ggPSBuZXcgVEhSRUUuQm94MigpLFxyXG5cclxuXHRfZW5hYmxlTGlnaHRpbmcgPSBmYWxzZSxcclxuXHRfYW1iaWVudExpZ2h0ID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X2RpcmVjdGlvbmFsTGlnaHRzID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblx0X3BvaW50TGlnaHRzID0gbmV3IFRIUkVFLkNvbG9yKCksXHJcblxyXG5cdF92ZWN0b3IzID0gbmV3IFRIUkVFLlZlY3RvcjMoKSwgLy8gTmVlZGVkIGZvciBQb2ludExpZ2h0XHJcblxyXG5cdF9waXhlbE1hcCwgX3BpeGVsTWFwQ29udGV4dCwgX3BpeGVsTWFwSW1hZ2UsIF9waXhlbE1hcERhdGEsXHJcblx0X2dyYWRpZW50TWFwLCBfZ3JhZGllbnRNYXBDb250ZXh0LCBfZ3JhZGllbnRNYXBRdWFsaXR5ID0gMTY7XHJcblxyXG5cdF9waXhlbE1hcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0X3BpeGVsTWFwLndpZHRoID0gX3BpeGVsTWFwLmhlaWdodCA9IDI7XHJcblxyXG5cdF9waXhlbE1hcENvbnRleHQgPSBfcGl4ZWxNYXAuZ2V0Q29udGV4dCggJzJkJyApO1xyXG5cdF9waXhlbE1hcENvbnRleHQuZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMSknO1xyXG5cdF9waXhlbE1hcENvbnRleHQuZmlsbFJlY3QoIDAsIDAsIDIsIDIgKTtcclxuXHJcblx0X3BpeGVsTWFwSW1hZ2UgPSBfcGl4ZWxNYXBDb250ZXh0LmdldEltYWdlRGF0YSggMCwgMCwgMiwgMiApO1xyXG5cdF9waXhlbE1hcERhdGEgPSBfcGl4ZWxNYXBJbWFnZS5kYXRhO1xyXG5cclxuXHRfZ3JhZGllbnRNYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xyXG5cdF9ncmFkaWVudE1hcC53aWR0aCA9IF9ncmFkaWVudE1hcC5oZWlnaHQgPSBfZ3JhZGllbnRNYXBRdWFsaXR5O1xyXG5cclxuXHRfZ3JhZGllbnRNYXBDb250ZXh0ID0gX2dyYWRpZW50TWFwLmdldENvbnRleHQoICcyZCcgKTtcclxuXHRfZ3JhZGllbnRNYXBDb250ZXh0LnRyYW5zbGF0ZSggLSBfZ3JhZGllbnRNYXBRdWFsaXR5IC8gMiwgLSBfZ3JhZGllbnRNYXBRdWFsaXR5IC8gMiApO1xyXG5cdF9ncmFkaWVudE1hcENvbnRleHQuc2NhbGUoIF9ncmFkaWVudE1hcFF1YWxpdHksIF9ncmFkaWVudE1hcFF1YWxpdHkgKTtcclxuXHJcblx0X2dyYWRpZW50TWFwUXVhbGl0eSAtLTsgLy8gRml4IFVWc1xyXG5cclxuXHQvLyBkYXNoK2dhcCBmYWxsYmFja3MgZm9yIEZpcmVmb3ggYW5kIGV2ZXJ5dGhpbmcgZWxzZVxyXG5cclxuXHRpZiAoIF9jb250ZXh0LnNldExpbmVEYXNoID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0aWYgKCBfY29udGV4dC5tb3pEYXNoICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfY29udGV4dC5zZXRMaW5lRGFzaCA9IGZ1bmN0aW9uICggdmFsdWVzICkge1xyXG5cclxuXHRcdFx0XHRfY29udGV4dC5tb3pEYXNoID0gdmFsdWVzWyAwIF0gIT09IG51bGwgPyB2YWx1ZXMgOiBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfY29udGV4dC5zZXRMaW5lRGFzaCA9IGZ1bmN0aW9uICgpIHt9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudCA9IF9jYW52YXM7XHJcblxyXG5cdHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IHBhcmFtZXRlcnMuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkXHJcblx0XHRcdFx0PyBwYXJhbWV0ZXJzLmRldmljZVBpeGVsUmF0aW9cclxuXHRcdFx0XHQ6IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICE9PSB1bmRlZmluZWRcclxuXHRcdFx0XHRcdD8gd2luZG93LmRldmljZVBpeGVsUmF0aW9cclxuXHRcdFx0XHRcdDogMTtcclxuXHJcblx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xyXG5cdHRoaXMuc29ydE9iamVjdHMgPSB0cnVlO1xyXG5cdHRoaXMuc29ydEVsZW1lbnRzID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5pbmZvID0ge1xyXG5cclxuXHRcdHJlbmRlcjoge1xyXG5cclxuXHRcdFx0dmVydGljZXM6IDAsXHJcblx0XHRcdGZhY2VzOiAwXHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIFdlYkdMUmVuZGVyZXIgY29tcGF0aWJpbGl0eVxyXG5cclxuXHR0aGlzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7fTtcclxuXHR0aGlzLnNldEZhY2VDdWxsaW5nID0gZnVuY3Rpb24gKCkge307XHJcblxyXG5cdHRoaXMuc2V0U2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCApIHtcclxuXHJcblx0XHRfY2FudmFzV2lkdGggPSB3aWR0aCAqIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbztcclxuXHRcdF9jYW52YXNIZWlnaHQgPSBoZWlnaHQgKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XHJcblxyXG5cdFx0X2NhbnZhc1dpZHRoSGFsZiA9IE1hdGguZmxvb3IoIF9jYW52YXNXaWR0aCAvIDIgKTtcclxuXHRcdF9jYW52YXNIZWlnaHRIYWxmID0gTWF0aC5mbG9vciggX2NhbnZhc0hlaWdodCAvIDIgKTtcclxuXHJcblx0XHRfY2FudmFzLndpZHRoID0gX2NhbnZhc1dpZHRoO1xyXG5cdFx0X2NhbnZhcy5oZWlnaHQgPSBfY2FudmFzSGVpZ2h0O1xyXG5cclxuXHRcdF9jYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XHJcblx0XHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XHJcblxyXG5cdFx0X2NsaXBCb3guc2V0KFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggLSBfY2FudmFzV2lkdGhIYWxmLCAtIF9jYW52YXNIZWlnaHRIYWxmICksXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBfY2FudmFzV2lkdGhIYWxmLCBfY2FudmFzSGVpZ2h0SGFsZiApXHJcblx0XHQpO1xyXG5cclxuXHRcdF9jbGVhckJveC5zZXQoXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCAtIF9jYW52YXNXaWR0aEhhbGYsIC0gX2NhbnZhc0hlaWdodEhhbGYgKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIF9jYW52YXNXaWR0aEhhbGYsIF9jYW52YXNIZWlnaHRIYWxmIClcclxuXHRcdCk7XHJcblxyXG5cdFx0X2NvbnRleHRHbG9iYWxBbHBoYSA9IDE7XHJcblx0XHRfY29udGV4dEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IDA7XHJcblx0XHRfY29udGV4dFN0cm9rZVN0eWxlID0gbnVsbDtcclxuXHRcdF9jb250ZXh0RmlsbFN0eWxlID0gbnVsbDtcclxuXHRcdF9jb250ZXh0TGluZVdpZHRoID0gbnVsbDtcclxuXHRcdF9jb250ZXh0TGluZUNhcCA9IG51bGw7XHJcblx0XHRfY29udGV4dExpbmVKb2luID0gbnVsbDtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCBjb2xvciwgb3BhY2l0eSApIHtcclxuXHJcblx0XHRfY2xlYXJDb2xvci5jb3B5KCBjb2xvciApO1xyXG5cdFx0X2NsZWFyT3BhY2l0eSA9IG9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IG9wYWNpdHkgOiAxO1xyXG5cclxuXHRcdF9jbGVhckJveC5zZXQoXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCAtIF9jYW52YXNXaWR0aEhhbGYsIC0gX2NhbnZhc0hlaWdodEhhbGYgKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIF9jYW52YXNXaWR0aEhhbGYsIF9jYW52YXNIZWlnaHRIYWxmIClcclxuXHRcdCk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0Q2xlYXJDb2xvckhleCA9IGZ1bmN0aW9uICggaGV4LCBvcGFjaXR5ICkge1xyXG5cclxuXHRcdF9jbGVhckNvbG9yLnNldEhleCggaGV4ICk7XHJcblx0XHRfY2xlYXJPcGFjaXR5ID0gb3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gb3BhY2l0eSA6IDE7XHJcblxyXG5cdFx0X2NsZWFyQm94LnNldChcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIC0gX2NhbnZhc1dpZHRoSGFsZiwgLSBfY2FudmFzSGVpZ2h0SGFsZiApLFxyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggX2NhbnZhc1dpZHRoSGFsZiwgX2NhbnZhc0hlaWdodEhhbGYgKVxyXG5cdFx0KTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5nZXRNYXhBbmlzb3Ryb3B5ICA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRfY29udGV4dC5zZXRUcmFuc2Zvcm0oIDEsIDAsIDAsIC0gMSwgX2NhbnZhc1dpZHRoSGFsZiwgX2NhbnZhc0hlaWdodEhhbGYgKTtcclxuXHJcblx0XHRpZiAoIF9jbGVhckJveC5lbXB0eSgpID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdF9jbGVhckJveC5pbnRlcnNlY3QoIF9jbGlwQm94ICk7XHJcblx0XHRcdF9jbGVhckJveC5leHBhbmRCeVNjYWxhciggMiApO1xyXG5cclxuXHRcdFx0aWYgKCBfY2xlYXJPcGFjaXR5IDwgMSApIHtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuY2xlYXJSZWN0KFxyXG5cdFx0XHRcdFx0X2NsZWFyQm94Lm1pbi54IHwgMCxcclxuXHRcdFx0XHRcdF9jbGVhckJveC5taW4ueSB8IDAsXHJcblx0XHRcdFx0XHQoIF9jbGVhckJveC5tYXgueCAtIF9jbGVhckJveC5taW4ueCApIHwgMCxcclxuXHRcdFx0XHRcdCggX2NsZWFyQm94Lm1heC55IC0gX2NsZWFyQm94Lm1pbi55ICkgfCAwXHJcblx0XHRcdFx0KTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggX2NsZWFyT3BhY2l0eSA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdHNldEJsZW5kaW5nKCBUSFJFRS5Ob3JtYWxCbGVuZGluZyApO1xyXG5cdFx0XHRcdHNldE9wYWNpdHkoIDEgKTtcclxuXHJcblx0XHRcdFx0c2V0RmlsbFN0eWxlKCAncmdiYSgnICsgTWF0aC5mbG9vciggX2NsZWFyQ29sb3IuciAqIDI1NSApICsgJywnICsgTWF0aC5mbG9vciggX2NsZWFyQ29sb3IuZyAqIDI1NSApICsgJywnICsgTWF0aC5mbG9vciggX2NsZWFyQ29sb3IuYiAqIDI1NSApICsgJywnICsgX2NsZWFyT3BhY2l0eSArICcpJyApO1xyXG5cclxuXHRcdFx0XHRfY29udGV4dC5maWxsUmVjdChcclxuXHRcdFx0XHRcdF9jbGVhckJveC5taW4ueCB8IDAsXHJcblx0XHRcdFx0XHRfY2xlYXJCb3gubWluLnkgfCAwLFxyXG5cdFx0XHRcdFx0KCBfY2xlYXJCb3gubWF4LnggLSBfY2xlYXJCb3gubWluLnggKSB8IDAsXHJcblx0XHRcdFx0XHQoIF9jbGVhckJveC5tYXgueSAtIF9jbGVhckJveC5taW4ueSApIHwgMFxyXG5cdFx0XHRcdCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfY2xlYXJCb3gubWFrZUVtcHR5KCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCBjYW1lcmEgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmEgPT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvQ2xlYXIgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmNsZWFyKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9jb250ZXh0LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgLSAxLCBfY2FudmFzV2lkdGhIYWxmLCBfY2FudmFzSGVpZ2h0SGFsZiApO1xyXG5cclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzID0gMDtcclxuXHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzID0gMDtcclxuXHJcblx0XHRfcmVuZGVyRGF0YSA9IF9wcm9qZWN0b3IucHJvamVjdFNjZW5lKCBzY2VuZSwgY2FtZXJhLCB0aGlzLnNvcnRPYmplY3RzLCB0aGlzLnNvcnRFbGVtZW50cyApO1xyXG5cdFx0X2VsZW1lbnRzID0gX3JlbmRlckRhdGEuZWxlbWVudHM7XHJcblx0XHRfbGlnaHRzID0gX3JlbmRlckRhdGEubGlnaHRzO1xyXG5cclxuXHRcdC8qIERFQlVHXHJcblx0XHRzZXRGaWxsU3R5bGUoICdyZ2JhKCAwLCAyNTUsIDI1NSwgMC41ICknICk7XHJcblx0XHRfY29udGV4dC5maWxsUmVjdCggX2NsaXBCb3gubWluLngsIF9jbGlwQm94Lm1pbi55LCBfY2xpcEJveC5tYXgueCAtIF9jbGlwQm94Lm1pbi54LCBfY2xpcEJveC5tYXgueSAtIF9jbGlwQm94Lm1pbi55ICk7XHJcblx0XHQqL1xyXG5cclxuXHRcdF9lbmFibGVMaWdodGluZyA9IF9saWdodHMubGVuZ3RoID4gMDtcclxuXHJcblx0XHRpZiAoIF9lbmFibGVMaWdodGluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdCBjYWxjdWxhdGVMaWdodHMoKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGUgPSAwLCBlbCA9IF9lbGVtZW50cy5sZW5ndGg7IGUgPCBlbDsgZSsrICkge1xyXG5cclxuXHRcdFx0dmFyIGVsZW1lbnQgPSBfZWxlbWVudHNbIGUgXTtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IGVsZW1lbnQubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsID09PSB1bmRlZmluZWQgfHwgbWF0ZXJpYWwudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdF9lbGVtQm94Lm1ha2VFbXB0eSgpO1xyXG5cclxuXHRcdFx0aWYgKCBlbGVtZW50IGluc3RhbmNlb2YgVEhSRUUuUmVuZGVyYWJsZVBhcnRpY2xlICkge1xyXG5cclxuXHRcdFx0XHRfdjEgPSBlbGVtZW50O1xyXG5cdFx0XHRcdF92MS54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92MS55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cclxuXHRcdFx0XHRyZW5kZXJQYXJ0aWNsZSggX3YxLCBlbGVtZW50LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudCBpbnN0YW5jZW9mIFRIUkVFLlJlbmRlcmFibGVMaW5lICkge1xyXG5cclxuXHRcdFx0XHRfdjEgPSBlbGVtZW50LnYxOyBfdjIgPSBlbGVtZW50LnYyO1xyXG5cclxuXHRcdFx0XHRfdjEucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjEucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHRcdFx0XHRfdjIucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjIucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHJcblx0XHRcdFx0X2VsZW1Cb3guc2V0RnJvbVBvaW50cyggWyBfdjEucG9zaXRpb25TY3JlZW4sIF92Mi5wb3NpdGlvblNjcmVlbiBdICk7XHJcblxyXG5cdFx0XHRcdGlmICggX2NsaXBCb3guaXNJbnRlcnNlY3Rpb25Cb3goIF9lbGVtQm94ICkgPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyTGluZSggX3YxLCBfdjIsIGVsZW1lbnQsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQgaW5zdGFuY2VvZiBUSFJFRS5SZW5kZXJhYmxlRmFjZTMgKSB7XHJcblxyXG5cdFx0XHRcdF92MSA9IGVsZW1lbnQudjE7IF92MiA9IGVsZW1lbnQudjI7IF92MyA9IGVsZW1lbnQudjM7XHJcblxyXG5cdFx0XHRcdGlmICggX3YxLnBvc2l0aW9uU2NyZWVuLnogPCAtMSB8fCBfdjEucG9zaXRpb25TY3JlZW4ueiA+IDEgKSBjb250aW51ZTtcclxuXHRcdFx0XHRpZiAoIF92Mi5wb3NpdGlvblNjcmVlbi56IDwgLTEgfHwgX3YyLnBvc2l0aW9uU2NyZWVuLnogPiAxICkgY29udGludWU7XHJcblx0XHRcdFx0aWYgKCBfdjMucG9zaXRpb25TY3JlZW4ueiA8IC0xIHx8IF92My5wb3NpdGlvblNjcmVlbi56ID4gMSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRfdjEucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjEucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHRcdFx0XHRfdjIucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjIucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHRcdFx0XHRfdjMucG9zaXRpb25TY3JlZW4ueCAqPSBfY2FudmFzV2lkdGhIYWxmOyBfdjMucG9zaXRpb25TY3JlZW4ueSAqPSBfY2FudmFzSGVpZ2h0SGFsZjtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5vdmVyZHJhdyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRleHBhbmQoIF92MS5wb3NpdGlvblNjcmVlbiwgX3YyLnBvc2l0aW9uU2NyZWVuICk7XHJcblx0XHRcdFx0XHRleHBhbmQoIF92Mi5wb3NpdGlvblNjcmVlbiwgX3YzLnBvc2l0aW9uU2NyZWVuICk7XHJcblx0XHRcdFx0XHRleHBhbmQoIF92My5wb3NpdGlvblNjcmVlbiwgX3YxLnBvc2l0aW9uU2NyZWVuICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2VsZW1Cb3guc2V0RnJvbVBvaW50cyggWyBfdjEucG9zaXRpb25TY3JlZW4sIF92Mi5wb3NpdGlvblNjcmVlbiwgX3YzLnBvc2l0aW9uU2NyZWVuIF0gKTtcclxuXHJcblx0XHRcdFx0cmVuZGVyRmFjZTMoIF92MSwgX3YyLCBfdjMsIDAsIDEsIDIsIGVsZW1lbnQsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50IGluc3RhbmNlb2YgVEhSRUUuUmVuZGVyYWJsZUZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHRfdjEgPSBlbGVtZW50LnYxOyBfdjIgPSBlbGVtZW50LnYyOyBfdjMgPSBlbGVtZW50LnYzOyBfdjQgPSBlbGVtZW50LnY0O1xyXG5cclxuXHRcdFx0XHRpZiAoIF92MS5wb3NpdGlvblNjcmVlbi56IDwgLTEgfHwgX3YxLnBvc2l0aW9uU2NyZWVuLnogPiAxICkgY29udGludWU7XHJcblx0XHRcdFx0aWYgKCBfdjIucG9zaXRpb25TY3JlZW4ueiA8IC0xIHx8IF92Mi5wb3NpdGlvblNjcmVlbi56ID4gMSApIGNvbnRpbnVlO1xyXG5cdFx0XHRcdGlmICggX3YzLnBvc2l0aW9uU2NyZWVuLnogPCAtMSB8fCBfdjMucG9zaXRpb25TY3JlZW4ueiA+IDEgKSBjb250aW51ZTtcclxuXHRcdFx0XHRpZiAoIF92NC5wb3NpdGlvblNjcmVlbi56IDwgLTEgfHwgX3Y0LnBvc2l0aW9uU2NyZWVuLnogPiAxICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdF92MS5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92MS5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cdFx0XHRcdF92Mi5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92Mi5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cdFx0XHRcdF92My5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92My5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cdFx0XHRcdF92NC5wb3NpdGlvblNjcmVlbi54ICo9IF9jYW52YXNXaWR0aEhhbGY7IF92NC5wb3NpdGlvblNjcmVlbi55ICo9IF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cclxuXHRcdFx0XHRfdjUucG9zaXRpb25TY3JlZW4uY29weSggX3YyLnBvc2l0aW9uU2NyZWVuICk7XHJcblx0XHRcdFx0X3Y2LnBvc2l0aW9uU2NyZWVuLmNvcHkoIF92NC5wb3NpdGlvblNjcmVlbiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLm92ZXJkcmF3ID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdGV4cGFuZCggX3YxLnBvc2l0aW9uU2NyZWVuLCBfdjIucG9zaXRpb25TY3JlZW4gKTtcclxuXHRcdFx0XHRcdGV4cGFuZCggX3YyLnBvc2l0aW9uU2NyZWVuLCBfdjQucG9zaXRpb25TY3JlZW4gKTtcclxuXHRcdFx0XHRcdGV4cGFuZCggX3Y0LnBvc2l0aW9uU2NyZWVuLCBfdjEucG9zaXRpb25TY3JlZW4gKTtcclxuXHJcblx0XHRcdFx0XHRleHBhbmQoIF92My5wb3NpdGlvblNjcmVlbiwgX3Y1LnBvc2l0aW9uU2NyZWVuICk7XHJcblx0XHRcdFx0XHRleHBhbmQoIF92My5wb3NpdGlvblNjcmVlbiwgX3Y2LnBvc2l0aW9uU2NyZWVuICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2VsZW1Cb3guc2V0RnJvbVBvaW50cyggWyBfdjEucG9zaXRpb25TY3JlZW4sIF92Mi5wb3NpdGlvblNjcmVlbiwgX3YzLnBvc2l0aW9uU2NyZWVuLCBfdjQucG9zaXRpb25TY3JlZW4gXSApO1xyXG5cclxuXHRcdFx0XHRyZW5kZXJGYWNlNCggX3YxLCBfdjIsIF92MywgX3Y0LCBfdjUsIF92NiwgZWxlbWVudCwgbWF0ZXJpYWwsIHNjZW5lICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKiBERUJVR1xyXG5cdFx0XHRzZXRMaW5lV2lkdGgoIDEgKTtcclxuXHRcdFx0c2V0U3Ryb2tlU3R5bGUoICdyZ2JhKCAwLCAyNTUsIDAsIDAuNSApJyApO1xyXG5cdFx0XHRfY29udGV4dC5zdHJva2VSZWN0KCBfZWxlbUJveC5taW4ueCwgX2VsZW1Cb3gubWluLnksIF9lbGVtQm94Lm1heC54IC0gX2VsZW1Cb3gubWluLngsIF9lbGVtQm94Lm1heC55IC0gX2VsZW1Cb3gubWluLnkgKTtcclxuXHRcdFx0Ki9cclxuXHJcblx0XHRcdF9jbGVhckJveC51bmlvbiggX2VsZW1Cb3ggKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0LyogREVCVUdcclxuXHRcdHNldExpbmVXaWR0aCggMSApO1xyXG5cdFx0c2V0U3Ryb2tlU3R5bGUoICdyZ2JhKCAyNTUsIDAsIDAsIDAuNSApJyApO1xyXG5cdFx0X2NvbnRleHQuc3Ryb2tlUmVjdCggX2NsZWFyQm94Lm1pbi54LCBfY2xlYXJCb3gubWluLnksIF9jbGVhckJveC5tYXgueCAtIF9jbGVhckJveC5taW4ueCwgX2NsZWFyQm94Lm1heC55IC0gX2NsZWFyQm94Lm1pbi55ICk7XHJcblx0XHQqL1xyXG5cclxuXHRcdF9jb250ZXh0LnNldFRyYW5zZm9ybSggMSwgMCwgMCwgMSwgMCwgMCApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0ZnVuY3Rpb24gY2FsY3VsYXRlTGlnaHRzKCkge1xyXG5cclxuXHRcdFx0X2FtYmllbnRMaWdodC5zZXRSR0IoIDAsIDAsIDAgKTtcclxuXHRcdFx0X2RpcmVjdGlvbmFsTGlnaHRzLnNldFJHQiggMCwgMCwgMCApO1xyXG5cdFx0XHRfcG9pbnRMaWdodHMuc2V0UkdCKCAwLCAwLCAwICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgbCA9IDAsIGxsID0gX2xpZ2h0cy5sZW5ndGg7IGwgPCBsbDsgbCArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGxpZ2h0ID0gX2xpZ2h0c1sgbCBdO1xyXG5cdFx0XHRcdHZhciBsaWdodENvbG9yID0gbGlnaHQuY29sb3I7XHJcblxyXG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5BbWJpZW50TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2FtYmllbnRMaWdodC5hZGQoIGxpZ2h0Q29sb3IgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGZvciBwYXJ0aWNsZXNcclxuXHJcblx0XHRcdFx0XHRfZGlyZWN0aW9uYWxMaWdodHMuYWRkKCBsaWdodENvbG9yICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuUG9pbnRMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHQvLyBmb3IgcGFydGljbGVzXHJcblxyXG5cdFx0XHRcdFx0X3BvaW50TGlnaHRzLmFkZCggbGlnaHRDb2xvciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNhbGN1bGF0ZUxpZ2h0KCBwb3NpdGlvbiwgbm9ybWFsLCBjb2xvciApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBsID0gMCwgbGwgPSBfbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbGlnaHQgPSBfbGlnaHRzWyBsIF07XHJcblxyXG5cdFx0XHRcdF9saWdodENvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICk7XHJcblxyXG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBsaWdodFBvc2l0aW9uID0gX3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBsaWdodC5tYXRyaXhXb3JsZCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHRcdHZhciBhbW91bnQgPSBub3JtYWwuZG90KCBsaWdodFBvc2l0aW9uICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhbW91bnQgPD0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGFtb3VudCAqPSBsaWdodC5pbnRlbnNpdHk7XHJcblxyXG5cdFx0XHRcdFx0Y29sb3IuYWRkKCBfbGlnaHRDb2xvci5tdWx0aXBseVNjYWxhciggYW1vdW50ICkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBsaWdodFBvc2l0aW9uID0gX3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdHZhciBhbW91bnQgPSBub3JtYWwuZG90KCBfdmVjdG9yMy5zdWJWZWN0b3JzKCBsaWdodFBvc2l0aW9uLCBwb3NpdGlvbiApLm5vcm1hbGl6ZSgpICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhbW91bnQgPD0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGFtb3VudCAqPSBsaWdodC5kaXN0YW5jZSA9PSAwID8gMSA6IDEgLSBNYXRoLm1pbiggcG9zaXRpb24uZGlzdGFuY2VUbyggbGlnaHRQb3NpdGlvbiApIC8gbGlnaHQuZGlzdGFuY2UsIDEgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGFtb3VudCA9PSAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0YW1vdW50ICo9IGxpZ2h0LmludGVuc2l0eTtcclxuXHJcblx0XHRcdFx0XHRjb2xvci5hZGQoIF9saWdodENvbG9yLm11bHRpcGx5U2NhbGFyKCBhbW91bnQgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHJlbmRlclBhcnRpY2xlKCB2MSwgZWxlbWVudCwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzZXRPcGFjaXR5KCBtYXRlcmlhbC5vcGFjaXR5ICk7XHJcblx0XHRcdHNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZyApO1xyXG5cclxuXHRcdFx0dmFyIHdpZHRoLCBoZWlnaHQsIHNjYWxlWCwgc2NhbGVZLFxyXG5cdFx0XHRiaXRtYXAsIGJpdG1hcFdpZHRoLCBiaXRtYXBIZWlnaHQ7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1hcCA9PT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRzY2FsZVggPSBlbGVtZW50Lm9iamVjdC5zY2FsZS54O1xyXG5cdFx0XHRcdFx0c2NhbGVZID0gZWxlbWVudC5vYmplY3Quc2NhbGUueTtcclxuXHJcblx0XHRcdFx0XHQvLyBUT0RPOiBCZSBhYmxlIHRvIGRpc2FibGUgdGhpc1xyXG5cclxuXHRcdFx0XHRcdHNjYWxlWCAqPSBlbGVtZW50LnNjYWxlLnggKiBfY2FudmFzV2lkdGhIYWxmO1xyXG5cdFx0XHRcdFx0c2NhbGVZICo9IGVsZW1lbnQuc2NhbGUueSAqIF9jYW52YXNIZWlnaHRIYWxmO1xyXG5cclxuXHRcdFx0XHRcdF9lbGVtQm94Lm1pbi5zZXQoIHYxLnggLSBzY2FsZVgsIHYxLnkgLSBzY2FsZVkgKTtcclxuXHRcdFx0XHRcdF9lbGVtQm94Lm1heC5zZXQoIHYxLnggKyBzY2FsZVgsIHYxLnkgKyBzY2FsZVkgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIF9jbGlwQm94LmlzSW50ZXJzZWN0aW9uQm94KCBfZWxlbUJveCApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0c2V0RmlsbFN0eWxlKCBtYXRlcmlhbC5jb2xvci5nZXRTdHlsZSgpICk7XHJcblxyXG5cdFx0XHRcdFx0X2NvbnRleHQuc2F2ZSgpO1xyXG5cdFx0XHRcdFx0X2NvbnRleHQudHJhbnNsYXRlKCB2MS54LCB2MS55ICk7XHJcblx0XHRcdFx0XHRfY29udGV4dC5yb3RhdGUoIC0gZWxlbWVudC5yb3RhdGlvbiApO1xyXG5cdFx0XHRcdFx0X2NvbnRleHQuc2NhbGUoIHNjYWxlWCwgc2NhbGVZICk7XHJcblx0XHRcdFx0XHRfY29udGV4dC5maWxsUmVjdCggLTEsIC0xLCAyLCAyICk7XHJcblx0XHRcdFx0XHRfY29udGV4dC5yZXN0b3JlKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Yml0bWFwID0gbWF0ZXJpYWwubWFwLmltYWdlO1xyXG5cdFx0XHRcdFx0Yml0bWFwV2lkdGggPSBiaXRtYXAud2lkdGggPj4gMTtcclxuXHRcdFx0XHRcdGJpdG1hcEhlaWdodCA9IGJpdG1hcC5oZWlnaHQgPj4gMTtcclxuXHJcblx0XHRcdFx0XHRzY2FsZVggPSBlbGVtZW50LnNjYWxlLnggKiBfY2FudmFzV2lkdGhIYWxmO1xyXG5cdFx0XHRcdFx0c2NhbGVZID0gZWxlbWVudC5zY2FsZS55ICogX2NhbnZhc0hlaWdodEhhbGY7XHJcblxyXG5cdFx0XHRcdFx0d2lkdGggPSBzY2FsZVggKiBiaXRtYXBXaWR0aDtcclxuXHRcdFx0XHRcdGhlaWdodCA9IHNjYWxlWSAqIGJpdG1hcEhlaWdodDtcclxuXHJcblx0XHRcdFx0XHQvLyBUT0RPOiBSb3RhdGlvbnMgYnJlYWsgdGhpcy4uLlxyXG5cclxuXHRcdFx0XHRcdF9lbGVtQm94Lm1pbi5zZXQoIHYxLnggLSB3aWR0aCwgdjEueSAtIGhlaWdodCApO1xyXG5cdFx0XHRcdFx0X2VsZW1Cb3gubWF4LnNldCggdjEueCArIHdpZHRoLCB2MS55ICsgaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBfY2xpcEJveC5pc0ludGVyc2VjdGlvbkJveCggX2VsZW1Cb3ggKSA9PT0gZmFsc2UgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdF9jb250ZXh0LnNhdmUoKTtcclxuXHRcdFx0XHRcdF9jb250ZXh0LnRyYW5zbGF0ZSggdjEueCwgdjEueSApO1xyXG5cdFx0XHRcdFx0X2NvbnRleHQucm90YXRlKCAtIGVsZW1lbnQucm90YXRpb24gKTtcclxuXHRcdFx0XHRcdF9jb250ZXh0LnNjYWxlKCBzY2FsZVgsIC0gc2NhbGVZICk7XHJcblxyXG5cdFx0XHRcdFx0X2NvbnRleHQudHJhbnNsYXRlKCAtIGJpdG1hcFdpZHRoLCAtIGJpdG1hcEhlaWdodCApO1xyXG5cdFx0XHRcdFx0X2NvbnRleHQuZHJhd0ltYWdlKCBiaXRtYXAsIDAsIDAgKTtcclxuXHRcdFx0XHRcdF9jb250ZXh0LnJlc3RvcmUoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvKiBERUJVR1xyXG5cdFx0XHRcdHNldFN0cm9rZVN0eWxlKCAncmdiKDI1NSwyNTUsMCknICk7XHJcblx0XHRcdFx0X2NvbnRleHQuYmVnaW5QYXRoKCk7XHJcblx0XHRcdFx0X2NvbnRleHQubW92ZVRvKCB2MS54IC0gMTAsIHYxLnkgKTtcclxuXHRcdFx0XHRfY29udGV4dC5saW5lVG8oIHYxLnggKyAxMCwgdjEueSApO1xyXG5cdFx0XHRcdF9jb250ZXh0Lm1vdmVUbyggdjEueCwgdjEueSAtIDEwICk7XHJcblx0XHRcdFx0X2NvbnRleHQubGluZVRvKCB2MS54LCB2MS55ICsgMTAgKTtcclxuXHRcdFx0XHRfY29udGV4dC5zdHJva2UoKTtcclxuXHRcdFx0XHQqL1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZUNhbnZhc01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHR3aWR0aCA9IGVsZW1lbnQuc2NhbGUueCAqIF9jYW52YXNXaWR0aEhhbGY7XHJcblx0XHRcdFx0aGVpZ2h0ID0gZWxlbWVudC5zY2FsZS55ICogX2NhbnZhc0hlaWdodEhhbGY7XHJcblxyXG5cdFx0XHRcdF9lbGVtQm94Lm1pbi5zZXQoIHYxLnggLSB3aWR0aCwgdjEueSAtIGhlaWdodCApO1xyXG5cdFx0XHRcdF9lbGVtQm94Lm1heC5zZXQoIHYxLnggKyB3aWR0aCwgdjEueSArIGhlaWdodCApO1xyXG5cclxuXHRcdFx0XHRpZiAoIF9jbGlwQm94LmlzSW50ZXJzZWN0aW9uQm94KCBfZWxlbUJveCApID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2V0U3Ryb2tlU3R5bGUoIG1hdGVyaWFsLmNvbG9yLmdldFN0eWxlKCkgKTtcclxuXHRcdFx0XHRzZXRGaWxsU3R5bGUoIG1hdGVyaWFsLmNvbG9yLmdldFN0eWxlKCkgKTtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuc2F2ZSgpO1xyXG5cdFx0XHRcdF9jb250ZXh0LnRyYW5zbGF0ZSggdjEueCwgdjEueSApO1xyXG5cdFx0XHRcdF9jb250ZXh0LnJvdGF0ZSggLSBlbGVtZW50LnJvdGF0aW9uICk7XHJcblx0XHRcdFx0X2NvbnRleHQuc2NhbGUoIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwucHJvZ3JhbSggX2NvbnRleHQgKTtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQucmVzdG9yZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiByZW5kZXJMaW5lKCB2MSwgdjIsIGVsZW1lbnQsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0c2V0T3BhY2l0eSggbWF0ZXJpYWwub3BhY2l0eSApO1xyXG5cdFx0XHRzZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcgKTtcclxuXHJcblx0XHRcdF9jb250ZXh0LmJlZ2luUGF0aCgpO1xyXG5cdFx0XHRfY29udGV4dC5tb3ZlVG8oIHYxLnBvc2l0aW9uU2NyZWVuLngsIHYxLnBvc2l0aW9uU2NyZWVuLnkgKTtcclxuXHRcdFx0X2NvbnRleHQubGluZVRvKCB2Mi5wb3NpdGlvblNjcmVlbi54LCB2Mi5wb3NpdGlvblNjcmVlbi55ICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHNldExpbmVXaWR0aCggbWF0ZXJpYWwubGluZXdpZHRoICk7XHJcblx0XHRcdFx0c2V0TGluZUNhcCggbWF0ZXJpYWwubGluZWNhcCApO1xyXG5cdFx0XHRcdHNldExpbmVKb2luKCBtYXRlcmlhbC5saW5lam9pbiApO1xyXG5cdFx0XHRcdHNldFN0cm9rZVN0eWxlKCBtYXRlcmlhbC5jb2xvci5nZXRTdHlsZSgpICk7XHJcblx0XHRcdFx0c2V0RGFzaEFuZEdhcCggbnVsbCwgbnVsbCApO1xyXG5cclxuXHRcdFx0XHRfY29udGV4dC5zdHJva2UoKTtcclxuXHRcdFx0XHRfZWxlbUJveC5leHBhbmRCeVNjYWxhciggbWF0ZXJpYWwubGluZXdpZHRoICogMiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHNldExpbmVXaWR0aCggbWF0ZXJpYWwubGluZXdpZHRoICk7XHJcblx0XHRcdFx0c2V0TGluZUNhcCggbWF0ZXJpYWwubGluZWNhcCApO1xyXG5cdFx0XHRcdHNldExpbmVKb2luKCBtYXRlcmlhbC5saW5lam9pbiApO1xyXG5cdFx0XHRcdHNldFN0cm9rZVN0eWxlKCBtYXRlcmlhbC5jb2xvci5nZXRTdHlsZSgpICk7XHJcblx0XHRcdFx0c2V0RGFzaEFuZEdhcCggbWF0ZXJpYWwuZGFzaFNpemUsIG1hdGVyaWFsLmdhcFNpemUgKTtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuc3Ryb2tlKCk7XHJcblx0XHRcdFx0X2VsZW1Cb3guZXhwYW5kQnlTY2FsYXIoIG1hdGVyaWFsLmxpbmV3aWR0aCAqIDIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVuZGVyRmFjZTMoIHYxLCB2MiwgdjMsIHV2MSwgdXYyLCB1djMsIGVsZW1lbnQsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gMztcclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKys7XHJcblxyXG5cdFx0XHRzZXRPcGFjaXR5KCBtYXRlcmlhbC5vcGFjaXR5ICk7XHJcblx0XHRcdHNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZyApO1xyXG5cclxuXHRcdFx0X3YxeCA9IHYxLnBvc2l0aW9uU2NyZWVuLng7IF92MXkgPSB2MS5wb3NpdGlvblNjcmVlbi55O1xyXG5cdFx0XHRfdjJ4ID0gdjIucG9zaXRpb25TY3JlZW4ueDsgX3YyeSA9IHYyLnBvc2l0aW9uU2NyZWVuLnk7XHJcblx0XHRcdF92M3ggPSB2My5wb3NpdGlvblNjcmVlbi54OyBfdjN5ID0gdjMucG9zaXRpb25TY3JlZW4ueTtcclxuXHJcblx0XHRcdGRyYXdUcmlhbmdsZSggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSApO1xyXG5cclxuXHRcdFx0aWYgKCAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkgJiYgbWF0ZXJpYWwubWFwID09PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRfZGlmZnVzZUNvbG9yLmNvcHkoIG1hdGVyaWFsLmNvbG9yICk7XHJcblx0XHRcdFx0X2VtaXNzaXZlQ29sb3IuY29weSggbWF0ZXJpYWwuZW1pc3NpdmUgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPT09IFRIUkVFLkZhY2VDb2xvcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2RpZmZ1c2VDb2xvci5tdWx0aXBseSggZWxlbWVudC5jb2xvciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggX2VuYWJsZUxpZ2h0aW5nID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSBmYWxzZSAmJiBtYXRlcmlhbC5zaGFkaW5nID09IFRIUkVFLlNtb290aFNoYWRpbmcgJiYgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTGVuZ3RoID09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfY29sb3IxLmNvcHkoIF9hbWJpZW50TGlnaHQgKTtcclxuXHRcdFx0XHRcdFx0X2NvbG9yMi5jb3B5KCBfYW1iaWVudExpZ2h0ICk7XHJcblx0XHRcdFx0XHRcdF9jb2xvcjMuY29weSggX2FtYmllbnRMaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIGVsZW1lbnQudjEucG9zaXRpb25Xb3JsZCwgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxbIDAgXSwgX2NvbG9yMSApO1xyXG5cdFx0XHRcdFx0XHRjYWxjdWxhdGVMaWdodCggZWxlbWVudC52Mi5wb3NpdGlvbldvcmxkLCBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFsgMSBdLCBfY29sb3IyICk7XHJcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBlbGVtZW50LnYzLnBvc2l0aW9uV29ybGQsIGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsWyAyIF0sIF9jb2xvcjMgKTtcclxuXHJcblx0XHRcdFx0XHRcdF9jb2xvcjEubXVsdGlwbHkoIF9kaWZmdXNlQ29sb3IgKS5hZGQoIF9lbWlzc2l2ZUNvbG9yICk7XHJcblx0XHRcdFx0XHRcdF9jb2xvcjIubXVsdGlwbHkoIF9kaWZmdXNlQ29sb3IgKS5hZGQoIF9lbWlzc2l2ZUNvbG9yICk7XHJcblx0XHRcdFx0XHRcdF9jb2xvcjMubXVsdGlwbHkoIF9kaWZmdXNlQ29sb3IgKS5hZGQoIF9lbWlzc2l2ZUNvbG9yICk7XHJcblx0XHRcdFx0XHRcdF9jb2xvcjQuYWRkQ29sb3JzKCBfY29sb3IyLCBfY29sb3IzICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0XHRcdFx0X2ltYWdlID0gZ2V0R3JhZGllbnRUZXh0dXJlKCBfY29sb3IxLCBfY29sb3IyLCBfY29sb3IzLCBfY29sb3I0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRjbGlwSW1hZ2UoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksIDAsIDAsIDEsIDAsIDAsIDEsIF9pbWFnZSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfY29sb3IuY29weSggX2FtYmllbnRMaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIGVsZW1lbnQuY2VudHJvaWRNb2RlbCwgZWxlbWVudC5ub3JtYWxNb2RlbCwgX2NvbG9yICk7XHJcblxyXG5cdFx0XHRcdFx0XHRfY29sb3IubXVsdGlwbHkoIF9kaWZmdXNlQ29sb3IgKS5hZGQoIF9lbWlzc2l2ZUNvbG9yICk7XHJcblxyXG5cdFx0XHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWVcclxuXHRcdFx0XHRcdFx0XHQ/IHN0cm9rZVBhdGgoIF9jb2xvciwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiApXHJcblx0XHRcdFx0XHRcdFx0OiBmaWxsUGF0aCggX2NvbG9yICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHQ/IHN0cm9rZVBhdGgoIG1hdGVyaWFsLmNvbG9yLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGgsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luIClcclxuXHRcdFx0XHRcdFx0OiBmaWxsUGF0aCggbWF0ZXJpYWwuY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCB8fCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHwgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAubWFwcGluZyBpbnN0YW5jZW9mIFRIUkVFLlVWTWFwcGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRcdF91dnMgPSBlbGVtZW50LnV2c1sgMCBdO1xyXG5cdFx0XHRcdFx0XHRwYXR0ZXJuUGF0aCggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgX3V2c1sgdXYxIF0ueCwgX3V2c1sgdXYxIF0ueSwgX3V2c1sgdXYyIF0ueCwgX3V2c1sgdXYyIF0ueSwgX3V2c1sgdXYzIF0ueCwgX3V2c1sgdXYzIF0ueSwgbWF0ZXJpYWwubWFwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZW52TWFwICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgaW5zdGFuY2VvZiBUSFJFRS5TcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRcdF92ZWN0b3IzLmNvcHkoIGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsVmlld1sgdXYxIF0gKTtcclxuXHRcdFx0XHRcdFx0X3V2MXggPSAwLjUgKiBfdmVjdG9yMy54ICsgMC41O1xyXG5cdFx0XHRcdFx0XHRfdXYxeSA9IDAuNSAqIF92ZWN0b3IzLnkgKyAwLjU7XHJcblxyXG5cdFx0XHRcdFx0XHRfdmVjdG9yMy5jb3B5KCBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbIHV2MiBdICk7XHJcblx0XHRcdFx0XHRcdF91djJ4ID0gMC41ICogX3ZlY3RvcjMueCArIDAuNTtcclxuXHRcdFx0XHRcdFx0X3V2MnkgPSAwLjUgKiBfdmVjdG9yMy55ICsgMC41O1xyXG5cclxuXHRcdFx0XHRcdFx0X3ZlY3RvcjMuY29weSggZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxWaWV3WyB1djMgXSApO1xyXG5cdFx0XHRcdFx0XHRfdXYzeCA9IDAuNSAqIF92ZWN0b3IzLnggKyAwLjU7XHJcblx0XHRcdFx0XHRcdF91djN5ID0gMC41ICogX3ZlY3RvcjMueSArIDAuNTtcclxuXHJcblx0XHRcdFx0XHRcdHBhdHRlcm5QYXRoKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjN4LCBfdjN5LCBfdXYxeCwgX3V2MXksIF91djJ4LCBfdXYyeSwgX3V2M3gsIF91djN5LCBtYXRlcmlhbC5lbnZNYXAgKTtcclxuXHJcblx0XHRcdFx0XHR9LyogZWxzZSBpZiAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nID09IFRIUkVFLlNwaGVyaWNhbFJlZnJhY3Rpb25NYXBwaW5nICkge1xyXG5cclxuXHJcblxyXG5cdFx0XHRcdFx0fSovXHJcblxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF9jb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwudmVydGV4Q29sb3JzID09PSBUSFJFRS5GYWNlQ29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2NvbG9yLm11bHRpcGx5KCBlbGVtZW50LmNvbG9yICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHQ/IHN0cm9rZVBhdGgoIF9jb2xvciwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiApXHJcblx0XHRcdFx0XHRcdDogZmlsbFBhdGgoIF9jb2xvciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRfbmVhciA9IGNhbWVyYS5uZWFyO1xyXG5cdFx0XHRcdF9mYXIgPSBjYW1lcmEuZmFyO1xyXG5cclxuXHRcdFx0XHRfY29sb3IxLnIgPSBfY29sb3IxLmcgPSBfY29sb3IxLmIgPSAxIC0gc21vb3Roc3RlcCggdjEucG9zaXRpb25TY3JlZW4ueiAqIHYxLnBvc2l0aW9uU2NyZWVuLncsIF9uZWFyLCBfZmFyICk7XHJcblx0XHRcdFx0X2NvbG9yMi5yID0gX2NvbG9yMi5nID0gX2NvbG9yMi5iID0gMSAtIHNtb290aHN0ZXAoIHYyLnBvc2l0aW9uU2NyZWVuLnogKiB2Mi5wb3NpdGlvblNjcmVlbi53LCBfbmVhciwgX2ZhciApO1xyXG5cdFx0XHRcdF9jb2xvcjMuciA9IF9jb2xvcjMuZyA9IF9jb2xvcjMuYiA9IDEgLSBzbW9vdGhzdGVwKCB2My5wb3NpdGlvblNjcmVlbi56ICogdjMucG9zaXRpb25TY3JlZW4udywgX25lYXIsIF9mYXIgKTtcclxuXHRcdFx0XHRfY29sb3I0LmFkZENvbG9ycyggX2NvbG9yMiwgX2NvbG9yMyApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0X2ltYWdlID0gZ2V0R3JhZGllbnRUZXh0dXJlKCBfY29sb3IxLCBfY29sb3IyLCBfY29sb3IzLCBfY29sb3I0ICk7XHJcblxyXG5cdFx0XHRcdGNsaXBJbWFnZSggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgMCwgMCwgMSwgMCwgMCwgMSwgX2ltYWdlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hOb3JtYWxNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0dmFyIG5vcm1hbDtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC5zaGFkaW5nID09IFRIUkVFLkZsYXRTaGFkaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbCA9IGVsZW1lbnQubm9ybWFsTW9kZWxWaWV3O1xyXG5cclxuXHRcdFx0XHRcdF9jb2xvci5zZXRSR0IoIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKS5tdWx0aXBseVNjYWxhciggMC41ICkuYWRkU2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWVcclxuXHRcdFx0XHRcdFx0PyBzdHJva2VQYXRoKCBfY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKVxyXG5cdFx0XHRcdFx0XHQ6IGZpbGxQYXRoKCBfY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc2hhZGluZyA9PSBUSFJFRS5TbW9vdGhTaGFkaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbCA9IGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsVmlld1sgdXYxIF07XHJcblx0XHRcdFx0XHRfY29sb3IxLnNldFJHQiggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApLm11bHRpcGx5U2NhbGFyKCAwLjUgKS5hZGRTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbCA9IGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsVmlld1sgdXYyIF07XHJcblx0XHRcdFx0XHRfY29sb3IyLnNldFJHQiggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApLm11bHRpcGx5U2NhbGFyKCAwLjUgKS5hZGRTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbCA9IGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsVmlld1sgdXYzIF07XHJcblx0XHRcdFx0XHRfY29sb3IzLnNldFJHQiggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApLm11bHRpcGx5U2NhbGFyKCAwLjUgKS5hZGRTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0XHRcdF9jb2xvcjQuYWRkQ29sb3JzKCBfY29sb3IyLCBfY29sb3IzICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0XHRcdF9pbWFnZSA9IGdldEdyYWRpZW50VGV4dHVyZSggX2NvbG9yMSwgX2NvbG9yMiwgX2NvbG9yMywgX2NvbG9yNCApO1xyXG5cclxuXHRcdFx0XHRcdGNsaXBJbWFnZSggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgMCwgMCwgMSwgMCwgMCwgMSwgX2ltYWdlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmVuZGVyRmFjZTQoIHYxLCB2MiwgdjMsIHY0LCB2NSwgdjYsIGVsZW1lbnQsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgKz0gNDtcclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKys7XHJcblxyXG5cdFx0XHRzZXRPcGFjaXR5KCBtYXRlcmlhbC5vcGFjaXR5ICk7XHJcblx0XHRcdHNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZyApO1xyXG5cclxuXHRcdFx0aWYgKCAoIG1hdGVyaWFsLm1hcCAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHx8ICggbWF0ZXJpYWwuZW52TWFwICE9PSB1bmRlZmluZWQgJiYgbWF0ZXJpYWwuZW52TWFwICE9PSBudWxsICkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIExldCByZW5kZXJGYWNlMygpIGhhbmRsZSB0aGlzXHJcblxyXG5cdFx0XHRcdHJlbmRlckZhY2UzKCB2MSwgdjIsIHY0LCAwLCAxLCAzLCBlbGVtZW50LCBtYXRlcmlhbCApO1xyXG5cdFx0XHRcdHJlbmRlckZhY2UzKCB2NSwgdjMsIHY2LCAxLCAyLCAzLCBlbGVtZW50LCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfdjF4ID0gdjEucG9zaXRpb25TY3JlZW4ueDsgX3YxeSA9IHYxLnBvc2l0aW9uU2NyZWVuLnk7XHJcblx0XHRcdF92MnggPSB2Mi5wb3NpdGlvblNjcmVlbi54OyBfdjJ5ID0gdjIucG9zaXRpb25TY3JlZW4ueTtcclxuXHRcdFx0X3YzeCA9IHYzLnBvc2l0aW9uU2NyZWVuLng7IF92M3kgPSB2My5wb3NpdGlvblNjcmVlbi55O1xyXG5cdFx0XHRfdjR4ID0gdjQucG9zaXRpb25TY3JlZW4ueDsgX3Y0eSA9IHY0LnBvc2l0aW9uU2NyZWVuLnk7XHJcblx0XHRcdF92NXggPSB2NS5wb3NpdGlvblNjcmVlbi54OyBfdjV5ID0gdjUucG9zaXRpb25TY3JlZW4ueTtcclxuXHRcdFx0X3Y2eCA9IHY2LnBvc2l0aW9uU2NyZWVuLng7IF92NnkgPSB2Ni5wb3NpdGlvblNjcmVlbi55O1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hMYW1iZXJ0TWF0ZXJpYWwgfHwgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0X2RpZmZ1c2VDb2xvci5jb3B5KCBtYXRlcmlhbC5jb2xvciApO1xyXG5cdFx0XHRcdF9lbWlzc2l2ZUNvbG9yLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICk7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwudmVydGV4Q29sb3JzID09PSBUSFJFRS5GYWNlQ29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRcdF9kaWZmdXNlQ29sb3IubXVsdGlwbHkoIGVsZW1lbnQuY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIF9lbmFibGVMaWdodGluZyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gZmFsc2UgJiYgbWF0ZXJpYWwuc2hhZGluZyA9PSBUSFJFRS5TbW9vdGhTaGFkaW5nICYmIGVsZW1lbnQudmVydGV4Tm9ybWFsc0xlbmd0aCA9PSA0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2NvbG9yMS5jb3B5KCBfYW1iaWVudExpZ2h0ICk7XHJcblx0XHRcdFx0XHRcdF9jb2xvcjIuY29weSggX2FtYmllbnRMaWdodCApO1xyXG5cdFx0XHRcdFx0XHRfY29sb3IzLmNvcHkoIF9hbWJpZW50TGlnaHQgKTtcclxuXHRcdFx0XHRcdFx0X2NvbG9yNC5jb3B5KCBfYW1iaWVudExpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRjYWxjdWxhdGVMaWdodCggZWxlbWVudC52MS5wb3NpdGlvbldvcmxkLCBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFsgMCBdLCBfY29sb3IxICk7XHJcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBlbGVtZW50LnYyLnBvc2l0aW9uV29ybGQsIGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsWyAxIF0sIF9jb2xvcjIgKTtcclxuXHRcdFx0XHRcdFx0Y2FsY3VsYXRlTGlnaHQoIGVsZW1lbnQudjQucG9zaXRpb25Xb3JsZCwgZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxbIDMgXSwgX2NvbG9yMyApO1xyXG5cdFx0XHRcdFx0XHRjYWxjdWxhdGVMaWdodCggZWxlbWVudC52My5wb3NpdGlvbldvcmxkLCBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFsgMiBdLCBfY29sb3I0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRfY29sb3IxLm11bHRpcGx5KCBfZGlmZnVzZUNvbG9yICkuYWRkKCBfZW1pc3NpdmVDb2xvciApO1xyXG5cdFx0XHRcdFx0XHRfY29sb3IyLm11bHRpcGx5KCBfZGlmZnVzZUNvbG9yICkuYWRkKCBfZW1pc3NpdmVDb2xvciApO1xyXG5cdFx0XHRcdFx0XHRfY29sb3IzLm11bHRpcGx5KCBfZGlmZnVzZUNvbG9yICkuYWRkKCBfZW1pc3NpdmVDb2xvciApO1xyXG5cdFx0XHRcdFx0XHRfY29sb3I0Lm11bHRpcGx5KCBfZGlmZnVzZUNvbG9yICkuYWRkKCBfZW1pc3NpdmVDb2xvciApO1xyXG5cclxuXHRcdFx0XHRcdFx0X2ltYWdlID0gZ2V0R3JhZGllbnRUZXh0dXJlKCBfY29sb3IxLCBfY29sb3IyLCBfY29sb3IzLCBfY29sb3I0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBVVnMgYXJlIGluY29ycmVjdCwgdjQtPnYzP1xyXG5cclxuXHRcdFx0XHRcdFx0ZHJhd1RyaWFuZ2xlKCBfdjF4LCBfdjF5LCBfdjJ4LCBfdjJ5LCBfdjR4LCBfdjR5ICk7XHJcblx0XHRcdFx0XHRcdGNsaXBJbWFnZSggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3Y0eCwgX3Y0eSwgMCwgMCwgMSwgMCwgMCwgMSwgX2ltYWdlICk7XHJcblxyXG5cdFx0XHRcdFx0XHRkcmF3VHJpYW5nbGUoIF92NXgsIF92NXksIF92M3gsIF92M3ksIF92NngsIF92NnkgKTtcclxuXHRcdFx0XHRcdFx0Y2xpcEltYWdlKCBfdjV4LCBfdjV5LCBfdjN4LCBfdjN5LCBfdjZ4LCBfdjZ5LCAxLCAwLCAxLCAxLCAwLCAxLCBfaW1hZ2UgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0X2NvbG9yLmNvcHkoIF9hbWJpZW50TGlnaHQgKTtcclxuXHJcblx0XHRcdFx0XHRcdGNhbGN1bGF0ZUxpZ2h0KCBlbGVtZW50LmNlbnRyb2lkTW9kZWwsIGVsZW1lbnQubm9ybWFsTW9kZWwsIF9jb2xvciApO1xyXG5cclxuXHRcdFx0XHRcdFx0X2NvbG9yLm11bHRpcGx5KCBfZGlmZnVzZUNvbG9yICkuYWRkKCBfZW1pc3NpdmVDb2xvciApO1xyXG5cclxuXHRcdFx0XHRcdFx0ZHJhd1F1YWQoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksIF92NHgsIF92NHkgKTtcclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHRcdD8gc3Ryb2tlUGF0aCggX2NvbG9yLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGgsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVjYXAsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luIClcclxuXHRcdFx0XHRcdFx0XHQ6IGZpbGxQYXRoKCBfY29sb3IgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X2NvbG9yLmFkZENvbG9ycyggX2RpZmZ1c2VDb2xvciwgX2VtaXNzaXZlQ29sb3IgKTtcclxuXHJcblx0XHRcdFx0XHRkcmF3UXVhZCggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3YzeCwgX3YzeSwgX3Y0eCwgX3Y0eSApO1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZVxyXG5cdFx0XHRcdFx0XHQ/IHN0cm9rZVBhdGgoIF9jb2xvciwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiApXHJcblx0XHRcdFx0XHRcdDogZmlsbFBhdGgoIF9jb2xvciApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRfY29sb3IuY29weSggbWF0ZXJpYWwuY29sb3IgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPT09IFRIUkVFLkZhY2VDb2xvcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2NvbG9yLm11bHRpcGx5KCBlbGVtZW50LmNvbG9yICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZHJhd1F1YWQoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksIF92NHgsIF92NHkgKTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlXHJcblx0XHRcdFx0XHQ/IHN0cm9rZVBhdGgoIF9jb2xvciwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lY2FwLCBtYXRlcmlhbC53aXJlZnJhbWVMaW5lam9pbiApXHJcblx0XHRcdFx0XHQ6IGZpbGxQYXRoKCBfY29sb3IgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbm9ybWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIG1hdGVyaWFsLnNoYWRpbmcgPT0gVEhSRUUuRmxhdFNoYWRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsID0gZWxlbWVudC5ub3JtYWxNb2RlbFZpZXc7XHJcblx0XHRcdFx0XHRfY29sb3Iuc2V0UkdCKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApLmFkZFNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRcdFx0ZHJhd1F1YWQoIF92MXgsIF92MXksIF92MngsIF92MnksIF92M3gsIF92M3ksIF92NHgsIF92NHkgKTtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbC53aXJlZnJhbWUgPT09IHRydWVcclxuXHRcdFx0XHRcdFx0PyBzdHJva2VQYXRoKCBfY29sb3IsIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCwgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWpvaW4gKVxyXG5cdFx0XHRcdFx0XHQ6IGZpbGxQYXRoKCBfY29sb3IgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuc2hhZGluZyA9PSBUSFJFRS5TbW9vdGhTaGFkaW5nICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbCA9IGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsVmlld1sgMCBdO1xyXG5cdFx0XHRcdFx0X2NvbG9yMS5zZXRSR0IoIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKS5tdWx0aXBseVNjYWxhciggMC41ICkuYWRkU2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRub3JtYWwgPSBlbGVtZW50LnZlcnRleE5vcm1hbHNNb2RlbFZpZXdbIDEgXTtcclxuXHRcdFx0XHRcdF9jb2xvcjIuc2V0UkdCKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApLmFkZFNjYWxhciggMC41ICk7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsID0gZWxlbWVudC52ZXJ0ZXhOb3JtYWxzTW9kZWxWaWV3WyAzIF07XHJcblx0XHRcdFx0XHRfY29sb3IzLnNldFJHQiggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApLm11bHRpcGx5U2NhbGFyKCAwLjUgKS5hZGRTY2FsYXIoIDAuNSApO1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbCA9IGVsZW1lbnQudmVydGV4Tm9ybWFsc01vZGVsVmlld1sgMiBdO1xyXG5cdFx0XHRcdFx0X2NvbG9yNC5zZXRSR0IoIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKS5tdWx0aXBseVNjYWxhciggMC41ICkuYWRkU2NhbGFyKCAwLjUgKTtcclxuXHJcblx0XHRcdFx0XHRfaW1hZ2UgPSBnZXRHcmFkaWVudFRleHR1cmUoIF9jb2xvcjEsIF9jb2xvcjIsIF9jb2xvcjMsIF9jb2xvcjQgKTtcclxuXHJcblx0XHRcdFx0XHRkcmF3VHJpYW5nbGUoIF92MXgsIF92MXksIF92MngsIF92MnksIF92NHgsIF92NHkgKTtcclxuXHRcdFx0XHRcdGNsaXBJbWFnZSggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3Y0eCwgX3Y0eSwgMCwgMCwgMSwgMCwgMCwgMSwgX2ltYWdlICk7XHJcblxyXG5cdFx0XHRcdFx0ZHJhd1RyaWFuZ2xlKCBfdjV4LCBfdjV5LCBfdjN4LCBfdjN5LCBfdjZ4LCBfdjZ5ICk7XHJcblx0XHRcdFx0XHRjbGlwSW1hZ2UoIF92NXgsIF92NXksIF92M3gsIF92M3ksIF92NngsIF92NnksIDEsIDAsIDEsIDEsIDAsIDEsIF9pbWFnZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdF9uZWFyID0gY2FtZXJhLm5lYXI7XHJcblx0XHRcdFx0X2ZhciA9IGNhbWVyYS5mYXI7XHJcblxyXG5cdFx0XHRcdF9jb2xvcjEuciA9IF9jb2xvcjEuZyA9IF9jb2xvcjEuYiA9IDEgLSBzbW9vdGhzdGVwKCB2MS5wb3NpdGlvblNjcmVlbi56ICogdjEucG9zaXRpb25TY3JlZW4udywgX25lYXIsIF9mYXIgKTtcclxuXHRcdFx0XHRfY29sb3IyLnIgPSBfY29sb3IyLmcgPSBfY29sb3IyLmIgPSAxIC0gc21vb3Roc3RlcCggdjIucG9zaXRpb25TY3JlZW4ueiAqIHYyLnBvc2l0aW9uU2NyZWVuLncsIF9uZWFyLCBfZmFyICk7XHJcblx0XHRcdFx0X2NvbG9yMy5yID0gX2NvbG9yMy5nID0gX2NvbG9yMy5iID0gMSAtIHNtb290aHN0ZXAoIHY0LnBvc2l0aW9uU2NyZWVuLnogKiB2NC5wb3NpdGlvblNjcmVlbi53LCBfbmVhciwgX2ZhciApO1xyXG5cdFx0XHRcdF9jb2xvcjQuciA9IF9jb2xvcjQuZyA9IF9jb2xvcjQuYiA9IDEgLSBzbW9vdGhzdGVwKCB2My5wb3NpdGlvblNjcmVlbi56ICogdjMucG9zaXRpb25TY3JlZW4udywgX25lYXIsIF9mYXIgKTtcclxuXHJcblx0XHRcdFx0X2ltYWdlID0gZ2V0R3JhZGllbnRUZXh0dXJlKCBfY29sb3IxLCBfY29sb3IyLCBfY29sb3IzLCBfY29sb3I0ICk7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IFVWcyBhcmUgaW5jb3JyZWN0LCB2NC0+djM/XHJcblxyXG5cdFx0XHRcdGRyYXdUcmlhbmdsZSggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3Y0eCwgX3Y0eSApO1xyXG5cdFx0XHRcdGNsaXBJbWFnZSggX3YxeCwgX3YxeSwgX3YyeCwgX3YyeSwgX3Y0eCwgX3Y0eSwgMCwgMCwgMSwgMCwgMCwgMSwgX2ltYWdlICk7XHJcblxyXG5cdFx0XHRcdGRyYXdUcmlhbmdsZSggX3Y1eCwgX3Y1eSwgX3YzeCwgX3YzeSwgX3Y2eCwgX3Y2eSApO1xyXG5cdFx0XHRcdGNsaXBJbWFnZSggX3Y1eCwgX3Y1eSwgX3YzeCwgX3YzeSwgX3Y2eCwgX3Y2eSwgMSwgMCwgMSwgMSwgMCwgMSwgX2ltYWdlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0ZnVuY3Rpb24gZHJhd1RyaWFuZ2xlKCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuYmVnaW5QYXRoKCk7XHJcblx0XHRcdF9jb250ZXh0Lm1vdmVUbyggeDAsIHkwICk7XHJcblx0XHRcdF9jb250ZXh0LmxpbmVUbyggeDEsIHkxICk7XHJcblx0XHRcdF9jb250ZXh0LmxpbmVUbyggeDIsIHkyICk7XHJcblx0XHRcdF9jb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBkcmF3UXVhZCggeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuYmVnaW5QYXRoKCk7XHJcblx0XHRcdF9jb250ZXh0Lm1vdmVUbyggeDAsIHkwICk7XHJcblx0XHRcdF9jb250ZXh0LmxpbmVUbyggeDEsIHkxICk7XHJcblx0XHRcdF9jb250ZXh0LmxpbmVUbyggeDIsIHkyICk7XHJcblx0XHRcdF9jb250ZXh0LmxpbmVUbyggeDMsIHkzICk7XHJcblx0XHRcdF9jb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBzdHJva2VQYXRoKCBjb2xvciwgbGluZXdpZHRoLCBsaW5lY2FwLCBsaW5lam9pbiApIHtcclxuXHJcblx0XHRcdHNldExpbmVXaWR0aCggbGluZXdpZHRoICk7XHJcblx0XHRcdHNldExpbmVDYXAoIGxpbmVjYXAgKTtcclxuXHRcdFx0c2V0TGluZUpvaW4oIGxpbmVqb2luICk7XHJcblx0XHRcdHNldFN0cm9rZVN0eWxlKCBjb2xvci5nZXRTdHlsZSgpICk7XHJcblxyXG5cdFx0XHRfY29udGV4dC5zdHJva2UoKTtcclxuXHJcblx0XHRcdF9lbGVtQm94LmV4cGFuZEJ5U2NhbGFyKCBsaW5ld2lkdGggKiAyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGZpbGxQYXRoKCBjb2xvciApIHtcclxuXHJcblx0XHRcdHNldEZpbGxTdHlsZSggY29sb3IuZ2V0U3R5bGUoKSApO1xyXG5cdFx0XHRfY29udGV4dC5maWxsKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIHBhdHRlcm5QYXRoKCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB1MCwgdjAsIHUxLCB2MSwgdTIsIHYyLCB0ZXh0dXJlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlIGluc3RhbmNlb2YgVEhSRUUuRGF0YVRleHR1cmUgfHwgdGV4dHVyZS5pbWFnZSA9PT0gdW5kZWZpbmVkIHx8IHRleHR1cmUuaW1hZ2Uud2lkdGggPT0gMCApIHJldHVybjtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5uZWVkc1VwZGF0ZSA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0dmFyIHJlcGVhdFggPSB0ZXh0dXJlLndyYXBTID09IFRIUkVFLlJlcGVhdFdyYXBwaW5nO1xyXG5cdFx0XHRcdHZhciByZXBlYXRZID0gdGV4dHVyZS53cmFwVCA9PSBUSFJFRS5SZXBlYXRXcmFwcGluZztcclxuXHJcblx0XHRcdFx0X3BhdHRlcm5zWyB0ZXh0dXJlLmlkIF0gPSBfY29udGV4dC5jcmVhdGVQYXR0ZXJuKFxyXG5cdFx0XHRcdFx0dGV4dHVyZS5pbWFnZSwgcmVwZWF0WCA9PT0gdHJ1ZSAmJiByZXBlYXRZID09PSB0cnVlXHJcblx0XHRcdFx0XHRcdD8gJ3JlcGVhdCdcclxuXHRcdFx0XHRcdFx0OiByZXBlYXRYID09PSB0cnVlICYmIHJlcGVhdFkgPT09IGZhbHNlXHJcblx0XHRcdFx0XHRcdFx0PyAncmVwZWF0LXgnXHJcblx0XHRcdFx0XHRcdFx0OiByZXBlYXRYID09PSBmYWxzZSAmJiByZXBlYXRZID09PSB0cnVlXHJcblx0XHRcdFx0XHRcdFx0XHQ/ICdyZXBlYXQteSdcclxuXHRcdFx0XHRcdFx0XHRcdDogJ25vLXJlcGVhdCdcclxuXHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfcGF0dGVybnNbIHRleHR1cmUuaWQgXSA9PT0gdW5kZWZpbmVkXHJcblx0XHRcdFx0PyBzZXRGaWxsU3R5bGUoICdyZ2JhKDAsMCwwLDEpJyApXHJcblx0XHRcdFx0OiBzZXRGaWxsU3R5bGUoIF9wYXR0ZXJuc1sgdGV4dHVyZS5pZCBdICk7XHJcblxyXG5cdFx0XHQvLyBodHRwOi8vZXh0cmVtZWx5c2F0aXNmYWN0b3J5dG90YWxpdGFyaWFuaXNtLmNvbS9ibG9nLz9wPTIxMjBcclxuXHJcblx0XHRcdHZhciBhLCBiLCBjLCBkLCBlLCBmLCBkZXQsIGlkZXQsXHJcblx0XHRcdG9mZnNldFggPSB0ZXh0dXJlLm9mZnNldC54IC8gdGV4dHVyZS5yZXBlYXQueCxcclxuXHRcdFx0b2Zmc2V0WSA9IHRleHR1cmUub2Zmc2V0LnkgLyB0ZXh0dXJlLnJlcGVhdC55LFxyXG5cdFx0XHR3aWR0aCA9IHRleHR1cmUuaW1hZ2Uud2lkdGggKiB0ZXh0dXJlLnJlcGVhdC54LFxyXG5cdFx0XHRoZWlnaHQgPSB0ZXh0dXJlLmltYWdlLmhlaWdodCAqIHRleHR1cmUucmVwZWF0Lnk7XHJcblxyXG5cdFx0XHR1MCA9ICggdTAgKyBvZmZzZXRYICkgKiB3aWR0aDtcclxuXHRcdFx0djAgPSAoIDEuMCAtIHYwICsgb2Zmc2V0WSApICogaGVpZ2h0O1xyXG5cclxuXHRcdFx0dTEgPSAoIHUxICsgb2Zmc2V0WCApICogd2lkdGg7XHJcblx0XHRcdHYxID0gKCAxLjAgLSB2MSArIG9mZnNldFkgKSAqIGhlaWdodDtcclxuXHJcblx0XHRcdHUyID0gKCB1MiArIG9mZnNldFggKSAqIHdpZHRoO1xyXG5cdFx0XHR2MiA9ICggMS4wIC0gdjIgKyBvZmZzZXRZICkgKiBoZWlnaHQ7XHJcblxyXG5cdFx0XHR4MSAtPSB4MDsgeTEgLT0geTA7XHJcblx0XHRcdHgyIC09IHgwOyB5MiAtPSB5MDtcclxuXHJcblx0XHRcdHUxIC09IHUwOyB2MSAtPSB2MDtcclxuXHRcdFx0dTIgLT0gdTA7IHYyIC09IHYwO1xyXG5cclxuXHRcdFx0ZGV0ID0gdTEgKiB2MiAtIHUyICogdjE7XHJcblxyXG5cdFx0XHRpZiAoIGRldCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBfaW1hZ2VkYXRhc1sgdGV4dHVyZS5pZCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnIClcclxuXHRcdFx0XHRcdGNhbnZhcy53aWR0aCA9IHRleHR1cmUuaW1hZ2Uud2lkdGg7XHJcblx0XHRcdFx0XHRjYW52YXMuaGVpZ2h0ID0gdGV4dHVyZS5pbWFnZS5oZWlnaHQ7XHJcblxyXG5cdFx0XHRcdFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xyXG5cdFx0XHRcdFx0Y29udGV4dC5kcmF3SW1hZ2UoIHRleHR1cmUuaW1hZ2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHRfaW1hZ2VkYXRhc1sgdGV4dHVyZS5pZCBdID0gY29udGV4dC5nZXRJbWFnZURhdGEoIDAsIDAsIHRleHR1cmUuaW1hZ2Uud2lkdGgsIHRleHR1cmUuaW1hZ2UuaGVpZ2h0ICkuZGF0YTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgZGF0YSA9IF9pbWFnZWRhdGFzWyB0ZXh0dXJlLmlkIF07XHJcblx0XHRcdFx0dmFyIGluZGV4ID0gKCBNYXRoLmZsb29yKCB1MCApICsgTWF0aC5mbG9vciggdjAgKSAqIHRleHR1cmUuaW1hZ2Uud2lkdGggKSAqIDQ7XHJcblxyXG5cdFx0XHRcdF9jb2xvci5zZXRSR0IoIGRhdGFbIGluZGV4IF0gLyAyNTUsIGRhdGFbIGluZGV4ICsgMSBdIC8gMjU1LCBkYXRhWyBpbmRleCArIDIgXSAvIDI1NSApO1xyXG5cdFx0XHRcdGZpbGxQYXRoKCBfY29sb3IgKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWRldCA9IDEgLyBkZXQ7XHJcblxyXG5cdFx0XHRhID0gKCB2MiAqIHgxIC0gdjEgKiB4MiApICogaWRldDtcclxuXHRcdFx0YiA9ICggdjIgKiB5MSAtIHYxICogeTIgKSAqIGlkZXQ7XHJcblx0XHRcdGMgPSAoIHUxICogeDIgLSB1MiAqIHgxICkgKiBpZGV0O1xyXG5cdFx0XHRkID0gKCB1MSAqIHkyIC0gdTIgKiB5MSApICogaWRldDtcclxuXHJcblx0XHRcdGUgPSB4MCAtIGEgKiB1MCAtIGMgKiB2MDtcclxuXHRcdFx0ZiA9IHkwIC0gYiAqIHUwIC0gZCAqIHYwO1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc2F2ZSgpO1xyXG5cdFx0XHRfY29udGV4dC50cmFuc2Zvcm0oIGEsIGIsIGMsIGQsIGUsIGYgKTtcclxuXHRcdFx0X2NvbnRleHQuZmlsbCgpO1xyXG5cdFx0XHRfY29udGV4dC5yZXN0b3JlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNsaXBJbWFnZSggeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgdTAsIHYwLCB1MSwgdjEsIHUyLCB2MiwgaW1hZ2UgKSB7XHJcblxyXG5cdFx0XHQvLyBodHRwOi8vZXh0cmVtZWx5c2F0aXNmYWN0b3J5dG90YWxpdGFyaWFuaXNtLmNvbS9ibG9nLz9wPTIxMjBcclxuXHJcblx0XHRcdHZhciBhLCBiLCBjLCBkLCBlLCBmLCBkZXQsIGlkZXQsXHJcblx0XHRcdHdpZHRoID0gaW1hZ2Uud2lkdGggLSAxLFxyXG5cdFx0XHRoZWlnaHQgPSBpbWFnZS5oZWlnaHQgLSAxO1xyXG5cclxuXHRcdFx0dTAgKj0gd2lkdGg7IHYwICo9IGhlaWdodDtcclxuXHRcdFx0dTEgKj0gd2lkdGg7IHYxICo9IGhlaWdodDtcclxuXHRcdFx0dTIgKj0gd2lkdGg7IHYyICo9IGhlaWdodDtcclxuXHJcblx0XHRcdHgxIC09IHgwOyB5MSAtPSB5MDtcclxuXHRcdFx0eDIgLT0geDA7IHkyIC09IHkwO1xyXG5cclxuXHRcdFx0dTEgLT0gdTA7IHYxIC09IHYwO1xyXG5cdFx0XHR1MiAtPSB1MDsgdjIgLT0gdjA7XHJcblxyXG5cdFx0XHRkZXQgPSB1MSAqIHYyIC0gdTIgKiB2MTtcclxuXHJcblx0XHRcdGlkZXQgPSAxIC8gZGV0O1xyXG5cclxuXHRcdFx0YSA9ICggdjIgKiB4MSAtIHYxICogeDIgKSAqIGlkZXQ7XHJcblx0XHRcdGIgPSAoIHYyICogeTEgLSB2MSAqIHkyICkgKiBpZGV0O1xyXG5cdFx0XHRjID0gKCB1MSAqIHgyIC0gdTIgKiB4MSApICogaWRldDtcclxuXHRcdFx0ZCA9ICggdTEgKiB5MiAtIHUyICogeTEgKSAqIGlkZXQ7XHJcblxyXG5cdFx0XHRlID0geDAgLSBhICogdTAgLSBjICogdjA7XHJcblx0XHRcdGYgPSB5MCAtIGIgKiB1MCAtIGQgKiB2MDtcclxuXHJcblx0XHRcdF9jb250ZXh0LnNhdmUoKTtcclxuXHRcdFx0X2NvbnRleHQudHJhbnNmb3JtKCBhLCBiLCBjLCBkLCBlLCBmICk7XHJcblx0XHRcdF9jb250ZXh0LmNsaXAoKTtcclxuXHRcdFx0X2NvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCApO1xyXG5cdFx0XHRfY29udGV4dC5yZXN0b3JlKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGdldEdyYWRpZW50VGV4dHVyZSggY29sb3IxLCBjb2xvcjIsIGNvbG9yMywgY29sb3I0ICkge1xyXG5cclxuXHRcdFx0Ly8gaHR0cDovL21yZG9vYi5jb20vYmxvZy9wb3N0LzcxMFxyXG5cclxuXHRcdFx0X3BpeGVsTWFwRGF0YVsgMCBdID0gKCBjb2xvcjEuciAqIDI1NSApIHwgMDtcclxuXHRcdFx0X3BpeGVsTWFwRGF0YVsgMSBdID0gKCBjb2xvcjEuZyAqIDI1NSApIHwgMDtcclxuXHRcdFx0X3BpeGVsTWFwRGF0YVsgMiBdID0gKCBjb2xvcjEuYiAqIDI1NSApIHwgMDtcclxuXHJcblx0XHRcdF9waXhlbE1hcERhdGFbIDQgXSA9ICggY29sb3IyLnIgKiAyNTUgKSB8IDA7XHJcblx0XHRcdF9waXhlbE1hcERhdGFbIDUgXSA9ICggY29sb3IyLmcgKiAyNTUgKSB8IDA7XHJcblx0XHRcdF9waXhlbE1hcERhdGFbIDYgXSA9ICggY29sb3IyLmIgKiAyNTUgKSB8IDA7XHJcblxyXG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyA4IF0gPSAoIGNvbG9yMy5yICogMjU1ICkgfCAwO1xyXG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyA5IF0gPSAoIGNvbG9yMy5nICogMjU1ICkgfCAwO1xyXG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyAxMCBdID0gKCBjb2xvcjMuYiAqIDI1NSApIHwgMDtcclxuXHJcblx0XHRcdF9waXhlbE1hcERhdGFbIDEyIF0gPSAoIGNvbG9yNC5yICogMjU1ICkgfCAwO1xyXG5cdFx0XHRfcGl4ZWxNYXBEYXRhWyAxMyBdID0gKCBjb2xvcjQuZyAqIDI1NSApIHwgMDtcclxuXHRcdFx0X3BpeGVsTWFwRGF0YVsgMTQgXSA9ICggY29sb3I0LmIgKiAyNTUgKSB8IDA7XHJcblxyXG5cdFx0XHRfcGl4ZWxNYXBDb250ZXh0LnB1dEltYWdlRGF0YSggX3BpeGVsTWFwSW1hZ2UsIDAsIDAgKTtcclxuXHRcdFx0X2dyYWRpZW50TWFwQ29udGV4dC5kcmF3SW1hZ2UoIF9waXhlbE1hcCwgMCwgMCApO1xyXG5cclxuXHRcdFx0cmV0dXJuIF9ncmFkaWVudE1hcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gSGlkZSBhbnRpLWFsaWFzIGdhcHNcclxuXHJcblx0XHRmdW5jdGlvbiBleHBhbmQoIHYxLCB2MiApIHtcclxuXHJcblx0XHRcdHZhciB4ID0gdjIueCAtIHYxLngsIHkgPSAgdjIueSAtIHYxLnksXHJcblx0XHRcdGRldCA9IHggKiB4ICsgeSAqIHksIGlkZXQ7XHJcblxyXG5cdFx0XHRpZiAoIGRldCA9PT0gMCApIHJldHVybjtcclxuXHJcblx0XHRcdGlkZXQgPSAxIC8gTWF0aC5zcXJ0KCBkZXQgKTtcclxuXHJcblx0XHRcdHggKj0gaWRldDsgeSAqPSBpZGV0O1xyXG5cclxuXHRcdFx0djIueCArPSB4OyB2Mi55ICs9IHk7XHJcblx0XHRcdHYxLnggLT0geDsgdjEueSAtPSB5O1xyXG5cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvLyBDb250ZXh0IGNhY2hlZCBtZXRob2RzLlxyXG5cclxuXHRmdW5jdGlvbiBzZXRPcGFjaXR5KCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0R2xvYmFsQWxwaGEgIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuZ2xvYmFsQWxwaGEgPSB2YWx1ZTtcclxuXHRcdFx0X2NvbnRleHRHbG9iYWxBbHBoYSA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRCbGVuZGluZyggdmFsdWUgKSB7XHJcblxyXG5cdFx0aWYgKCBfY29udGV4dEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiAhPT0gdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHZhbHVlID09PSBUSFJFRS5Ob3JtYWxCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHZhbHVlID09PSBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHRfY29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnbGlnaHRlcic7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gVEhSRUUuU3VidHJhY3RpdmVCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0X2NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rhcmtlcic7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfY29udGV4dEdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRMaW5lV2lkdGgoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggX2NvbnRleHRMaW5lV2lkdGggIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQubGluZVdpZHRoID0gdmFsdWU7XHJcblx0XHRcdF9jb250ZXh0TGluZVdpZHRoID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldExpbmVDYXAoIHZhbHVlICkge1xyXG5cclxuXHRcdC8vIFwiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0TGluZUNhcCAhPT0gdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRfY29udGV4dC5saW5lQ2FwID0gdmFsdWU7XHJcblx0XHRcdF9jb250ZXh0TGluZUNhcCA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRMaW5lSm9pbiggdmFsdWUgKSB7XHJcblxyXG5cdFx0Ly8gXCJyb3VuZFwiLCBcImJldmVsXCIsIFwibWl0ZXJcIlxyXG5cclxuXHRcdGlmICggX2NvbnRleHRMaW5lSm9pbiAhPT0gdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRfY29udGV4dC5saW5lSm9pbiA9IHZhbHVlO1xyXG5cdFx0XHRfY29udGV4dExpbmVKb2luID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldFN0cm9rZVN0eWxlKCB2YWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0U3Ryb2tlU3R5bGUgIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuc3Ryb2tlU3R5bGUgPSB2YWx1ZTtcclxuXHRcdFx0X2NvbnRleHRTdHJva2VTdHlsZSA9IHZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRGaWxsU3R5bGUoIHZhbHVlICkge1xyXG5cclxuXHRcdGlmICggX2NvbnRleHRGaWxsU3R5bGUgIT09IHZhbHVlICkge1xyXG5cclxuXHRcdFx0X2NvbnRleHQuZmlsbFN0eWxlID0gdmFsdWU7XHJcblx0XHRcdF9jb250ZXh0RmlsbFN0eWxlID0gdmFsdWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldERhc2hBbmRHYXAoIGRhc2hTaXplVmFsdWUsIGdhcFNpemVWYWx1ZSApIHtcclxuXHJcblx0XHRpZiAoIF9jb250ZXh0RGFzaFNpemUgIT09IGRhc2hTaXplVmFsdWUgfHwgX2NvbnRleHRHYXBTaXplICE9PSBnYXBTaXplVmFsdWUgKSB7XHJcblxyXG5cdFx0XHRfY29udGV4dC5zZXRMaW5lRGFzaCggWyBkYXNoU2l6ZVZhbHVlLCBnYXBTaXplVmFsdWUgXSApO1xyXG5cdFx0XHRfY29udGV4dERhc2hTaXplID0gZGFzaFNpemVWYWx1ZTtcclxuXHRcdFx0X2NvbnRleHRHYXBTaXplID0gZ2FwU2l6ZVZhbHVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqL1xyXG5cclxuVEhSRUUuU2hhZGVyQ2h1bmsgPSB7XHJcblxyXG5cdC8vIEZPR1xyXG5cclxuXHRmb2dfcGFyc19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9GT0dcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRk9HX0VYUDJcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBmb2dOZWFyO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBmb2dGYXI7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRmb2dfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfRk9HXCIsXHJcblxyXG5cdFx0XHRcImZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEZPR19FWFAyXCIsXHJcblxyXG5cdFx0XHRcdFwiY29uc3QgZmxvYXQgTE9HMiA9IDEuNDQyNjk1O1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7XCIsXHJcblx0XHRcdFx0XCJmb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZGVwdGggKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcImdsX0ZyYWdDb2xvciA9IG1peCggZ2xfRnJhZ0NvbG9yLCB2ZWM0KCBmb2dDb2xvciwgZ2xfRnJhZ0NvbG9yLncgKSwgZm9nRmFjdG9yICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIEVOVklST05NRU5UIE1BUFxyXG5cclxuXHRlbnZtYXBfcGFyc19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9FTlZNQVBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyQ3ViZSBlbnZNYXA7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBmbGlwRW52TWFwO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gaW50IGNvbWJpbmU7XCIsXHJcblxyXG5cdFx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKVwiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCByZWZyYWN0aW9uUmF0aW87XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMzIHZSZWZsZWN0O1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0ZW52bWFwX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0VOVk1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIHJlZmxlY3RWZWM7XCIsXHJcblxyXG5cdFx0XHRcIiNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKVwiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcIixcclxuXHJcblx0XHRcdFx0XCJpZiAoIHVzZVJlZnJhY3QgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJyZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIG5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XCIsXHJcblxyXG5cdFx0XHRcdFwifSBlbHNlIHsgXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJyZWZsZWN0VmVjID0gcmVmbGVjdCggY2FtZXJhVG9WZXJ0ZXgsIG5vcm1hbCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XCJyZWZsZWN0VmVjID0gdlJlZmxlY3Q7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgZmxpcE5vcm1hbCA9ICggLTEuMCArIDIuMCAqIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWM0IGN1YmVDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIGZsaXBOb3JtYWwgKiB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICkgKTtcIixcclxuXHJcblx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGN1YmVDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEdBTU1BX0lOUFVUXCIsXHJcblxyXG5cdFx0XHRcdFwiY3ViZUNvbG9yLnh5eiAqPSBjdWJlQ29sb3IueHl6O1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiaWYgKCBjb21iaW5lID09IDEgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IG1peCggZ2xfRnJhZ0NvbG9yLnh5eiwgY3ViZUNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9IGVsc2UgaWYgKCBjb21iaW5lID09IDIgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiArPSBjdWJlQ29sb3IueHl6ICogc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eTtcIixcclxuXHJcblx0XHRcdFwifSBlbHNlIHtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gbWl4KCBnbF9GcmFnQ29sb3IueHl6LCBnbF9GcmFnQ29sb3IueHl6ICogY3ViZUNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGVudm1hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgJiYgISBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZSZWZsZWN0O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGJvb2wgdXNlUmVmcmFjdDtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0d29ybGRwb3NfdmVydGV4IDogW1xyXG5cclxuXHRcdFwiI2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIExBTUJFUlQgKSB8fCBkZWZpbmVkICggVVNFX1NIQURPV01BUCApXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHNraW5uZWQ7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjaWYgZGVmaW5lZCggVVNFX01PUlBIVEFSR0VUUyApICYmICEgZGVmaW5lZCggVVNFX1NLSU5OSU5HIClcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIG1vcnBoZWQsIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmICEgZGVmaW5lZCggVVNFX01PUlBIVEFSR0VUUyApICYmICEgZGVmaW5lZCggVVNFX1NLSU5OSU5HIClcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGVudm1hcF92ZXJ0ZXggOiBbXHJcblxyXG5cdFx0XCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmICEgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSAmJiAhIGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIHdvcmxkTm9ybWFsID0gbWF0MyggbW9kZWxNYXRyaXhbIDAgXS54eXosIG1vZGVsTWF0cml4WyAxIF0ueHl6LCBtb2RlbE1hdHJpeFsgMiBdLnh5eiApICogb2JqZWN0Tm9ybWFsO1wiLFxyXG5cdFx0XHRcIndvcmxkTm9ybWFsID0gbm9ybWFsaXplKCB3b3JsZE5vcm1hbCApO1wiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB3b3JsZFBvc2l0aW9uLnh5eiAtIGNhbWVyYVBvc2l0aW9uICk7XCIsXHJcblxyXG5cdFx0XHRcImlmICggdXNlUmVmcmFjdCApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XCIsXHJcblxyXG5cdFx0XHRcIn0gZWxzZSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidlJlZmxlY3QgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBDT0xPUiBNQVAgKHBhcnRpY2xlcylcclxuXHJcblx0bWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblxyXG5cdG1hcF9wYXJ0aWNsZV9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9NQVBcIixcclxuXHJcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4dHVyZTJEKCBtYXAsIHZlYzIoIGdsX1BvaW50Q29vcmQueCwgMS4wIC0gZ2xfUG9pbnRDb29yZC55ICkgKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gQ09MT1IgTUFQICh0cmlhbmdsZXMpXHJcblxyXG5cdG1hcF9wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlV2O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjNCBvZmZzZXRSZXBlYXQ7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdG1hcF9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWYgZGVmaW5lZCggVVNFX01BUCApIHx8IGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFVTRV9TUEVDVUxBUk1BUCApXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0bWFwX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKVwiLFxyXG5cclxuXHRcdFx0XCJ2VXYgPSB1diAqIG9mZnNldFJlcGVhdC56dyArIG9mZnNldFJlcGVhdC54eTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0bWFwX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX01BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIG1hcCwgdlV2ICk7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBHQU1NQV9JTlBVVFwiLFxyXG5cclxuXHRcdFx0XHRcInRleGVsQ29sb3IueHl6ICo9IHRleGVsQ29sb3IueHl6O1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4ZWxDb2xvcjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gTElHSFQgTUFQXHJcblxyXG5cdGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTElHSFRNQVBcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVdjI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbGlnaHRNYXA7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGxpZ2h0bWFwX3BhcnNfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0xJR0hUTUFQXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VXYyO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRsaWdodG1hcF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9MSUdIVE1BUFwiLFxyXG5cclxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGxpZ2h0bWFwX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9MSUdIVE1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2VXYyID0gdXYyO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBCVU1QIE1BUFxyXG5cclxuXHRidW1wbWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfQlVNUE1BUFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBidW1wTWFwO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1wiLFxyXG5cclxuXHRcdFx0Ly8gRGVyaXZhdGl2ZSBtYXBzIC0gYnVtcCBtYXBwaW5nIHVucGFyYW1ldHJpemVkIHN1cmZhY2VzIGJ5IE1vcnRlbiBNaWtrZWxzZW5cclxuXHRcdFx0Ly9cdGh0dHA6Ly9tbWlra2Vsc2VuM2QuYmxvZ3Nwb3Quc2svMjAxMS8wNy9kZXJpdmF0aXZlLW1hcHMuaHRtbFxyXG5cclxuXHRcdFx0Ly8gRXZhbHVhdGUgdGhlIGRlcml2YXRpdmUgb2YgdGhlIGhlaWdodCB3LnIudC4gc2NyZWVuLXNwYWNlIHVzaW5nIGZvcndhcmQgZGlmZmVyZW5jaW5nIChsaXN0aW5nIDIpXHJcblxyXG5cdFx0XHRcInZlYzIgZEhkeHlfZndkKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzIgZFNUZHggPSBkRmR4KCB2VXYgKTtcIixcclxuXHRcdFx0XHRcInZlYzIgZFNUZHkgPSBkRmR5KCB2VXYgKTtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBIbGwgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiApLng7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR4ICkueCAtIEhsbDtcIixcclxuXHRcdFx0XHRcImZsb2F0IGRCeSA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICsgZFNUZHkgKS54IC0gSGxsO1wiLFxyXG5cclxuXHRcdFx0XHRcInJldHVybiB2ZWMyKCBkQngsIGRCeSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcInZlYzMgcGVydHVyYk5vcm1hbEFyYiggdmVjMyBzdXJmX3BvcywgdmVjMyBzdXJmX25vcm0sIHZlYzIgZEhkeHkgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyB2U2lnbWFYID0gZEZkeCggc3VyZl9wb3MgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgdlNpZ21hWSA9IGRGZHkoIHN1cmZfcG9zICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIHZOID0gc3VyZl9ub3JtO1wiLFx0XHQvLyBub3JtYWxpemVkXHJcblxyXG5cdFx0XHRcdFwidmVjMyBSMSA9IGNyb3NzKCB2U2lnbWFZLCB2TiApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICk7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7XCIsXHJcblx0XHRcdFx0XCJyZXR1cm4gbm9ybWFsaXplKCBhYnMoIGZEZXQgKSAqIHN1cmZfbm9ybSAtIHZHcmFkICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gTk9STUFMIE1BUFxyXG5cclxuXHRub3JtYWxtYXBfcGFyc19mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9OT1JNQUxNQVBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMiBub3JtYWxTY2FsZTtcIixcclxuXHJcblx0XHRcdC8vIFBlci1QaXhlbCBUYW5nZW50IFNwYWNlIE5vcm1hbCBNYXBwaW5nXHJcblx0XHRcdC8vIGh0dHA6Ly9oYWNrc29mbGlmZS5ibG9nc3BvdC5jaC8yMDA5LzExL3Blci1waXhlbC10YW5nZW50LXNwYWNlLW5vcm1hbC1tYXBwaW5nLmh0bWxcclxuXHJcblx0XHRcdFwidmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHEwID0gZEZkeCggZXllX3Bvcy54eXogKTtcIixcclxuXHRcdFx0XHRcInZlYzMgcTEgPSBkRmR5KCBleWVfcG9zLnh5eiApO1wiLFxyXG5cdFx0XHRcdFwidmVjMiBzdDAgPSBkRmR4KCB2VXYuc3QgKTtcIixcclxuXHRcdFx0XHRcInZlYzIgc3QxID0gZEZkeSggdlV2LnN0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBTID0gbm9ybWFsaXplKCAgcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgVCA9IG5vcm1hbGl6ZSggLXEwICogc3QxLnMgKyBxMSAqIHN0MC5zICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIE4gPSBub3JtYWxpemUoIHN1cmZfbm9ybSApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgbWFwTiA9IHRleHR1cmUyRCggbm9ybWFsTWFwLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XCIsXHJcblx0XHRcdFx0XCJtYXBOLnh5ID0gbm9ybWFsU2NhbGUgKiBtYXBOLnh5O1wiLFxyXG5cdFx0XHRcdFwibWF0MyB0c24gPSBtYXQzKCBTLCBULCBOICk7XCIsXHJcblx0XHRcdFx0XCJyZXR1cm4gbm9ybWFsaXplKCB0c24gKiBtYXBOICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gU1BFQ1VMQVIgTUFQXHJcblxyXG5cdHNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNwZWN1bGFybWFwX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1wiLFxyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTtcIixcclxuXHRcdFx0XCJzcGVjdWxhclN0cmVuZ3RoID0gdGV4ZWxTcGVjdWxhci5yO1wiLFxyXG5cclxuXHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFwic3BlY3VsYXJTdHJlbmd0aCA9IDEuMDtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gTElHSFRTIExBTUJFUlRcclxuXHJcblx0bGlnaHRzX2xhbWJlcnRfcGFyc192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcInVuaWZvcm0gdmVjMyBhbWJpZW50O1wiLFxyXG5cdFx0XCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcIixcclxuXHRcdFwidW5pZm9ybSB2ZWMzIGVtaXNzaXZlO1wiLFxyXG5cclxuXHRcdFwidW5pZm9ybSB2ZWMzIGFtYmllbnRMaWdodENvbG9yO1wiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yWyBNQVhfRElSX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBNQVhfRElSX0xJR0hUUyBdO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIE1BWF9IRU1JX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodERpcmVjdGlvblsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodENvbG9yWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvblsgTUFYX1BPSU5UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEV4cG9uZW50WyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyB3cmFwUkdCO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRsaWdodHNfbGFtYmVydF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcInZMaWdodEZyb250ID0gdmVjMyggMC4wICk7XCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcInZMaWdodEJhY2sgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwidHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgaSBdLCAwLjAgKTtcIixcclxuXHRcdFx0XCJ2ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcIixcclxuXHJcblx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGRpclZlY3RvciApO1wiLFxyXG5cdFx0XHRcInZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZyA9IHZlYzMoIG1heCggZG90UHJvZHVjdCwgMC4wICkgKTtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0JhY2sgPSB2ZWMzKCBtYXgoIC1kb3RQcm9kdWN0LCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2sgPSB2ZWMzKCBtYXgoIC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZiA9IHZlYzMoIG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcIixcclxuXHRcdFx0XHRcImRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmcgPSBtaXgoIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmcsIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmLCB3cmFwUkdCICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0JhY2sgPSBtaXgoIGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdCYWNrLCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2ssIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcInZMaWdodEZyb250ICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZztcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcInZMaWdodEJhY2sgKz0gZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nQmFjaztcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiAtIG12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcIixcclxuXHRcdFx0XHRcImlmICggcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVwiLFxyXG5cdFx0XHRcdFx0XCJsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCJsVmVjdG9yID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCB0cmFuc2Zvcm1lZE5vcm1hbCwgbFZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgcG9pbnRMaWdodFdlaWdodGluZyA9IHZlYzMoIG1heCggZG90UHJvZHVjdCwgMC4wICkgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmdCYWNrID0gdmVjMyggbWF4KCAtZG90UHJvZHVjdCwgMC4wICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHBvaW50TGlnaHRXZWlnaHRpbmdIYWxmQmFjayA9IHZlYzMoIG1heCggLTAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgcG9pbnRMaWdodFdlaWdodGluZ0hhbGYgPSB2ZWMzKCBtYXgoIDAuNSAqIGRvdFByb2R1Y3QgKyAwLjUsIDAuMCApICk7XCIsXHJcblx0XHRcdFx0XHRcInBvaW50TGlnaHRXZWlnaHRpbmcgPSBtaXgoIHBvaW50TGlnaHRXZWlnaHRpbmcsIHBvaW50TGlnaHRXZWlnaHRpbmdIYWxmLCB3cmFwUkdCICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInBvaW50TGlnaHRXZWlnaHRpbmdCYWNrID0gbWl4KCBwb2ludExpZ2h0V2VpZ2h0aW5nQmFjaywgcG9pbnRMaWdodFdlaWdodGluZ0hhbGZCYWNrLCB3cmFwUkdCICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJ2TGlnaHRGcm9udCArPSBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50TGlnaHRXZWlnaHRpbmcgKiBsRGlzdGFuY2U7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidkxpZ2h0QmFjayArPSBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50TGlnaHRXZWlnaHRpbmdCYWNrICogbERpc3RhbmNlO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiAtIG12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IHNwb3RFZmZlY3QgPSBkb3QoIHNwb3RMaWdodERpcmVjdGlvblsgaSBdLCBub3JtYWxpemUoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0gLSB3b3JsZFBvc2l0aW9uLnh5eiApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYgKCBzcG90RWZmZWN0ID4gc3BvdExpZ2h0QW5nbGVDb3NbIGkgXSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcInNwb3RFZmZlY3QgPSBtYXgoIHBvdyggc3BvdEVmZmVjdCwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcIixcclxuXHRcdFx0XHRcdFwiaWYgKCBzcG90TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcIixcclxuXHRcdFx0XHRcdFx0XCJsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBzcG90TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwibFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggdHJhbnNmb3JtZWROb3JtYWwsIGxWZWN0b3IgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMyBzcG90TGlnaHRXZWlnaHRpbmcgPSB2ZWMzKCBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nQmFjayA9IHZlYzMoIG1heCggLWRvdFByb2R1Y3QsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2sgPSB2ZWMzKCBtYXgoIC0wLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZiA9IHZlYzMoIG1heCggMC41ICogZG90UHJvZHVjdCArIDAuNSwgMC4wICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJzcG90TGlnaHRXZWlnaHRpbmcgPSBtaXgoIHNwb3RMaWdodFdlaWdodGluZywgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZiwgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwic3BvdExpZ2h0V2VpZ2h0aW5nQmFjayA9IG1peCggc3BvdExpZ2h0V2VpZ2h0aW5nQmFjaywgc3BvdExpZ2h0V2VpZ2h0aW5nSGFsZkJhY2ssIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcInZMaWdodEZyb250ICs9IHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90TGlnaHRXZWlnaHRpbmcgKiBsRGlzdGFuY2UgKiBzcG90RWZmZWN0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2TGlnaHRCYWNrICs9IHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90TGlnaHRXZWlnaHRpbmdCYWNrICogbERpc3RhbmNlICogc3BvdEVmZmVjdDtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIHRyYW5zZm9ybWVkTm9ybWFsLCBsVmVjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHRCYWNrID0gLTAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XCIsXHJcblxyXG5cdFx0XHRcdFwidkxpZ2h0RnJvbnQgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XHRcInZMaWdodEJhY2sgKz0gbWl4KCBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgaSBdLCBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgaSBdLCBoZW1pRGlmZnVzZVdlaWdodEJhY2sgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJ2TGlnaHRGcm9udCA9IHZMaWdodEZyb250ICogZGlmZnVzZSArIGFtYmllbnQgKiBhbWJpZW50TGlnaHRDb2xvciArIGVtaXNzaXZlO1wiLFxyXG5cclxuXHRcdFwiI2lmZGVmIERPVUJMRV9TSURFRFwiLFxyXG5cclxuXHRcdFx0XCJ2TGlnaHRCYWNrID0gdkxpZ2h0QmFjayAqIGRpZmZ1c2UgKyBhbWJpZW50ICogYW1iaWVudExpZ2h0Q29sb3IgKyBlbWlzc2l2ZTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gTElHSFRTIFBIT05HXHJcblxyXG5cdGxpZ2h0c19waG9uZ19wYXJzX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmbmRlZiBQSE9OR19QRVJfUElYRUxcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBwb2ludExpZ2h0RGlzdGFuY2VbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWM0IHZQb2ludExpZ2h0WyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjNCB2U3BvdExpZ2h0WyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblxyXG5cdGxpZ2h0c19waG9uZ192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZm5kZWYgUEhPTkdfUEVSX1BJWEVMXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogLSBtdlBvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBsRGlzdGFuY2UgPSAxLjA7XCIsXHJcblx0XHRcdFx0XCJpZiAoIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcIixcclxuXHRcdFx0XHRcdFwibERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggbFZlY3RvciApIC8gcG9pbnRMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwidlBvaW50TGlnaHRbIGkgXSA9IHZlYzQoIGxWZWN0b3IsIGxEaXN0YW5jZSApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiAtIG12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcIixcclxuXHRcdFx0XHRcImlmICggc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXCIsXHJcblx0XHRcdFx0XHRcImxEaXN0YW5jZSA9IDEuMCAtIG1pbiggKCBsZW5ndGgoIGxWZWN0b3IgKSAvIHNwb3RMaWdodERpc3RhbmNlWyBpIF0gKSwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwidlNwb3RMaWdodFsgaSBdID0gdmVjNCggbFZlY3RvciwgbERpc3RhbmNlICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXCIsXHJcblxyXG5cdFx0XHRcInZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCJ1bmlmb3JtIHZlYzMgYW1iaWVudExpZ2h0Q29sb3I7XCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0RJUl9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIE1BWF9ESVJfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFBIT05HX1BFUl9QSVhFTFwiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFwidmFyeWluZyB2ZWM0IHZQb2ludExpZ2h0WyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0Q29sb3JbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRBbmdsZUNvc1sgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRFeHBvbmVudFsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBQSE9OR19QRVJfUElYRUxcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodERpc3RhbmNlWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlNwb3RMaWdodFsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMCB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyB3cmFwUkdCO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHRcdFwidmFyeWluZyB2ZWMzIHZOb3JtYWw7XCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRsaWdodHNfcGhvbmdfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcInZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XCIsXHJcblx0XHRcInZlYzMgdmlld1Bvc2l0aW9uID0gbm9ybWFsaXplKCB2Vmlld1Bvc2l0aW9uICk7XCIsXHJcblxyXG5cdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcIm5vcm1hbCA9IG5vcm1hbCAqICggLTEuMCArIDIuMCAqIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfTk9STUFMTUFQXCIsXHJcblxyXG5cdFx0XHRcIm5vcm1hbCA9IHBlcnR1cmJOb3JtYWwyQXJiKCAtdmlld1Bvc2l0aW9uLCBub3JtYWwgKTtcIixcclxuXHJcblx0XHRcIiNlbGlmIGRlZmluZWQoIFVTRV9CVU1QTUFQIClcIixcclxuXHJcblx0XHRcdFwibm9ybWFsID0gcGVydHVyYk5vcm1hbEFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCwgZEhkeHlfZndkKCkgKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInZlYzMgcG9pbnREaWZmdXNlICA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcInZlYzMgcG9pbnRTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XCJmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBQSE9OR19QRVJfUElYRUxcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHBvaW50TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbFBvc2l0aW9uLnh5eiArIHZWaWV3UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgbERpc3RhbmNlID0gMS4wO1wiLFxyXG5cdFx0XHRcdFx0XCJpZiAoIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcIixcclxuXHRcdFx0XHRcdFx0XCJsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImxWZWN0b3IgPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbm9ybWFsaXplKCB2UG9pbnRMaWdodFsgaSBdLnh5eiApO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCBsRGlzdGFuY2UgPSB2UG9pbnRMaWdodFsgaSBdLnc7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdC8vIGRpZmZ1c2VcclxuXHJcblx0XHRcdFx0XCJmbG9hdCBkb3RQcm9kdWN0ID0gZG90KCBub3JtYWwsIGxWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IHBvaW50RGlmZnVzZVdlaWdodEZ1bGwgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWl4KCB2ZWMzICggcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJwb2ludERpZmZ1c2UgICs9IGRpZmZ1c2UgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFx0Ly8gc3BlY3VsYXJcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHBvaW50SGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgcG9pbnREb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgcG9pbnRTcGVjdWxhcldlaWdodCA9IHNwZWN1bGFyU3RyZW5ndGggKiBtYXgoIHBvdyggcG9pbnREb3ROb3JtYWxIYWxmLCBzaGluaW5lc3MgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1wiLFxyXG5cclxuXHRcdFx0XHRcdC8vIDIuMCA9PiAyLjAwMDEgaXMgaGFjayB0byB3b3JrIGFyb3VuZCBBTkdMRSBidWdcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2sgPSBzcGVjdWxhciArIHZlYzMoIDEuMCAtIHNwZWN1bGFyICkgKiBwb3coIDEuMCAtIGRvdCggbFZlY3RvciwgcG9pbnRIYWxmVmVjdG9yICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJwb2ludFNwZWN1bGFyICs9IHNjaGxpY2sgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50U3BlY3VsYXJXZWlnaHQgKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcInBvaW50U3BlY3VsYXIgKz0gc3BlY3VsYXIgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50U3BlY3VsYXJXZWlnaHQgKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2U7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidmVjMyBzcG90RGlmZnVzZSAgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHRcdFx0XCJ2ZWMzIHNwb3RTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XCJmb3IgKCBpbnQgaSA9IDA7IGkgPCBNQVhfU1BPVF9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFBIT05HX1BFUl9QSVhFTFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggc3BvdExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XCIsXHJcblx0XHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IGxQb3NpdGlvbi54eXogKyB2Vmlld1Bvc2l0aW9uLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGxEaXN0YW5jZSA9IDEuMDtcIixcclxuXHRcdFx0XHRcdFwiaWYgKCBzcG90TGlnaHREaXN0YW5jZVsgaSBdID4gMC4wIClcIixcclxuXHRcdFx0XHRcdFx0XCJsRGlzdGFuY2UgPSAxLjAgLSBtaW4oICggbGVuZ3RoKCBsVmVjdG9yICkgLyBzcG90TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwibFZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGxWZWN0b3IgPSBub3JtYWxpemUoIHZTcG90TGlnaHRbIGkgXS54eXogKTtcIixcclxuXHRcdFx0XHRcdFwiZmxvYXQgbERpc3RhbmNlID0gdlNwb3RMaWdodFsgaSBdLnc7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgc3BvdEVmZmVjdCA9IGRvdCggc3BvdExpZ2h0RGlyZWN0aW9uWyBpIF0sIG5vcm1hbGl6ZSggc3BvdExpZ2h0UG9zaXRpb25bIGkgXSAtIHZXb3JsZFBvc2l0aW9uICkgKTtcIixcclxuXHJcblx0XHRcdFx0XCJpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwic3BvdEVmZmVjdCA9IG1heCggcG93KCBzcG90RWZmZWN0LCBzcG90TGlnaHRFeHBvbmVudFsgaSBdICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdC8vIGRpZmZ1c2VcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgbFZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBzcG90RGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyAoIHNwb3REaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBzcG90RGlmZnVzZVdlaWdodEhhbGYgKSwgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdFByb2R1Y3QsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJzcG90RGlmZnVzZSArPSBkaWZmdXNlICogc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHNwb3REaWZmdXNlV2VpZ2h0ICogbERpc3RhbmNlICogc3BvdEVmZmVjdDtcIixcclxuXHJcblx0XHRcdFx0XHQvLyBzcGVjdWxhclxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBzcG90SGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggbFZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCBzcG90RG90Tm9ybWFsSGFsZiA9IG1heCggZG90KCBub3JtYWwsIHNwb3RIYWxmVmVjdG9yICksIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCBzcG90U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIHNwb3REb3ROb3JtYWxIYWxmLCBzaGluaW5lc3MgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgUEhZU0lDQUxMWV9CQVNFRF9TSEFESU5HXCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyAyLjAgPT4gMi4wMDAxIGlzIGhhY2sgdG8gd29yayBhcm91bmQgQU5HTEUgYnVnXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggc2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggMS4wIC0gZG90KCBsVmVjdG9yLCBzcG90SGFsZlZlY3RvciApLCA1LjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJzcG90U3BlY3VsYXIgKz0gc2NobGljayAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiBzcG90U3BlY3VsYXJXZWlnaHQgKiBzcG90RGlmZnVzZVdlaWdodCAqIGxEaXN0YW5jZSAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbiAqIHNwb3RFZmZlY3Q7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJzcG90U3BlY3VsYXIgKz0gc3BlY3VsYXIgKiBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdFNwZWN1bGFyV2VpZ2h0ICogc3BvdERpZmZ1c2VXZWlnaHQgKiBsRGlzdGFuY2UgKiBzcG90RWZmZWN0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidmVjMyBkaXJEaWZmdXNlICA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcInZlYzMgZGlyU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIiAsXHJcblxyXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX0RJUl9MSUdIVFM7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIGRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25bIGkgXSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIGRpclZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gZGlmZnVzZVxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGRvdFByb2R1Y3QgPSBkb3QoIG5vcm1hbCwgZGlyVmVjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90UHJvZHVjdCwgMC4wICk7XCIsXHJcblx0XHRcdFx0XHRcImZsb2F0IGRpckRpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3RQcm9kdWN0ICsgMC41LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyRGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggZGlyRGlmZnVzZVdlaWdodEhhbGYgKSwgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkaXJEaWZmdXNlV2VpZ2h0ID0gbWF4KCBkb3RQcm9kdWN0LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJkaXJEaWZmdXNlICArPSBkaWZmdXNlICogZGlyZWN0aW9uYWxMaWdodENvbG9yWyBpIF0gKiBkaXJEaWZmdXNlV2VpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHQvLyBzcGVjdWxhclxyXG5cclxuXHRcdFx0XHRcInZlYzMgZGlySGFsZlZlY3RvciA9IG5vcm1hbGl6ZSggZGlyVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBkaXJEb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgZGlySGFsZlZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGRpclNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBkaXJEb3ROb3JtYWxIYWxmLCBzaGluaW5lc3MgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1wiLFxyXG5cclxuXHRcdFx0XHRcdC8qXHJcblx0XHRcdFx0XHQvLyBmcmVzbmVsIHRlcm0gZnJvbSBza2luIHNoYWRlclxyXG5cdFx0XHRcdFx0XCJjb25zdCBmbG9hdCBGMCA9IDAuMTI4O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgYmFzZSA9IDEuMCAtIGRvdCggdmlld1Bvc2l0aW9uLCBkaXJIYWxmVmVjdG9yICk7XCIsXHJcblx0XHRcdFx0XHRcImZsb2F0IGV4cG9uZW50aWFsID0gcG93KCBiYXNlLCA1LjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGZyZXNuZWwgPSBleHBvbmVudGlhbCArIEYwICogKCAxLjAgLSBleHBvbmVudGlhbCApO1wiLFxyXG5cdFx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0XHQvKlxyXG5cdFx0XHRcdFx0Ly8gZnJlc25lbCB0ZXJtIGZyb20gZnJlc25lbCBzaGFkZXJcclxuXHRcdFx0XHRcdFwiY29uc3QgZmxvYXQgbUZyZXNuZWxCaWFzID0gMC4wODtcIixcclxuXHRcdFx0XHRcdFwiY29uc3QgZmxvYXQgbUZyZXNuZWxTY2FsZSA9IDAuMztcIixcclxuXHRcdFx0XHRcdFwiY29uc3QgZmxvYXQgbUZyZXNuZWxQb3dlciA9IDUuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGZyZXNuZWwgPSBtRnJlc25lbEJpYXMgKyBtRnJlc25lbFNjYWxlICogcG93KCAxLjAgKyBkb3QoIG5vcm1hbGl6ZSggLXZpZXdQb3NpdGlvbiApLCBub3JtYWwgKSwgbUZyZXNuZWxQb3dlciApO1wiLFxyXG5cdFx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0XHQvLyAyLjAgPT4gMi4wMDAxIGlzIGhhY2sgdG8gd29yayBhcm91bmQgQU5HTEUgYnVnXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdC8vXCJkaXJTcGVjdWxhciArPSBzcGVjdWxhciAqIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyU3BlY3VsYXJXZWlnaHQgKiBkaXJEaWZmdXNlV2VpZ2h0ICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogZnJlc25lbDtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgc2NobGljayA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggMS4wIC0gZG90KCBkaXJWZWN0b3IsIGRpckhhbGZWZWN0b3IgKSwgNS4wICk7XCIsXHJcblx0XHRcdFx0XHRcImRpclNwZWN1bGFyICs9IHNjaGxpY2sgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodCAqIHNwZWN1bGFyTm9ybWFsaXphdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZGlyU3BlY3VsYXIgKz0gc3BlY3VsYXIgKiBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIGkgXSAqIGRpclNwZWN1bGFyV2VpZ2h0ICogZGlyRGlmZnVzZVdlaWdodDtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX0hFTUlfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIGhlbWlEaWZmdXNlICA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcInZlYzMgaGVtaVNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIgLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9IRU1JX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBsVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1wiLFxyXG5cclxuXHRcdFx0XHQvLyBkaWZmdXNlXHJcblxyXG5cdFx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBoZW1pRGlmZnVzZVdlaWdodCA9IDAuNSAqIGRvdFByb2R1Y3QgKyAwLjU7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBoZW1pQ29sb3IgPSBtaXgoIGhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yWyBpIF0sIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBpIF0sIGhlbWlEaWZmdXNlV2VpZ2h0ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiaGVtaURpZmZ1c2UgKz0gZGlmZnVzZSAqIGhlbWlDb2xvcjtcIixcclxuXHJcblx0XHRcdFx0Ly8gc3BlY3VsYXIgKHNreSBsaWdodClcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGhlbWlIYWxmVmVjdG9yU2t5ID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBoZW1pRG90Tm9ybWFsSGFsZlNreSA9IDAuNSAqIGRvdCggbm9ybWFsLCBoZW1pSGFsZlZlY3RvclNreSApICsgMC41O1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ID0gc3BlY3VsYXJTdHJlbmd0aCAqIG1heCggcG93KCBoZW1pRG90Tm9ybWFsSGFsZlNreSwgc2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHQvLyBzcGVjdWxhciAoZ3JvdW5kIGxpZ2h0KVxyXG5cclxuXHRcdFx0XHRcInZlYzMgbFZlY3Rvckdyb3VuZCA9IC1sVmVjdG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgaGVtaUhhbGZWZWN0b3JHcm91bmQgPSBub3JtYWxpemUoIGxWZWN0b3JHcm91bmQgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcImZsb2F0IGhlbWlEb3ROb3JtYWxIYWxmR3JvdW5kID0gMC41ICogZG90KCBub3JtYWwsIGhlbWlIYWxmVmVjdG9yR3JvdW5kICkgKyAwLjU7XCIsXHJcblx0XHRcdFx0XCJmbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgPSBzcGVjdWxhclN0cmVuZ3RoICogbWF4KCBwb3coIGhlbWlEb3ROb3JtYWxIYWxmR3JvdW5kLCBzaGluaW5lc3MgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdEdyb3VuZCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yR3JvdW5kICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0Ly8gMi4wID0+IDIuMDAwMSBpcyBoYWNrIHRvIHdvcmsgYXJvdW5kIEFOR0xFIGJ1Z1xyXG5cclxuXHRcdFx0XHRcdFwiZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCBzaGluaW5lc3MgKyAyLjAwMDEgKSAvIDguMDtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgc2NobGlja1NreSA9IHNwZWN1bGFyICsgdmVjMyggMS4wIC0gc3BlY3VsYXIgKSAqIHBvdyggMS4wIC0gZG90KCBsVmVjdG9yLCBoZW1pSGFsZlZlY3RvclNreSApLCA1LjAgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjMyBzY2hsaWNrR3JvdW5kID0gc3BlY3VsYXIgKyB2ZWMzKCAxLjAgLSBzcGVjdWxhciApICogcG93KCAxLjAgLSBkb3QoIGxWZWN0b3JHcm91bmQsIGhlbWlIYWxmVmVjdG9yR3JvdW5kICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJoZW1pU3BlY3VsYXIgKz0gaGVtaUNvbG9yICogc3BlY3VsYXJOb3JtYWxpemF0aW9uICogKCBzY2hsaWNrU2t5ICogaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ICogbWF4KCBkb3RQcm9kdWN0LCAwLjAgKSArIHNjaGxpY2tHcm91bmQgKiBoZW1pU3BlY3VsYXJXZWlnaHRHcm91bmQgKiBtYXgoIGRvdFByb2R1Y3RHcm91bmQsIDAuMCApICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcImhlbWlTcGVjdWxhciArPSBzcGVjdWxhciAqIGhlbWlDb2xvciAqICggaGVtaVNwZWN1bGFyV2VpZ2h0U2t5ICsgaGVtaVNwZWN1bGFyV2VpZ2h0R3JvdW5kICkgKiBoZW1pRGlmZnVzZVdlaWdodDtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJ2ZWMzIHRvdGFsRGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XCJ2ZWMzIHRvdGFsU3BlY3VsYXIgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidG90YWxEaWZmdXNlICs9IGRpckRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidG90YWxTcGVjdWxhciArPSBkaXJTcGVjdWxhcjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidG90YWxEaWZmdXNlICs9IGhlbWlEaWZmdXNlO1wiLFxyXG5cdFx0XHRcInRvdGFsU3BlY3VsYXIgKz0gaGVtaVNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFwidG90YWxEaWZmdXNlICs9IHBvaW50RGlmZnVzZTtcIixcclxuXHRcdFx0XCJ0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiBNQVhfU1BPVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcInRvdGFsRGlmZnVzZSArPSBzcG90RGlmZnVzZTtcIixcclxuXHRcdFx0XCJ0b3RhbFNwZWN1bGFyICs9IHNwb3RTcGVjdWxhcjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmZGVmIE1FVEFMXCIsXHJcblxyXG5cdFx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBnbF9GcmFnQ29sb3IueHl6ICogKCBlbWlzc2l2ZSArIHRvdGFsRGlmZnVzZSArIGFtYmllbnRMaWdodENvbG9yICogYW1iaWVudCArIHRvdGFsU3BlY3VsYXIgKTtcIixcclxuXHJcblx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBnbF9GcmFnQ29sb3IueHl6ICogKCBlbWlzc2l2ZSArIHRvdGFsRGlmZnVzZSArIGFtYmllbnRMaWdodENvbG9yICogYW1iaWVudCApICsgdG90YWxTcGVjdWxhcjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gVkVSVEVYIENPTE9SU1xyXG5cclxuXHRjb2xvcl9wYXJzX2ZyYWdtZW50OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX0NPTE9SXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Q29sb3I7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cclxuXHRjb2xvcl9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9DT0xPUlwiLFxyXG5cclxuXHRcdFx0XCJnbF9GcmFnQ29sb3IgPSBnbF9GcmFnQ29sb3IgKiB2ZWM0KCB2Q29sb3IsIG9wYWNpdHkgKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Y29sb3JfcGFyc192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfQ09MT1JcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZDb2xvcjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblxyXG5cdGNvbG9yX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9DT0xPUlwiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgR0FNTUFfSU5QVVRcIixcclxuXHJcblx0XHRcdFx0XCJ2Q29sb3IgPSBjb2xvciAqIGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcInZDb2xvciA9IGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gU0tJTk5JTkdcclxuXHJcblx0c2tpbm5pbmdfcGFyc192ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEJPTkVfVEVYVFVSRVwiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIGJvbmVUZXh0dXJlO1wiLFxyXG5cclxuXHRcdFx0XHRcIm1hdDQgZ2V0Qm9uZU1hdHJpeCggY29uc3QgaW4gZmxvYXQgaSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcImZsb2F0IGogPSBpICogNC4wO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCB4ID0gbW9kKCBqLCBOX0JPTkVfUElYRUxfWCApO1wiLFxyXG5cdFx0XHRcdFx0XCJmbG9hdCB5ID0gZmxvb3IoIGogLyBOX0JPTkVfUElYRUxfWCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiY29uc3QgZmxvYXQgZHggPSAxLjAgLyBOX0JPTkVfUElYRUxfWDtcIixcclxuXHRcdFx0XHRcdFwiY29uc3QgZmxvYXQgZHkgPSAxLjAgLyBOX0JPTkVfUElYRUxfWTtcIixcclxuXHJcblx0XHRcdFx0XHRcInkgPSBkeSAqICggeSArIDAuNSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWM0IHYyID0gdGV4dHVyZTJEKCBib25lVGV4dHVyZSwgdmVjMiggZHggKiAoIHggKyAxLjUgKSwgeSApICk7XCIsXHJcblx0XHRcdFx0XHRcInZlYzQgdjMgPSB0ZXh0dXJlMkQoIGJvbmVUZXh0dXJlLCB2ZWMyKCBkeCAqICggeCArIDIuNSApLCB5ICkgKTtcIixcclxuXHRcdFx0XHRcdFwidmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwibWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInJldHVybiBib25lO1wiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIG1hdDQgYm9uZUdsb2JhbE1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcIixcclxuXHJcblx0XHRcdFx0XCJtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJtYXQ0IGJvbmUgPSBib25lR2xvYmFsTWF0cmljZXNbIGludChpKSBdO1wiLFxyXG5cdFx0XHRcdFx0XCJyZXR1cm4gYm9uZTtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRza2luYmFzZV92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFwibWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XCIsXHJcblx0XHRcdFwibWF0NCBib25lTWF0WSA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC55ICk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNraW5uaW5nX3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1wiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHNraW5WZXJ0ZXggPSB2ZWM0KCBtb3JwaGVkLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFwidmVjNCBza2luVmVydGV4ID0gdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwidmVjNCBza2lubmVkICA9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcIixcclxuXHRcdFx0XCJza2lubmVkIFx0ICArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdC8vIE1PUlBISU5HXHJcblxyXG5cdG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1wiLFxyXG5cclxuXHRcdFx0XCIjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcIixcclxuXHJcblx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdG1vcnBodGFyZ2V0X3ZlcnRleDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcIixcclxuXHJcblx0XHRcdFwidmVjMyBtb3JwaGVkID0gdmVjMyggMC4wICk7XCIsXHJcblx0XHRcdFwibW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDAgXTtcIixcclxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDIgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XCIsXHJcblx0XHRcdFwibW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0MyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDMgXTtcIixcclxuXHJcblx0XHRcdFwiI2lmbmRlZiBVU0VfTU9SUEhOT1JNQUxTXCIsXHJcblxyXG5cdFx0XHRcIm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDQgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA0IF07XCIsXHJcblx0XHRcdFwibW9ycGhlZCArPSAoIG1vcnBoVGFyZ2V0NSAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDUgXTtcIixcclxuXHRcdFx0XCJtb3JwaGVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWQgKz0gKCBtb3JwaFRhcmdldDcgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA3IF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJtb3JwaGVkICs9IHBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRkZWZhdWx0X3ZlcnRleCA6IFtcclxuXHJcblx0XHRcInZlYzQgbXZQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFwibXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHNraW5uZWQ7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZiAhZGVmaW5lZCggVVNFX1NLSU5OSU5HICkgJiYgZGVmaW5lZCggVVNFX01PUlBIVEFSR0VUUyApXCIsXHJcblxyXG5cdFx0XHRcIm12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBtb3JwaGVkLCAxLjAgKTtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmICFkZWZpbmVkKCBVU0VfU0tJTk5JTkcgKSAmJiAhIGRlZmluZWQoIFVTRV9NT1JQSFRBUkdFVFMgKVwiLFxyXG5cclxuXHRcdFx0XCJtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0bW9ycGhub3JtYWxfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1wiLFxyXG5cclxuXHRcdFx0XCJ2ZWMzIG1vcnBoZWROb3JtYWwgPSB2ZWMzKCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFwibW9ycGhlZE5vcm1hbCArPSAgKCBtb3JwaE5vcm1hbDAgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1wiLFxyXG5cdFx0XHRcIm1vcnBoZWROb3JtYWwgKz0gICggbW9ycGhOb3JtYWwxIC0gbm9ybWFsICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDEgXTtcIixcclxuXHRcdFx0XCJtb3JwaGVkTm9ybWFsICs9ICAoIG1vcnBoTm9ybWFsMiAtIG5vcm1hbCApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAyIF07XCIsXHJcblx0XHRcdFwibW9ycGhlZE5vcm1hbCArPSAgKCBtb3JwaE5vcm1hbDMgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1wiLFxyXG5cclxuXHRcdFx0XCJtb3JwaGVkTm9ybWFsICs9IG5vcm1hbDtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0c2tpbm5vcm1hbF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0tJTk5JTkdcIixcclxuXHJcblx0XHRcdFwibWF0NCBza2luTWF0cml4ID0gc2tpbldlaWdodC54ICogYm9uZU1hdFg7XCIsXHJcblx0XHRcdFwic2tpbk1hdHJpeCBcdCs9IHNraW5XZWlnaHQueSAqIGJvbmVNYXRZO1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1wiLFxyXG5cclxuXHRcdFx0XCJ2ZWM0IHNraW5uZWROb3JtYWwgPSBza2luTWF0cml4ICogdmVjNCggbW9ycGhlZE5vcm1hbCwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcInZlYzQgc2tpbm5lZE5vcm1hbCA9IHNraW5NYXRyaXggKiB2ZWM0KCBub3JtYWwsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcInZlYzMgb2JqZWN0Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxyXG5cclxuXHRcdFx0XCJvYmplY3ROb3JtYWwgPSBza2lubmVkTm9ybWFsLnh5ejtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmICFkZWZpbmVkKCBVU0VfU0tJTk5JTkcgKSAmJiBkZWZpbmVkKCBVU0VfTU9SUEhOT1JNQUxTIClcIixcclxuXHJcblx0XHRcdFwib2JqZWN0Tm9ybWFsID0gbW9ycGhlZE5vcm1hbDtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFwiI2lmICFkZWZpbmVkKCBVU0VfU0tJTk5JTkcgKSAmJiAhIGRlZmluZWQoIFVTRV9NT1JQSE5PUk1BTFMgKVwiLFxyXG5cclxuXHRcdFx0XCJvYmplY3ROb3JtYWwgPSBub3JtYWw7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcIiNpZmRlZiBGTElQX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcIm9iamVjdE5vcm1hbCA9IC1vYmplY3ROb3JtYWw7XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcInZlYzMgdHJhbnNmb3JtZWROb3JtYWwgPSBub3JtYWxNYXRyaXggKiBvYmplY3ROb3JtYWw7XCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHQvLyBTSEFET1cgTUFQXHJcblxyXG5cdC8vIGJhc2VkIG9uIFNwaWRlckdMIHNoYWRvdyBtYXAgYW5kIEZhYmllbiBTYW5nbGFyZCdzIEdMU0wgc2hhZG93IG1hcHBpbmcgZXhhbXBsZXNcclxuXHQvLyAgaHR0cDovL3NwaWRlcmdsLm9yZy9leGFtcGxlLnBocD9pZD02XHJcblx0Ly8gXHRodHRwOi8vZmFiaWVuc2FuZ2xhcmQubmV0L3NoYWRvd21hcHBpbmdcclxuXHJcblx0c2hhZG93bWFwX3BhcnNfZnJhZ21lbnQ6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHNoYWRvd01hcFsgTUFYX1NIQURPV1MgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgc2hhZG93TWFwU2l6ZVsgTUFYX1NIQURPV1MgXTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaGFkb3dEYXJrbmVzc1sgTUFYX1NIQURPV1MgXTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNoYWRvd0JpYXNbIE1BWF9TSEFET1dTIF07XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjNCB2U2hhZG93Q29vcmRbIE1BWF9TSEFET1dTIF07XCIsXHJcblxyXG5cdFx0XHRcImZsb2F0IHVucGFja0RlcHRoKCBjb25zdCBpbiB2ZWM0IHJnYmFfZGVwdGggKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiY29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwiZmxvYXQgZGVwdGggPSBkb3QoIHJnYmFfZGVwdGgsIGJpdF9zaGlmdCApO1wiLFxyXG5cdFx0XHRcdFwicmV0dXJuIGRlcHRoO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNoYWRvd21hcF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFNIQURPV01BUF9ERUJVR1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgZnJ1c3R1bUNvbG9yc1szXTtcIixcclxuXHRcdFx0XHRcImZydXN0dW1Db2xvcnNbMF0gPSB2ZWMzKCAxLjAsIDAuNSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XCJmcnVzdHVtQ29sb3JzWzFdID0gdmVjMyggMC4wLCAxLjAsIDAuOCApO1wiLFxyXG5cdFx0XHRcdFwiZnJ1c3R1bUNvbG9yc1syXSA9IHZlYzMoIDAuMCwgMC41LCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBTSEFET1dNQVBfQ0FTQ0FERVwiLFxyXG5cclxuXHRcdFx0XHRcImludCBpbkZydXN0dW1Db3VudCA9IDA7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJmbG9hdCBmRGVwdGg7XCIsXHJcblx0XHRcdFwidmVjMyBzaGFkb3dDb2xvciA9IHZlYzMoIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9TSEFET1dTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgc2hhZG93Q29vcmQgPSB2U2hhZG93Q29vcmRbIGkgXS54eXogLyB2U2hhZG93Q29vcmRbIGkgXS53O1wiLFxyXG5cclxuXHRcdFx0XHQvLyBcImlmICggc29tZXRoaW5nICYmIHNvbWV0aGluZyApXCIgXHRcdCBicmVha3MgQVRJIE9wZW5HTCBzaGFkZXIgY29tcGlsZXJcclxuXHRcdFx0XHQvLyBcImlmICggYWxsKCBzb21ldGhpbmcsIHNvbWV0aGluZyApIClcIiAgdXNpbmcgdGhpcyBpbnN0ZWFkXHJcblxyXG5cdFx0XHRcdFwiYnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1wiLFxyXG5cdFx0XHRcdFwiYm9vbCBpbkZydXN0dW0gPSBhbGwoIGluRnJ1c3R1bVZlYyApO1wiLFxyXG5cclxuXHRcdFx0XHQvLyBkb24ndCBzaGFkb3cgcGl4ZWxzIG91dHNpZGUgb2YgbGlnaHQgZnJ1c3R1bVxyXG5cdFx0XHRcdC8vIHVzZSBqdXN0IGZpcnN0IGZydXN0dW0gKGZvciBjYXNjYWRlcylcclxuXHRcdFx0XHQvLyBkb24ndCBzaGFkb3cgcGl4ZWxzIGJlaGluZCBmYXIgcGxhbmUgb2YgbGlnaHQgZnJ1c3R1bVxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBTSEFET1dNQVBfQ0FTQ0FERVwiLFxyXG5cclxuXHRcdFx0XHRcdFwiaW5GcnVzdHVtQ291bnQgKz0gaW50KCBpbkZydXN0dW0gKTtcIixcclxuXHRcdFx0XHRcdFwiYnZlYzMgZnJ1c3R1bVRlc3RWZWMgPSBidmVjMyggaW5GcnVzdHVtLCBpbkZydXN0dW1Db3VudCA9PSAxLCBzaGFkb3dDb29yZC56IDw9IDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJidmVjMiBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMyKCBpbkZydXN0dW0sIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiYm9vbCBmcnVzdHVtVGVzdCA9IGFsbCggZnJ1c3R1bVRlc3RWZWMgKTtcIixcclxuXHJcblx0XHRcdFx0XCJpZiAoIGZydXN0dW1UZXN0ICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwic2hhZG93Q29vcmQueiArPSBzaGFkb3dCaWFzWyBpIF07XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGIClcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIFBlcmNlbnRhZ2UtY2xvc2UgZmlsdGVyaW5nXHJcblx0XHRcdFx0XHRcdC8vICg5IHBpeGVsIGtlcm5lbClcclxuXHRcdFx0XHRcdFx0Ly8gaHR0cDovL2ZhYmllbnNhbmdsYXJkLm5ldC9zaGFkb3dtYXBwaW5nUENGL1xyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBzaGFkb3cgPSAwLjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvKlxyXG5cdFx0XHRcdFx0XHQvLyBuZXN0ZWQgbG9vcHMgYnJlYWtzIHNoYWRlciBjb21waWxlciAvIHZhbGlkYXRvciBvbiBzb21lIEFUSSBjYXJkcyB3aGVuIHVzaW5nIE9wZW5HTFxyXG5cdFx0XHRcdFx0XHQvLyBtdXN0IGVucm9sbCBsb29wIG1hbnVhbGx5XHJcblxyXG5cdFx0XHRcdFx0XHRcImZvciAoIGZsb2F0IHkgPSAtMS4yNTsgeSA8PSAxLjI1OyB5ICs9IDEuMjUgKVwiLFxyXG5cdFx0XHRcdFx0XHRcdFwiZm9yICggZmxvYXQgeCA9IC0xLjI1OyB4IDw9IDEuMjU7IHggKz0gMS4yNSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcInZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgdmVjMiggeCAqIHhQaXhlbE9mZnNldCwgeSAqIHlQaXhlbE9mZnNldCApICsgc2hhZG93Q29vcmQueHkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBkb2Vzbid0IHNlZW0gdG8gcHJvZHVjZSBhbnkgbm90aWNlYWJsZSB2aXN1YWwgZGlmZmVyZW5jZSBjb21wYXJlZCB0byBzaW1wbGUgXCJ0ZXh0dXJlMkRcIiBsb29rdXBcclxuXHRcdFx0XHRcdFx0XHRcdC8vXCJ2ZWM0IHJnYmFEZXB0aCA9IHRleHR1cmUyRFByb2ooIHNoYWRvd01hcFsgaSBdLCB2ZWM0KCB2U2hhZG93Q29vcmRbIGkgXS53ICogKCB2ZWMyKCB4ICogeFBpeGVsT2Zmc2V0LCB5ICogeVBpeGVsT2Zmc2V0ICkgKyBzaGFkb3dDb29yZC54eSApLCAwLjA1LCB2U2hhZG93Q29vcmRbIGkgXS53ICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcImZsb2F0IGZEZXB0aCA9IHVucGFja0RlcHRoKCByZ2JhRGVwdGggKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdFwic2hhZG93ICs9IDEuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJzaGFkb3cgLz0gOS4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ki9cclxuXHJcblx0XHRcdFx0XHRcdFwiY29uc3QgZmxvYXQgc2hhZG93RGVsdGEgPSAxLjAgLyA5LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHhQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS54O1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHlQaXhlbE9mZnNldCA9IDEuMCAvIHNoYWRvd01hcFNpemVbIGkgXS55O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkeDAgPSAtMS4yNSAqIHhQaXhlbE9mZnNldDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkeTAgPSAtMS4yNSAqIHlQaXhlbE9mZnNldDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkeDEgPSAxLjI1ICogeFBpeGVsT2Zmc2V0O1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGR5MSA9IDEuMjUgKiB5UGl4ZWxPZmZzZXQ7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkwICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTAgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZkRlcHRoID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTEgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBmRGVwdGggPCBzaGFkb3dDb29yZC56ICkgc2hhZG93ICs9IHNoYWRvd0RlbHRhO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmRGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MSApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGZEZXB0aCA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3cgKz0gc2hhZG93RGVsdGE7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZEZXB0aCA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApIHNoYWRvdyArPSBzaGFkb3dEZWx0YTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwic2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvciAqIHZlYzMoICggMS4wIC0gc2hhZG93RGFya25lc3NbIGkgXSAqIHNoYWRvdyApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZWxpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBQZXJjZW50YWdlLWNsb3NlIGZpbHRlcmluZ1xyXG5cdFx0XHRcdFx0XHQvLyAoOSBwaXhlbCBrZXJuZWwpXHJcblx0XHRcdFx0XHRcdC8vIGh0dHA6Ly9mYWJpZW5zYW5nbGFyZC5uZXQvc2hhZG93bWFwcGluZ1BDRi9cclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgc2hhZG93ID0gMC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCB4UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCB5UGl4ZWxPZmZzZXQgPSAxLjAgLyBzaGFkb3dNYXBTaXplWyBpIF0ueTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZHgwID0gLTEuMCAqIHhQaXhlbE9mZnNldDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkeTAgPSAtMS4wICogeVBpeGVsT2Zmc2V0O1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGR4MSA9IDEuMCAqIHhQaXhlbE9mZnNldDtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkeTEgPSAxLjAgKiB5UGl4ZWxPZmZzZXQ7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIm1hdDMgc2hhZG93S2VybmVsO1wiLFxyXG5cdFx0XHRcdFx0XHRcIm1hdDMgZGVwdGhLZXJuZWw7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImRlcHRoS2VybmVsWzBdWzBdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBkZXB0aEtlcm5lbFswXVswXSA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3dLZXJuZWxbMF1bMF0gPSAwLjI1O1wiLFxyXG5cdFx0XHRcdFx0XHRcImVsc2Ugc2hhZG93S2VybmVsWzBdWzBdID0gMC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJkZXB0aEtlcm5lbFswXVsxXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgMC4wICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZGVwdGhLZXJuZWxbMF1bMV0gPCBzaGFkb3dDb29yZC56ICkgc2hhZG93S2VybmVsWzBdWzFdID0gMC4yNTtcIixcclxuXHRcdFx0XHRcdFx0XCJlbHNlIHNoYWRvd0tlcm5lbFswXVsxXSA9IDAuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZGVwdGhLZXJuZWxbMF1bMl0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGldLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MCwgZHkxICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZGVwdGhLZXJuZWxbMF1bMl0gPCBzaGFkb3dDb29yZC56ICkgc2hhZG93S2VybmVsWzBdWzJdID0gMC4yNTtcIixcclxuXHRcdFx0XHRcdFx0XCJlbHNlIHNoYWRvd0tlcm5lbFswXVsyXSA9IDAuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZGVwdGhLZXJuZWxbMV1bMF0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCAwLjAsIGR5MCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGRlcHRoS2VybmVsWzFdWzBdIDwgc2hhZG93Q29vcmQueiApIHNoYWRvd0tlcm5lbFsxXVswXSA9IDAuMjU7XCIsXHJcblx0XHRcdFx0XHRcdFwiZWxzZSBzaGFkb3dLZXJuZWxbMV1bMF0gPSAwLjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImRlcHRoS2VybmVsWzFdWzFdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGRlcHRoS2VybmVsWzFdWzFdIDwgc2hhZG93Q29vcmQueiApIHNoYWRvd0tlcm5lbFsxXVsxXSA9IDAuMjU7XCIsXHJcblx0XHRcdFx0XHRcdFwiZWxzZSBzaGFkb3dLZXJuZWxbMV1bMV0gPSAwLjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImRlcHRoS2VybmVsWzFdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBkZXB0aEtlcm5lbFsxXVsyXSA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3dLZXJuZWxbMV1bMl0gPSAwLjI1O1wiLFxyXG5cdFx0XHRcdFx0XHRcImVsc2Ugc2hhZG93S2VybmVsWzFdWzJdID0gMC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJkZXB0aEtlcm5lbFsyXVswXSA9IHVucGFja0RlcHRoKCB0ZXh0dXJlMkQoIHNoYWRvd01hcFsgaSBdLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkwICkgKSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImlmICggZGVwdGhLZXJuZWxbMl1bMF0gPCBzaGFkb3dDb29yZC56ICkgc2hhZG93S2VybmVsWzJdWzBdID0gMC4yNTtcIixcclxuXHRcdFx0XHRcdFx0XCJlbHNlIHNoYWRvd0tlcm5lbFsyXVswXSA9IDAuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZGVwdGhLZXJuZWxbMl1bMV0gPSB1bnBhY2tEZXB0aCggdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIDAuMCApICkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIGRlcHRoS2VybmVsWzJdWzFdIDwgc2hhZG93Q29vcmQueiApIHNoYWRvd0tlcm5lbFsyXVsxXSA9IDAuMjU7XCIsXHJcblx0XHRcdFx0XHRcdFwiZWxzZSBzaGFkb3dLZXJuZWxbMl1bMV0gPSAwLjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImRlcHRoS2VybmVsWzJdWzJdID0gdW5wYWNrRGVwdGgoIHRleHR1cmUyRCggc2hhZG93TWFwWyBpIF0sIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgxLCBkeTEgKSApICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBkZXB0aEtlcm5lbFsyXVsyXSA8IHNoYWRvd0Nvb3JkLnogKSBzaGFkb3dLZXJuZWxbMl1bMl0gPSAwLjI1O1wiLFxyXG5cdFx0XHRcdFx0XHRcImVsc2Ugc2hhZG93S2VybmVsWzJdWzJdID0gMC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMyIGZyYWN0aW9uYWxDb29yZCA9IDEuMCAtIGZyYWN0KCBzaGFkb3dDb29yZC54eSAqIHNoYWRvd01hcFNpemVbaV0ueHkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwic2hhZG93S2VybmVsWzBdID0gbWl4KCBzaGFkb3dLZXJuZWxbMV0sIHNoYWRvd0tlcm5lbFswXSwgZnJhY3Rpb25hbENvb3JkLnggKTtcIixcclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dLZXJuZWxbMV0gPSBtaXgoIHNoYWRvd0tlcm5lbFsyXSwgc2hhZG93S2VybmVsWzFdLCBmcmFjdGlvbmFsQ29vcmQueCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IHNoYWRvd1ZhbHVlcztcIixcclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dWYWx1ZXMueCA9IG1peCggc2hhZG93S2VybmVsWzBdWzFdLCBzaGFkb3dLZXJuZWxbMF1bMF0sIGZyYWN0aW9uYWxDb29yZC55ICk7XCIsXHJcblx0XHRcdFx0XHRcdFwic2hhZG93VmFsdWVzLnkgPSBtaXgoIHNoYWRvd0tlcm5lbFswXVsyXSwgc2hhZG93S2VybmVsWzBdWzFdLCBmcmFjdGlvbmFsQ29vcmQueSApO1wiLFxyXG5cdFx0XHRcdFx0XHRcInNoYWRvd1ZhbHVlcy56ID0gbWl4KCBzaGFkb3dLZXJuZWxbMV1bMV0sIHNoYWRvd0tlcm5lbFsxXVswXSwgZnJhY3Rpb25hbENvb3JkLnkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dWYWx1ZXMudyA9IG1peCggc2hhZG93S2VybmVsWzFdWzJdLCBzaGFkb3dLZXJuZWxbMV1bMV0sIGZyYWN0aW9uYWxDb29yZC55ICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInNoYWRvdyA9IGRvdCggc2hhZG93VmFsdWVzLCB2ZWM0KCAxLjAgKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJzaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yICogdmVjMyggKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICogc2hhZG93ICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzQgcmdiYURlcHRoID0gdGV4dHVyZTJEKCBzaGFkb3dNYXBbIGkgXSwgc2hhZG93Q29vcmQueHkgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBmRGVwdGggPSB1bnBhY2tEZXB0aCggcmdiYURlcHRoICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImlmICggZkRlcHRoIDwgc2hhZG93Q29vcmQueiApXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHNwb3Qgd2l0aCBtdWx0aXBsZSBzaGFkb3dzIGlzIGRhcmtlclxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IgKiB2ZWMzKCAxLjAgLSBzaGFkb3dEYXJrbmVzc1sgaSBdICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIHNwb3Qgd2l0aCBtdWx0aXBsZSBzaGFkb3dzIGhhcyB0aGUgc2FtZSBjb2xvciBhcyBzaW5nbGUgc2hhZG93IHNwb3RcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly9cInNoYWRvd0NvbG9yID0gbWluKCBzaGFkb3dDb2xvciwgdmVjMyggc2hhZG93RGFya25lc3NbIGkgXSApICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBTSEFET1dNQVBfREVCVUdcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBTSEFET1dNQVBfQ0FTQ0FERVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIGluRnJ1c3R1bSAmJiBpbkZydXN0dW1Db3VudCA9PSAxICkgZ2xfRnJhZ0NvbG9yLnh5eiAqPSBmcnVzdHVtQ29sb3JzWyBpIF07XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIGluRnJ1c3R1bSApIGdsX0ZyYWdDb2xvci54eXogKj0gZnJ1c3R1bUNvbG9yc1sgaSBdO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIEdBTU1BX09VVFBVVFwiLFxyXG5cclxuXHRcdFx0XHRcInNoYWRvd0NvbG9yICo9IHNoYWRvd0NvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IGdsX0ZyYWdDb2xvci54eXogKiBzaGFkb3dDb2xvcjtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0c2hhZG93bWFwX3BhcnNfdmVydGV4OiBbXHJcblxyXG5cdFx0XCIjaWZkZWYgVVNFX1NIQURPV01BUFwiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzQgdlNoYWRvd0Nvb3JkWyBNQVhfU0hBRE9XUyBdO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gbWF0NCBzaGFkb3dNYXRyaXhbIE1BWF9TSEFET1dTIF07XCIsXHJcblxyXG5cdFx0XCIjZW5kaWZcIlxyXG5cclxuXHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdHNoYWRvd21hcF92ZXJ0ZXg6IFtcclxuXHJcblx0XHRcIiNpZmRlZiBVU0VfU0hBRE9XTUFQXCIsXHJcblxyXG5cdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX1NIQURPV1M7IGkgKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidlNoYWRvd0Nvb3JkWyBpIF0gPSBzaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcIn1cIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gQUxQSEFURVNUXHJcblxyXG5cdGFscGhhdGVzdF9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIEFMUEhBVEVTVFwiLFxyXG5cclxuXHRcdFx0XCJpZiAoIGdsX0ZyYWdDb2xvci5hIDwgQUxQSEFURVNUICkgZGlzY2FyZDtcIixcclxuXHJcblx0XHRcIiNlbmRpZlwiXHJcblxyXG5cdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0Ly8gTElORUFSIFNQQUNFXHJcblxyXG5cdGxpbmVhcl90b19nYW1tYV9mcmFnbWVudDogW1xyXG5cclxuXHRcdFwiI2lmZGVmIEdBTU1BX09VVFBVVFwiLFxyXG5cclxuXHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gc3FydCggZ2xfRnJhZ0NvbG9yLnh5eiApO1wiLFxyXG5cclxuXHRcdFwiI2VuZGlmXCJcclxuXHJcblx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cclxufTtcclxuXHJcblRIUkVFLlVuaWZvcm1zVXRpbHMgPSB7XHJcblxyXG5cdG1lcmdlOiBmdW5jdGlvbiAoIHVuaWZvcm1zICkge1xyXG5cclxuXHRcdHZhciB1LCBwLCB0bXAsIG1lcmdlZCA9IHt9O1xyXG5cclxuXHRcdGZvciAoIHUgPSAwOyB1IDwgdW5pZm9ybXMubGVuZ3RoOyB1ICsrICkge1xyXG5cclxuXHRcdFx0dG1wID0gdGhpcy5jbG9uZSggdW5pZm9ybXNbIHUgXSApO1xyXG5cclxuXHRcdFx0Zm9yICggcCBpbiB0bXAgKSB7XHJcblxyXG5cdFx0XHRcdG1lcmdlZFsgcCBdID0gdG1wWyBwIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBtZXJnZWQ7XHJcblxyXG5cdH0sXHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoIHVuaWZvcm1zX3NyYyApIHtcclxuXHJcblx0XHR2YXIgdSwgcCwgcGFyYW1ldGVyLCBwYXJhbWV0ZXJfc3JjLCB1bmlmb3Jtc19kc3QgPSB7fTtcclxuXHJcblx0XHRmb3IgKCB1IGluIHVuaWZvcm1zX3NyYyApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdID0ge307XHJcblxyXG5cdFx0XHRmb3IgKCBwIGluIHVuaWZvcm1zX3NyY1sgdSBdICkge1xyXG5cclxuXHRcdFx0XHRwYXJhbWV0ZXJfc3JjID0gdW5pZm9ybXNfc3JjWyB1IF1bIHAgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuQ29sb3IgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuVmVjdG9yMiB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzIHx8XHJcblx0XHRcdFx0XHQgcGFyYW1ldGVyX3NyYyBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjQgfHxcclxuXHRcdFx0XHRcdCBwYXJhbWV0ZXJfc3JjIGluc3RhbmNlb2YgVEhSRUUuTWF0cml4NCB8fFxyXG5cdFx0XHRcdFx0IHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBUSFJFRS5UZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcl9zcmMgaW5zdGFuY2VvZiBBcnJheSApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYy5zbGljZSgpO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB1bmlmb3Jtc19kc3Q7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Vbmlmb3Jtc0xpYiA9IHtcclxuXHJcblx0Y29tbW9uOiB7XHJcblxyXG5cdFx0XCJkaWZmdXNlXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGVlZWVlZSApIH0sXHJcblx0XHRcIm9wYWNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHJcblx0XHRcIm1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwib2Zmc2V0UmVwZWF0XCIgOiB7IHR5cGU6IFwidjRcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3I0KCAwLCAwLCAxLCAxICkgfSxcclxuXHJcblx0XHRcImxpZ2h0TWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJzcGVjdWxhck1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHJcblx0XHRcImVudk1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwiZmxpcEVudk1hcFwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0xIH0sXHJcblx0XHRcInVzZVJlZnJhY3RcIiA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXHJcblx0XHRcInJlZmxlY3Rpdml0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9LFxyXG5cdFx0XCJyZWZyYWN0aW9uUmF0aW9cIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjk4IH0sXHJcblx0XHRcImNvbWJpbmVcIiA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXHJcblxyXG5cdFx0XCJtb3JwaFRhcmdldEluZmx1ZW5jZXNcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwIH1cclxuXHJcblx0fSxcclxuXHJcblx0YnVtcDoge1xyXG5cclxuXHRcdFwiYnVtcE1hcFwiIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFwiYnVtcFNjYWxlXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdG5vcm1hbG1hcDoge1xyXG5cclxuXHRcdFwibm9ybWFsTWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cdFx0XCJub3JtYWxTY2FsZVwiIDogeyB0eXBlOiBcInYyXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMiggMSwgMSApIH1cclxuXHR9LFxyXG5cclxuXHRmb2cgOiB7XHJcblxyXG5cdFx0XCJmb2dEZW5zaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC4wMDAyNSB9LFxyXG5cdFx0XCJmb2dOZWFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cdFx0XCJmb2dGYXJcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAyMDAwIH0sXHJcblx0XHRcImZvZ0NvbG9yXCIgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH1cclxuXHJcblx0fSxcclxuXHJcblx0bGlnaHRzOiB7XHJcblxyXG5cdFx0XCJhbWJpZW50TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwiZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJkaXJlY3Rpb25hbExpZ2h0Q29sb3JcIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcImhlbWlzcGhlcmVMaWdodERpcmVjdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJoZW1pc3BoZXJlTGlnaHRTa3lDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwicG9pbnRMaWdodENvbG9yXCIgOiB7IHR5cGU6IFwiZnZcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInBvaW50TGlnaHRQb3NpdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJwb2ludExpZ2h0RGlzdGFuY2VcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblxyXG5cdFx0XCJzcG90TGlnaHRDb2xvclwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJzcG90TGlnaHRQb3NpdGlvblwiIDogeyB0eXBlOiBcImZ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJzcG90TGlnaHREaXJlY3Rpb25cIiA6IHsgdHlwZTogXCJmdlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic3BvdExpZ2h0RGlzdGFuY2VcIiA6IHsgdHlwZTogXCJmdjFcIiwgdmFsdWU6IFtdIH0sXHJcblx0XHRcInNwb3RMaWdodEFuZ2xlQ29zXCIgOiB7IHR5cGU6IFwiZnYxXCIsIHZhbHVlOiBbXSB9LFxyXG5cdFx0XCJzcG90TGlnaHRFeHBvbmVudFwiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfVxyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJ0aWNsZToge1xyXG5cclxuXHRcdFwicHNDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhlZWVlZWUgKSB9LFxyXG5cdFx0XCJvcGFjaXR5XCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblx0XHRcInNpemVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwic2NhbGVcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFwibWFwXCIgOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LFxyXG5cclxuXHRcdFwiZm9nRGVuc2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMDAwMjUgfSxcclxuXHRcdFwiZm9nTmVhclwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEgfSxcclxuXHRcdFwiZm9nRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMCB9LFxyXG5cdFx0XCJmb2dDb2xvclwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9XHJcblxyXG5cdH0sXHJcblxyXG5cdHNoYWRvd21hcDoge1xyXG5cclxuXHRcdFwic2hhZG93TWFwXCI6IHsgdHlwZTogXCJ0dlwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic2hhZG93TWFwU2l6ZVwiOiB7IHR5cGU6IFwidjJ2XCIsIHZhbHVlOiBbXSB9LFxyXG5cclxuXHRcdFwic2hhZG93Qmlhc1wiIDogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHRcdFwic2hhZG93RGFya25lc3NcIjogeyB0eXBlOiBcImZ2MVwiLCB2YWx1ZTogW10gfSxcclxuXHJcblx0XHRcInNoYWRvd01hdHJpeFwiIDogeyB0eXBlOiBcIm00dlwiLCB2YWx1ZTogW10gfVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2hhZGVyTGliID0ge1xyXG5cclxuXHQnYmFzaWMnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFVTRV9FTlZNQVBcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubm9ybWFsX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZGVmYXVsdF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0J2xhbWJlcnQnOiB7XHJcblxyXG5cdFx0dW5pZm9ybXM6IFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImNvbW1vblwiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImZvZ1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcImxpZ2h0c1wiIF0sXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInNoYWRvd21hcFwiIF0sXHJcblxyXG5cdFx0XHR7XHJcblx0XHRcdFx0XCJhbWJpZW50XCIgIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9LFxyXG5cdFx0XHRcdFwiZW1pc3NpdmVcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICkgfSxcclxuXHRcdFx0XHRcIndyYXBSR0JcIiAgOiB7IHR5cGU6IFwidjNcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICkgfVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCIjZGVmaW5lIExBTUJFUlRcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodEZyb250O1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFwidmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ19wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaG5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5iYXNlX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5vcm1hbF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwid29ybGRwb3NfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfbGFtYmVydF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0RnJvbnQ7XCIsXHJcblxyXG5cdFx0XHRcIiNpZmRlZiBET1VCTEVfU0lERURcIixcclxuXHJcblx0XHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkxpZ2h0QmFjaztcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzICggMS4wICksIG9wYWNpdHkgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJhbHBoYXRlc3RfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNwZWN1bGFybWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgRE9VQkxFX1NJREVEXCIsXHJcblxyXG5cdFx0XHRcdFx0Ly9cImZsb2F0IGlzRnJvbnQgPSBmbG9hdCggZ2xfRnJvbnRGYWNpbmcgKTtcIixcclxuXHRcdFx0XHRcdC8vXCJnbF9GcmFnQ29sb3IueHl6ICo9IGlzRnJvbnQgKiB2TGlnaHRGcm9udCArICggMS4wIC0gaXNGcm9udCApICogdkxpZ2h0QmFjaztcIixcclxuXHJcblx0XHRcdFx0XHRcImlmICggZ2xfRnJvbnRGYWNpbmcgKVwiLFxyXG5cdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci54eXogKj0gdkxpZ2h0RnJvbnQ7XCIsXHJcblx0XHRcdFx0XHRcImVsc2VcIixcclxuXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ICo9IHZMaWdodEJhY2s7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci54eXogKj0gdkxpZ2h0RnJvbnQ7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZW52bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaW5lYXJfdG9fZ2FtbWFfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0J3Bob25nJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJjb21tb25cIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJidW1wXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibm9ybWFsbWFwXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwibGlnaHRzXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXSxcclxuXHJcblx0XHRcdHtcclxuXHRcdFx0XHRcImFtYmllbnRcIiAgOiB7IHR5cGU6IFwiY1wiLCB2YWx1ZTogbmV3IFRIUkVFLkNvbG9yKCAweGZmZmZmZiApIH0sXHJcblx0XHRcdFx0XCJlbWlzc2l2ZVwiIDogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHgwMDAwMDAgKSB9LFxyXG5cdFx0XHRcdFwic3BlY3VsYXJcIiA6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICkgfSxcclxuXHRcdFx0XHRcInNoaW5pbmVzc1wiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMzAgfSxcclxuXHRcdFx0XHRcIndyYXBSR0JcIiAgOiB7IHR5cGU6IFwidjNcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IzKCAxLCAxLCAxICkgfVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCIjZGVmaW5lIFBIT05HXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJlbnZtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc192ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0bWFwX3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGhub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0bm9ybWFsX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcdFwidk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibW9ycGh0YXJnZXRfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2lubmluZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImRlZmF1bHRfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0XCJ2Vmlld1Bvc2l0aW9uID0gLW12UG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImxpZ2h0c19waG9uZ192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgYW1iaWVudDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZW1pc3NpdmU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwZWN1bGFyO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGlnaHRtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYnVtcG1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibm9ybWFsbWFwX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIHZlYzMgKCAxLjAgKSwgb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImFscGhhdGVzdF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic3BlY3VsYXJtYXBfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodHNfcGhvbmdfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJsaWdodG1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImVudm1hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX2ZyYWdtZW50XCIgXSxcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cdH0sXHJcblxyXG5cdCdwYXJ0aWNsZV9iYXNpYyc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogIFRIUkVFLlVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcclxuXHJcblx0XHRcdFRIUkVFLlVuaWZvcm1zTGliWyBcInBhcnRpY2xlXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwic2hhZG93bWFwXCIgXVxyXG5cclxuXHRcdF0gKSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBzaXplO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgc2NhbGU7XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFVTRV9TSVpFQVRURU5VQVRJT05cIixcclxuXHRcdFx0XHRcdFwiZ2xfUG9pbnRTaXplID0gc2l6ZSAqICggc2NhbGUgLyBsZW5ndGgoIG12UG9zaXRpb24ueHl6ICkgKTtcIixcclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblx0XHRcdFx0XHRcImdsX1BvaW50U2l6ZSA9IHNpemU7XCIsXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJ3b3JsZHBvc192ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHBzQ29sb3I7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiY29sb3JfcGFyc19mcmFnbWVudFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJzaGFkb3dtYXBfcGFyc19mcmFnbWVudFwiIF0sXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwc0NvbG9yLCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1hcF9wYXJ0aWNsZV9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiYWxwaGF0ZXN0X2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0J2Rhc2hlZCc6IHtcclxuXHJcblx0XHR1bmlmb3JtczogVEhSRUUuVW5pZm9ybXNVdGlscy5tZXJnZSggW1xyXG5cclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiY29tbW9uXCIgXSxcclxuXHRcdFx0VEhSRUUuVW5pZm9ybXNMaWJbIFwiZm9nXCIgXSxcclxuXHJcblx0XHRcdHtcclxuXHRcdFx0XHRcInNjYWxlXCI6ICAgICB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMSB9LFxyXG5cdFx0XHRcdFwiZGFzaFNpemVcIjogIHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblx0XHRcdFx0XCJ0b3RhbFNpemVcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDIgfVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XSApLFxyXG5cclxuXHRcdHZlcnRleFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSBmbG9hdCBsaW5lRGlzdGFuY2U7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl92ZXJ0ZXhcIiBdLFxyXG5cclxuXHRcdFx0XHRcInZMaW5lRGlzdGFuY2UgPSBzY2FsZSAqIGxpbmVEaXN0YW5jZTtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblx0XHRcdFx0XCJnbF9Qb3NpdGlvbiA9IHByb2plY3Rpb25NYXRyaXggKiBtdlBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGRhc2hTaXplO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdG90YWxTaXplO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XCIsXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJjb2xvcl9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJkaXNjYXJkO1wiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcImNvbG9yX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fSxcclxuXHJcblx0J2RlcHRoJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcIm1OZWFyXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfSxcclxuXHRcdFx0XCJtRmFyXCIgOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMjAwMC4wIH0sXHJcblx0XHRcdFwib3BhY2l0eVwiIDogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDEuMCB9XHJcblxyXG5cdFx0fSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgbU5lYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBtRmFyO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImZsb2F0IGRlcHRoID0gZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudztcIixcclxuXHRcdFx0XHRcImZsb2F0IGNvbG9yID0gMS4wIC0gc21vb3Roc3RlcCggbU5lYXIsIG1GYXIsIGRlcHRoICk7XCIsXHJcblx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB2ZWMzKCBjb2xvciApLCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKVxyXG5cclxuXHR9LFxyXG5cclxuXHQnbm9ybWFsJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiB7XHJcblxyXG5cdFx0XHRcIm9wYWNpdHlcIiA6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxLjAgfVxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggcG9zaXRpb24sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFwidk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogbm9ybWFsICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHZlYzQoIDAuNSAqIG5vcm1hbGl6ZSggdk5vcm1hbCApICsgMC41LCBvcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKVxyXG5cclxuXHR9LFxyXG5cclxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0Ly9cdE5vcm1hbCBtYXAgc2hhZGVyXHJcblx0Ly9cdFx0LSBCbGlubi1QaG9uZ1xyXG5cdC8vXHRcdC0gbm9ybWFsICsgZGlmZnVzZSArIHNwZWN1bGFyICsgQU8gKyBkaXNwbGFjZW1lbnQgKyByZWZsZWN0aW9uICsgc2hhZG93IG1hcHNcclxuXHQvL1x0XHQtIHBvaW50IGFuZCBkaXJlY3Rpb25hbCBsaWdodHMgKHVzZSB3aXRoIFwibGlnaHRzOiB0cnVlXCIgbWF0ZXJpYWwgb3B0aW9uKVxyXG5cdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5cdCdub3JtYWxtYXAnIDoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiBUSFJFRS5Vbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXHJcblxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJmb2dcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJsaWdodHNcIiBdLFxyXG5cdFx0XHRUSFJFRS5Vbmlmb3Jtc0xpYlsgXCJzaGFkb3dtYXBcIiBdLFxyXG5cclxuXHRcdFx0e1xyXG5cclxuXHRcdFx0XCJlbmFibGVBT1wiXHRcdCAgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxyXG5cdFx0XHRcImVuYWJsZURpZmZ1c2VcIlx0ICA6IHsgdHlwZTogXCJpXCIsIHZhbHVlOiAwIH0sXHJcblx0XHRcdFwiZW5hYmxlU3BlY3VsYXJcIiAgOiB7IHR5cGU6IFwiaVwiLCB2YWx1ZTogMCB9LFxyXG5cdFx0XHRcImVuYWJsZVJlZmxlY3Rpb25cIjogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcclxuXHRcdFx0XCJlbmFibGVEaXNwbGFjZW1lbnRcIjogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcclxuXHJcblx0XHRcdFwidERpc3BsYWNlbWVudFwiOiB7IHR5cGU6IFwidFwiLCB2YWx1ZTogbnVsbCB9LCAvLyBtdXN0IGdvIGZpcnN0IGFzIHRoaXMgaXMgdmVydGV4IHRleHR1cmVcclxuXHRcdFx0XCJ0RGlmZnVzZVwiXHQgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFwidEN1YmVcIlx0XHQgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFwidE5vcm1hbFwiXHQgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblx0XHRcdFwidFNwZWN1bGFyXCJcdCAgIDogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0XCJ0QU9cIlx0XHQgICA6IHsgdHlwZTogXCJ0XCIsIHZhbHVlOiBudWxsIH0sXHJcblxyXG5cdFx0XHRcInVOb3JtYWxTY2FsZVwiOiB7IHR5cGU6IFwidjJcIiwgdmFsdWU6IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICkgfSxcclxuXHJcblx0XHRcdFwidURpc3BsYWNlbWVudEJpYXNcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IDAuMCB9LFxyXG5cdFx0XHRcInVEaXNwbGFjZW1lbnRTY2FsZVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMS4wIH0sXHJcblxyXG5cdFx0XHRcInVEaWZmdXNlQ29sb3JcIjogeyB0eXBlOiBcImNcIiwgdmFsdWU6IG5ldyBUSFJFRS5Db2xvciggMHhmZmZmZmYgKSB9LFxyXG5cdFx0XHRcInVTcGVjdWxhckNvbG9yXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4MTExMTExICkgfSxcclxuXHRcdFx0XCJ1QW1iaWVudENvbG9yXCI6IHsgdHlwZTogXCJjXCIsIHZhbHVlOiBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICkgfSxcclxuXHRcdFx0XCJ1U2hpbmluZXNzXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAzMCB9LFxyXG5cdFx0XHRcInVPcGFjaXR5XCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAxIH0sXHJcblxyXG5cdFx0XHRcInVzZVJlZnJhY3RcIjogeyB0eXBlOiBcImlcIiwgdmFsdWU6IDAgfSxcclxuXHRcdFx0XCJ1UmVmcmFjdGlvblJhdGlvXCI6IHsgdHlwZTogXCJmXCIsIHZhbHVlOiAwLjk4IH0sXHJcblx0XHRcdFwidVJlZmxlY3Rpdml0eVwiOiB7IHR5cGU6IFwiZlwiLCB2YWx1ZTogMC41IH0sXHJcblxyXG5cdFx0XHRcInVPZmZzZXRcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDAsIDAgKSB9LFxyXG5cdFx0XHRcInVSZXBlYXRcIiA6IHsgdHlwZTogXCJ2MlwiLCB2YWx1ZTogbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKSB9LFxyXG5cclxuXHRcdFx0XCJ3cmFwUkdCXCIgIDogeyB0eXBlOiBcInYzXCIsIHZhbHVlOiBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMSApIH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRdICksXHJcblxyXG5cdFx0ZnJhZ21lbnRTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHVBbWJpZW50Q29sb3I7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHVEaWZmdXNlQ29sb3I7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHVTcGVjdWxhckNvbG9yO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdVNoaW5pbmVzcztcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHVPcGFjaXR5O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGJvb2wgZW5hYmxlRGlmZnVzZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGJvb2wgZW5hYmxlU3BlY3VsYXI7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBib29sIGVuYWJsZUFPO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gYm9vbCBlbmFibGVSZWZsZWN0aW9uO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0RGlmZnVzZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0Tm9ybWFsO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIHRTcGVjdWxhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCB0QU87XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMiB1Tm9ybWFsU2NhbGU7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gYm9vbCB1c2VSZWZyYWN0O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgdVJlZnJhY3Rpb25SYXRpbztcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHVSZWZsZWN0aXZpdHk7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkJpbm9ybWFsO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcIixcclxuXHJcblx0XHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0Q29sb3JbIE1BWF9ESVJfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvblsgTUFYX0RJUl9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIGhlbWlzcGhlcmVMaWdodFNreUNvbG9yWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBoZW1pc3BoZXJlTGlnaHRHcm91bmRDb2xvclsgTUFYX0hFTUlfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBNQVhfSEVNSV9MSUdIVFMgXTtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIiNpZiBNQVhfUE9JTlRfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0Q29sb3JbIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bIE1BWF9QT0lOVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodERpc3RhbmNlWyBNQVhfUE9JTlRfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRDb2xvclsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0UG9zaXRpb25bIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodERpcmVjdGlvblsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblx0XHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodEFuZ2xlQ29zWyBNQVhfU1BPVF9MSUdIVFMgXTtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0RXhwb25lbnRbIE1BWF9TUE9UX0xJR0hUUyBdO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHREaXN0YW5jZVsgTUFYX1NQT1RfTElHSFRTIF07XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XCJ1bmlmb3JtIHZlYzMgd3JhcFJHQjtcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9wYXJzX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwiZm9nX3BhcnNfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggMS4wICksIHVPcGFjaXR5ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBzcGVjdWxhclRleCA9IHZlYzMoIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzMgbm9ybWFsVGV4ID0gdGV4dHVyZTJEKCB0Tm9ybWFsLCB2VXYgKS54eXogKiAyLjAgLSAxLjA7XCIsXHJcblx0XHRcdFx0XCJub3JtYWxUZXgueHkgKj0gdU5vcm1hbFNjYWxlO1wiLFxyXG5cdFx0XHRcdFwibm9ybWFsVGV4ID0gbm9ybWFsaXplKCBub3JtYWxUZXggKTtcIixcclxuXHJcblx0XHRcdFx0XCJpZiggZW5hYmxlRGlmZnVzZSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBHQU1NQV9JTlBVVFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQoIHREaWZmdXNlLCB2VXYgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJ0ZXhlbENvbG9yLnh5eiAqPSB0ZXhlbENvbG9yLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gZ2xfRnJhZ0NvbG9yICogdGV4ZWxDb2xvcjtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IGdsX0ZyYWdDb2xvciAqIHRleHR1cmUyRCggdERpZmZ1c2UsIHZVdiApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcImlmKCBlbmFibGVBTyApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNpZmRlZiBHQU1NQV9JTlBVVFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IGFvQ29sb3IgPSB0ZXh0dXJlMkQoIHRBTywgdlV2ICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiYW9Db2xvci54eXogKj0gYW9Db2xvci54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci54eXogPSBnbF9GcmFnQ29sb3IueHl6ICogYW9Db2xvci54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqIHRleHR1cmUyRCggdEFPLCB2VXYgKS54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYoIGVuYWJsZVNwZWN1bGFyIClcIixcclxuXHRcdFx0XHRcdFwic3BlY3VsYXJUZXggPSB0ZXh0dXJlMkQoIHRTcGVjdWxhciwgdlV2ICkueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcIm1hdDMgdHNiID0gbWF0Myggbm9ybWFsaXplKCB2VGFuZ2VudCApLCBub3JtYWxpemUoIHZCaW5vcm1hbCApLCBub3JtYWxpemUoIHZOb3JtYWwgKSApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyBmaW5hbE5vcm1hbCA9IHRzYiAqIG5vcm1hbFRleDtcIixcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgRkxJUF9TSURFRFwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZmluYWxOb3JtYWwgPSAtZmluYWxOb3JtYWw7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMyBub3JtYWwgPSBub3JtYWxpemUoIGZpbmFsTm9ybWFsICk7XCIsXHJcblx0XHRcdFx0XCJ2ZWMzIHZpZXdQb3NpdGlvbiA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1wiLFxyXG5cclxuXHRcdFx0XHQvLyBwb2ludCBsaWdodHNcclxuXHJcblx0XHRcdFx0XCIjaWYgTUFYX1BPSU5UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgcG9pbnREaWZmdXNlID0gdmVjMyggMC4wICk7XCIsXHJcblx0XHRcdFx0XHRcInZlYzMgcG9pbnRTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1BPSU5UX0xJR0hUUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjNCBsUG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNCggcG9pbnRMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcInZlYzMgcG9pbnRWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHBvaW50RGlzdGFuY2UgPSAxLjA7XCIsXHJcblx0XHRcdFx0XHRcdFwiaWYgKCBwb2ludExpZ2h0RGlzdGFuY2VbIGkgXSA+IDAuMCApXCIsXHJcblx0XHRcdFx0XHRcdFx0XCJwb2ludERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggcG9pbnRWZWN0b3IgKSAvIHBvaW50TGlnaHREaXN0YW5jZVsgaSBdICksIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJwb2ludFZlY3RvciA9IG5vcm1hbGl6ZSggcG9pbnRWZWN0b3IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIGRpZmZ1c2VcclxuXHJcblx0XHRcdFx0XHRcdFwiI2lmZGVmIFdSQVBfQVJPVU5EXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCA9IG1heCggZG90KCBub3JtYWwsIHBvaW50VmVjdG9yICksIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgcG9pbnREaWZmdXNlV2VpZ2h0SGFsZiA9IG1heCggMC41ICogZG90KCBub3JtYWwsIHBvaW50VmVjdG9yICkgKyAwLjUsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzMgcG9pbnREaWZmdXNlV2VpZ2h0ID0gbWl4KCB2ZWMzICggcG9pbnREaWZmdXNlV2VpZ2h0RnVsbCApLCB2ZWMzKCBwb2ludERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBwb2ludERpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdCggbm9ybWFsLCBwb2ludFZlY3RvciApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInBvaW50RGlmZnVzZSArPSBwb2ludERpc3RhbmNlICogcG9pbnRMaWdodENvbG9yWyBpIF0gKiB1RGlmZnVzZUNvbG9yICogcG9pbnREaWZmdXNlV2VpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXJcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBwb2ludEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIHBvaW50VmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgcG9pbnREb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgcG9pbnRIYWxmVmVjdG9yICksIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHBvaW50U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIHBvaW50RG90Tm9ybWFsSGFsZiwgdVNoaW5pbmVzcyApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2lmZGVmIFBIWVNJQ0FMTFlfQkFTRURfU0hBRElOR1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyAyLjAgPT4gMi4wMDAxIGlzIGhhY2sgdG8gd29yayBhcm91bmQgQU5HTEUgYnVnXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwiZmxvYXQgc3BlY3VsYXJOb3JtYWxpemF0aW9uID0gKCB1U2hpbmluZXNzICsgMi4wMDAxICkgLyA4LjA7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFwidmVjMyBzY2hsaWNrID0gdVNwZWN1bGFyQ29sb3IgKyB2ZWMzKCAxLjAgLSB1U3BlY3VsYXJDb2xvciApICogcG93KCAxLjAgLSBkb3QoIHBvaW50VmVjdG9yLCBwb2ludEhhbGZWZWN0b3IgKSwgNS4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJwb2ludFNwZWN1bGFyICs9IHNjaGxpY2sgKiBwb2ludExpZ2h0Q29sb3JbIGkgXSAqIHBvaW50U3BlY3VsYXJXZWlnaHQgKiBwb2ludERpZmZ1c2VXZWlnaHQgKiBwb2ludERpc3RhbmNlICogc3BlY3VsYXJOb3JtYWxpemF0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInBvaW50U3BlY3VsYXIgKz0gcG9pbnREaXN0YW5jZSAqIHBvaW50TGlnaHRDb2xvclsgaSBdICogdVNwZWN1bGFyQ29sb3IgKiBwb2ludFNwZWN1bGFyV2VpZ2h0ICogcG9pbnREaWZmdXNlV2VpZ2h0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0Ly8gc3BvdCBsaWdodHNcclxuXHJcblx0XHRcdFx0XCIjaWYgTUFYX1NQT1RfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjMyBzcG90RGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWMzIHNwb3RTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZm9yICggaW50IGkgPSAwOyBpIDwgTUFYX1NQT1RfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBzcG90TGlnaHRQb3NpdGlvblsgaSBdLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIHNwb3RWZWN0b3IgPSBsUG9zaXRpb24ueHl6ICsgdlZpZXdQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REaXN0YW5jZSA9IDEuMDtcIixcclxuXHRcdFx0XHRcdFx0XCJpZiAoIHNwb3RMaWdodERpc3RhbmNlWyBpIF0gPiAwLjAgKVwiLFxyXG5cdFx0XHRcdFx0XHRcdFwic3BvdERpc3RhbmNlID0gMS4wIC0gbWluKCAoIGxlbmd0aCggc3BvdFZlY3RvciApIC8gc3BvdExpZ2h0RGlzdGFuY2VbIGkgXSApLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwic3BvdFZlY3RvciA9IG5vcm1hbGl6ZSggc3BvdFZlY3RvciApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBzcG90RWZmZWN0ID0gZG90KCBzcG90TGlnaHREaXJlY3Rpb25bIGkgXSwgbm9ybWFsaXplKCBzcG90TGlnaHRQb3NpdGlvblsgaSBdIC0gdldvcmxkUG9zaXRpb24gKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJpZiAoIHNwb3RFZmZlY3QgPiBzcG90TGlnaHRBbmdsZUNvc1sgaSBdICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInNwb3RFZmZlY3QgPSBtYXgoIHBvdyggc3BvdEVmZmVjdCwgc3BvdExpZ2h0RXhwb25lbnRbIGkgXSApLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gZGlmZnVzZVxyXG5cclxuXHRcdFx0XHRcdFx0XHRcIiNpZmRlZiBXUkFQX0FST1VORFwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFwiZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRGdWxsID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFwiZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHRIYWxmID0gbWF4KCAwLjUgKiBkb3QoIG5vcm1hbCwgc3BvdFZlY3RvciApICsgMC41LCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcInZlYzMgc3BvdERpZmZ1c2VXZWlnaHQgPSBtaXgoIHZlYzMgKCBzcG90RGlmZnVzZVdlaWdodEZ1bGwgKSwgdmVjMyggc3BvdERpZmZ1c2VXZWlnaHRIYWxmICksIHdyYXBSR0IgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFwiZmxvYXQgc3BvdERpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdCggbm9ybWFsLCBzcG90VmVjdG9yICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInNwb3REaWZmdXNlICs9IHNwb3REaXN0YW5jZSAqIHNwb3RMaWdodENvbG9yWyBpIF0gKiB1RGlmZnVzZUNvbG9yICogc3BvdERpZmZ1c2VXZWlnaHQgKiBzcG90RWZmZWN0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHQvLyBzcGVjdWxhclxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzMgc3BvdEhhbGZWZWN0b3IgPSBub3JtYWxpemUoIHNwb3RWZWN0b3IgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IHNwb3REb3ROb3JtYWxIYWxmID0gbWF4KCBkb3QoIG5vcm1hbCwgc3BvdEhhbGZWZWN0b3IgKSwgMC4wICk7XCIsXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBzcG90U3BlY3VsYXJXZWlnaHQgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIHNwb3REb3ROb3JtYWxIYWxmLCB1U2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcIiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XHQvLyAyLjAgPT4gMi4wMDAxIGlzIGhhY2sgdG8gd29yayBhcm91bmQgQU5HTEUgYnVnXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XCJmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHVTaGluaW5lc3MgKyAyLjAwMDEgKSAvIDguMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcInZlYzMgc2NobGljayA9IHVTcGVjdWxhckNvbG9yICsgdmVjMyggMS4wIC0gdVNwZWN1bGFyQ29sb3IgKSAqIHBvdyggMS4wIC0gZG90KCBzcG90VmVjdG9yLCBzcG90SGFsZlZlY3RvciApLCA1LjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFwic3BvdFNwZWN1bGFyICs9IHNjaGxpY2sgKiBzcG90TGlnaHRDb2xvclsgaSBdICogc3BvdFNwZWN1bGFyV2VpZ2h0ICogc3BvdERpZmZ1c2VXZWlnaHQgKiBzcG90RGlzdGFuY2UgKiBzcGVjdWxhck5vcm1hbGl6YXRpb24gKiBzcG90RWZmZWN0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XCJzcG90U3BlY3VsYXIgKz0gc3BvdERpc3RhbmNlICogc3BvdExpZ2h0Q29sb3JbIGkgXSAqIHVTcGVjdWxhckNvbG9yICogc3BvdFNwZWN1bGFyV2VpZ2h0ICogc3BvdERpZmZ1c2VXZWlnaHQgKiBzcG90RWZmZWN0O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdC8vIGRpcmVjdGlvbmFsIGxpZ2h0c1xyXG5cclxuXHRcdFx0XHRcIiNpZiBNQVhfRElSX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgZGlyRGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGRpclNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmb3IoIGludCBpID0gMDsgaSA8IE1BWF9ESVJfTElHSFRTOyBpKysgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcInZlYzMgZGlyVmVjdG9yID0gbm9ybWFsaXplKCBsRGlyZWN0aW9uLnh5eiApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gZGlmZnVzZVxyXG5cclxuXHRcdFx0XHRcdFx0XCIjaWZkZWYgV1JBUF9BUk9VTkRcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBkaXJlY3Rpb25hbExpZ2h0V2VpZ2h0aW5nRnVsbCA9IG1heCggZG90KCBub3JtYWwsIGRpclZlY3RvciApLCAwLjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IGRpcmVjdGlvbmFsTGlnaHRXZWlnaHRpbmdIYWxmID0gbWF4KCAwLjUgKiBkb3QoIG5vcm1hbCwgZGlyVmVjdG9yICkgKyAwLjUsIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzMgZGlyRGlmZnVzZVdlaWdodCA9IG1peCggdmVjMyggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0Z1bGwgKSwgdmVjMyggZGlyZWN0aW9uYWxMaWdodFdlaWdodGluZ0hhbGYgKSwgd3JhcFJHQiApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IGRpckRpZmZ1c2VXZWlnaHQgPSBtYXgoIGRvdCggbm9ybWFsLCBkaXJWZWN0b3IgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJkaXJEaWZmdXNlICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogdURpZmZ1c2VDb2xvciAqIGRpckRpZmZ1c2VXZWlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHQvLyBzcGVjdWxhclxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIGRpckhhbGZWZWN0b3IgPSBub3JtYWxpemUoIGRpclZlY3RvciArIHZpZXdQb3NpdGlvbiApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGRpckRvdE5vcm1hbEhhbGYgPSBtYXgoIGRvdCggbm9ybWFsLCBkaXJIYWxmVmVjdG9yICksIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGRpclNwZWN1bGFyV2VpZ2h0ID0gc3BlY3VsYXJUZXguciAqIG1heCggcG93KCBkaXJEb3ROb3JtYWxIYWxmLCB1U2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjaWZkZWYgUEhZU0lDQUxMWV9CQVNFRF9TSEFESU5HXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcdC8vIDIuMCA9PiAyLjAwMDEgaXMgaGFjayB0byB3b3JrIGFyb3VuZCBBTkdMRSBidWdcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBzcGVjdWxhck5vcm1hbGl6YXRpb24gPSAoIHVTaGluaW5lc3MgKyAyLjAwMDEgKSAvIDguMDtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWMzIHNjaGxpY2sgPSB1U3BlY3VsYXJDb2xvciArIHZlYzMoIDEuMCAtIHVTcGVjdWxhckNvbG9yICkgKiBwb3coIDEuMCAtIGRvdCggZGlyVmVjdG9yLCBkaXJIYWxmVmVjdG9yICksIDUuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwiZGlyU3BlY3VsYXIgKz0gc2NobGljayAqIGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogZGlyU3BlY3VsYXJXZWlnaHQgKiBkaXJEaWZmdXNlV2VpZ2h0ICogc3BlY3VsYXJOb3JtYWxpemF0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImRpclNwZWN1bGFyICs9IGRpcmVjdGlvbmFsTGlnaHRDb2xvclsgaSBdICogdVNwZWN1bGFyQ29sb3IgKiBkaXJTcGVjdWxhcldlaWdodCAqIGRpckRpZmZ1c2VXZWlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHQvLyBoZW1pc3BoZXJlIGxpZ2h0c1xyXG5cclxuXHRcdFx0XHRcIiNpZiBNQVhfSEVNSV9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGhlbWlEaWZmdXNlICA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2ZWMzIGhlbWlTcGVjdWxhciA9IHZlYzMoIDAuMCApO1wiICxcclxuXHJcblx0XHRcdFx0XHRcImZvciggaW50IGkgPSAwOyBpIDwgTUFYX0hFTUlfTElHSFRTOyBpICsrICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCggaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uWyBpIF0sIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XHRcInZlYzMgbFZlY3RvciA9IG5vcm1hbGl6ZSggbERpcmVjdGlvbi54eXogKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIGRpZmZ1c2VcclxuXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZG90UHJvZHVjdCA9IGRvdCggbm9ybWFsLCBsVmVjdG9yICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3RQcm9kdWN0ICsgMC41O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIGhlbWlDb2xvciA9IG1peCggaGVtaXNwaGVyZUxpZ2h0R3JvdW5kQ29sb3JbIGkgXSwgaGVtaXNwaGVyZUxpZ2h0U2t5Q29sb3JbIGkgXSwgaGVtaURpZmZ1c2VXZWlnaHQgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiaGVtaURpZmZ1c2UgKz0gdURpZmZ1c2VDb2xvciAqIGhlbWlDb2xvcjtcIixcclxuXHJcblx0XHRcdFx0XHRcdC8vIHNwZWN1bGFyIChza3kgbGlnaHQpXHJcblxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIGhlbWlIYWxmVmVjdG9yU2t5ID0gbm9ybWFsaXplKCBsVmVjdG9yICsgdmlld1Bvc2l0aW9uICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgaGVtaURvdE5vcm1hbEhhbGZTa3kgPSAwLjUgKiBkb3QoIG5vcm1hbCwgaGVtaUhhbGZWZWN0b3JTa3kgKSArIDAuNTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBoZW1pU3BlY3VsYXJXZWlnaHRTa3kgPSBzcGVjdWxhclRleC5yICogbWF4KCBwb3coIGhlbWlEb3ROb3JtYWxIYWxmU2t5LCB1U2hpbmluZXNzICksIDAuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0Ly8gc3BlY3VsYXIgKGdyb3VuZCBsaWdodClcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjMyBsVmVjdG9yR3JvdW5kID0gLWxWZWN0b3I7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzMgaGVtaUhhbGZWZWN0b3JHcm91bmQgPSBub3JtYWxpemUoIGxWZWN0b3JHcm91bmQgKyB2aWV3UG9zaXRpb24gKTtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBoZW1pRG90Tm9ybWFsSGFsZkdyb3VuZCA9IDAuNSAqIGRvdCggbm9ybWFsLCBoZW1pSGFsZlZlY3Rvckdyb3VuZCApICsgMC41O1wiLFxyXG5cdFx0XHRcdFx0XHRcImZsb2F0IGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCA9IHNwZWN1bGFyVGV4LnIgKiBtYXgoIHBvdyggaGVtaURvdE5vcm1hbEhhbGZHcm91bmQsIHVTaGluaW5lc3MgKSwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNpZmRlZiBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJmbG9hdCBkb3RQcm9kdWN0R3JvdW5kID0gZG90KCBub3JtYWwsIGxWZWN0b3JHcm91bmQgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0Ly8gMi4wID0+IDIuMDAwMSBpcyBoYWNrIHRvIHdvcmsgYXJvdW5kIEFOR0xFIGJ1Z1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcImZsb2F0IHNwZWN1bGFyTm9ybWFsaXphdGlvbiA9ICggdVNoaW5pbmVzcyArIDIuMDAwMSApIC8gOC4wO1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzMgc2NobGlja1NreSA9IHVTcGVjdWxhckNvbG9yICsgdmVjMyggMS4wIC0gdVNwZWN1bGFyQ29sb3IgKSAqIHBvdyggMS4wIC0gZG90KCBsVmVjdG9yLCBoZW1pSGFsZlZlY3RvclNreSApLCA1LjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcInZlYzMgc2NobGlja0dyb3VuZCA9IHVTcGVjdWxhckNvbG9yICsgdmVjMyggMS4wIC0gdVNwZWN1bGFyQ29sb3IgKSAqIHBvdyggMS4wIC0gZG90KCBsVmVjdG9yR3JvdW5kLCBoZW1pSGFsZlZlY3Rvckdyb3VuZCApLCA1LjAgKTtcIixcclxuXHRcdFx0XHRcdFx0XHRcImhlbWlTcGVjdWxhciArPSBoZW1pQ29sb3IgKiBzcGVjdWxhck5vcm1hbGl6YXRpb24gKiAoIHNjaGxpY2tTa3kgKiBoZW1pU3BlY3VsYXJXZWlnaHRTa3kgKiBtYXgoIGRvdFByb2R1Y3QsIDAuMCApICsgc2NobGlja0dyb3VuZCAqIGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCAqIG1heCggZG90UHJvZHVjdEdyb3VuZCwgMC4wICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJoZW1pU3BlY3VsYXIgKz0gdVNwZWN1bGFyQ29sb3IgKiBoZW1pQ29sb3IgKiAoIGhlbWlTcGVjdWxhcldlaWdodFNreSArIGhlbWlTcGVjdWxhcldlaWdodEdyb3VuZCApICogaGVtaURpZmZ1c2VXZWlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHQvLyBhbGwgbGlnaHRzIGNvbnRyaWJ1dGlvbiBzdW1tYXRpb25cclxuXHJcblx0XHRcdFx0XCJ2ZWMzIHRvdGFsRGlmZnVzZSA9IHZlYzMoIDAuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjMyB0b3RhbFNwZWN1bGFyID0gdmVjMyggMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9ESVJfTElHSFRTID4gMFwiLFxyXG5cclxuXHRcdFx0XHRcdFwidG90YWxEaWZmdXNlICs9IGRpckRpZmZ1c2U7XCIsXHJcblx0XHRcdFx0XHRcInRvdGFsU3BlY3VsYXIgKz0gZGlyU3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9IRU1JX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XHRcInRvdGFsRGlmZnVzZSArPSBoZW1pRGlmZnVzZTtcIixcclxuXHRcdFx0XHRcdFwidG90YWxTcGVjdWxhciArPSBoZW1pU3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ0b3RhbERpZmZ1c2UgKz0gcG9pbnREaWZmdXNlO1wiLFxyXG5cdFx0XHRcdFx0XCJ0b3RhbFNwZWN1bGFyICs9IHBvaW50U3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcIixcclxuXHJcblx0XHRcdFx0XHRcInRvdGFsRGlmZnVzZSArPSBzcG90RGlmZnVzZTtcIixcclxuXHRcdFx0XHRcdFwidG90YWxTcGVjdWxhciArPSBzcG90U3BlY3VsYXI7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIE1FVEFMXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiB1QW1iaWVudENvbG9yICsgdG90YWxTcGVjdWxhciApO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IueHl6ID0gZ2xfRnJhZ0NvbG9yLnh5eiAqICggdG90YWxEaWZmdXNlICsgYW1iaWVudExpZ2h0Q29sb3IgKiB1QW1iaWVudENvbG9yICkgKyB0b3RhbFNwZWN1bGFyO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcImlmICggZW5hYmxlUmVmbGVjdGlvbiApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzMgdlJlZmxlY3Q7XCIsXHJcblx0XHRcdFx0XHRcInZlYzMgY2FtZXJhVG9WZXJ0ZXggPSBub3JtYWxpemUoIHZXb3JsZFBvc2l0aW9uIC0gY2FtZXJhUG9zaXRpb24gKTtcIixcclxuXHJcblx0XHRcdFx0XHRcImlmICggdXNlUmVmcmFjdCApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidlJlZmxlY3QgPSByZWZyYWN0KCBjYW1lcmFUb1ZlcnRleCwgbm9ybWFsLCB1UmVmcmFjdGlvblJhdGlvICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCBub3JtYWwgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzQgY3ViZUNvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCAtdlJlZmxlY3QueCwgdlJlZmxlY3QueXogKSApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2lmZGVmIEdBTU1BX0lOUFVUXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImN1YmVDb2xvci54eXogKj0gY3ViZUNvbG9yLnh5ejtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yLnh5eiA9IG1peCggZ2xfRnJhZ0NvbG9yLnh5eiwgY3ViZUNvbG9yLnh5eiwgc3BlY3VsYXJUZXguciAqIHVSZWZsZWN0aXZpdHkgKTtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNoYWRvd21hcF9mcmFnbWVudFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwibGluZWFyX3RvX2dhbW1hX2ZyYWdtZW50XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJmb2dfZnJhZ21lbnRcIiBdLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIiksXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWM0IHRhbmdlbnQ7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMiB1T2Zmc2V0O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMiB1UmVwZWF0O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGJvb2wgZW5hYmxlRGlzcGxhY2VtZW50O1wiLFxyXG5cclxuXHRcdFx0XCIjaWZkZWYgVkVSVEVYX1RFWFRVUkVTXCIsXHJcblxyXG5cdFx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgdERpc3BsYWNlbWVudDtcIixcclxuXHRcdFx0XHRcInVuaWZvcm0gZmxvYXQgdURpc3BsYWNlbWVudFNjYWxlO1wiLFxyXG5cdFx0XHRcdFwidW5pZm9ybSBmbG9hdCB1RGlzcGxhY2VtZW50QmlhcztcIixcclxuXHJcblx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2VGFuZ2VudDtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdkJpbm9ybWFsO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2Tm9ybWFsO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VXY7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcIixcclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2hhZG93bWFwX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5ub3JtYWxfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFx0Ly8gbm9ybWFsLCB0YW5nZW50IGFuZCBiaW5vcm1hbCB2ZWN0b3JzXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidk5vcm1hbCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogc2tpbm5lZE5vcm1hbC54eXogKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZlYzQgc2tpbm5lZFRhbmdlbnQgPSBza2luTWF0cml4ICogdmVjNCggdGFuZ2VudC54eXosIDAuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2VGFuZ2VudCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogc2tpbm5lZFRhbmdlbnQueHl6ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcInZOb3JtYWwgPSBub3JtYWxpemUoIG5vcm1hbE1hdHJpeCAqIG5vcm1hbCApO1wiLFxyXG5cdFx0XHRcdFx0XCJ2VGFuZ2VudCA9IG5vcm1hbGl6ZSggbm9ybWFsTWF0cml4ICogdGFuZ2VudC54eXogKTtcIixcclxuXHJcblx0XHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFx0XCJ2Qmlub3JtYWwgPSBub3JtYWxpemUoIGNyb3NzKCB2Tm9ybWFsLCB2VGFuZ2VudCApICogdGFuZ2VudC53ICk7XCIsXHJcblxyXG5cdFx0XHRcdFwidlV2ID0gdXYgKiB1UmVwZWF0ICsgdU9mZnNldDtcIixcclxuXHJcblx0XHRcdFx0Ly8gZGlzcGxhY2VtZW50IG1hcHBpbmdcclxuXHJcblx0XHRcdFx0XCJ2ZWMzIGRpc3BsYWNlZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcIiNpZmRlZiBWRVJURVhfVEVYVFVSRVNcIixcclxuXHJcblx0XHRcdFx0XHRcImlmICggZW5hYmxlRGlzcGxhY2VtZW50ICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJ2ZWMzIGR2ID0gdGV4dHVyZTJEKCB0RGlzcGxhY2VtZW50LCB1diApLnh5ejtcIixcclxuXHRcdFx0XHRcdFx0XCJmbG9hdCBkZiA9IHVEaXNwbGFjZW1lbnRTY2FsZSAqIGR2LnggKyB1RGlzcGxhY2VtZW50QmlhcztcIixcclxuXHRcdFx0XHRcdFx0XCJkaXNwbGFjZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgbm9ybWFsaXplKCBub3JtYWwgKSAqIGRmO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwifSBlbHNlIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcInZlYzQgc2tpblZlcnRleCA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFx0XCJ2ZWM0IHNraW5uZWQgID0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1wiLFxyXG5cdFx0XHRcdFx0XHRcdFwic2tpbm5lZCBcdCAgKz0gYm9uZU1hdFkgKiBza2luVmVydGV4ICogc2tpbldlaWdodC55O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImRpc3BsYWNlZFBvc2l0aW9uICA9IHNraW5uZWQueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFx0XHRcImRpc3BsYWNlZFBvc2l0aW9uID0gcG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcIiNlbHNlXCIsXHJcblxyXG5cdFx0XHRcdFx0XCIjaWZkZWYgVVNFX1NLSU5OSU5HXCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcInZlYzQgc2tpblZlcnRleCA9IHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidmVjNCBza2lubmVkICA9IGJvbmVNYXRYICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueDtcIixcclxuXHRcdFx0XHRcdFx0XCJza2lubmVkIFx0ICArPSBib25lTWF0WSAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lnk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XHRcImRpc3BsYWNlZFBvc2l0aW9uICA9IHNraW5uZWQueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiI2Vsc2VcIixcclxuXHJcblx0XHRcdFx0XHRcdFwiZGlzcGxhY2VkUG9zaXRpb24gPSBwb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XHQvL1xyXG5cclxuXHRcdFx0XHRcInZlYzQgbXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIGRpc3BsYWNlZFBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHRcdFx0XHRcInZlYzQgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNCggZGlzcGxhY2VkUG9zaXRpb24sIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdC8vXHJcblxyXG5cdFx0XHRcdFwidldvcmxkUG9zaXRpb24gPSB3b3JsZFBvc2l0aW9uLnh5ejtcIixcclxuXHRcdFx0XHRcInZWaWV3UG9zaXRpb24gPSAtbXZQb3NpdGlvbi54eXo7XCIsXHJcblxyXG5cdFx0XHRcdC8vIHNoYWRvd3NcclxuXHJcblx0XHRcdFx0XCIjaWZkZWYgVVNFX1NIQURPV01BUFwiLFxyXG5cclxuXHRcdFx0XHRcdFwiZm9yKCBpbnQgaSA9IDA7IGkgPCBNQVhfU0hBRE9XUzsgaSArKyApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcdFwidlNoYWRvd0Nvb3JkWyBpIF0gPSBzaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFwiI2VuZGlmXCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKVxyXG5cclxuXHR9LFxyXG5cclxuXHQvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblx0Ly9cdEN1YmUgbWFwIHNoYWRlclxyXG5cdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5cdCdjdWJlJzoge1xyXG5cclxuXHRcdHVuaWZvcm1zOiB7IFwidEN1YmVcIjogeyB0eXBlOiBcInRcIiwgdmFsdWU6IG51bGwgfSxcclxuXHRcdFx0XHRcdFwidEZsaXBcIjogeyB0eXBlOiBcImZcIiwgdmFsdWU6IC0xIH0gfSxcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjNCB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XCIsXHJcblx0XHRcdFx0XCJ2V29ybGRQb3NpdGlvbiA9IHdvcmxkUG9zaXRpb24ueHl6O1wiLFxyXG5cclxuXHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCB0RmxpcDtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZUN1YmUoIHRDdWJlLCB2ZWMzKCB0RmxpcCAqIHZXb3JsZFBvc2l0aW9uLngsIHZXb3JsZFBvc2l0aW9uLnl6ICkgKTtcIixcclxuXHJcblx0XHRcdFwifVwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpXHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIERlcHRoIGVuY29kaW5nIGludG8gUkdCQSB0ZXh0dXJlXHJcblx0Ly8gXHRiYXNlZCBvbiBTcGlkZXJHTCBzaGFkb3cgbWFwIGV4YW1wbGVcclxuXHQvLyBcdFx0aHR0cDovL3NwaWRlcmdsLm9yZy9leGFtcGxlLnBocD9pZD02XHJcblx0Ly8gXHRvcmlnaW5hbGx5IGZyb21cclxuXHQvL1x0XHRodHRwOi8vd3d3LmdhbWVkZXYubmV0L3RvcGljLzQ0MjEzOC1wYWNraW5nLWEtZmxvYXQtaW50by1hLWE4cjhnOGI4LXRleHR1cmUtc2hhZGVyL3BhZ2VfX3doaWNocGFnZV9fMSUyNUVGJTI1QkYlMjVCRFxyXG5cdC8vIFx0c2VlIGFsc28gaGVyZTpcclxuXHQvL1x0XHRodHRwOi8vYXJhcy1wLmluZm8vYmxvZy8yMDA5LzA3LzMwL2VuY29kaW5nLWZsb2F0cy10by1yZ2JhLXRoZS1maW5hbC9cclxuXHJcblx0J2RlcHRoUkdCQSc6IHtcclxuXHJcblx0XHR1bmlmb3Jtczoge30sXHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJtb3JwaHRhcmdldF9wYXJzX3ZlcnRleFwiIF0sXHJcblx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcInNraW5uaW5nX3BhcnNfdmVydGV4XCIgXSxcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJza2luYmFzZV92ZXJ0ZXhcIiBdLFxyXG5cdFx0XHRcdFRIUkVFLlNoYWRlckNodW5rWyBcIm1vcnBodGFyZ2V0X3ZlcnRleFwiIF0sXHJcblx0XHRcdFx0VEhSRUUuU2hhZGVyQ2h1bmtbIFwic2tpbm5pbmdfdmVydGV4XCIgXSxcclxuXHRcdFx0XHRUSFJFRS5TaGFkZXJDaHVua1sgXCJkZWZhdWx0X3ZlcnRleFwiIF0sXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ2ZWM0IHBhY2tfZGVwdGgoIGNvbnN0IGluIGZsb2F0IGRlcHRoICkge1wiLFxyXG5cclxuXHRcdFx0XHRcImNvbnN0IHZlYzQgYml0X3NoaWZ0ID0gdmVjNCggMjU2LjAgKiAyNTYuMCAqIDI1Ni4wLCAyNTYuMCAqIDI1Ni4wLCAyNTYuMCwgMS4wICk7XCIsXHJcblx0XHRcdFx0XCJjb25zdCB2ZWM0IGJpdF9tYXNrICA9IHZlYzQoIDAuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCApO1wiLFxyXG5cdFx0XHRcdFwidmVjNCByZXMgPSBmcmFjdCggZGVwdGggKiBiaXRfc2hpZnQgKTtcIixcclxuXHRcdFx0XHRcInJlcyAtPSByZXMueHh5eiAqIGJpdF9tYXNrO1wiLFxyXG5cdFx0XHRcdFwicmV0dXJuIHJlcztcIixcclxuXHJcblx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56ICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vXCJnbF9GcmFnRGF0YVsgMCBdID0gcGFja19kZXB0aCggZ2xfRnJhZ0Nvb3JkLnogLyBnbF9GcmFnQ29vcmQudyApO1wiLFxyXG5cdFx0XHRcdC8vXCJmbG9hdCB6ID0gKCAoIGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLncgKSAtIDMuMCApIC8gKCA0MDAwLjAgLSAzLjAgKTtcIixcclxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHBhY2tfZGVwdGgoIHogKTtcIixcclxuXHRcdFx0XHQvL1wiZ2xfRnJhZ0RhdGFbIDAgXSA9IHZlYzQoIHosIHosIHosIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oXCJcXG5cIilcclxuXHJcblx0fVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFJlbmRlcmVyID0gZnVuY3Rpb24gKCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXInLCBUSFJFRS5SRVZJU0lPTiApO1xyXG5cclxuXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcclxuXHJcblx0dmFyIF9jYW52YXMgPSBwYXJhbWV0ZXJzLmNhbnZhcyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jYW52YXMgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApLFxyXG5cclxuXHRfcHJlY2lzaW9uID0gcGFyYW1ldGVycy5wcmVjaXNpb24gIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMucHJlY2lzaW9uIDogJ2hpZ2hwJyxcclxuXHJcblx0X2FscGhhID0gcGFyYW1ldGVycy5hbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5hbHBoYSA6IHRydWUsXHJcblx0X3ByZW11bHRpcGxpZWRBbHBoYSA9IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA6IHRydWUsXHJcblx0X2FudGlhbGlhcyA9IHBhcmFtZXRlcnMuYW50aWFsaWFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmFudGlhbGlhcyA6IGZhbHNlLFxyXG5cdF9zdGVuY2lsID0gcGFyYW1ldGVycy5zdGVuY2lsICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnN0ZW5jaWwgOiB0cnVlLFxyXG5cdF9wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgPSBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVzZXJ2ZURyYXdpbmdCdWZmZXIgOiBmYWxzZSxcclxuXHJcblx0X2NsZWFyQ29sb3IgPSBwYXJhbWV0ZXJzLmNsZWFyQ29sb3IgIT09IHVuZGVmaW5lZCA/IG5ldyBUSFJFRS5Db2xvciggcGFyYW1ldGVycy5jbGVhckNvbG9yICkgOiBuZXcgVEhSRUUuQ29sb3IoIDB4MDAwMDAwICksXHJcblx0X2NsZWFyQWxwaGEgPSBwYXJhbWV0ZXJzLmNsZWFyQWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuY2xlYXJBbHBoYSA6IDA7XHJcblxyXG5cdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXHJcblxyXG5cdHRoaXMuZG9tRWxlbWVudCA9IF9jYW52YXM7XHJcblx0dGhpcy5jb250ZXh0ID0gbnVsbDtcclxuXHR0aGlzLmRldmljZVBpeGVsUmF0aW8gPSBwYXJhbWV0ZXJzLmRldmljZVBpeGVsUmF0aW8gIT09IHVuZGVmaW5lZFxyXG5cdFx0XHRcdD8gcGFyYW1ldGVycy5kZXZpY2VQaXhlbFJhdGlvXHJcblx0XHRcdFx0OiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gdW5kZWZpbmVkXHJcblx0XHRcdFx0XHQ/IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvXHJcblx0XHRcdFx0XHQ6IDE7XHJcblxyXG5cdC8vIGNsZWFyaW5nXHJcblxyXG5cdHRoaXMuYXV0b0NsZWFyID0gdHJ1ZTtcclxuXHR0aGlzLmF1dG9DbGVhckNvbG9yID0gdHJ1ZTtcclxuXHR0aGlzLmF1dG9DbGVhckRlcHRoID0gdHJ1ZTtcclxuXHR0aGlzLmF1dG9DbGVhclN0ZW5jaWwgPSB0cnVlO1xyXG5cclxuXHQvLyBzY2VuZSBncmFwaFxyXG5cclxuXHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5hdXRvVXBkYXRlT2JqZWN0cyA9IHRydWU7XHJcblx0dGhpcy5hdXRvVXBkYXRlU2NlbmUgPSB0cnVlO1xyXG5cclxuXHQvLyBwaHlzaWNhbGx5IGJhc2VkIHNoYWRpbmdcclxuXHJcblx0dGhpcy5nYW1tYUlucHV0ID0gZmFsc2U7XHJcblx0dGhpcy5nYW1tYU91dHB1dCA9IGZhbHNlO1xyXG5cdHRoaXMucGh5c2ljYWxseUJhc2VkU2hhZGluZyA9IGZhbHNlO1xyXG5cclxuXHQvLyBzaGFkb3cgbWFwXHJcblxyXG5cdHRoaXMuc2hhZG93TWFwRW5hYmxlZCA9IGZhbHNlO1xyXG5cdHRoaXMuc2hhZG93TWFwQXV0b1VwZGF0ZSA9IHRydWU7XHJcblx0dGhpcy5zaGFkb3dNYXBUeXBlID0gVEhSRUUuUENGU2hhZG93TWFwO1xyXG5cdHRoaXMuc2hhZG93TWFwQ3VsbEZhY2UgPSBUSFJFRS5DdWxsRmFjZUZyb250O1xyXG5cdHRoaXMuc2hhZG93TWFwRGVidWcgPSBmYWxzZTtcclxuXHR0aGlzLnNoYWRvd01hcENhc2NhZGUgPSBmYWxzZTtcclxuXHJcblx0Ly8gbW9ycGhzXHJcblxyXG5cdHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcclxuXHR0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XHJcblxyXG5cdC8vIGZsYWdzXHJcblxyXG5cdHRoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgPSB0cnVlO1xyXG5cclxuXHQvLyBjdXN0b20gcmVuZGVyIHBsdWdpbnNcclxuXHJcblx0dGhpcy5yZW5kZXJQbHVnaW5zUHJlID0gW107XHJcblx0dGhpcy5yZW5kZXJQbHVnaW5zUG9zdCA9IFtdO1xyXG5cclxuXHQvLyBpbmZvXHJcblxyXG5cdHRoaXMuaW5mbyA9IHtcclxuXHJcblx0XHRtZW1vcnk6IHtcclxuXHJcblx0XHRcdHByb2dyYW1zOiAwLFxyXG5cdFx0XHRnZW9tZXRyaWVzOiAwLFxyXG5cdFx0XHR0ZXh0dXJlczogMFxyXG5cclxuXHRcdH0sXHJcblxyXG5cdFx0cmVuZGVyOiB7XHJcblxyXG5cdFx0XHRjYWxsczogMCxcclxuXHRcdFx0dmVydGljZXM6IDAsXHJcblx0XHRcdGZhY2VzOiAwLFxyXG5cdFx0XHRwb2ludHM6IDBcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIGludGVybmFsIHByb3BlcnRpZXNcclxuXHJcblx0dmFyIF90aGlzID0gdGhpcyxcclxuXHJcblx0X3Byb2dyYW1zID0gW10sXHJcblx0X3Byb2dyYW1zX2NvdW50ZXIgPSAwLFxyXG5cclxuXHQvLyBpbnRlcm5hbCBzdGF0ZSBjYWNoZVxyXG5cclxuXHRfY3VycmVudFByb2dyYW0gPSBudWxsLFxyXG5cdF9jdXJyZW50RnJhbWVidWZmZXIgPSBudWxsLFxyXG5cdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xLFxyXG5cdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSBudWxsLFxyXG5cdF9jdXJyZW50Q2FtZXJhID0gbnVsbCxcclxuXHRfZ2VvbWV0cnlHcm91cENvdW50ZXIgPSAwLFxyXG5cclxuXHRfdXNlZFRleHR1cmVVbml0cyA9IDAsXHJcblxyXG5cdC8vIEdMIHN0YXRlIGNhY2hlXHJcblxyXG5cdF9vbGREb3VibGVTaWRlZCA9IC0xLFxyXG5cdF9vbGRGbGlwU2lkZWQgPSAtMSxcclxuXHJcblx0X29sZEJsZW5kaW5nID0gLTEsXHJcblxyXG5cdF9vbGRCbGVuZEVxdWF0aW9uID0gLTEsXHJcblx0X29sZEJsZW5kU3JjID0gLTEsXHJcblx0X29sZEJsZW5kRHN0ID0gLTEsXHJcblxyXG5cdF9vbGREZXB0aFRlc3QgPSAtMSxcclxuXHRfb2xkRGVwdGhXcml0ZSA9IC0xLFxyXG5cclxuXHRfb2xkUG9seWdvbk9mZnNldCA9IG51bGwsXHJcblx0X29sZFBvbHlnb25PZmZzZXRGYWN0b3IgPSBudWxsLFxyXG5cdF9vbGRQb2x5Z29uT2Zmc2V0VW5pdHMgPSBudWxsLFxyXG5cclxuXHRfb2xkTGluZVdpZHRoID0gbnVsbCxcclxuXHJcblx0X3ZpZXdwb3J0WCA9IDAsXHJcblx0X3ZpZXdwb3J0WSA9IDAsXHJcblx0X3ZpZXdwb3J0V2lkdGggPSAwLFxyXG5cdF92aWV3cG9ydEhlaWdodCA9IDAsXHJcblx0X2N1cnJlbnRXaWR0aCA9IDAsXHJcblx0X2N1cnJlbnRIZWlnaHQgPSAwLFxyXG5cclxuXHRfZW5hYmxlZEF0dHJpYnV0ZXMgPSB7fSxcclxuXHJcblx0Ly8gZnJ1c3R1bVxyXG5cclxuXHRfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXHJcblxyXG5cdCAvLyBjYW1lcmEgbWF0cmljZXMgY2FjaGVcclxuXHJcblx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cdF9wcm9qU2NyZWVuTWF0cml4UFMgPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cclxuXHRfdmVjdG9yMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG5cdC8vIGxpZ2h0IGFycmF5cyBjYWNoZVxyXG5cclxuXHRfZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcblx0X2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlLFxyXG5cclxuXHRfbGlnaHRzID0ge1xyXG5cclxuXHRcdGFtYmllbnQ6IFsgMCwgMCwgMCBdLFxyXG5cdFx0ZGlyZWN0aW9uYWw6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IG5ldyBBcnJheSgpLCBwb3NpdGlvbnM6IG5ldyBBcnJheSgpIH0sXHJcblx0XHRwb2ludDogeyBsZW5ndGg6IDAsIGNvbG9yczogbmV3IEFycmF5KCksIHBvc2l0aW9uczogbmV3IEFycmF5KCksIGRpc3RhbmNlczogbmV3IEFycmF5KCkgfSxcclxuXHRcdHNwb3Q6IHsgbGVuZ3RoOiAwLCBjb2xvcnM6IG5ldyBBcnJheSgpLCBwb3NpdGlvbnM6IG5ldyBBcnJheSgpLCBkaXN0YW5jZXM6IG5ldyBBcnJheSgpLCBkaXJlY3Rpb25zOiBuZXcgQXJyYXkoKSwgYW5nbGVzQ29zOiBuZXcgQXJyYXkoKSwgZXhwb25lbnRzOiBuZXcgQXJyYXkoKSB9LFxyXG5cdFx0aGVtaTogeyBsZW5ndGg6IDAsIHNreUNvbG9yczogbmV3IEFycmF5KCksIGdyb3VuZENvbG9yczogbmV3IEFycmF5KCksIHBvc2l0aW9uczogbmV3IEFycmF5KCkgfVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBpbml0aWFsaXplXHJcblxyXG5cdHZhciBfZ2w7XHJcblxyXG5cdHZhciBfZ2xFeHRlbnNpb25UZXh0dXJlRmxvYXQ7XHJcblx0dmFyIF9nbEV4dGVuc2lvblN0YW5kYXJkRGVyaXZhdGl2ZXM7XHJcblx0dmFyIF9nbEV4dGVuc2lvblRleHR1cmVGaWx0ZXJBbmlzb3Ryb3BpYztcclxuXHR2YXIgX2dsRXh0ZW5zaW9uQ29tcHJlc3NlZFRleHR1cmVTM1RDO1xyXG5cclxuXHRpbml0R0woKTtcclxuXHJcblx0c2V0RGVmYXVsdEdMU3RhdGUoKTtcclxuXHJcblx0dGhpcy5jb250ZXh0ID0gX2dsO1xyXG5cclxuXHQvLyBHUFUgY2FwYWJpbGl0aWVzXHJcblxyXG5cdHZhciBfbWF4VGV4dHVyZXMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKTtcclxuXHR2YXIgX21heFZlcnRleFRleHR1cmVzID0gX2dsLmdldFBhcmFtZXRlciggX2dsLk1BWF9WRVJURVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xyXG5cdHZhciBfbWF4VGV4dHVyZVNpemUgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1RFWFRVUkVfU0laRSApO1xyXG5cdHZhciBfbWF4Q3ViZW1hcFNpemUgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX0NVQkVfTUFQX1RFWFRVUkVfU0laRSApO1xyXG5cclxuXHR2YXIgX21heEFuaXNvdHJvcHkgPSBfZ2xFeHRlbnNpb25UZXh0dXJlRmlsdGVyQW5pc290cm9waWMgPyBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2xFeHRlbnNpb25UZXh0dXJlRmlsdGVyQW5pc290cm9waWMuTUFYX1RFWFRVUkVfTUFYX0FOSVNPVFJPUFlfRVhUICkgOiAwO1xyXG5cclxuXHR2YXIgX3N1cHBvcnRzVmVydGV4VGV4dHVyZXMgPSAoIF9tYXhWZXJ0ZXhUZXh0dXJlcyA+IDAgKTtcclxuXHR2YXIgX3N1cHBvcnRzQm9uZVRleHR1cmVzID0gX3N1cHBvcnRzVmVydGV4VGV4dHVyZXMgJiYgX2dsRXh0ZW5zaW9uVGV4dHVyZUZsb2F0O1xyXG5cclxuXHR2YXIgX2NvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQyA/IF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5DT01QUkVTU0VEX1RFWFRVUkVfRk9STUFUUyApIDogW107XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uSGlnaHBGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5WRVJURVhfU0hBREVSLCBfZ2wuSElHSF9GTE9BVCApO1xyXG5cdHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5NRURJVU1fRkxPQVQgKTtcclxuXHR2YXIgX3ZlcnRleFNoYWRlclByZWNpc2lvbkxvd3BGbG9hdCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5WRVJURVhfU0hBREVSLCBfZ2wuTE9XX0ZMT0FUICk7XHJcblxyXG5cdHZhciBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25IaWdocEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLkZSQUdNRU5UX1NIQURFUiwgX2dsLkhJR0hfRkxPQVQgKTtcclxuXHR2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTWVkaXVtcEZsb2F0ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLkZSQUdNRU5UX1NIQURFUiwgX2dsLk1FRElVTV9GTE9BVCApO1xyXG5cdHZhciBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25Mb3dwRmxvYXQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuRlJBR01FTlRfU0hBREVSLCBfZ2wuTE9XX0ZMT0FUICk7XHJcblxyXG5cdHZhciBfdmVydGV4U2hhZGVyUHJlY2lzaW9uSGlnaHBJbnQgPSBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBfZ2wuVkVSVEVYX1NIQURFUiwgX2dsLkhJR0hfSU5UICk7XHJcblx0dmFyIF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25NZWRpdW1wSW50ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5NRURJVU1fSU5UICk7XHJcblx0dmFyIF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25Mb3dwSW50ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLlZFUlRFWF9TSEFERVIsIF9nbC5MT1dfSU5UICk7XHJcblxyXG5cdHZhciBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25IaWdocEludCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5ISUdIX0lOVCApO1xyXG5cdHZhciBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25NZWRpdW1wSW50ID0gX2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggX2dsLkZSQUdNRU5UX1NIQURFUiwgX2dsLk1FRElVTV9JTlQgKTtcclxuXHR2YXIgX2ZyYWdtZW50U2hhZGVyUHJlY2lzaW9uTG93cEludCA9IF9nbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIF9nbC5GUkFHTUVOVF9TSEFERVIsIF9nbC5MT1dfSU5UICk7XHJcblxyXG5cdC8vIGNsYW1wIHByZWNpc2lvbiB0byBtYXhpbXVtIGF2YWlsYWJsZVxyXG5cclxuXHR2YXIgaGlnaHBBdmFpbGFibGUgPSBfdmVydGV4U2hhZGVyUHJlY2lzaW9uSGlnaHBGbG9hdC5wcmVjaXNpb24gPiAwICYmIF9mcmFnbWVudFNoYWRlclByZWNpc2lvbkhpZ2hwRmxvYXQucHJlY2lzaW9uID4gMDtcclxuXHR2YXIgbWVkaXVtcEF2YWlsYWJsZSA9IF92ZXJ0ZXhTaGFkZXJQcmVjaXNpb25NZWRpdW1wRmxvYXQucHJlY2lzaW9uID4gMCAmJiBfZnJhZ21lbnRTaGFkZXJQcmVjaXNpb25NZWRpdW1wRmxvYXQucHJlY2lzaW9uID4gMDtcclxuXHJcblx0aWYgKCBfcHJlY2lzaW9uID09PSBcImhpZ2hwXCIgJiYgISBoaWdocEF2YWlsYWJsZSApIHtcclxuXHJcblx0XHRpZiAoIG1lZGl1bXBBdmFpbGFibGUgKSB7XHJcblxyXG5cdFx0XHRfcHJlY2lzaW9uID0gXCJtZWRpdW1wXCI7XHJcblx0XHRcdGNvbnNvbGUud2FybiggXCJXZWJHTFJlbmRlcmVyOiBoaWdocCBub3Qgc3VwcG9ydGVkLCB1c2luZyBtZWRpdW1wXCIgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X3ByZWNpc2lvbiA9IFwibG93cFwiO1xyXG5cdFx0XHRjb25zb2xlLndhcm4oIFwiV2ViR0xSZW5kZXJlcjogaGlnaHAgYW5kIG1lZGl1bXAgbm90IHN1cHBvcnRlZCwgdXNpbmcgbG93cFwiICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGlmICggX3ByZWNpc2lvbiA9PT0gXCJtZWRpdW1wXCIgJiYgISBtZWRpdW1wQXZhaWxhYmxlICkge1xyXG5cclxuXHRcdF9wcmVjaXNpb24gPSBcImxvd3BcIjtcclxuXHRcdGNvbnNvbGUud2FybiggXCJXZWJHTFJlbmRlcmVyOiBtZWRpdW1wIG5vdCBzdXBwb3J0ZWQsIHVzaW5nIGxvd3BcIiApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEFQSVxyXG5cclxuXHR0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9nbDtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zdXBwb3J0c1ZlcnRleFRleHR1cmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcztcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zdXBwb3J0c0Zsb2F0VGV4dHVyZXMgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0cmV0dXJuIF9nbEV4dGVuc2lvblRleHR1cmVGbG9hdDtcclxuXHJcblx0fTtcclxuXHRcclxuXHR0aGlzLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gX2dsRXh0ZW5zaW9uU3RhbmRhcmREZXJpdmF0aXZlcztcclxuXHJcblx0fTtcclxuXHRcclxuXHR0aGlzLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVTM1RDID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfZ2xFeHRlbnNpb25Db21wcmVzc2VkVGV4dHVyZVMzVEM7XHJcblxyXG5cdH07XHJcblx0XHJcblx0dGhpcy5nZXRNYXhBbmlzb3Ryb3B5ICA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gX21heEFuaXNvdHJvcHk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHJldHVybiBfcHJlY2lzaW9uO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0X2NhbnZhcy53aWR0aCA9IHdpZHRoICogdGhpcy5kZXZpY2VQaXhlbFJhdGlvO1xyXG5cdFx0X2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiB0aGlzLmRldmljZVBpeGVsUmF0aW87XHJcblxyXG5cdFx0X2NhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcclxuXHRcdF9jYW52YXMuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcclxuXHJcblx0XHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCBfY2FudmFzLndpZHRoLCBfY2FudmFzLmhlaWdodCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xyXG5cclxuXHRcdF92aWV3cG9ydFggPSB4ICE9PSB1bmRlZmluZWQgPyB4IDogMDtcclxuXHRcdF92aWV3cG9ydFkgPSB5ICE9PSB1bmRlZmluZWQgPyB5IDogMDtcclxuXHJcblx0XHRfdmlld3BvcnRXaWR0aCA9IHdpZHRoICE9PSB1bmRlZmluZWQgPyB3aWR0aCA6IF9jYW52YXMud2lkdGg7XHJcblx0XHRfdmlld3BvcnRIZWlnaHQgPSBoZWlnaHQgIT09IHVuZGVmaW5lZCA/IGhlaWdodCA6IF9jYW52YXMuaGVpZ2h0O1xyXG5cclxuXHRcdF9nbC52aWV3cG9ydCggX3ZpZXdwb3J0WCwgX3ZpZXdwb3J0WSwgX3ZpZXdwb3J0V2lkdGgsIF92aWV3cG9ydEhlaWdodCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldFNjaXNzb3IgPSBmdW5jdGlvbiAoIHgsIHksIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdFx0X2dsLnNjaXNzb3IoIHgsIHksIHdpZHRoLCBoZWlnaHQgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5lbmFibGVTY2lzc29yVGVzdCA9IGZ1bmN0aW9uICggZW5hYmxlICkge1xyXG5cclxuXHRcdGVuYWJsZSA/IF9nbC5lbmFibGUoIF9nbC5TQ0lTU09SX1RFU1QgKSA6IF9nbC5kaXNhYmxlKCBfZ2wuU0NJU1NPUl9URVNUICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIENsZWFyaW5nXHJcblxyXG5cdHRoaXMuc2V0Q2xlYXJDb2xvckhleCA9IGZ1bmN0aW9uICggaGV4LCBhbHBoYSApIHtcclxuXHJcblx0XHRfY2xlYXJDb2xvci5zZXRIZXgoIGhleCApO1xyXG5cdFx0X2NsZWFyQWxwaGEgPSBhbHBoYTtcclxuXHJcblx0XHRfZ2wuY2xlYXJDb2xvciggX2NsZWFyQ29sb3IuciwgX2NsZWFyQ29sb3IuZywgX2NsZWFyQ29sb3IuYiwgX2NsZWFyQWxwaGEgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XHJcblxyXG5cdFx0X2NsZWFyQ29sb3IuY29weSggY29sb3IgKTtcclxuXHRcdF9jbGVhckFscGhhID0gYWxwaGE7XHJcblxyXG5cdFx0X2dsLmNsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gX2NsZWFyQ29sb3I7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuZ2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRyZXR1cm4gX2NsZWFyQWxwaGE7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuY2xlYXIgPSBmdW5jdGlvbiAoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcclxuXHJcblx0XHR2YXIgYml0cyA9IDA7XHJcblxyXG5cdFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkIHx8IGNvbG9yICkgYml0cyB8PSBfZ2wuQ09MT1JfQlVGRkVSX0JJVDtcclxuXHRcdGlmICggZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCApIGJpdHMgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XHJcblx0XHRpZiAoIHN0ZW5jaWwgPT09IHVuZGVmaW5lZCB8fCBzdGVuY2lsICkgYml0cyB8PSBfZ2wuU1RFTkNJTF9CVUZGRVJfQklUO1xyXG5cclxuXHRcdF9nbC5jbGVhciggYml0cyApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmNsZWFyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcclxuXHJcblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblx0XHR0aGlzLmNsZWFyKCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gUGx1Z2luc1xyXG5cclxuXHR0aGlzLmFkZFBvc3RQbHVnaW4gPSBmdW5jdGlvbiAoIHBsdWdpbiApIHtcclxuXHJcblx0XHRwbHVnaW4uaW5pdCggdGhpcyApO1xyXG5cdFx0dGhpcy5yZW5kZXJQbHVnaW5zUG9zdC5wdXNoKCBwbHVnaW4gKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5hZGRQcmVQbHVnaW4gPSBmdW5jdGlvbiAoIHBsdWdpbiApIHtcclxuXHJcblx0XHRwbHVnaW4uaW5pdCggdGhpcyApO1xyXG5cdFx0dGhpcy5yZW5kZXJQbHVnaW5zUHJlLnB1c2goIHBsdWdpbiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBSZW5kZXJpbmdcclxuXHJcblx0dGhpcy51cGRhdGVTaGFkb3dNYXAgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcclxuXHRcdF9vbGRCbGVuZGluZyA9IC0xO1xyXG5cdFx0X29sZERlcHRoVGVzdCA9IC0xO1xyXG5cdFx0X29sZERlcHRoV3JpdGUgPSAtMTtcclxuXHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtMTtcclxuXHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0xO1xyXG5cdFx0X2xpZ2h0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0X29sZERvdWJsZVNpZGVkID0gLTE7XHJcblx0XHRfb2xkRmxpcFNpZGVkID0gLTE7XHJcblxyXG5cdFx0dGhpcy5zaGFkb3dNYXBQbHVnaW4udXBkYXRlKCBzY2VuZSwgY2FtZXJhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEludGVybmFsIGZ1bmN0aW9uc1xyXG5cclxuXHQvLyBCdWZmZXIgYWxsb2NhdGlvblxyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVQYXJ0aWNsZUJ1ZmZlcnMgKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbENvbG9yQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZUxpbmVCdWZmZXJzICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xMaW5lRGlzdGFuY2VCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkuZ2VvbWV0cmllcyArKztcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlUmliYm9uQnVmZmVycyAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsTm9ybWFsQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNyZWF0ZU1lc2hCdWZmZXJzICggZ2VvbWV0cnlHcm91cCApIHtcclxuXHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xOb3JtYWxCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xUYW5nZW50QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsQ29sb3JCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVkJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWMkJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luSW5kaWNlc0J1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdHZhciBtLCBtbDtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVycyA9IFtdO1xyXG5cclxuXHRcdFx0Zm9yICggbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHM7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVycy5wdXNoKCBfZ2wuY3JlYXRlQnVmZmVyKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzOyBtIDwgbWw7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoTm9ybWFsc0J1ZmZlcnMucHVzaCggX2dsLmNyZWF0ZUJ1ZmZlcigpICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgKys7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEV2ZW50c1xyXG5cclxuXHR2YXIgb25HZW9tZXRyeURpc3Bvc2UgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdHZhciBnZW9tZXRyeSA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHRnZW9tZXRyeS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uR2VvbWV0cnlEaXNwb3NlICk7XHJcblxyXG5cdFx0ZGVhbGxvY2F0ZUdlb21ldHJ5KCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgLS07XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBvblRleHR1cmVEaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHR2YXIgdGV4dHVyZSA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHR0ZXh0dXJlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25UZXh0dXJlRGlzcG9zZSApO1xyXG5cclxuXHRcdGRlYWxsb2NhdGVUZXh0dXJlKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0X3RoaXMuaW5mby5tZW1vcnkudGV4dHVyZXMgLS07XHJcblxyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgb25SZW5kZXJUYXJnZXREaXNwb3NlID0gZnVuY3Rpb24gKCBldmVudCApIHtcclxuXHJcblx0XHR2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xyXG5cclxuXHRcdGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzIC0tO1xyXG5cclxuXHR9O1xyXG5cclxuXHR2YXIgb25NYXRlcmlhbERpc3Bvc2UgPSBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdHZhciBtYXRlcmlhbCA9IGV2ZW50LnRhcmdldDtcclxuXHJcblx0XHRtYXRlcmlhbC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uTWF0ZXJpYWxEaXNwb3NlICk7XHJcblxyXG5cdFx0ZGVhbGxvY2F0ZU1hdGVyaWFsKCBtYXRlcmlhbCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBCdWZmZXIgZGVhbGxvY2F0aW9uXHJcblxyXG5cdHZhciBkZWFsbG9jYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdGdlb21ldHJ5Ll9fd2ViZ2xJbml0ID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciAhPT0gdW5kZWZpbmVkICkgX2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsTm9ybWFsQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XHJcblx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xUYW5nZW50QnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsVGFuZ2VudEJ1ZmZlciApO1xyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgIT09IHVuZGVmaW5lZCApIF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsVVZCdWZmZXIgIT09IHVuZGVmaW5lZCApIF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xVVkJ1ZmZlciApO1xyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsVVYyQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsVVYyQnVmZmVyICk7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgIT09IHVuZGVmaW5lZCApIF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xTa2luSW5kaWNlc0J1ZmZlciApO1xyXG5cdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsU2tpbldlaWdodHNCdWZmZXIgIT09IHVuZGVmaW5lZCApIF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xTa2luV2VpZ2h0c0J1ZmZlciApO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbEZhY2VCdWZmZXIgIT09IHVuZGVmaW5lZCApIF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xGYWNlQnVmZmVyICk7XHJcblx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xMaW5lQnVmZmVyICE9PSB1bmRlZmluZWQgKSBfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsTGluZUJ1ZmZlciApO1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciAhPT0gdW5kZWZpbmVkICkgX2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciApO1xyXG5cclxuXHRcdC8vIGdlb21ldHJ5IGdyb3Vwc1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBnIGluIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ2VvbWV0cnlHcm91cCA9IGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBnIF07XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHM7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbIG0gXSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhOb3JtYWxzOyBtIDwgbWw7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzWyBtIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZGVsZXRlQ3VzdG9tQXR0cmlidXRlc0J1ZmZlcnMoIGdlb21ldHJ5R3JvdXAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlQ3VzdG9tQXR0cmlidXRlc0J1ZmZlcnMoIGdlb21ldHJ5ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBkZWFsbG9jYXRlVGV4dHVyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSApIHtcclxuXHJcblx0XHRpZiAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZS5pbWFnZS5fX3dlYmdsVGV4dHVyZUN1YmUgKSB7XHJcblxyXG5cdFx0XHQvLyBjdWJlIHRleHR1cmVcclxuXHJcblx0XHRcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlLmltYWdlLl9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyAyRCB0ZXh0dXJlXHJcblxyXG5cdFx0XHRpZiAoICEgdGV4dHVyZS5fX3dlYmdsSW5pdCApIHJldHVybjtcclxuXHJcblx0XHRcdHRleHR1cmUuX193ZWJnbEluaXQgPSBmYWxzZTtcclxuXHRcdFx0X2dsLmRlbGV0ZVRleHR1cmUoIHRleHR1cmUuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBkZWFsbG9jYXRlUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0aWYgKCAhcmVuZGVyVGFyZ2V0IHx8ICEgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlICkgcmV0dXJuO1xyXG5cclxuXHRcdF9nbC5kZWxldGVUZXh0dXJlKCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kZWxldGVGcmFtZWJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICk7XHJcblx0XHRcdFx0X2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXJbIGkgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgKTtcclxuXHRcdFx0X2dsLmRlbGV0ZVJlbmRlcmJ1ZmZlciggcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBkZWFsbG9jYXRlTWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gbWF0ZXJpYWwucHJvZ3JhbTtcclxuXHJcblx0XHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHJldHVybjtcclxuXHJcblx0XHRtYXRlcmlhbC5wcm9ncmFtID0gdW5kZWZpbmVkO1xyXG5cclxuXHRcdC8vIG9ubHkgZGVhbGxvY2F0ZSBHTCBwcm9ncmFtIGlmIHRoaXMgd2FzIHRoZSBsYXN0IHVzZSBvZiBzaGFyZWQgcHJvZ3JhbVxyXG5cdFx0Ly8gYXNzdW1lZCB0aGVyZSBpcyBvbmx5IHNpbmdsZSBjb3B5IG9mIGFueSBwcm9ncmFtIGluIHRoZSBfcHJvZ3JhbXMgbGlzdFxyXG5cdFx0Ly8gKHRoYXQncyBob3cgaXQncyBjb25zdHJ1Y3RlZClcclxuXHJcblx0XHR2YXIgaSwgaWwsIHByb2dyYW1JbmZvO1xyXG5cdFx0dmFyIGRlbGV0ZVByb2dyYW0gPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBfcHJvZ3JhbXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRwcm9ncmFtSW5mbyA9IF9wcm9ncmFtc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBwcm9ncmFtSW5mby5wcm9ncmFtID09PSBwcm9ncmFtICkge1xyXG5cclxuXHRcdFx0XHRwcm9ncmFtSW5mby51c2VkVGltZXMgLS07XHJcblxyXG5cdFx0XHRcdGlmICggcHJvZ3JhbUluZm8udXNlZFRpbWVzID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdGRlbGV0ZVByb2dyYW0gPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRlbGV0ZVByb2dyYW0gPT09IHRydWUgKSB7XHJcblxyXG5cdFx0XHQvLyBhdm9pZCB1c2luZyBhcnJheS5zcGxpY2UsIHRoaXMgaXMgY29zdGxpZXIgdGhhbiBjcmVhdGluZyBuZXcgYXJyYXkgZnJvbSBzY3JhdGNoXHJcblxyXG5cdFx0XHR2YXIgbmV3UHJvZ3JhbXMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IF9wcm9ncmFtcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0cHJvZ3JhbUluZm8gPSBfcHJvZ3JhbXNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBwcm9ncmFtSW5mby5wcm9ncmFtICE9PSBwcm9ncmFtICkge1xyXG5cclxuXHRcdFx0XHRcdG5ld1Byb2dyYW1zLnB1c2goIHByb2dyYW1JbmZvICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9wcm9ncmFtcyA9IG5ld1Byb2dyYW1zO1xyXG5cclxuXHRcdFx0X2dsLmRlbGV0ZVByb2dyYW0oIHByb2dyYW0gKTtcclxuXHJcblx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnByb2dyYW1zIC0tO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly9cclxuXHJcblx0LypcclxuXHRmdW5jdGlvbiBkZWxldGVQYXJ0aWNsZUJ1ZmZlcnMgKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyICk7XHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHJcblx0XHRkZWxldGVDdXN0b21BdHRyaWJ1dGVzQnVmZmVycyggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBkZWxldGVMaW5lQnVmZmVycyAoIGdlb21ldHJ5ICkge1xyXG5cclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnkuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciApO1xyXG5cclxuXHRcdGRlbGV0ZUN1c3RvbUF0dHJpYnV0ZXNCdWZmZXJzKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5Lmdlb21ldHJpZXMgLS07XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGRlbGV0ZVJpYmJvbkJ1ZmZlcnMgKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyICk7XHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xOb3JtYWxCdWZmZXIgKTtcclxuXHJcblx0XHRkZWxldGVDdXN0b21BdHRyaWJ1dGVzQnVmZmVycyggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBkZWxldGVNZXNoQnVmZmVycyAoIGdlb21ldHJ5R3JvdXAgKSB7XHJcblxyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4QnVmZmVyICk7XHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xOb3JtYWxCdWZmZXIgKTtcclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbFRhbmdlbnRCdWZmZXIgKTtcclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbENvbG9yQnVmZmVyICk7XHJcblx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVkJ1ZmZlciApO1xyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsVVYyQnVmZmVyICk7XHJcblxyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgKTtcclxuXHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyICk7XHJcblxyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUJ1ZmZlciApO1xyXG5cdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZUJ1ZmZlciApO1xyXG5cclxuXHRcdHZhciBtLCBtbDtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0Zm9yICggbSA9IDAsIG1sID0gZ2VvbWV0cnlHcm91cC5udW1Nb3JwaFRhcmdldHM7IG0gPCBtbDsgbSArKyApIHtcclxuXHJcblx0XHRcdFx0X2dsLmRlbGV0ZUJ1ZmZlciggZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgbSBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBtID0gMCwgbWwgPSBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFsczsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGVsZXRlQnVmZmVyKCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzWyBtIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0ZGVsZXRlQ3VzdG9tQXR0cmlidXRlc0J1ZmZlcnMoIGdlb21ldHJ5R3JvdXAgKTtcclxuXHJcblx0XHRfdGhpcy5pbmZvLm1lbW9yeS5nZW9tZXRyaWVzIC0tO1xyXG5cclxuXHR9O1xyXG5cdCovXHJcblxyXG5cdGZ1bmN0aW9uIGRlbGV0ZUN1c3RvbUF0dHJpYnV0ZXNCdWZmZXJzKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpZCBpbiBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kZWxldGVCdWZmZXIoIGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdFsgaWQgXS5idWZmZXIgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEJ1ZmZlciBpbml0aWFsaXphdGlvblxyXG5cclxuXHRmdW5jdGlvbiBpbml0Q3VzdG9tQXR0cmlidXRlcyAoIGdlb21ldHJ5LCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIG52ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ID0gW107XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgYSBpbiBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYXR0cmlidXRlID0gbWF0ZXJpYWwuYXR0cmlidXRlc1sgYSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoICFhdHRyaWJ1dGUuX193ZWJnbEluaXRpYWxpemVkIHx8IGF0dHJpYnV0ZS5jcmVhdGVVbmlxdWVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5fX3dlYmdsSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdHZhciBzaXplID0gMTtcdFx0Ly8gXCJmXCIgYW5kIFwiaVwiXHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGUudHlwZSA9PT0gXCJ2MlwiICkgc2l6ZSA9IDI7XHJcblx0XHRcdFx0XHRlbHNlIGlmICggYXR0cmlidXRlLnR5cGUgPT09IFwidjNcIiApIHNpemUgPSAzO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiAoIGF0dHJpYnV0ZS50eXBlID09PSBcInY0XCIgKSBzaXplID0gNDtcclxuXHRcdFx0XHRcdGVsc2UgaWYgKCBhdHRyaWJ1dGUudHlwZSA9PT0gXCJjXCIgICkgc2l6ZSA9IDM7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLnNpemUgPSBzaXplO1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIHNpemUgKTtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuYnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0XHRcdFx0YXR0cmlidXRlLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGUgPSBhO1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LnB1c2goIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gaW5pdFBhcnRpY2xlQnVmZmVycyAoIGdlb21ldHJ5LCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIG52ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3ZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xyXG5cdFx0Z2VvbWV0cnkuX19jb2xvckFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xyXG5cclxuXHRcdGdlb21ldHJ5Ll9fc29ydEFycmF5ID0gW107XHJcblxyXG5cdFx0Z2VvbWV0cnkuX193ZWJnbFBhcnRpY2xlQ291bnQgPSBudmVydGljZXM7XHJcblxyXG5cdFx0aW5pdEN1c3RvbUF0dHJpYnV0ZXMgKCBnZW9tZXRyeSwgb2JqZWN0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRMaW5lQnVmZmVycyAoIGdlb21ldHJ5LCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIG52ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3ZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xyXG5cdFx0Z2VvbWV0cnkuX19jb2xvckFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xyXG5cdFx0Z2VvbWV0cnkuX19saW5lRGlzdGFuY2VBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDEgKTtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsTGluZUNvdW50ID0gbnZlcnRpY2VzO1xyXG5cclxuXHRcdGluaXRDdXN0b21BdHRyaWJ1dGVzICggZ2VvbWV0cnksIG9iamVjdCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBpbml0UmliYm9uQnVmZmVycyAoIGdlb21ldHJ5LCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIG52ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3ZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xyXG5cdFx0Z2VvbWV0cnkuX19jb2xvckFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xyXG5cdFx0Z2VvbWV0cnkuX19ub3JtYWxBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcclxuXHJcblx0XHRnZW9tZXRyeS5fX3dlYmdsVmVydGV4Q291bnQgPSBudmVydGljZXM7XHJcblxyXG5cdFx0aW5pdEN1c3RvbUF0dHJpYnV0ZXMgKCBnZW9tZXRyeSwgb2JqZWN0ICk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRNZXNoQnVmZmVycyAoIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnksXHJcblx0XHRcdGZhY2VzMyA9IGdlb21ldHJ5R3JvdXAuZmFjZXMzLFxyXG5cdFx0XHRmYWNlczQgPSBnZW9tZXRyeUdyb3VwLmZhY2VzNCxcclxuXHJcblx0XHRcdG52ZXJ0aWNlcyA9IGZhY2VzMy5sZW5ndGggKiAzICsgZmFjZXM0Lmxlbmd0aCAqIDQsXHJcblx0XHRcdG50cmlzICAgICA9IGZhY2VzMy5sZW5ndGggKiAxICsgZmFjZXM0Lmxlbmd0aCAqIDIsXHJcblx0XHRcdG5saW5lcyAgICA9IGZhY2VzMy5sZW5ndGggKiAzICsgZmFjZXM0Lmxlbmd0aCAqIDQsXHJcblxyXG5cdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5R3JvdXAgKSxcclxuXHJcblx0XHRcdHV2VHlwZSA9IGJ1ZmZlckd1ZXNzVVZUeXBlKCBtYXRlcmlhbCApLFxyXG5cdFx0XHRub3JtYWxUeXBlID0gYnVmZmVyR3Vlc3NOb3JtYWxUeXBlKCBtYXRlcmlhbCApLFxyXG5cdFx0XHR2ZXJ0ZXhDb2xvclR5cGUgPSBidWZmZXJHdWVzc1ZlcnRleENvbG9yVHlwZSggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCBcInV2VHlwZVwiLCB1dlR5cGUsIFwibm9ybWFsVHlwZVwiLCBub3JtYWxUeXBlLCBcInZlcnRleENvbG9yVHlwZVwiLCB2ZXJ0ZXhDb2xvclR5cGUsIG9iamVjdCwgZ2VvbWV0cnlHcm91cCwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fdmVydGV4QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAzICk7XHJcblxyXG5cdFx0aWYgKCBub3JtYWxUeXBlICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX25vcm1hbEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Lmhhc1RhbmdlbnRzICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3RhbmdlbnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB2ZXJ0ZXhDb2xvclR5cGUgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fY29sb3JBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB1dlR5cGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5LmZhY2VVdnMubGVuZ3RoID4gMCB8fCBnZW9tZXRyeS5mYWNlVmVydGV4VXZzLmxlbmd0aCA+IDAgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX191dkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeS5mYWNlVXZzLmxlbmd0aCA+IDEgfHwgZ2VvbWV0cnkuZmFjZVZlcnRleFV2cy5sZW5ndGggPiAxICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fdXYyQXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiAyICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAmJiBvYmplY3QuZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnlHcm91cC5fX3NraW5JbmRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogNCApO1xyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fc2tpbldlaWdodEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogNCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fZmFjZUFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBudHJpcyAqIDMgKTtcclxuXHRcdGdlb21ldHJ5R3JvdXAuX19saW5lQXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIG5saW5lcyAqIDIgKTtcclxuXHJcblx0XHR2YXIgbSwgbWw7XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeUdyb3VwLm51bU1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdGdlb21ldHJ5R3JvdXAuX19tb3JwaFRhcmdldHNBcnJheXMgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIG0gPSAwLCBtbCA9IGdlb21ldHJ5R3JvdXAubnVtTW9ycGhUYXJnZXRzOyBtIDwgbWw7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX19tb3JwaFRhcmdldHNBcnJheXMucHVzaCggbmV3IEZsb2F0MzJBcnJheSggbnZlcnRpY2VzICogMyApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnlHcm91cC5udW1Nb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhOb3JtYWxzQXJyYXlzID0gW107XHJcblxyXG5cdFx0XHRmb3IgKCBtID0gMCwgbWwgPSBnZW9tZXRyeUdyb3VwLm51bU1vcnBoTm9ybWFsczsgbSA8IG1sOyBtICsrICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeUdyb3VwLl9fbW9ycGhOb3JtYWxzQXJyYXlzLnB1c2goIG5ldyBGbG9hdDMyQXJyYXkoIG52ZXJ0aWNlcyAqIDMgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQ291bnQgPSBudHJpcyAqIDM7XHJcblx0XHRnZW9tZXRyeUdyb3VwLl9fd2ViZ2xMaW5lQ291bnQgPSBubGluZXMgKiAyO1xyXG5cclxuXHJcblx0XHQvLyBjdXN0b20gYXR0cmlidXRlc1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QgPSBbXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIHZhciBhIGluIG1hdGVyaWFsLmF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdC8vIERvIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBhdHRyaWJ1dGUgb2JqZWN0IHNvIGRpZmZlcmVudCBnZW9tZXRyeUdyb3VwIGNodW5rcyB1c2UgZGlmZmVyZW50XHJcblx0XHRcdFx0Ly8gYXR0cmlidXRlIGJ1ZmZlcnMgd2hpY2ggYXJlIGNvcnJlY3RseSBpbmRleGVkIGluIHRoZSBzZXRNZXNoQnVmZmVycyBmdW5jdGlvblxyXG5cclxuXHRcdFx0XHR2YXIgb3JpZ2luYWxBdHRyaWJ1dGUgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzWyBhIF07XHJcblxyXG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUgPSB7fTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIHByb3BlcnR5IGluIG9yaWdpbmFsQXR0cmlidXRlICkge1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZVsgcHJvcGVydHkgXSA9IG9yaWdpbmFsQXR0cmlidXRlWyBwcm9wZXJ0eSBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggIWF0dHJpYnV0ZS5fX3dlYmdsSW5pdGlhbGl6ZWQgfHwgYXR0cmlidXRlLmNyZWF0ZVVuaXF1ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLl9fd2ViZ2xJbml0aWFsaXplZCA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHNpemUgPSAxO1x0XHQvLyBcImZcIiBhbmQgXCJpXCJcclxuXHJcblx0XHRcdFx0XHRpZiggYXR0cmlidXRlLnR5cGUgPT09IFwidjJcIiApIHNpemUgPSAyO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiggYXR0cmlidXRlLnR5cGUgPT09IFwidjNcIiApIHNpemUgPSAzO1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiggYXR0cmlidXRlLnR5cGUgPT09IFwidjRcIiApIHNpemUgPSA0O1xyXG5cdFx0XHRcdFx0ZWxzZSBpZiggYXR0cmlidXRlLnR5cGUgPT09IFwiY1wiICApIHNpemUgPSAzO1xyXG5cclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5zaXplID0gc2l6ZTtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCBudmVydGljZXMgKiBzaXplICk7XHJcblxyXG5cdFx0XHRcdFx0YXR0cmlidXRlLmJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdFx0XHRcdGF0dHJpYnV0ZS5idWZmZXIuYmVsb25nc1RvQXR0cmlidXRlID0gYTtcclxuXHJcblx0XHRcdFx0XHRvcmlnaW5hbEF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUuX19vcmlnaW5hbCA9IG9yaWdpbmFsQXR0cmlidXRlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LnB1c2goIGF0dHJpYnV0ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRnZW9tZXRyeUdyb3VwLl9faW5pdHRlZEFycmF5cyA9IHRydWU7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5R3JvdXAgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdC5tYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWxcclxuXHRcdFx0PyBvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzWyBnZW9tZXRyeUdyb3VwLm1hdGVyaWFsSW5kZXggXVxyXG5cdFx0XHQ6IG9iamVjdC5tYXRlcmlhbDtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gbWF0ZXJpYWxOZWVkc1Ntb290aE5vcm1hbHMgKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRyZXR1cm4gbWF0ZXJpYWwgJiYgbWF0ZXJpYWwuc2hhZGluZyAhPT0gdW5kZWZpbmVkICYmIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGJ1ZmZlckd1ZXNzTm9ybWFsVHlwZSAoIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdC8vIG9ubHkgTWVzaEJhc2ljTWF0ZXJpYWwgYW5kIE1lc2hEZXB0aE1hdGVyaWFsIGRvbid0IG5lZWQgbm9ybWFsc1xyXG5cclxuXHRcdGlmICggKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsICYmICFtYXRlcmlhbC5lbnZNYXAgKSB8fCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hEZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsTmVlZHNTbW9vdGhOb3JtYWxzKCBtYXRlcmlhbCApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIFRIUkVFLlNtb290aFNoYWRpbmc7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHJldHVybiBUSFJFRS5GbGF0U2hhZGluZztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGJ1ZmZlckd1ZXNzVmVydGV4Q29sb3JUeXBlICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gbWF0ZXJpYWwudmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGJ1ZmZlckd1ZXNzVVZUeXBlICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0Ly8gbWF0ZXJpYWwgbXVzdCB1c2Ugc29tZSB0ZXh0dXJlIHRvIHJlcXVpcmUgdXZzXHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5tYXAgfHwgbWF0ZXJpYWwubGlnaHRNYXAgfHwgbWF0ZXJpYWwuYnVtcE1hcCB8fCBtYXRlcmlhbC5ub3JtYWxNYXAgfHwgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgfHwgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5TaGFkZXJNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZmFsc2U7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vXHJcblxyXG5cdGZ1bmN0aW9uIGluaXREaXJlY3RCdWZmZXJzKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHR2YXIgYSwgYXR0cmlidXRlLCB0eXBlO1xyXG5cclxuXHRcdGZvciAoIGEgaW4gZ2VvbWV0cnkuYXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGlmICggYSA9PT0gXCJpbmRleFwiICkge1xyXG5cclxuXHRcdFx0XHR0eXBlID0gX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0dHlwZSA9IF9nbC5BUlJBWV9CVUZGRVI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRhdHRyaWJ1dGUgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBhIF07XHJcblxyXG5cdFx0XHRhdHRyaWJ1dGUuYnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIHR5cGUsIGF0dHJpYnV0ZS5idWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIHR5cGUsIGF0dHJpYnV0ZS5hcnJheSwgX2dsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBCdWZmZXIgc2V0dGluZ1xyXG5cclxuXHRmdW5jdGlvbiBzZXRQYXJ0aWNsZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgaGludCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciB2LCBjLCB2ZXJ0ZXgsIG9mZnNldCwgaW5kZXgsIGNvbG9yLFxyXG5cclxuXHRcdHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMsXHJcblx0XHR2bCA9IHZlcnRpY2VzLmxlbmd0aCxcclxuXHJcblx0XHRjb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnMsXHJcblx0XHRjbCA9IGNvbG9ycy5sZW5ndGgsXHJcblxyXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeS5fX3ZlcnRleEFycmF5LFxyXG5cdFx0Y29sb3JBcnJheSA9IGdlb21ldHJ5Ll9fY29sb3JBcnJheSxcclxuXHJcblx0XHRzb3J0QXJyYXkgPSBnZW9tZXRyeS5fX3NvcnRBcnJheSxcclxuXHJcblx0XHRkaXJ0eVZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlFbGVtZW50cyA9IGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSxcclxuXHRcdGRpcnR5Q29sb3JzID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSxcclxuXHJcblx0XHRjdXN0b21BdHRyaWJ1dGVzID0gZ2VvbWV0cnkuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0LFxyXG5cdFx0aSwgaWwsXHJcblx0XHRhLCBjYSwgY2FsLCB2YWx1ZSxcclxuXHRcdGN1c3RvbUF0dHJpYnV0ZTtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5zb3J0UGFydGljbGVzICkge1xyXG5cclxuXHRcdFx0X3Byb2pTY3JlZW5NYXRyaXhQUy5jb3B5KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cdFx0XHRfcHJvalNjcmVlbk1hdHJpeFBTLm11bHRpcGx5KCBvYmplY3QubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyB2IF07XHJcblxyXG5cdFx0XHRcdF92ZWN0b3IzLmNvcHkoIHZlcnRleCApO1xyXG5cdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXhQUyApO1xyXG5cclxuXHRcdFx0XHRzb3J0QXJyYXlbIHYgXSA9IFsgX3ZlY3RvcjMueiwgdiBdO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0c29ydEFycmF5LnNvcnQoIG51bWVyaWNhbFNvcnQgKTtcclxuXHJcblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyBzb3J0QXJyYXlbdl1bMV0gXTtcclxuXHJcblx0XHRcdFx0b2Zmc2V0ID0gdiAqIDM7XHJcblxyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgXSAgICAgPSB2ZXJ0ZXgueDtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdmVydGV4Lnk7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDIgXSA9IHZlcnRleC56O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggYyA9IDA7IGMgPCBjbDsgYyArKyApIHtcclxuXHJcblx0XHRcdFx0b2Zmc2V0ID0gYyAqIDM7XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gY29sb3JzWyBzb3J0QXJyYXlbY11bMV0gXTtcclxuXHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3IucjtcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggISAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdFx0XHRjYWwgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWUubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW5kZXggPSBzb3J0QXJyYXlbIGNhIF1bIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBjYSBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDI7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSBcImNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSBzb3J0QXJyYXlbIGNhIF1bIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgaW5kZXggXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgICA9IHZhbHVlLnI7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGluZGV4IF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMiBdID0gdmFsdWUuejtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSA0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGluZGV4ID0gc29ydEFycmF5WyBjYSBdWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBpbmRleCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdICAgICAgPSB2YWx1ZS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSAgXSA9IHZhbHVlLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyICBdID0gdmFsdWUuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDMgIF0gPSB2YWx1ZS53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aWYgKCBkaXJ0eVZlcnRpY2VzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyB2IF07XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gdiAqIDM7XHJcblxyXG5cdFx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHZlcnRleC54O1xyXG5cdFx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHZlcnRleC55O1xyXG5cdFx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDIgXSA9IHZlcnRleC56O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGRpcnR5Q29sb3JzICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBjID0gMDsgYyA8IGNsOyBjICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbG9yID0gY29sb3JzWyBjIF07XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gYyAqIDM7XHJcblxyXG5cdFx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3IucjtcclxuXHRcdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmc7XHJcblx0XHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLm5lZWRzVXBkYXRlICYmXHJcblx0XHRcdFx0XHRcdCAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHxcclxuXHRcdFx0XHRcdFx0ICAgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIikgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjYWwgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWUubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdFx0b2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDI7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSBcImNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUucjtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxIF0gPSB2YWx1ZS5nO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcclxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAyIF0gPSB2YWx1ZS56O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSAgICAgID0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSAgXSA9IHZhbHVlLnk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgIF0gPSB2YWx1ZS56O1xyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAzICBdID0gdmFsdWUudztcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gNDtcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5VmVydGljZXMgfHwgb2JqZWN0LnNvcnRQYXJ0aWNsZXMgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdmVydGV4QXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSB8fCBvYmplY3Quc29ydFBhcnRpY2xlcyApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0TGluZUJ1ZmZlcnMgKCBnZW9tZXRyeSwgaGludCApIHtcclxuXHJcblx0XHR2YXIgdiwgYywgZCwgdmVydGV4LCBvZmZzZXQsIGNvbG9yLFxyXG5cclxuXHRcdHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMsXHJcblx0XHRjb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnMsXHJcblx0XHRsaW5lRGlzdGFuY2VzID0gZ2VvbWV0cnkubGluZURpc3RhbmNlcyxcclxuXHJcblx0XHR2bCA9IHZlcnRpY2VzLmxlbmd0aCxcclxuXHRcdGNsID0gY29sb3JzLmxlbmd0aCxcclxuXHRcdGRsID0gbGluZURpc3RhbmNlcy5sZW5ndGgsXHJcblxyXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeS5fX3ZlcnRleEFycmF5LFxyXG5cdFx0Y29sb3JBcnJheSA9IGdlb21ldHJ5Ll9fY29sb3JBcnJheSxcclxuXHRcdGxpbmVEaXN0YW5jZUFycmF5ID0gZ2VvbWV0cnkuX19saW5lRGlzdGFuY2VBcnJheSxcclxuXHJcblx0XHRkaXJ0eVZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlDb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlMaW5lRGlzdGFuY2VzID0gZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUsXHJcblxyXG5cdFx0Y3VzdG9tQXR0cmlidXRlcyA9IGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdCxcclxuXHJcblx0XHRpLCBpbCxcclxuXHRcdGEsIGNhLCBjYWwsIHZhbHVlLFxyXG5cdFx0Y3VzdG9tQXR0cmlidXRlO1xyXG5cclxuXHRcdGlmICggZGlydHlWZXJ0aWNlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIHYgPSAwOyB2IDwgdmw7IHYgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZlcnRleCA9IHZlcnRpY2VzWyB2IF07XHJcblxyXG5cdFx0XHRcdG9mZnNldCA9IHYgKiAzO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0IF0gICAgID0gdmVydGV4Lng7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHZlcnRleC55O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAyIF0gPSB2ZXJ0ZXguejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5fX3dlYmdsVmVydGV4QnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhBcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5Q29sb3JzICkge1xyXG5cclxuXHRcdFx0Zm9yICggYyA9IDA7IGMgPCBjbDsgYyArKyApIHtcclxuXHJcblx0XHRcdFx0Y29sb3IgPSBjb2xvcnNbIGMgXTtcclxuXHJcblx0XHRcdFx0b2Zmc2V0ID0gYyAqIDM7XHJcblxyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCBdICAgICA9IGNvbG9yLnI7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZztcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5Ll9fd2ViZ2xDb2xvckJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY29sb3JBcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5TGluZURpc3RhbmNlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIGQgPSAwOyBkIDwgZGw7IGQgKysgKSB7XHJcblxyXG5cdFx0XHRcdGxpbmVEaXN0YW5jZUFycmF5WyBkIF0gPSBsaW5lRGlzdGFuY2VzWyBkIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbExpbmVEaXN0YW5jZUJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgbGluZURpc3RhbmNlQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gY3VzdG9tQXR0cmlidXRlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlID0gY3VzdG9tQXR0cmlidXRlc1sgaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSAmJlxyXG5cdFx0XHRcdFx0ICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fFxyXG5cdFx0XHRcdFx0ICAgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApICkge1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldCA9IDA7XHJcblxyXG5cdFx0XHRcdFx0Y2FsID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgY2EgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSAyO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUudHlwZSA9PT0gXCJjXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLnI7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLmc7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLmI7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0IF0gXHQ9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlLnk7XHJcblx0XHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlLno7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gNCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGNhID0gMDsgY2EgPCBjYWw7IGNhICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2EgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdCA9IHZhbHVlLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAxICBdID0gdmFsdWUueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDIgIF0gPSB2YWx1ZS56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMyAgXSA9IHZhbHVlLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldCArPSA0O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRSaWJib25CdWZmZXJzICggZ2VvbWV0cnksIGhpbnQgKSB7XHJcblxyXG5cdFx0dmFyIHYsIGMsIG4sIHZlcnRleCwgb2Zmc2V0LCBjb2xvciwgbm9ybWFsLFxyXG5cclxuXHRcdGksIGlsLCBjYSwgY2FsLCBjdXN0b21BdHRyaWJ1dGUsIHZhbHVlLFxyXG5cclxuXHRcdHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXMsXHJcblx0XHRjb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnMsXHJcblx0XHRub3JtYWxzID0gZ2VvbWV0cnkubm9ybWFscyxcclxuXHJcblx0XHR2bCA9IHZlcnRpY2VzLmxlbmd0aCxcclxuXHRcdGNsID0gY29sb3JzLmxlbmd0aCxcclxuXHRcdG5sID0gbm9ybWFscy5sZW5ndGgsXHJcblxyXG5cdFx0dmVydGV4QXJyYXkgPSBnZW9tZXRyeS5fX3ZlcnRleEFycmF5LFxyXG5cdFx0Y29sb3JBcnJheSA9IGdlb21ldHJ5Ll9fY29sb3JBcnJheSxcclxuXHRcdG5vcm1hbEFycmF5ID0gZ2VvbWV0cnkuX19ub3JtYWxBcnJheSxcclxuXHJcblx0XHRkaXJ0eVZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlDb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlLFxyXG5cdFx0ZGlydHlOb3JtYWxzID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUsXHJcblxyXG5cdFx0Y3VzdG9tQXR0cmlidXRlcyA9IGdlb21ldHJ5Ll9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdDtcclxuXHJcblx0XHRpZiAoIGRpcnR5VmVydGljZXMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2ID0gMDsgdiA8IHZsOyB2ICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXggPSB2ZXJ0aWNlc1sgdiBdO1xyXG5cclxuXHRcdFx0XHRvZmZzZXQgPSB2ICogMztcclxuXHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHZlcnRleC54O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAxIF0gPSB2ZXJ0ZXgueTtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMiBdID0gdmVydGV4Lno7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdmVydGV4QXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eUNvbG9ycyApIHtcclxuXHJcblx0XHRcdGZvciAoIGMgPSAwOyBjIDwgY2w7IGMgKysgKSB7XHJcblxyXG5cdFx0XHRcdGNvbG9yID0gY29sb3JzWyBjIF07XHJcblxyXG5cdFx0XHRcdG9mZnNldCA9IGMgKiAzO1xyXG5cclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXQgXSAgICAgPSBjb2xvci5yO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldCArIDEgXSA9IGNvbG9yLmc7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0ICsgMiBdID0gY29sb3IuYjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eU5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBuID0gMDsgbiA8IG5sOyBuICsrICkge1xyXG5cclxuXHRcdFx0XHRub3JtYWwgPSBub3JtYWxzWyBuIF07XHJcblxyXG5cdFx0XHRcdG9mZnNldCA9IG4gKiAzO1xyXG5cclxuXHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0IF0gICAgID0gbm9ybWFsLng7XHJcblx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldCArIDEgXSA9IG5vcm1hbC55O1xyXG5cdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXQgKyAyIF0gPSBub3JtYWwuejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeS5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBub3JtYWxBcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBjdXN0b21BdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUgPSBjdXN0b21BdHRyaWJ1dGVzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLm5lZWRzVXBkYXRlICYmXHJcblx0XHRcdFx0XHQgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8XHJcblx0XHRcdFx0XHQgICBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJ2ZXJ0aWNlc1wiICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gMDtcclxuXHJcblx0XHRcdFx0XHRjYWwgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWUubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBjYSA9IDA7IGNhIDwgY2FsOyBjYSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBjYSBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAyICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0PSB2YWx1ZS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDI7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS50eXBlID09PSBcImNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUucjtcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUuZztcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMiBdID0gdmFsdWUuYjtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNhIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgXSBcdD0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWUueTtcclxuXHRcdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMiBdID0gdmFsdWUuejtcclxuXHJcblx0XHRcdFx0XHRcdFx0XHRvZmZzZXQgKz0gMztcclxuXHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSA0ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggY2EgPSAwOyBjYSA8IGNhbDsgY2EgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjYSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCBdIFx0ID0gdmFsdWUueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldCArIDEgIF0gPSB2YWx1ZS55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0ICsgMiAgXSA9IHZhbHVlLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXQgKyAzICBdID0gdmFsdWUudztcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0ICs9IDQ7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBjdXN0b21BdHRyaWJ1dGUuYnVmZmVyICk7XHJcblx0XHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QsIGhpbnQsIGRpc3Bvc2UsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdGlmICggISBnZW9tZXRyeUdyb3VwLl9faW5pdHRlZEFycmF5cyApIHtcclxuXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG5vcm1hbFR5cGUgPSBidWZmZXJHdWVzc05vcm1hbFR5cGUoIG1hdGVyaWFsICksXHJcblx0XHR2ZXJ0ZXhDb2xvclR5cGUgPSBidWZmZXJHdWVzc1ZlcnRleENvbG9yVHlwZSggbWF0ZXJpYWwgKSxcclxuXHRcdHV2VHlwZSA9IGJ1ZmZlckd1ZXNzVVZUeXBlKCBtYXRlcmlhbCApLFxyXG5cclxuXHRcdG5lZWRzU21vb3RoTm9ybWFscyA9ICggbm9ybWFsVHlwZSA9PT0gVEhSRUUuU21vb3RoU2hhZGluZyApO1xyXG5cclxuXHRcdHZhciBmLCBmbCwgZmksIGZhY2UsXHJcblx0XHR2ZXJ0ZXhOb3JtYWxzLCBmYWNlTm9ybWFsLCBub3JtYWwsXHJcblx0XHR2ZXJ0ZXhDb2xvcnMsIGZhY2VDb2xvcixcclxuXHRcdHZlcnRleFRhbmdlbnRzLFxyXG5cdFx0dXYsIHV2MiwgdjEsIHYyLCB2MywgdjQsIHQxLCB0MiwgdDMsIHQ0LCBuMSwgbjIsIG4zLCBuNCxcclxuXHRcdGMxLCBjMiwgYzMsIGM0LFxyXG5cdFx0c3cxLCBzdzIsIHN3Mywgc3c0LFxyXG5cdFx0c2kxLCBzaTIsIHNpMywgc2k0LFxyXG5cdFx0c2ExLCBzYTIsIHNhMywgc2E0LFxyXG5cdFx0c2IxLCBzYjIsIHNiMywgc2I0LFxyXG5cdFx0bSwgbWwsIGksIGlsLFxyXG5cdFx0dm4sIHV2aSwgdXYyaSxcclxuXHRcdHZrLCB2a2wsIHZrYSxcclxuXHRcdG5rYSwgY2hmLCBmYWNlVmVydGV4Tm9ybWFscyxcclxuXHRcdGEsXHJcblxyXG5cdFx0dmVydGV4SW5kZXggPSAwLFxyXG5cclxuXHRcdG9mZnNldCA9IDAsXHJcblx0XHRvZmZzZXRfdXYgPSAwLFxyXG5cdFx0b2Zmc2V0X3V2MiA9IDAsXHJcblx0XHRvZmZzZXRfZmFjZSA9IDAsXHJcblx0XHRvZmZzZXRfbm9ybWFsID0gMCxcclxuXHRcdG9mZnNldF90YW5nZW50ID0gMCxcclxuXHRcdG9mZnNldF9saW5lID0gMCxcclxuXHRcdG9mZnNldF9jb2xvciA9IDAsXHJcblx0XHRvZmZzZXRfc2tpbiA9IDAsXHJcblx0XHRvZmZzZXRfbW9ycGhUYXJnZXQgPSAwLFxyXG5cdFx0b2Zmc2V0X2N1c3RvbSA9IDAsXHJcblx0XHRvZmZzZXRfY3VzdG9tU3JjID0gMCxcclxuXHJcblx0XHR2YWx1ZSxcclxuXHJcblx0XHR2ZXJ0ZXhBcnJheSA9IGdlb21ldHJ5R3JvdXAuX192ZXJ0ZXhBcnJheSxcclxuXHRcdHV2QXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fdXZBcnJheSxcclxuXHRcdHV2MkFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3V2MkFycmF5LFxyXG5cdFx0bm9ybWFsQXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fbm9ybWFsQXJyYXksXHJcblx0XHR0YW5nZW50QXJyYXkgPSBnZW9tZXRyeUdyb3VwLl9fdGFuZ2VudEFycmF5LFxyXG5cdFx0Y29sb3JBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19jb2xvckFycmF5LFxyXG5cclxuXHRcdHNraW5JbmRleEFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3NraW5JbmRleEFycmF5LFxyXG5cdFx0c2tpbldlaWdodEFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX3NraW5XZWlnaHRBcnJheSxcclxuXHJcblx0XHRtb3JwaFRhcmdldHNBcnJheXMgPSBnZW9tZXRyeUdyb3VwLl9fbW9ycGhUYXJnZXRzQXJyYXlzLFxyXG5cdFx0bW9ycGhOb3JtYWxzQXJyYXlzID0gZ2VvbWV0cnlHcm91cC5fX21vcnBoTm9ybWFsc0FycmF5cyxcclxuXHJcblx0XHRjdXN0b21BdHRyaWJ1dGVzID0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ3VzdG9tQXR0cmlidXRlc0xpc3QsXHJcblx0XHRjdXN0b21BdHRyaWJ1dGUsXHJcblxyXG5cdFx0ZmFjZUFycmF5ID0gZ2VvbWV0cnlHcm91cC5fX2ZhY2VBcnJheSxcclxuXHRcdGxpbmVBcnJheSA9IGdlb21ldHJ5R3JvdXAuX19saW5lQXJyYXksXHJcblxyXG5cdFx0Z2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnksIC8vIHRoaXMgaXMgc2hhcmVkIGZvciBhbGwgY2h1bmtzXHJcblxyXG5cdFx0ZGlydHlWZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSxcclxuXHRcdGRpcnR5RWxlbWVudHMgPSBnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUsXHJcblx0XHRkaXJ0eVV2cyA9IGdlb21ldHJ5LnV2c05lZWRVcGRhdGUsXHJcblx0XHRkaXJ0eU5vcm1hbHMgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSxcclxuXHRcdGRpcnR5VGFuZ2VudHMgPSBnZW9tZXRyeS50YW5nZW50c05lZWRVcGRhdGUsXHJcblx0XHRkaXJ0eUNvbG9ycyA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUsXHJcblx0XHRkaXJ0eU1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c05lZWRVcGRhdGUsXHJcblxyXG5cdFx0dmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcyxcclxuXHRcdGNodW5rX2ZhY2VzMyA9IGdlb21ldHJ5R3JvdXAuZmFjZXMzLFxyXG5cdFx0Y2h1bmtfZmFjZXM0ID0gZ2VvbWV0cnlHcm91cC5mYWNlczQsXHJcblx0XHRvYmpfZmFjZXMgPSBnZW9tZXRyeS5mYWNlcyxcclxuXHJcblx0XHRvYmpfdXZzICA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXSxcclxuXHRcdG9ial91dnMyID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMSBdLFxyXG5cclxuXHRcdG9ial9jb2xvcnMgPSBnZW9tZXRyeS5jb2xvcnMsXHJcblxyXG5cdFx0b2JqX3NraW5JbmRpY2VzID0gZ2VvbWV0cnkuc2tpbkluZGljZXMsXHJcblx0XHRvYmpfc2tpbldlaWdodHMgPSBnZW9tZXRyeS5za2luV2VpZ2h0cyxcclxuXHJcblx0XHRtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHMsXHJcblx0XHRtb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHM7XHJcblxyXG5cdFx0aWYgKCBkaXJ0eVZlcnRpY2VzICkge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHR2MSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHR2MiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHR2MyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCBdICAgICA9IHYxLng7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEgXSA9IHYxLnk7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDIgXSA9IHYxLno7XHJcblxyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAzIF0gPSB2Mi54O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA0IF0gPSB2Mi55O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA1IF0gPSB2Mi56O1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNiBdID0gdjMueDtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgNyBdID0gdjMueTtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgOCBdID0gdjMuejtcclxuXHJcblx0XHRcdFx0b2Zmc2V0ICs9IDk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzNFsgZiBdIF07XHJcblxyXG5cdFx0XHRcdHYxID0gdmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdHYyID0gdmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdHYzID0gdmVydGljZXNbIGZhY2UuYyBdO1xyXG5cdFx0XHRcdHY0ID0gdmVydGljZXNbIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0IF0gICAgID0gdjEueDtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMSBdID0gdjEueTtcclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgMiBdID0gdjEuejtcclxuXHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDMgXSA9IHYyLng7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDQgXSA9IHYyLnk7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDUgXSA9IHYyLno7XHJcblxyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA2IF0gPSB2My54O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA3IF0gPSB2My55O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyA4IF0gPSB2My56O1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhBcnJheVsgb2Zmc2V0ICsgOSBdICA9IHY0Lng7XHJcblx0XHRcdFx0dmVydGV4QXJyYXlbIG9mZnNldCArIDEwIF0gPSB2NC55O1xyXG5cdFx0XHRcdHZlcnRleEFycmF5WyBvZmZzZXQgKyAxMSBdID0gdjQuejtcclxuXHJcblx0XHRcdFx0b2Zmc2V0ICs9IDEyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdmVydGV4QXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eU1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdGZvciAoIHZrID0gMCwgdmtsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgdmsgPCB2a2w7IHZrICsrICkge1xyXG5cclxuXHRcdFx0XHRvZmZzZXRfbW9ycGhUYXJnZXQgPSAwO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0Y2hmID0gY2h1bmtfZmFjZXMzWyBmIF07XHJcblx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaGYgXTtcclxuXHJcblx0XHRcdFx0XHQvLyBtb3JwaCBwb3NpdGlvbnNcclxuXHJcblx0XHRcdFx0XHR2MSA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdFx0XHR2MiA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0XHR2MyA9IG1vcnBoVGFyZ2V0c1sgdmsgXS52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdFx0dmthID0gbW9ycGhUYXJnZXRzQXJyYXlzWyB2ayBdO1xyXG5cclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0IF0gXHQgID0gdjEueDtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMSBdID0gdjEueTtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMiBdID0gdjEuejtcclxuXHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDMgXSA9IHYyLng7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDQgXSA9IHYyLnk7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDUgXSA9IHYyLno7XHJcblxyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA2IF0gPSB2My54O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA3IF0gPSB2My55O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA4IF0gPSB2My56O1xyXG5cclxuXHRcdFx0XHRcdC8vIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggbmVlZHNTbW9vdGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IG1vcnBoTm9ybWFsc1sgdmsgXS52ZXJ0ZXhOb3JtYWxzWyBjaGYgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0bjEgPSBmYWNlVmVydGV4Tm9ybWFscy5hO1xyXG5cdFx0XHRcdFx0XHRcdG4yID0gZmFjZVZlcnRleE5vcm1hbHMuYjtcclxuXHRcdFx0XHRcdFx0XHRuMyA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmM7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRuMSA9IG1vcnBoTm9ybWFsc1sgdmsgXS5mYWNlTm9ybWFsc1sgY2hmIF07XHJcblx0XHRcdFx0XHRcdFx0bjIgPSBuMTtcclxuXHRcdFx0XHRcdFx0XHRuMyA9IG4xO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0bmthID0gbW9ycGhOb3JtYWxzQXJyYXlzWyB2ayBdO1xyXG5cclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgXSBcdCAgPSBuMS54O1xyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDEgXSA9IG4xLnk7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMiBdID0gbjEuejtcclxuXHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMyBdID0gbjIueDtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA0IF0gPSBuMi55O1xyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDUgXSA9IG4yLno7XHJcblxyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDYgXSA9IG4zLng7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNyBdID0gbjMueTtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA4IF0gPSBuMy56O1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvL1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldF9tb3JwaFRhcmdldCArPSA5O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRjaGYgPSBjaHVua19mYWNlczRbIGYgXTtcclxuXHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNoZiBdO1xyXG5cclxuXHRcdFx0XHRcdC8vIG1vcnBoIHBvc2l0aW9uc1xyXG5cclxuXHRcdFx0XHRcdHYxID0gbW9ycGhUYXJnZXRzWyB2ayBdLnZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdHYyID0gbW9ycGhUYXJnZXRzWyB2ayBdLnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdHYzID0gbW9ycGhUYXJnZXRzWyB2ayBdLnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRcdHY0ID0gbW9ycGhUYXJnZXRzWyB2ayBdLnZlcnRpY2VzWyBmYWNlLmQgXTtcclxuXHJcblx0XHRcdFx0XHR2a2EgPSBtb3JwaFRhcmdldHNBcnJheXNbIHZrIF07XHJcblxyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgXSBcdCAgPSB2MS54O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAxIF0gPSB2MS55O1xyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAyIF0gPSB2MS56O1xyXG5cclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMyBdID0gdjIueDtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNCBdID0gdjIueTtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNSBdID0gdjIuejtcclxuXHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDYgXSA9IHYzLng7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDcgXSA9IHYzLnk7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDggXSA9IHYzLno7XHJcblxyXG5cdFx0XHRcdFx0dmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA5IF0gID0gdjQueDtcclxuXHRcdFx0XHRcdHZrYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMTAgXSA9IHY0Lnk7XHJcblx0XHRcdFx0XHR2a2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDExIF0gPSB2NC56O1xyXG5cclxuXHRcdFx0XHRcdC8vIG1vcnBoIG5vcm1hbHNcclxuXHJcblx0XHRcdFx0XHRpZiAoIG1hdGVyaWFsLm1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGlmICggbmVlZHNTbW9vdGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IG1vcnBoTm9ybWFsc1sgdmsgXS52ZXJ0ZXhOb3JtYWxzWyBjaGYgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0bjEgPSBmYWNlVmVydGV4Tm9ybWFscy5hO1xyXG5cdFx0XHRcdFx0XHRcdG4yID0gZmFjZVZlcnRleE5vcm1hbHMuYjtcclxuXHRcdFx0XHRcdFx0XHRuMyA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmM7XHJcblx0XHRcdFx0XHRcdFx0bjQgPSBmYWNlVmVydGV4Tm9ybWFscy5kO1xyXG5cclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0bjEgPSBtb3JwaE5vcm1hbHNbIHZrIF0uZmFjZU5vcm1hbHNbIGNoZiBdO1xyXG5cdFx0XHRcdFx0XHRcdG4yID0gbjE7XHJcblx0XHRcdFx0XHRcdFx0bjMgPSBuMTtcclxuXHRcdFx0XHRcdFx0XHRuNCA9IG4xO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0bmthID0gbW9ycGhOb3JtYWxzQXJyYXlzWyB2ayBdO1xyXG5cclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgXSBcdCAgPSBuMS54O1xyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDEgXSA9IG4xLnk7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMiBdID0gbjEuejtcclxuXHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgMyBdID0gbjIueDtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA0IF0gPSBuMi55O1xyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDUgXSA9IG4yLno7XHJcblxyXG5cdFx0XHRcdFx0XHRua2FbIG9mZnNldF9tb3JwaFRhcmdldCArIDYgXSA9IG4zLng7XHJcblx0XHRcdFx0XHRcdG5rYVsgb2Zmc2V0X21vcnBoVGFyZ2V0ICsgNyBdID0gbjMueTtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA4IF0gPSBuMy56O1xyXG5cclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyA5IF0gID0gbjQueDtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAxMCBdID0gbjQueTtcclxuXHRcdFx0XHRcdFx0bmthWyBvZmZzZXRfbW9ycGhUYXJnZXQgKyAxMSBdID0gbjQuejtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly9cclxuXHJcblx0XHRcdFx0XHRvZmZzZXRfbW9ycGhUYXJnZXQgKz0gMTI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbE1vcnBoVGFyZ2V0c0J1ZmZlcnNbIHZrIF0gKTtcclxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgbW9ycGhUYXJnZXRzQXJyYXlzWyB2ayBdLCBoaW50ICk7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzWyB2ayBdICk7XHJcblx0XHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgbW9ycGhOb3JtYWxzQXJyYXlzWyB2ayBdLCBoaW50ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmpfc2tpbldlaWdodHMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcclxuXHJcblx0XHRcdFx0Ly8gd2VpZ2h0c1xyXG5cclxuXHRcdFx0XHRzdzEgPSBvYmpfc2tpbldlaWdodHNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdHN3MiA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5iIF07XHJcblx0XHRcdFx0c3czID0gb2JqX3NraW5XZWlnaHRzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHN3MS54O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxIF0gPSBzdzEueTtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMiBdID0gc3cxLno7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IHN3MS53O1xyXG5cclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNCBdID0gc3cyLng7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDUgXSA9IHN3Mi55O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA2IF0gPSBzdzIuejtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNyBdID0gc3cyLnc7XHJcblxyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA4IF0gID0gc3czLng7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDkgXSAgPSBzdzMueTtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTAgXSA9IHN3My56O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxMSBdID0gc3czLnc7XHJcblxyXG5cdFx0XHRcdC8vIGluZGljZXNcclxuXHJcblx0XHRcdFx0c2kxID0gb2JqX3NraW5JbmRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRzaTIgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdHNpMyA9IG9ial9za2luSW5kaWNlc1sgZmFjZS5jIF07XHJcblxyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiBdICAgICA9IHNpMS54O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDEgXSA9IHNpMS55O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDIgXSA9IHNpMS56O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDMgXSA9IHNpMS53O1xyXG5cclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA0IF0gPSBzaTIueDtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA1IF0gPSBzaTIueTtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA2IF0gPSBzaTIuejtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA3IF0gPSBzaTIudztcclxuXHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgOCBdICA9IHNpMy54O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDkgXSAgPSBzaTMueTtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxMCBdID0gc2kzLno7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMTEgXSA9IHNpMy53O1xyXG5cclxuXHRcdFx0XHRvZmZzZXRfc2tpbiArPSAxMjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXM0WyBmIF0gXTtcclxuXHJcblx0XHRcdFx0Ly8gd2VpZ2h0c1xyXG5cclxuXHRcdFx0XHRzdzEgPSBvYmpfc2tpbldlaWdodHNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdHN3MiA9IG9ial9za2luV2VpZ2h0c1sgZmFjZS5iIF07XHJcblx0XHRcdFx0c3czID0gb2JqX3NraW5XZWlnaHRzWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRzdzQgPSBvYmpfc2tpbldlaWdodHNbIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luIF0gICAgID0gc3cxLng7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDEgXSA9IHN3MS55O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAyIF0gPSBzdzEuejtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMyBdID0gc3cxLnc7XHJcblxyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA0IF0gPSBzdzIueDtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgNSBdID0gc3cyLnk7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDYgXSA9IHN3Mi56O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyA3IF0gPSBzdzIudztcclxuXHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDggXSAgPSBzdzMueDtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgOSBdICA9IHN3My55O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxMCBdID0gc3czLno7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDExIF0gPSBzdzMudztcclxuXHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDEyIF0gPSBzdzQueDtcclxuXHRcdFx0XHRza2luV2VpZ2h0QXJyYXlbIG9mZnNldF9za2luICsgMTMgXSA9IHN3NC55O1xyXG5cdFx0XHRcdHNraW5XZWlnaHRBcnJheVsgb2Zmc2V0X3NraW4gKyAxNCBdID0gc3c0Lno7XHJcblx0XHRcdFx0c2tpbldlaWdodEFycmF5WyBvZmZzZXRfc2tpbiArIDE1IF0gPSBzdzQudztcclxuXHJcblx0XHRcdFx0Ly8gaW5kaWNlc1xyXG5cclxuXHRcdFx0XHRzaTEgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdHNpMiA9IG9ial9za2luSW5kaWNlc1sgZmFjZS5iIF07XHJcblx0XHRcdFx0c2kzID0gb2JqX3NraW5JbmRpY2VzWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRzaTQgPSBvYmpfc2tpbkluZGljZXNbIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gXSAgICAgPSBzaTEueDtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxIF0gPSBzaTEueTtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAyIF0gPSBzaTEuejtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAzIF0gPSBzaTEudztcclxuXHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNCBdID0gc2kyLng7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNSBdID0gc2kyLnk7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNiBdID0gc2kyLno7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgNyBdID0gc2kyLnc7XHJcblxyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDggXSAgPSBzaTMueDtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyA5IF0gID0gc2kzLnk7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMTAgXSA9IHNpMy56O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDExIF0gPSBzaTMudztcclxuXHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMTIgXSA9IHNpNC54O1xyXG5cdFx0XHRcdHNraW5JbmRleEFycmF5WyBvZmZzZXRfc2tpbiArIDEzIF0gPSBzaTQueTtcclxuXHRcdFx0XHRza2luSW5kZXhBcnJheVsgb2Zmc2V0X3NraW4gKyAxNCBdID0gc2k0Lno7XHJcblx0XHRcdFx0c2tpbkluZGV4QXJyYXlbIG9mZnNldF9za2luICsgMTUgXSA9IHNpNC53O1xyXG5cclxuXHRcdFx0XHRvZmZzZXRfc2tpbiArPSAxNjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2Zmc2V0X3NraW4gPiAwICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsU2tpbkluZGljZXNCdWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgc2tpbkluZGV4QXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyICk7XHJcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHNraW5XZWlnaHRBcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5Q29sb3JzICYmIHZlcnRleENvbG9yVHlwZSApIHtcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XHJcblxyXG5cdFx0XHRcdHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cdFx0XHRcdGZhY2VDb2xvciA9IGZhY2UuY29sb3I7XHJcblxyXG5cdFx0XHRcdGlmICggdmVydGV4Q29sb3JzLmxlbmd0aCA9PT0gMyAmJiB2ZXJ0ZXhDb2xvclR5cGUgPT09IFRIUkVFLlZlcnRleENvbG9ycyApIHtcclxuXHJcblx0XHRcdFx0XHRjMSA9IHZlcnRleENvbG9yc1sgMCBdO1xyXG5cdFx0XHRcdFx0YzIgPSB2ZXJ0ZXhDb2xvcnNbIDEgXTtcclxuXHRcdFx0XHRcdGMzID0gdmVydGV4Q29sb3JzWyAyIF07XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0YzEgPSBmYWNlQ29sb3I7XHJcblx0XHRcdFx0XHRjMiA9IGZhY2VDb2xvcjtcclxuXHRcdFx0XHRcdGMzID0gZmFjZUNvbG9yO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciBdICAgICA9IGMxLnI7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgMSBdID0gYzEuZztcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAyIF0gPSBjMS5iO1xyXG5cclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAzIF0gPSBjMi5yO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDQgXSA9IGMyLmc7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNSBdID0gYzIuYjtcclxuXHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNiBdID0gYzMucjtcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA3IF0gPSBjMy5nO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDggXSA9IGMzLmI7XHJcblxyXG5cdFx0XHRcdG9mZnNldF9jb2xvciArPSA5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcclxuXHRcdFx0XHRmYWNlQ29sb3IgPSBmYWNlLmNvbG9yO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZlcnRleENvbG9ycy5sZW5ndGggPT09IDQgJiYgdmVydGV4Q29sb3JUeXBlID09PSBUSFJFRS5WZXJ0ZXhDb2xvcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0YzEgPSB2ZXJ0ZXhDb2xvcnNbIDAgXTtcclxuXHRcdFx0XHRcdGMyID0gdmVydGV4Q29sb3JzWyAxIF07XHJcblx0XHRcdFx0XHRjMyA9IHZlcnRleENvbG9yc1sgMiBdO1xyXG5cdFx0XHRcdFx0YzQgPSB2ZXJ0ZXhDb2xvcnNbIDMgXTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRjMSA9IGZhY2VDb2xvcjtcclxuXHRcdFx0XHRcdGMyID0gZmFjZUNvbG9yO1xyXG5cdFx0XHRcdFx0YzMgPSBmYWNlQ29sb3I7XHJcblx0XHRcdFx0XHRjNCA9IGZhY2VDb2xvcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgXSAgICAgPSBjMS5yO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDEgXSA9IGMxLmc7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgMiBdID0gYzEuYjtcclxuXHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgMyBdID0gYzIucjtcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA0IF0gPSBjMi5nO1xyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDUgXSA9IGMyLmI7XHJcblxyXG5cdFx0XHRcdGNvbG9yQXJyYXlbIG9mZnNldF9jb2xvciArIDYgXSA9IGMzLnI7XHJcblx0XHRcdFx0Y29sb3JBcnJheVsgb2Zmc2V0X2NvbG9yICsgNyBdID0gYzMuZztcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA4IF0gPSBjMy5iO1xyXG5cclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyA5IF0gID0gYzQucjtcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAxMCBdID0gYzQuZztcclxuXHRcdFx0XHRjb2xvckFycmF5WyBvZmZzZXRfY29sb3IgKyAxMSBdID0gYzQuYjtcclxuXHJcblx0XHRcdFx0b2Zmc2V0X2NvbG9yICs9IDEyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBvZmZzZXRfY29sb3IgPiAwICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY29sb3JBcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5VGFuZ2VudHMgJiYgZ2VvbWV0cnkuaGFzVGFuZ2VudHMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdXHRdO1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhUYW5nZW50cyA9IGZhY2UudmVydGV4VGFuZ2VudHM7XHJcblxyXG5cdFx0XHRcdHQxID0gdmVydGV4VGFuZ2VudHNbIDAgXTtcclxuXHRcdFx0XHR0MiA9IHZlcnRleFRhbmdlbnRzWyAxIF07XHJcblx0XHRcdFx0dDMgPSB2ZXJ0ZXhUYW5nZW50c1sgMiBdO1xyXG5cclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50IF0gICAgID0gdDEueDtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMSBdID0gdDEueTtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMiBdID0gdDEuejtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMyBdID0gdDEudztcclxuXHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDQgXSA9IHQyLng7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDUgXSA9IHQyLnk7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDYgXSA9IHQyLno7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDcgXSA9IHQyLnc7XHJcblxyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA4IF0gID0gdDMueDtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgOSBdICA9IHQzLnk7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEwIF0gPSB0My56O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxMSBdID0gdDMudztcclxuXHJcblx0XHRcdFx0b2Zmc2V0X3RhbmdlbnQgKz0gMTI7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzNFsgZiBdIF07XHJcblxyXG5cdFx0XHRcdHZlcnRleFRhbmdlbnRzID0gZmFjZS52ZXJ0ZXhUYW5nZW50cztcclxuXHJcblx0XHRcdFx0dDEgPSB2ZXJ0ZXhUYW5nZW50c1sgMCBdO1xyXG5cdFx0XHRcdHQyID0gdmVydGV4VGFuZ2VudHNbIDEgXTtcclxuXHRcdFx0XHR0MyA9IHZlcnRleFRhbmdlbnRzWyAyIF07XHJcblx0XHRcdFx0dDQgPSB2ZXJ0ZXhUYW5nZW50c1sgMyBdO1xyXG5cclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50IF0gICAgID0gdDEueDtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMSBdID0gdDEueTtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMiBdID0gdDEuejtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMyBdID0gdDEudztcclxuXHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDQgXSA9IHQyLng7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDUgXSA9IHQyLnk7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDYgXSA9IHQyLno7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDcgXSA9IHQyLnc7XHJcblxyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyA4IF0gID0gdDMueDtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgOSBdICA9IHQzLnk7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEwIF0gPSB0My56O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxMSBdID0gdDMudztcclxuXHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDEyIF0gPSB0NC54O1xyXG5cdFx0XHRcdHRhbmdlbnRBcnJheVsgb2Zmc2V0X3RhbmdlbnQgKyAxMyBdID0gdDQueTtcclxuXHRcdFx0XHR0YW5nZW50QXJyYXlbIG9mZnNldF90YW5nZW50ICsgMTQgXSA9IHQ0Lno7XHJcblx0XHRcdFx0dGFuZ2VudEFycmF5WyBvZmZzZXRfdGFuZ2VudCArIDE1IF0gPSB0NC53O1xyXG5cclxuXHRcdFx0XHRvZmZzZXRfdGFuZ2VudCArPSAxNjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xUYW5nZW50QnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB0YW5nZW50QXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eU5vcm1hbHMgJiYgbm9ybWFsVHlwZSApIHtcclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XHJcblxyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblx0XHRcdFx0ZmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICYmIG5lZWRzU21vb3RoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2biA9IHZlcnRleE5vcm1hbHNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsIF0gICAgID0gdm4ueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAxIF0gPSB2bi55O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCArIDIgXSA9IHZuLno7XHJcblxyXG5cdFx0XHRcdFx0XHRvZmZzZXRfbm9ybWFsICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsIF0gICAgID0gZmFjZU5vcm1hbC54O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCArIDEgXSA9IGZhY2VOb3JtYWwueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAyIF0gPSBmYWNlTm9ybWFsLno7XHJcblxyXG5cdFx0XHRcdFx0XHRvZmZzZXRfbm9ybWFsICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzNFsgZiBdIF07XHJcblxyXG5cdFx0XHRcdHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XHJcblx0XHRcdFx0ZmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsO1xyXG5cclxuXHRcdFx0XHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSA0ICYmIG5lZWRzU21vb3RoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2biA9IHZlcnRleE5vcm1hbHNbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsIF0gICAgID0gdm4ueDtcclxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAxIF0gPSB2bi55O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCArIDIgXSA9IHZuLno7XHJcblxyXG5cdFx0XHRcdFx0XHRvZmZzZXRfbm9ybWFsICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG5vcm1hbEFycmF5WyBvZmZzZXRfbm9ybWFsIF0gICAgID0gZmFjZU5vcm1hbC54O1xyXG5cdFx0XHRcdFx0XHRub3JtYWxBcnJheVsgb2Zmc2V0X25vcm1hbCArIDEgXSA9IGZhY2VOb3JtYWwueTtcclxuXHRcdFx0XHRcdFx0bm9ybWFsQXJyYXlbIG9mZnNldF9ub3JtYWwgKyAyIF0gPSBmYWNlTm9ybWFsLno7XHJcblxyXG5cdFx0XHRcdFx0XHRvZmZzZXRfbm9ybWFsICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBub3JtYWxBcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5VXZzICYmIG9ial91dnMgJiYgdXZUeXBlICkge1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRmaSA9IGNodW5rX2ZhY2VzM1sgZiBdO1xyXG5cclxuXHRcdFx0XHR1diA9IG9ial91dnNbIGZpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdXYgPT09IHVuZGVmaW5lZCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dXZpID0gdXZbIGkgXTtcclxuXHJcblx0XHRcdFx0XHR1dkFycmF5WyBvZmZzZXRfdXYgXSAgICAgPSB1dmkueDtcclxuXHRcdFx0XHRcdHV2QXJyYXlbIG9mZnNldF91diArIDEgXSA9IHV2aS55O1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldF91diArPSAyO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZpID0gY2h1bmtfZmFjZXM0WyBmIF07XHJcblxyXG5cdFx0XHRcdHV2ID0gb2JqX3V2c1sgZmkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCB1diA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgNDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR1dmkgPSB1dlsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdHV2QXJyYXlbIG9mZnNldF91diBdICAgICA9IHV2aS54O1xyXG5cdFx0XHRcdFx0dXZBcnJheVsgb2Zmc2V0X3V2ICsgMSBdID0gdXZpLnk7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0X3V2ICs9IDI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2Zmc2V0X3V2ID4gMCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWQnVmZmVyICk7XHJcblx0XHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIHV2QXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBkaXJ0eVV2cyAmJiBvYmpfdXZzMiAmJiB1dlR5cGUgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZpID0gY2h1bmtfZmFjZXMzWyBmIF07XHJcblxyXG5cdFx0XHRcdHV2MiA9IG9ial91dnMyWyBmaSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIHV2MiA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR1djJpID0gdXYyWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0dXYyQXJyYXlbIG9mZnNldF91djIgXSAgICAgPSB1djJpLng7XHJcblx0XHRcdFx0XHR1djJBcnJheVsgb2Zmc2V0X3V2MiArIDEgXSA9IHV2MmkueTtcclxuXHJcblx0XHRcdFx0XHRvZmZzZXRfdXYyICs9IDI7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0ZmkgPSBjaHVua19mYWNlczRbIGYgXTtcclxuXHJcblx0XHRcdFx0dXYyID0gb2JqX3V2czJbIGZpIF07XHJcblxyXG5cdFx0XHRcdGlmICggdXYyID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHV2MmkgPSB1djJbIGkgXTtcclxuXHJcblx0XHRcdFx0XHR1djJBcnJheVsgb2Zmc2V0X3V2MiBdICAgICA9IHV2MmkueDtcclxuXHRcdFx0XHRcdHV2MkFycmF5WyBvZmZzZXRfdXYyICsgMSBdID0gdXYyaS55O1xyXG5cclxuXHRcdFx0XHRcdG9mZnNldF91djIgKz0gMjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBvZmZzZXRfdXYyID4gMCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFVWMkJ1ZmZlciApO1xyXG5cdFx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB1djJBcnJheSwgaGludCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpcnR5RWxlbWVudHMgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgXSBcdCA9IHZlcnRleEluZGV4O1xyXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyAxIF0gPSB2ZXJ0ZXhJbmRleCArIDE7XHJcblx0XHRcdFx0ZmFjZUFycmF5WyBvZmZzZXRfZmFjZSArIDIgXSA9IHZlcnRleEluZGV4ICsgMjtcclxuXHJcblx0XHRcdFx0b2Zmc2V0X2ZhY2UgKz0gMztcclxuXHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSBdICAgICA9IHZlcnRleEluZGV4O1xyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyAxIF0gPSB2ZXJ0ZXhJbmRleCArIDE7XHJcblxyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyAyIF0gPSB2ZXJ0ZXhJbmRleDtcclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgMyBdID0gdmVydGV4SW5kZXggKyAyO1xyXG5cclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgNCBdID0gdmVydGV4SW5kZXggKyAxO1xyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyA1IF0gPSB2ZXJ0ZXhJbmRleCArIDI7XHJcblxyXG5cdFx0XHRcdG9mZnNldF9saW5lICs9IDY7XHJcblxyXG5cdFx0XHRcdHZlcnRleEluZGV4ICs9IDM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgXSAgICAgPSB2ZXJ0ZXhJbmRleDtcclxuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlICsgMSBdID0gdmVydGV4SW5kZXggKyAxO1xyXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyAyIF0gPSB2ZXJ0ZXhJbmRleCArIDM7XHJcblxyXG5cdFx0XHRcdGZhY2VBcnJheVsgb2Zmc2V0X2ZhY2UgKyAzIF0gPSB2ZXJ0ZXhJbmRleCArIDE7XHJcblx0XHRcdFx0ZmFjZUFycmF5WyBvZmZzZXRfZmFjZSArIDQgXSA9IHZlcnRleEluZGV4ICsgMjtcclxuXHRcdFx0XHRmYWNlQXJyYXlbIG9mZnNldF9mYWNlICsgNSBdID0gdmVydGV4SW5kZXggKyAzO1xyXG5cclxuXHRcdFx0XHRvZmZzZXRfZmFjZSArPSA2O1xyXG5cclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lIF0gICAgID0gdmVydGV4SW5kZXg7XHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDEgXSA9IHZlcnRleEluZGV4ICsgMTtcclxuXHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDIgXSA9IHZlcnRleEluZGV4O1xyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyAzIF0gPSB2ZXJ0ZXhJbmRleCArIDM7XHJcblxyXG5cdFx0XHRcdGxpbmVBcnJheVsgb2Zmc2V0X2xpbmUgKyA0IF0gPSB2ZXJ0ZXhJbmRleCArIDE7XHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDUgXSA9IHZlcnRleEluZGV4ICsgMjtcclxuXHJcblx0XHRcdFx0bGluZUFycmF5WyBvZmZzZXRfbGluZSArIDYgXSA9IHZlcnRleEluZGV4ICsgMjtcclxuXHRcdFx0XHRsaW5lQXJyYXlbIG9mZnNldF9saW5lICsgNyBdID0gdmVydGV4SW5kZXggKyAzO1xyXG5cclxuXHRcdFx0XHRvZmZzZXRfbGluZSArPSA4O1xyXG5cclxuXHRcdFx0XHR2ZXJ0ZXhJbmRleCArPSA0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlQXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbGluZUFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggY3VzdG9tQXR0cmlidXRlcyApIHtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGN1c3RvbUF0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZSA9IGN1c3RvbUF0dHJpYnV0ZXNbIGkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGN1c3RvbUF0dHJpYnV0ZS5fX29yaWdpbmFsLm5lZWRzVXBkYXRlICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdG9mZnNldF9jdXN0b20gPSAwO1xyXG5cdFx0XHRcdG9mZnNldF9jdXN0b21TcmMgPSAwO1xyXG5cclxuXHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5zaXplID09PSAxICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IHVuZGVmaW5lZCB8fCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJ2ZXJ0aWNlc1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczNbIGYgXVx0XTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmIgXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDM7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzNFsgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDQ7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwiZmFjZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzM1sgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAzO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXM0WyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDQ7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMiApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XHJcblx0XHRcdFx0XHRcdFx0djMgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjEueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MS55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2Mi54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYzLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjMueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA2O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRcdFx0XHR2NCA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5kIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2MS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHYxLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYyLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gdjIueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjMueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1IF0gPSB2My55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2IF0gPSB2NC54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgXSA9IHY0Lnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gODtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJmYWNlc1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2MS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHYxLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYyLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gdjIueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjMueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1IF0gPSB2My55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDY7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2NCA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjEueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MS55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2Mi54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyLnk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYzLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjMueTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiBdID0gdjQueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3IF0gPSB2NC55O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDg7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuc2l6ZSA9PT0gMyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgcHA7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUudHlwZSA9PT0gXCJjXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRwcCA9IFsgXCJyXCIsIFwiZ1wiLCBcImJcIiBdO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRwcCA9IFsgXCJ4XCIsIFwieVwiLCBcInpcIiBdO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSB1bmRlZmluZWQgfHwgY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwidmVydGljZXNcIiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzMy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0ZmFjZSA9IG9ial9mYWNlc1sgY2h1bmtfZmFjZXMzWyBmIF1cdF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XHJcblx0XHRcdFx0XHRcdFx0djMgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gXSBcdCAgID0gdjFbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxIF0gPSB2MVsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgXSA9IHYxWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgXSA9IHYyWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCBdID0gdjJbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1IF0gPSB2MlsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2IF0gPSB2M1sgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgXSA9IHYzWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCBdID0gdjNbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSA5O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXM0Lmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRmYWNlID0gb2JqX2ZhY2VzWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcclxuXHRcdFx0XHRcdFx0XHR2NCA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5kIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSBcdD0gdjFbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxICBdID0gdjFbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjFbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyAgXSA9IHYyWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2M1sgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgIF0gPSB2M1sgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggIF0gPSB2M1sgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA5ICBdID0gdjRbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMCBdID0gdjRbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjRbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAxMjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gXCJmYWNlc1wiICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggZiA9IDAsIGZsID0gY2h1bmtfZmFjZXMzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgY2h1bmtfZmFjZXMzWyBmIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0djEgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSBdIFx0ICAgPSB2MVsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgXSA9IHYxWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiBdID0gdjFbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyBdID0gdjJbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0IF0gPSB2MlsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgXSA9IHYyWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgXSA9IHYzWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyBdID0gdjNbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4IF0gPSB2M1sgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2NCA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gIF0gXHQ9IHYxWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiAgXSA9IHYxWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgIF0gPSB2MlsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgIF0gPSB2MlsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgIF0gPSB2MlsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjNbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjNbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjNbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHY0WyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTAgXSA9IHY0WyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHY0WyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMTI7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwiZmFjZVZlcnRpY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlWyAwIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZVsgMSBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWVbIDIgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tIF0gXHQgICA9IHYxWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSBdID0gdjFbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyIF0gPSB2MVsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzIF0gPSB2MlsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgXSA9IHYyWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSBdID0gdjJbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiBdID0gdjNbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3IF0gPSB2M1sgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggXSA9IHYzWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gOTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGYgPSAwLCBmbCA9IGNodW5rX2ZhY2VzNC5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGNodW5rX2ZhY2VzNFsgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxID0gdmFsdWVbIDAgXTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IHZhbHVlWyAxIF07XHJcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZVsgMiBdO1xyXG5cdFx0XHRcdFx0XHRcdHY0ID0gdmFsdWVbIDMgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICBdIFx0PSB2MVsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MVsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MVsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjJbIHBwWyAwIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjJbIHBwWyAxIF0gXTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1ICBdID0gdjJbIHBwWyAyIF0gXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiAgXSA9IHYzWyBwcFsgMCBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyAgXSA9IHYzWyBwcFsgMSBdIF07XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzWyBwcFsgMiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDkgIF0gPSB2NFsgcHBbIDAgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2NFsgcHBbIDEgXSBdO1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDExIF0gPSB2NFsgcHBbIDIgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDEyO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLnNpemUgPT09IDQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBjdXN0b21BdHRyaWJ1dGUuYm91bmRUbyA9PT0gdW5kZWZpbmVkIHx8IGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcInZlcnRpY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzM1sgZiBdXHRdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5hIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICBdIFx0PSB2MS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MS55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgIF0gPSB2MS53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1ICBdID0gdjIueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjIuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTAgXSA9IHYzLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHYzLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMTI7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGZhY2UgPSBvYmpfZmFjZXNbIGNodW5rX2ZhY2VzNFsgZiBdIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdHYxID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmEgXTtcclxuXHRcdFx0XHRcdFx0XHR2MiA9IGN1c3RvbUF0dHJpYnV0ZS52YWx1ZVsgZmFjZS5iIF07XHJcblx0XHRcdFx0XHRcdFx0djMgPSBjdXN0b21BdHRyaWJ1dGUudmFsdWVbIGZhY2UuYyBdO1xyXG5cdFx0XHRcdFx0XHRcdHY0ID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBmYWNlLmQgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICBdIFx0PSB2MS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MS55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgIF0gPSB2MS53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1ICBdID0gdjIueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjIuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTAgXSA9IHYzLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHYzLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEyIF0gPSB2NC54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEzIF0gPSB2NC55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDE0IF0gPSB2NC56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDE1IF0gPSB2NC53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRvZmZzZXRfY3VzdG9tICs9IDE2O1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIGN1c3RvbUF0dHJpYnV0ZS5ib3VuZFRvID09PSBcImZhY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICBdIFx0PSB2MS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MS55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgIF0gPSB2MS53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1ICBdID0gdjIueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjIuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTAgXSA9IHYzLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHYzLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMTI7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlO1xyXG5cdFx0XHRcdFx0XHRcdHYyID0gdmFsdWU7XHJcblx0XHRcdFx0XHRcdFx0djMgPSB2YWx1ZTtcclxuXHRcdFx0XHRcdFx0XHR2NCA9IHZhbHVlO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gIF0gXHQ9IHYxLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMSAgXSA9IHYxLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMiAgXSA9IHYxLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMyAgXSA9IHYxLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDQgIF0gPSB2Mi54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDUgIF0gPSB2Mi55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDYgIF0gPSB2Mi56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDcgIF0gPSB2Mi53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA4ICBdID0gdjMueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA5ICBdID0gdjMueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMCBdID0gdjMuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMSBdID0gdjMudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTIgXSA9IHY0Lng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTMgXSA9IHY0Lnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTQgXSA9IHY0Lno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTUgXSA9IHY0Lnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMTY7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIGlmICggY3VzdG9tQXR0cmlidXRlLmJvdW5kVG8gPT09IFwiZmFjZVZlcnRpY2VzXCIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczNbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlWyAwIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZVsgMSBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWVbIDIgXTtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICBdIFx0PSB2MS54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEgIF0gPSB2MS55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDIgIF0gPSB2MS56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDMgIF0gPSB2MS53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA0ICBdID0gdjIueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA1ICBdID0gdjIueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA2ICBdID0gdjIuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyA3ICBdID0gdjIudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOCAgXSA9IHYzLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgOSAgXSA9IHYzLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTAgXSA9IHYzLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgMTEgXSA9IHYzLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdG9mZnNldF9jdXN0b20gKz0gMTI7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCBmID0gMCwgZmwgPSBjaHVua19mYWNlczQubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gY3VzdG9tQXR0cmlidXRlLnZhbHVlWyBjaHVua19mYWNlczRbIGYgXSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2MSA9IHZhbHVlWyAwIF07XHJcblx0XHRcdFx0XHRcdFx0djIgPSB2YWx1ZVsgMSBdO1xyXG5cdFx0XHRcdFx0XHRcdHYzID0gdmFsdWVbIDIgXTtcclxuXHRcdFx0XHRcdFx0XHR2NCA9IHZhbHVlWyAzIF07XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSAgXSBcdD0gdjEueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxICBdID0gdjEueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAyICBdID0gdjEuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAzICBdID0gdjEudztcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNCAgXSA9IHYyLng7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNSAgXSA9IHYyLnk7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNiAgXSA9IHYyLno7XHJcblx0XHRcdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlLmFycmF5WyBvZmZzZXRfY3VzdG9tICsgNyAgXSA9IHYyLnc7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDggIF0gPSB2My54O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDkgIF0gPSB2My55O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDEwIF0gPSB2My56O1xyXG5cdFx0XHRcdFx0XHRcdGN1c3RvbUF0dHJpYnV0ZS5hcnJheVsgb2Zmc2V0X2N1c3RvbSArIDExIF0gPSB2My53O1xyXG5cclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMiBdID0gdjQueDtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxMyBdID0gdjQueTtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxNCBdID0gdjQuejtcclxuXHRcdFx0XHRcdFx0XHRjdXN0b21BdHRyaWJ1dGUuYXJyYXlbIG9mZnNldF9jdXN0b20gKyAxNSBdID0gdjQudztcclxuXHJcblx0XHRcdFx0XHRcdFx0b2Zmc2V0X2N1c3RvbSArPSAxNjtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGN1c3RvbUF0dHJpYnV0ZS5idWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgY3VzdG9tQXR0cmlidXRlLmFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZGlzcG9zZSApIHtcclxuXHJcblx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3VwLl9faW5pdHRlZEFycmF5cztcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19jb2xvckFycmF5O1xyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX25vcm1hbEFycmF5O1xyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3RhbmdlbnRBcnJheTtcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX191dkFycmF5O1xyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX3V2MkFycmF5O1xyXG5cdFx0XHRkZWxldGUgZ2VvbWV0cnlHcm91cC5fX2ZhY2VBcnJheTtcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX192ZXJ0ZXhBcnJheTtcclxuXHRcdFx0ZGVsZXRlIGdlb21ldHJ5R3JvdXAuX19saW5lQXJyYXk7XHJcblx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3VwLl9fc2tpbkluZGV4QXJyYXk7XHJcblx0XHRcdGRlbGV0ZSBnZW9tZXRyeUdyb3VwLl9fc2tpbldlaWdodEFycmF5O1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0RGlyZWN0QnVmZmVycyAoIGdlb21ldHJ5LCBoaW50LCBkaXNwb3NlICkge1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcclxuXHJcblx0XHR2YXIgaW5kZXggPSBhdHRyaWJ1dGVzWyBcImluZGV4XCIgXTtcclxuXHRcdHZhciBwb3NpdGlvbiA9IGF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdO1xyXG5cdFx0dmFyIG5vcm1hbCA9IGF0dHJpYnV0ZXNbIFwibm9ybWFsXCIgXTtcclxuXHRcdHZhciB1diA9IGF0dHJpYnV0ZXNbIFwidXZcIiBdO1xyXG5cdFx0dmFyIGNvbG9yID0gYXR0cmlidXRlc1sgXCJjb2xvclwiIF07XHJcblx0XHR2YXIgdGFuZ2VudCA9IGF0dHJpYnV0ZXNbIFwidGFuZ2VudFwiIF07XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgJiYgaW5kZXggIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4LmJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRleC5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSAmJiBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uLmJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb24uYXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSAmJiBub3JtYWwgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBub3JtYWwuYnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBub3JtYWwuYXJyYXksIGhpbnQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBnZW9tZXRyeS51dnNOZWVkVXBkYXRlICYmIHV2ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgdXYuYnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCB1di5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgJiYgY29sb3IgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBjb2xvci5idWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yLmFycmF5LCBoaW50ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlICYmIHRhbmdlbnQgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCB0YW5nZW50LmJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgdGFuZ2VudC5hcnJheSwgaGludCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIGRpc3Bvc2UgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSBpbiBnZW9tZXRyeS5hdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0XHRkZWxldGUgZ2VvbWV0cnkuYXR0cmlidXRlc1sgaSBdLmFycmF5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQnVmZmVyIHJlbmRlcmluZ1xyXG5cclxuXHR0aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSA9IGZ1bmN0aW9uICggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgISBvYmplY3QuX193ZWJnbFZlcnRleEJ1ZmZlciApIG9iamVjdC5fX3dlYmdsVmVydGV4QnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0aWYgKCBvYmplY3QuaGFzTm9ybWFscyAmJiAhIG9iamVjdC5fX3dlYmdsTm9ybWFsQnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xOb3JtYWxCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRpZiAoIG9iamVjdC5oYXNVdnMgJiYgISBvYmplY3QuX193ZWJnbFV2QnVmZmVyICkgb2JqZWN0Ll9fd2ViZ2xVdkJ1ZmZlciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcclxuXHRcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiAhIG9iamVjdC5fX3dlYmdsQ29sb3JCdWZmZXIgKSBvYmplY3QuX193ZWJnbENvbG9yQnVmZmVyID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc1Bvc2l0aW9ucyApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnBvc2l0aW9uQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcclxuXHRcdFx0X2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBwcm9ncmFtLmF0dHJpYnV0ZXMucG9zaXRpb24gKTtcclxuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW0uYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIG9iamVjdC5oYXNOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5fX3dlYmdsTm9ybWFsQnVmZmVyICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNoYWRpbmcgPT09IFRIUkVFLkZsYXRTaGFkaW5nICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbngsIG55LCBueixcclxuXHRcdFx0XHRcdG5heCwgbmJ4LCBuY3gsIG5heSwgbmJ5LCBuY3ksIG5heiwgbmJ6LCBuY3osXHJcblx0XHRcdFx0XHRub3JtYWxBcnJheSxcclxuXHRcdFx0XHRcdGksIGlsID0gb2JqZWN0LmNvdW50ICogMztcclxuXHJcblx0XHRcdFx0Zm9yKCBpID0gMDsgaSA8IGlsOyBpICs9IDkgKSB7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXkgPSBvYmplY3Qubm9ybWFsQXJyYXk7XHJcblxyXG5cdFx0XHRcdFx0bmF4ICA9IG5vcm1hbEFycmF5WyBpIF07XHJcblx0XHRcdFx0XHRuYXkgID0gbm9ybWFsQXJyYXlbIGkgKyAxIF07XHJcblx0XHRcdFx0XHRuYXogID0gbm9ybWFsQXJyYXlbIGkgKyAyIF07XHJcblxyXG5cdFx0XHRcdFx0bmJ4ICA9IG5vcm1hbEFycmF5WyBpICsgMyBdO1xyXG5cdFx0XHRcdFx0bmJ5ICA9IG5vcm1hbEFycmF5WyBpICsgNCBdO1xyXG5cdFx0XHRcdFx0bmJ6ICA9IG5vcm1hbEFycmF5WyBpICsgNSBdO1xyXG5cclxuXHRcdFx0XHRcdG5jeCAgPSBub3JtYWxBcnJheVsgaSArIDYgXTtcclxuXHRcdFx0XHRcdG5jeSAgPSBub3JtYWxBcnJheVsgaSArIDcgXTtcclxuXHRcdFx0XHRcdG5jeiAgPSBub3JtYWxBcnJheVsgaSArIDggXTtcclxuXHJcblx0XHRcdFx0XHRueCA9ICggbmF4ICsgbmJ4ICsgbmN4ICkgLyAzO1xyXG5cdFx0XHRcdFx0bnkgPSAoIG5heSArIG5ieSArIG5jeSApIC8gMztcclxuXHRcdFx0XHRcdG56ID0gKCBuYXogKyBuYnogKyBuY3ogKSAvIDM7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgXSBcdCA9IG54O1xyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyAxIF0gPSBueTtcclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgMiBdID0gbno7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyAzIF0gPSBueDtcclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgNCBdID0gbnk7XHJcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDUgXSA9IG56O1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbEFycmF5WyBpICsgNiBdID0gbng7XHJcblx0XHRcdFx0XHRub3JtYWxBcnJheVsgaSArIDcgXSA9IG55O1xyXG5cdFx0XHRcdFx0bm9ybWFsQXJyYXlbIGkgKyA4IF0gPSBuejtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5ub3JtYWxBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cdFx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIHByb2dyYW0uYXR0cmlidXRlcy5ub3JtYWwgKTtcclxuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW0uYXR0cmlidXRlcy5ub3JtYWwsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QuaGFzVXZzICYmIG1hdGVyaWFsLm1hcCApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QuX193ZWJnbFV2QnVmZmVyICk7XHJcblx0XHRcdF9nbC5idWZmZXJEYXRhKCBfZ2wuQVJSQVlfQlVGRkVSLCBvYmplY3QudXZBcnJheSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cdFx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIHByb2dyYW0uYXR0cmlidXRlcy51diApO1xyXG5cdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbS5hdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IFRIUkVFLk5vQ29sb3JzICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5fX3dlYmdsQ29sb3JCdWZmZXIgKTtcclxuXHRcdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblx0XHRcdF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggcHJvZ3JhbS5hdHRyaWJ1dGVzLmNvbG9yICk7XHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtLmF0dHJpYnV0ZXMuY29sb3IsIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5UUklBTkdMRVMsIDAsIG9iamVjdC5jb3VudCApO1xyXG5cclxuXHRcdG9iamVjdC5jb3VudCA9IDA7XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVyQnVmZmVyRGlyZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgZ2VvbWV0cnksIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciBwcm9ncmFtLCBhdHRyaWJ1dGVzLCBsaW5ld2lkdGgsIHByaW1pdGl2ZXMsIGEsIGF0dHJpYnV0ZTtcclxuXHJcblx0XHRwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuXHRcdGF0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0dmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZSxcclxuXHRcdFx0d2lyZWZyYW1lQml0ID0gbWF0ZXJpYWwud2lyZWZyYW1lID8gMSA6IDAsXHJcblx0XHRcdGdlb21ldHJ5SGFzaCA9ICggZ2VvbWV0cnkuaWQgKiAweGZmZmZmZiApICsgKCBwcm9ncmFtLmlkICogMiApICsgd2lyZWZyYW1lQml0O1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnlIYXNoICE9PSBfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoICkge1xyXG5cclxuXHRcdFx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IGdlb21ldHJ5SGFzaDtcclxuXHRcdFx0dXBkYXRlQnVmZmVycyA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcclxuXHJcblx0XHRcdGRpc2FibGVBdHRyaWJ1dGVzKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlbmRlciBtZXNoXHJcblxyXG5cdFx0aWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJpbmRleFwiIF07XHJcblxyXG5cdFx0XHQvLyBpbmRleGVkIHRyaWFuZ2xlc1xyXG5cclxuXHRcdFx0aWYgKCBpbmRleCApIHtcclxuXHJcblx0XHRcdFx0dmFyIG9mZnNldHMgPSBnZW9tZXRyeS5vZmZzZXRzO1xyXG5cclxuXHRcdFx0XHQvLyBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gMSBjaHVua1xyXG5cdFx0XHRcdC8vIG11c3Qgc2V0IGF0dHJpYnV0ZSBwb2ludGVycyB0byB1c2UgbmV3IG9mZnNldHMgZm9yIGVhY2ggY2h1bmtcclxuXHRcdFx0XHQvLyBldmVuIGlmIGdlb21ldHJ5IGFuZCBtYXRlcmlhbHMgZGlkbid0IGNoYW5nZVxyXG5cclxuXHRcdFx0XHRpZiAoIG9mZnNldHMubGVuZ3RoID4gMSApIHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gb2Zmc2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc3RhcnRJbmRleCA9IG9mZnNldHNbIGkgXS5pbmRleDtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHQvLyB2ZXJ0aWNlc1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF07XHJcblx0XHRcdFx0XHRcdHZhciBwb3NpdGlvblNpemUgPSBwb3NpdGlvbi5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbi5idWZmZXIgKTtcclxuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCBwb3NpdGlvblNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIHN0YXJ0SW5kZXggKiBwb3NpdGlvblNpemUgKiA0ICk7IC8vIDQgYnl0ZXMgcGVyIEZsb2F0MzJcclxuXHJcblx0XHRcdFx0XHRcdC8vIG5vcm1hbHNcclxuXHJcblx0XHRcdFx0XHRcdHZhciBub3JtYWwgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID49IDAgJiYgbm9ybWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgbm9ybWFsU2l6ZSA9IG5vcm1hbC5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIG5vcm1hbC5idWZmZXIgKTtcclxuXHRcdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMubm9ybWFsICk7XHJcblx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMubm9ybWFsLCBub3JtYWxTaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCBzdGFydEluZGV4ICogbm9ybWFsU2l6ZSAqIDQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIHV2c1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIHV2ID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJ1dlwiIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYgPj0gMCAmJiB1diApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHV2U2l6ZSA9IHV2Lml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgdXYuYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnV2ICk7XHJcblx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIHV2U2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgc3RhcnRJbmRleCAqIHV2U2l6ZSAqIDQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIGNvbG9yc1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGNvbG9yID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJjb2xvclwiIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuY29sb3IgPj0gMCAmJiBjb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIGNvbG9yU2l6ZSA9IGNvbG9yLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY29sb3IuYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmNvbG9yICk7XHJcblx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIGNvbG9yU2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgc3RhcnRJbmRleCAqIGNvbG9yU2l6ZSAqIDQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIHRhbmdlbnRzXHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdGFuZ2VudCA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwidGFuZ2VudFwiIF07XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMudGFuZ2VudCA+PSAwICYmIHRhbmdlbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciB0YW5nZW50U2l6ZSA9IHRhbmdlbnQuaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCB0YW5nZW50LmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy50YW5nZW50ICk7XHJcblx0XHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudGFuZ2VudCwgdGFuZ2VudFNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIHN0YXJ0SW5kZXggKiB0YW5nZW50U2l6ZSAqIDQgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdC8vIGluZGljZXNcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGluZGV4LmJ1ZmZlciApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyByZW5kZXIgaW5kZXhlZCB0cmlhbmdsZXNcclxuXHJcblx0XHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuVFJJQU5HTEVTLCBvZmZzZXRzWyBpIF0uY291bnQsIF9nbC5VTlNJR05FRF9TSE9SVCwgb2Zmc2V0c1sgaSBdLnN0YXJ0ICogMiApOyAvLyAyIGJ5dGVzIHBlciBVaW50MTZcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcclxuXHRcdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IG9mZnNldHNbIGkgXS5jb3VudDsgLy8gbm90IHJlYWxseSB0cnVlLCBoZXJlIHZlcnRpY2VzIGNhbiBiZSBzaGFyZWRcclxuXHRcdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmZhY2VzICs9IG9mZnNldHNbIGkgXS5jb3VudCAvIDM7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG5vbi1pbmRleGVkIHRyaWFuZ2xlc1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIHZlcnRpY2VzXHJcblxyXG5cdFx0XHRcdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF07XHJcblx0XHRcdFx0XHR2YXIgcG9zaXRpb25TaXplID0gcG9zaXRpb24uaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgcG9zaXRpb25TaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0Ly8gbm9ybWFsc1xyXG5cclxuXHRcdFx0XHRcdHZhciBub3JtYWwgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBcIm5vcm1hbFwiIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA+PSAwICYmIG5vcm1hbCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHZhciBub3JtYWxTaXplID0gbm9ybWFsLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIG5vcm1hbC5idWZmZXIgKTtcclxuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLm5vcm1hbCApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5ub3JtYWwsIG5vcm1hbFNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gdXZzXHJcblxyXG5cdFx0XHRcdFx0dmFyIHV2ID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJ1dlwiIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLnV2ID49IDAgJiYgdXYgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdXZTaXplID0gdXYuaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgdXYuYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgdXZTaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdC8vIGNvbG9yc1xyXG5cclxuXHRcdFx0XHRcdHZhciBjb2xvciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwiY29sb3JcIiBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlcy5jb2xvciA+PSAwICYmIGNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGNvbG9yU2l6ZSA9IGNvbG9yLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcclxuXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMuY29sb3IsIGNvbG9yU2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHQvLyB0YW5nZW50c1xyXG5cclxuXHRcdFx0XHRcdHZhciB0YW5nZW50ID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJ0YW5nZW50XCIgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMudGFuZ2VudCA+PSAwICYmIHRhbmdlbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdGFuZ2VudFNpemUgPSB0YW5nZW50Lml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIHRhbmdlbnQuYnVmZmVyICk7XHJcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy50YW5nZW50ICk7XHJcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnRhbmdlbnQsIHRhbmdlbnRTaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBub24taW5kZXhlZCB0cmlhbmdsZXNcclxuXHJcblx0XHRcdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5UUklBTkdMRVMsIDAsIHBvc2l0aW9uLm51bUl0ZW1zIC8gMyApO1xyXG5cclxuXHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5jYWxscyArKztcclxuXHRcdFx0XHRfdGhpcy5pbmZvLnJlbmRlci52ZXJ0aWNlcyArPSBwb3NpdGlvbi5udW1JdGVtcyAvIDM7XHJcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gcG9zaXRpb24ubnVtSXRlbXMgLyAzIC8gMztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHQvLyByZW5kZXIgcGFydGljbGVzXHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gKSB7XHJcblxyXG5cdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHZlcnRpY2VzXHJcblxyXG5cdFx0XHRcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwicG9zaXRpb25cIiBdO1xyXG5cdFx0XHRcdHZhciBwb3NpdGlvblNpemUgPSBwb3NpdGlvbi5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uLmJ1ZmZlciApO1xyXG5cdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xyXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCBwb3NpdGlvblNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0Ly8gY29sb3JzXHJcblxyXG5cdFx0XHRcdHZhciBjb2xvciA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIFwiY29sb3JcIiBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuY29sb3IgPj0gMCAmJiBjb2xvciApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgY29sb3JTaXplID0gY29sb3IuaXRlbVNpemU7XHJcblxyXG5cdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGNvbG9yLmJ1ZmZlciApO1xyXG5cdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmNvbG9yICk7XHJcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5jb2xvciwgY29sb3JTaXplLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Ly8gcmVuZGVyIHBhcnRpY2xlc1xyXG5cclxuXHRcdFx0XHRfZ2wuZHJhd0FycmF5cyggX2dsLlBPSU5UUywgMCwgcG9zaXRpb24ubnVtSXRlbXMgLyAzICk7XHJcblxyXG5cdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnBvaW50cyArPSBwb3NpdGlvbi5udW1JdGVtcyAvIDM7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGluZSApIHtcclxuXHJcblx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIHtcclxuXHJcblx0XHRcdFx0Ly8gdmVydGljZXNcclxuXHJcblx0XHRcdFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJwb3NpdGlvblwiIF07XHJcblx0XHRcdFx0dmFyIHBvc2l0aW9uU2l6ZSA9IHBvc2l0aW9uLml0ZW1TaXplO1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgcG9zaXRpb24uYnVmZmVyICk7XHJcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIHBvc2l0aW9uU2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHQvLyBjb2xvcnNcclxuXHJcblx0XHRcdFx0dmFyIGNvbG9yID0gZ2VvbWV0cnkuYXR0cmlidXRlc1sgXCJjb2xvclwiIF07XHJcblxyXG5cdFx0XHRcdGlmICggYXR0cmlidXRlcy5jb2xvciA+PSAwICYmIGNvbG9yICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBjb2xvclNpemUgPSBjb2xvci5pdGVtU2l6ZTtcclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgY29sb3IuYnVmZmVyICk7XHJcblx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMuY29sb3IgKTtcclxuXHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmNvbG9yLCBjb2xvclNpemUsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyByZW5kZXIgbGluZXNcclxuXHJcblx0XHRcdFx0c2V0TGluZVdpZHRoKCBtYXRlcmlhbC5saW5ld2lkdGggKTtcclxuXHJcblx0XHRcdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5MSU5FX1NUUklQLCAwLCBwb3NpdGlvbi5udW1JdGVtcyAvIDMgKTtcclxuXHJcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XHJcblx0XHRcdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzICs9IHBvc2l0aW9uLm51bUl0ZW1zO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuICAgIH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZW5kZXJCdWZmZXIgPSBmdW5jdGlvbiAoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcclxuXHJcblx0XHR2YXIgcHJvZ3JhbSwgYXR0cmlidXRlcywgbGluZXdpZHRoLCBwcmltaXRpdmVzLCBhLCBhdHRyaWJ1dGUsIGksIGlsO1xyXG5cclxuXHRcdHByb2dyYW0gPSBzZXRQcm9ncmFtKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XHJcblxyXG5cdFx0YXR0cmlidXRlcyA9IHByb2dyYW0uYXR0cmlidXRlcztcclxuXHJcblx0XHR2YXIgdXBkYXRlQnVmZmVycyA9IGZhbHNlLFxyXG5cdFx0XHR3aXJlZnJhbWVCaXQgPSBtYXRlcmlhbC53aXJlZnJhbWUgPyAxIDogMCxcclxuXHRcdFx0Z2VvbWV0cnlHcm91cEhhc2ggPSAoIGdlb21ldHJ5R3JvdXAuaWQgKiAweGZmZmZmZiApICsgKCBwcm9ncmFtLmlkICogMiApICsgd2lyZWZyYW1lQml0O1xyXG5cclxuXHRcdGlmICggZ2VvbWV0cnlHcm91cEhhc2ggIT09IF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggKSB7XHJcblxyXG5cdFx0XHRfY3VycmVudEdlb21ldHJ5R3JvdXBIYXNoID0gZ2VvbWV0cnlHcm91cEhhc2g7XHJcblx0XHRcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRkaXNhYmxlQXR0cmlidXRlcygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB2ZXJ0aWNlc1xyXG5cclxuXHRcdGlmICggIW1hdGVyaWFsLm1vcnBoVGFyZ2V0cyAmJiBhdHRyaWJ1dGVzLnBvc2l0aW9uID49IDAgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC5tb3JwaFRhcmdldEJhc2UgKSB7XHJcblxyXG5cdFx0XHRcdHNldHVwTW9ycGhUYXJnZXRzKCBtYXRlcmlhbCwgZ2VvbWV0cnlHcm91cCwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHJcblx0XHRpZiAoIHVwZGF0ZUJ1ZmZlcnMgKSB7XHJcblxyXG5cdFx0XHQvLyBjdXN0b20gYXR0cmlidXRlc1xyXG5cclxuXHRcdFx0Ly8gVXNlIHRoZSBwZXItZ2VvbWV0cnlHcm91cCBjdXN0b20gYXR0cmlidXRlIGFycmF5cyB3aGljaCBhcmUgc2V0dXAgaW4gaW5pdE1lc2hCdWZmZXJzXHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5R3JvdXAuX193ZWJnbEN1c3RvbUF0dHJpYnV0ZXNMaXN0ICkge1xyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRhdHRyaWJ1dGUgPSBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDdXN0b21BdHRyaWJ1dGVzTGlzdFsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggYXR0cmlidXRlc1sgYXR0cmlidXRlLmJ1ZmZlci5iZWxvbmdzVG9BdHRyaWJ1dGUgXSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGF0dHJpYnV0ZS5idWZmZXIgKTtcclxuXHRcdFx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzWyBhdHRyaWJ1dGUuYnVmZmVyLmJlbG9uZ3NUb0F0dHJpYnV0ZSBdICk7XHJcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzWyBhdHRyaWJ1dGUuYnVmZmVyLmJlbG9uZ3NUb0F0dHJpYnV0ZSBdLCBhdHRyaWJ1dGUuc2l6ZSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIGNvbG9yc1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmNvbG9yID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xDb2xvckJ1ZmZlciApO1xyXG5cdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5jb2xvciApO1xyXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmNvbG9yLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBub3JtYWxzXHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMubm9ybWFsID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xOb3JtYWxCdWZmZXIgKTtcclxuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMubm9ybWFsICk7XHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMubm9ybWFsLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB0YW5nZW50c1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLnRhbmdlbnQgPj0gMCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFRhbmdlbnRCdWZmZXIgKTtcclxuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudGFuZ2VudCApO1xyXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnRhbmdlbnQsIDQsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHV2c1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLnV2ID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVkJ1ZmZlciApO1xyXG5cdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xyXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGF0dHJpYnV0ZXMudXYyID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xVVjJCdWZmZXIgKTtcclxuXHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMudXYyICk7XHJcblx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYyLCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnNraW5uaW5nICYmXHJcblx0XHRcdFx0IGF0dHJpYnV0ZXMuc2tpbkluZGV4ID49IDAgJiYgYXR0cmlidXRlcy5za2luV2VpZ2h0ID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xTa2luSW5kaWNlc0J1ZmZlciApO1xyXG5cdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5za2luSW5kZXggKTtcclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5za2luSW5kZXgsIDQsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFNraW5XZWlnaHRzQnVmZmVyICk7XHJcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnNraW5XZWlnaHQgKTtcclxuXHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5za2luV2VpZ2h0LCA0LCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBsaW5lIGRpc3RhbmNlc1xyXG5cclxuXHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTGluZURpc3RhbmNlQnVmZmVyICk7XHJcblx0XHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZSApO1xyXG5cdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLmxpbmVEaXN0YW5jZSwgMSwgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZW5kZXIgbWVzaFxyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdC8vIHdpcmVmcmFtZVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC53aXJlZnJhbWUgKSB7XHJcblxyXG5cdFx0XHRcdHNldExpbmVXaWR0aCggbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoICk7XHJcblxyXG5cdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVCdWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuTElORVMsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVDb3VudCwgX2dsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cdFx0XHQvLyB0cmlhbmdsZXNcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGlmICggdXBkYXRlQnVmZmVycyApIF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VCdWZmZXIgKTtcclxuXHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuVFJJQU5HTEVTLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xGYWNlQ291bnQsIF9nbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLnZlcnRpY2VzICs9IGdlb21ldHJ5R3JvdXAuX193ZWJnbEZhY2VDb3VudDtcclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsRmFjZUNvdW50IC8gMztcclxuXHJcblx0XHQvLyByZW5kZXIgbGluZXNcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuXHRcdFx0cHJpbWl0aXZlcyA9ICggb2JqZWN0LnR5cGUgPT09IFRIUkVFLkxpbmVTdHJpcCApID8gX2dsLkxJTkVfU1RSSVAgOiBfZ2wuTElORVM7XHJcblxyXG5cdFx0XHRzZXRMaW5lV2lkdGgoIG1hdGVyaWFsLmxpbmV3aWR0aCApO1xyXG5cclxuXHRcdFx0X2dsLmRyYXdBcnJheXMoIHByaW1pdGl2ZXMsIDAsIGdlb21ldHJ5R3JvdXAuX193ZWJnbExpbmVDb3VudCApO1xyXG5cclxuXHRcdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgKys7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIHBhcnRpY2xlc1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkge1xyXG5cclxuXHRcdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5QT0lOVFMsIDAsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFBhcnRpY2xlQ291bnQgKTtcclxuXHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xyXG5cdFx0XHRfdGhpcy5pbmZvLnJlbmRlci5wb2ludHMgKz0gZ2VvbWV0cnlHcm91cC5fX3dlYmdsUGFydGljbGVDb3VudDtcclxuXHJcblx0XHQvLyByZW5kZXIgcmliYm9uXHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUmliYm9uICkge1xyXG5cclxuXHRcdFx0X2dsLmRyYXdBcnJheXMoIF9nbC5UUklBTkdMRV9TVFJJUCwgMCwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsVmVydGV4Q291bnQgKTtcclxuXHJcblx0XHRcdF90aGlzLmluZm8ucmVuZGVyLmNhbGxzICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XHJcblxyXG5cdFx0aWYgKCAhIF9lbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gKSB7XHJcblxyXG5cdFx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZSApO1xyXG5cdFx0XHRfZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGRpc2FibGVBdHRyaWJ1dGVzKCkge1xyXG5cclxuXHRcdGZvciAoIHZhciBhdHRyaWJ1dGUgaW4gX2VuYWJsZWRBdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0aWYgKCBfZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcclxuXHRcdFx0XHRfZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXR1cE1vcnBoVGFyZ2V0cyAoIG1hdGVyaWFsLCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Ly8gc2V0IGJhc2VcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlcyA9IG1hdGVyaWFsLnByb2dyYW0uYXR0cmlidXRlcztcclxuXHJcblx0XHRpZiAoIG9iamVjdC5tb3JwaFRhcmdldEJhc2UgIT09IC0xICYmIGF0dHJpYnV0ZXMucG9zaXRpb24gPj0gMCApIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyBvYmplY3QubW9ycGhUYXJnZXRCYXNlIF0gKTtcclxuXHRcdFx0ZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnBvc2l0aW9uICk7XHJcblx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggYXR0cmlidXRlcy5wb3NpdGlvbiA+PSAwICkge1xyXG5cclxuXHRcdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGdlb21ldHJ5R3JvdXAuX193ZWJnbFZlcnRleEJ1ZmZlciApO1xyXG5cdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcclxuXHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMucG9zaXRpb24sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBvYmplY3QubW9ycGhUYXJnZXRGb3JjZWRPcmRlci5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHQvLyBzZXQgZm9yY2VkIG9yZGVyXHJcblxyXG5cdFx0XHR2YXIgbSA9IDA7XHJcblx0XHRcdHZhciBvcmRlciA9IG9iamVjdC5tb3JwaFRhcmdldEZvcmNlZE9yZGVyO1xyXG5cdFx0XHR2YXIgaW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XHJcblxyXG5cdFx0XHR3aGlsZSAoIG0gPCBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgJiYgbSA8IG9yZGVyLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyBcIm1vcnBoVGFyZ2V0XCIgKyBtIF0gPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhUYXJnZXRzQnVmZmVyc1sgb3JkZXJbIG0gXSBdICk7XHJcblx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIFwibW9ycGhUYXJnZXRcIiArIG0gXSApO1xyXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIFwibW9ycGhUYXJnZXRcIiArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggYXR0cmlidXRlc1sgXCJtb3JwaE5vcm1hbFwiICsgbSBdID49IDAgJiYgbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaE5vcm1hbHNCdWZmZXJzWyBvcmRlclsgbSBdIF0gKTtcclxuXHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgXCJtb3JwaE5vcm1hbFwiICsgbSBdICk7XHJcblx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgXCJtb3JwaE5vcm1hbFwiICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0b2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXNbIG0gXSA9IGluZmx1ZW5jZXNbIG9yZGVyWyBtIF0gXTtcclxuXHJcblx0XHRcdFx0bSArKztcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHQvLyBmaW5kIHRoZSBtb3N0IGluZmx1ZW5jaW5nXHJcblxyXG5cdFx0XHR2YXIgaW5mbHVlbmNlLCBhY3RpdmVJbmZsdWVuY2VJbmRpY2VzID0gW107XHJcblx0XHRcdHZhciBpbmZsdWVuY2VzID0gb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcztcclxuXHRcdFx0dmFyIGksIGlsID0gaW5mbHVlbmNlcy5sZW5ndGg7XHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRpbmZsdWVuY2UgPSBpbmZsdWVuY2VzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggaW5mbHVlbmNlID4gMCApIHtcclxuXHJcblx0XHRcdFx0XHRhY3RpdmVJbmZsdWVuY2VJbmRpY2VzLnB1c2goIFsgaW5mbHVlbmNlLCBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBhY3RpdmVJbmZsdWVuY2VJbmRpY2VzLmxlbmd0aCA+IG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoVGFyZ2V0cyApIHtcclxuXHJcblx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5zb3J0KCBudW1lcmljYWxTb3J0ICk7XHJcblx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5sZW5ndGggPSBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHM7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBhY3RpdmVJbmZsdWVuY2VJbmRpY2VzLmxlbmd0aCA+IG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyApIHtcclxuXHJcblx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5zb3J0KCBudW1lcmljYWxTb3J0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBhY3RpdmVJbmZsdWVuY2VJbmRpY2VzLmxlbmd0aCA9PT0gMCApIHtcclxuXHJcblx0XHRcdFx0YWN0aXZlSW5mbHVlbmNlSW5kaWNlcy5wdXNoKCBbIDAsIDAgXSApO1xyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdHZhciBpbmZsdWVuY2VJbmRleCwgbSA9IDA7XHJcblxyXG5cdFx0XHR3aGlsZSAoIG0gPCBtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggYWN0aXZlSW5mbHVlbmNlSW5kaWNlc1sgbSBdICkge1xyXG5cclxuXHRcdFx0XHRcdGluZmx1ZW5jZUluZGV4ID0gYWN0aXZlSW5mbHVlbmNlSW5kaWNlc1sgbSBdWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyBcIm1vcnBoVGFyZ2V0XCIgKyBtIF0gPj0gMCApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBnZW9tZXRyeUdyb3VwLl9fd2ViZ2xNb3JwaFRhcmdldHNCdWZmZXJzWyBpbmZsdWVuY2VJbmRleCBdICk7XHJcblx0XHRcdFx0XHRcdGVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlc1sgXCJtb3JwaFRhcmdldFwiICsgbSBdICk7XHJcblx0XHRcdFx0XHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzWyBcIm1vcnBoVGFyZ2V0XCIgKyBtIF0sIDMsIF9nbC5GTE9BVCwgZmFsc2UsIDAsIDAgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyBcIm1vcnBoTm9ybWFsXCIgKyBtIF0gPj0gMCAmJiBtYXRlcmlhbC5tb3JwaE5vcm1hbHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgZ2VvbWV0cnlHcm91cC5fX3dlYmdsTW9ycGhOb3JtYWxzQnVmZmVyc1sgaW5mbHVlbmNlSW5kZXggXSApO1xyXG5cdFx0XHRcdFx0XHRlbmFibGVBdHRyaWJ1dGUoIGF0dHJpYnV0ZXNbIFwibW9ycGhOb3JtYWxcIiArIG0gXSApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlc1sgXCJtb3JwaE5vcm1hbFwiICsgbSBdLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XHJcblxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgbSBdID0gaW5mbHVlbmNlc1sgaW5mbHVlbmNlSW5kZXggXTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHQvKlxyXG5cdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIFwibW9ycGhUYXJnZXRcIiArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXNbIFwibW9ycGhOb3JtYWxcIiArIG0gXSwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdCovXHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0Ll9fd2ViZ2xNb3JwaFRhcmdldEluZmx1ZW5jZXNbIG0gXSA9IDA7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bSArKztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gbG9hZCB1cGRhdGVkIGluZmx1ZW5jZXMgdW5pZm9ybVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwucHJvZ3JhbS51bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybTFmdiggbWF0ZXJpYWwucHJvZ3JhbS51bmlmb3Jtcy5tb3JwaFRhcmdldEluZmx1ZW5jZXMsIG9iamVjdC5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBTb3J0aW5nXHJcblxyXG5cdGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcclxuXHJcblx0XHRpZiAoIGEueiAhPT0gYi56ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIGIuaWQgLSBhLmlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gbnVtZXJpY2FsU29ydCAoIGEsIGIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIGJbIDAgXSAtIGFbIDAgXTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdC8vIFJlbmRlcmluZ1xyXG5cclxuXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSwgcmVuZGVyVGFyZ2V0LCBmb3JjZUNsZWFyICkge1xyXG5cclxuXHRcdGlmICggY2FtZXJhIGluc3RhbmNlb2YgVEhSRUUuQ2FtZXJhID09PSBmYWxzZSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlbmRlcjogY2FtZXJhIGlzIG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5DYW1lcmEuJyApO1xyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBpLCBpbCxcclxuXHJcblx0XHR3ZWJnbE9iamVjdCwgb2JqZWN0LFxyXG5cdFx0cmVuZGVyTGlzdCxcclxuXHJcblx0XHRsaWdodHMgPSBzY2VuZS5fX2xpZ2h0cyxcclxuXHRcdGZvZyA9IHNjZW5lLmZvZztcclxuXHJcblx0XHQvLyByZXNldCBjYWNoaW5nIGZvciB0aGlzIGZyYW1lXHJcblxyXG5cdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XHJcblx0XHRfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXHJcblxyXG5cdFx0aWYgKCB0aGlzLmF1dG9VcGRhdGVTY2VuZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxyXG5cclxuXHRcdGlmICggY2FtZXJhLnBhcmVudCA9PT0gdW5kZWZpbmVkICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0Y2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHJcblx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cdFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgV2ViR0wgb2JqZWN0c1xyXG5cclxuXHRcdGlmICggdGhpcy5hdXRvVXBkYXRlT2JqZWN0cyApIHRoaXMuaW5pdFdlYkdMT2JqZWN0cyggc2NlbmUgKTtcclxuXHJcblx0XHQvLyBjdXN0b20gcmVuZGVyIHBsdWdpbnMgKHByZSBwYXNzKVxyXG5cclxuXHRcdHJlbmRlclBsdWdpbnMoIHRoaXMucmVuZGVyUGx1Z2luc1ByZSwgc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHRcdC8vXHJcblxyXG5cdFx0X3RoaXMuaW5mby5yZW5kZXIuY2FsbHMgPSAwO1xyXG5cdFx0X3RoaXMuaW5mby5yZW5kZXIudmVydGljZXMgPSAwO1xyXG5cdFx0X3RoaXMuaW5mby5yZW5kZXIuZmFjZXMgPSAwO1xyXG5cdFx0X3RoaXMuaW5mby5yZW5kZXIucG9pbnRzID0gMDtcclxuXHJcblx0XHR0aGlzLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0aWYgKCB0aGlzLmF1dG9DbGVhciB8fCBmb3JjZUNsZWFyICkge1xyXG5cclxuXHRcdFx0dGhpcy5jbGVhciggdGhpcy5hdXRvQ2xlYXJDb2xvciwgdGhpcy5hdXRvQ2xlYXJEZXB0aCwgdGhpcy5hdXRvQ2xlYXJTdGVuY2lsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNldCBtYXRyaWNlcyBmb3IgcmVndWxhciBvYmplY3RzIChmcnVzdHVtIGN1bGxlZClcclxuXHJcblx0XHRyZW5kZXJMaXN0ID0gc2NlbmUuX193ZWJnbE9iamVjdHM7XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xyXG5cdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XHJcblxyXG5cdFx0XHR3ZWJnbE9iamVjdC5yZW5kZXIgPSBmYWxzZTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggISAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggfHwgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gKSB8fCAhICggb2JqZWN0LmZydXN0dW1DdWxsZWQgKSB8fCBfZnJ1c3R1bS5pbnRlcnNlY3RzT2JqZWN0KCBvYmplY3QgKSApIHtcclxuXHJcblx0XHRcdFx0XHRzZXR1cE1hdHJpY2VzKCBvYmplY3QsIGNhbWVyYSApO1xyXG5cclxuXHRcdFx0XHRcdHVucm9sbEJ1ZmZlck1hdGVyaWFsKCB3ZWJnbE9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdHdlYmdsT2JqZWN0LnJlbmRlciA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCBvYmplY3QucmVuZGVyRGVwdGggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHdlYmdsT2JqZWN0LnogPSBvYmplY3QucmVuZGVyRGVwdGg7XHJcblxyXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRfdmVjdG9yMy5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdFx0XHRcdF92ZWN0b3IzLmFwcGx5UHJvamVjdGlvbiggX3Byb2pTY3JlZW5NYXRyaXggKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0d2ViZ2xPYmplY3QueiA9IF92ZWN0b3IzLno7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHR3ZWJnbE9iamVjdC5pZCA9IG9iamVjdC5pZDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0aGlzLnNvcnRPYmplY3RzICkge1xyXG5cclxuXHRcdFx0cmVuZGVyTGlzdC5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZXQgbWF0cmljZXMgZm9yIGltbWVkaWF0ZSBvYmplY3RzXHJcblxyXG5cdFx0cmVuZGVyTGlzdCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGkgXTtcclxuXHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QudmlzaWJsZSApIHtcclxuXHJcblx0XHRcdFx0c2V0dXBNYXRyaWNlcyggb2JqZWN0LCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdFx0dW5yb2xsSW1tZWRpYXRlQnVmZmVyTWF0ZXJpYWwoIHdlYmdsT2JqZWN0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggc2NlbmUub3ZlcnJpZGVNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWw7XHJcblxyXG5cdFx0XHR0aGlzLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0ICk7XHJcblx0XHRcdHRoaXMuc2V0RGVwdGhUZXN0KCBtYXRlcmlhbC5kZXB0aFRlc3QgKTtcclxuXHRcdFx0dGhpcy5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XHJcblx0XHRcdHNldFBvbHlnb25PZmZzZXQoIG1hdGVyaWFsLnBvbHlnb25PZmZzZXQsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IsIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRVbml0cyApO1xyXG5cclxuXHRcdFx0cmVuZGVyT2JqZWN0cyggc2NlbmUuX193ZWJnbE9iamVjdHMsIGZhbHNlLCBcIlwiLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCB0cnVlLCBtYXRlcmlhbCApO1xyXG5cdFx0XHRyZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSwgXCJcIiwgY2FtZXJhLCBsaWdodHMsIGZvZywgZmFsc2UsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciBtYXRlcmlhbCA9IG51bGw7XHJcblxyXG5cdFx0XHQvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcclxuXHJcblx0XHRcdHRoaXMuc2V0QmxlbmRpbmcoIFRIUkVFLk5vQmxlbmRpbmcgKTtcclxuXHJcblx0XHRcdHJlbmRlck9iamVjdHMoIHNjZW5lLl9fd2ViZ2xPYmplY3RzLCB0cnVlLCBcIm9wYXF1ZVwiLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBmYWxzZSwgbWF0ZXJpYWwgKTtcclxuXHRcdFx0cmVuZGVyT2JqZWN0c0ltbWVkaWF0ZSggc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsIFwib3BhcXVlXCIsIGNhbWVyYSwgbGlnaHRzLCBmb2csIGZhbHNlLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0Ly8gdHJhbnNwYXJlbnQgcGFzcyAoYmFjay10by1mcm9udCBvcmRlcilcclxuXHJcblx0XHRcdHJlbmRlck9iamVjdHMoIHNjZW5lLl9fd2ViZ2xPYmplY3RzLCBmYWxzZSwgXCJ0cmFuc3BhcmVudFwiLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCB0cnVlLCBtYXRlcmlhbCApO1xyXG5cdFx0XHRyZW5kZXJPYmplY3RzSW1tZWRpYXRlKCBzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSwgXCJ0cmFuc3BhcmVudFwiLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCB0cnVlLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBjdXN0b20gcmVuZGVyIHBsdWdpbnMgKHBvc3QgcGFzcylcclxuXHJcblx0XHRyZW5kZXJQbHVnaW5zKCB0aGlzLnJlbmRlclBsdWdpbnNQb3N0LCBzY2VuZSwgY2FtZXJhICk7XHJcblxyXG5cclxuXHRcdC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgJiYgcmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyAmJiByZW5kZXJUYXJnZXQubWluRmlsdGVyICE9PSBUSFJFRS5OZWFyZXN0RmlsdGVyICYmIHJlbmRlclRhcmdldC5taW5GaWx0ZXIgIT09IFRIUkVFLkxpbmVhckZpbHRlciApIHtcclxuXHJcblx0XHRcdHVwZGF0ZVJlbmRlclRhcmdldE1pcG1hcCggcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEVuc3VyZSBkZXB0aCBidWZmZXIgd3JpdGluZyBpcyBlbmFibGVkIHNvIGl0IGNhbiBiZSBjbGVhcmVkIG9uIG5leHQgcmVuZGVyXHJcblxyXG5cdFx0dGhpcy5zZXREZXB0aFRlc3QoIHRydWUgKTtcclxuXHRcdHRoaXMuc2V0RGVwdGhXcml0ZSggdHJ1ZSApO1xyXG5cclxuXHRcdC8vIF9nbC5maW5pc2goKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVuZGVyUGx1Z2lucyggcGx1Z2lucywgc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHRpZiAoICEgcGx1Z2lucy5sZW5ndGggKSByZXR1cm47XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBsdWdpbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHQvLyByZXNldCBzdGF0ZSBmb3IgcGx1Z2luICh0byBzdGFydCBmcm9tIGNsZWFuIHNsYXRlKVxyXG5cclxuXHRcdFx0X2N1cnJlbnRQcm9ncmFtID0gbnVsbDtcclxuXHRcdFx0X2N1cnJlbnRDYW1lcmEgPSBudWxsO1xyXG5cclxuXHRcdFx0X29sZEJsZW5kaW5nID0gLTE7XHJcblx0XHRcdF9vbGREZXB0aFRlc3QgPSAtMTtcclxuXHRcdFx0X29sZERlcHRoV3JpdGUgPSAtMTtcclxuXHRcdFx0X29sZERvdWJsZVNpZGVkID0gLTE7XHJcblx0XHRcdF9vbGRGbGlwU2lkZWQgPSAtMTtcclxuXHRcdFx0X2N1cnJlbnRHZW9tZXRyeUdyb3VwSGFzaCA9IC0xO1xyXG5cdFx0XHRfY3VycmVudE1hdGVyaWFsSWQgPSAtMTtcclxuXHJcblx0XHRcdF9saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdHBsdWdpbnNbIGkgXS5yZW5kZXIoIHNjZW5lLCBjYW1lcmEsIF9jdXJyZW50V2lkdGgsIF9jdXJyZW50SGVpZ2h0ICk7XHJcblxyXG5cdFx0XHQvLyByZXNldCBzdGF0ZSBhZnRlciBwbHVnaW4gKGFueXRoaW5nIGNvdWxkIGhhdmUgY2hhbmdlZClcclxuXHJcblx0XHRcdF9jdXJyZW50UHJvZ3JhbSA9IG51bGw7XHJcblx0XHRcdF9jdXJyZW50Q2FtZXJhID0gbnVsbDtcclxuXHJcblx0XHRcdF9vbGRCbGVuZGluZyA9IC0xO1xyXG5cdFx0XHRfb2xkRGVwdGhUZXN0ID0gLTE7XHJcblx0XHRcdF9vbGREZXB0aFdyaXRlID0gLTE7XHJcblx0XHRcdF9vbGREb3VibGVTaWRlZCA9IC0xO1xyXG5cdFx0XHRfb2xkRmxpcFNpZGVkID0gLTE7XHJcblx0XHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtMTtcclxuXHRcdFx0X2N1cnJlbnRNYXRlcmlhbElkID0gLTE7XHJcblxyXG5cdFx0XHRfbGlnaHRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZW5kZXJPYmplY3RzICggcmVuZGVyTGlzdCwgcmV2ZXJzZSwgbWF0ZXJpYWxUeXBlLCBjYW1lcmEsIGxpZ2h0cywgZm9nLCB1c2VCbGVuZGluZywgb3ZlcnJpZGVNYXRlcmlhbCApIHtcclxuXHJcblx0XHR2YXIgd2ViZ2xPYmplY3QsIG9iamVjdCwgYnVmZmVyLCBtYXRlcmlhbCwgc3RhcnQsIGVuZCwgZGVsdGE7XHJcblxyXG5cdFx0aWYgKCByZXZlcnNlICkge1xyXG5cclxuXHRcdFx0c3RhcnQgPSByZW5kZXJMaXN0Lmxlbmd0aCAtIDE7XHJcblx0XHRcdGVuZCA9IC0xO1xyXG5cdFx0XHRkZWx0YSA9IC0xO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRzdGFydCA9IDA7XHJcblx0XHRcdGVuZCA9IHJlbmRlckxpc3QubGVuZ3RoO1xyXG5cdFx0XHRkZWx0YSA9IDE7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSBzdGFydDsgaSAhPT0gZW5kOyBpICs9IGRlbHRhICkge1xyXG5cclxuXHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIHdlYmdsT2JqZWN0LnJlbmRlciApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cdFx0XHRcdGJ1ZmZlciA9IHdlYmdsT2JqZWN0LmJ1ZmZlcjtcclxuXHJcblx0XHRcdFx0aWYgKCBvdmVycmlkZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbCA9IHdlYmdsT2JqZWN0WyBtYXRlcmlhbFR5cGUgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoICEgbWF0ZXJpYWwgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHVzZUJsZW5kaW5nICkgX3RoaXMuc2V0QmxlbmRpbmcoIG1hdGVyaWFsLmJsZW5kaW5nLCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uLCBtYXRlcmlhbC5ibGVuZFNyYywgbWF0ZXJpYWwuYmxlbmREc3QgKTtcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xyXG5cdFx0XHRcdFx0X3RoaXMuc2V0RGVwdGhXcml0ZSggbWF0ZXJpYWwuZGVwdGhXcml0ZSApO1xyXG5cdFx0XHRcdFx0c2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X3RoaXMuc2V0TWF0ZXJpYWxGYWNlcyggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBidWZmZXIgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBidWZmZXIsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF90aGlzLnJlbmRlckJ1ZmZlciggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlbmRlck9iamVjdHNJbW1lZGlhdGUgKCByZW5kZXJMaXN0LCBtYXRlcmlhbFR5cGUsIGNhbWVyYSwgbGlnaHRzLCBmb2csIHVzZUJsZW5kaW5nLCBvdmVycmlkZU1hdGVyaWFsICkge1xyXG5cclxuXHRcdHZhciB3ZWJnbE9iamVjdCwgb2JqZWN0LCBtYXRlcmlhbCwgcHJvZ3JhbTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaSBdO1xyXG5cdFx0XHRvYmplY3QgPSB3ZWJnbE9iamVjdC5vYmplY3Q7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG92ZXJyaWRlTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBvdmVycmlkZU1hdGVyaWFsO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsID0gd2ViZ2xPYmplY3RbIG1hdGVyaWFsVHlwZSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggISBtYXRlcmlhbCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdXNlQmxlbmRpbmcgKSBfdGhpcy5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xyXG5cclxuXHRcdFx0XHRcdF90aGlzLnNldERlcHRoVGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XHJcblx0XHRcdFx0XHRfdGhpcy5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XHJcblx0XHRcdFx0XHRzZXRQb2x5Z29uT2Zmc2V0KCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0LCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0RmFjdG9yLCBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfdGhpcy5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMucmVuZGVySW1tZWRpYXRlT2JqZWN0ID0gZnVuY3Rpb24gKCBjYW1lcmEsIGxpZ2h0cywgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBsaWdodHMsIGZvZywgbWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuXHRcdF9jdXJyZW50R2VvbWV0cnlHcm91cEhhc2ggPSAtMTtcclxuXHJcblx0XHRfdGhpcy5zZXRNYXRlcmlhbEZhY2VzKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdGlmICggb2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0b2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrKCBwcm9ncmFtLCBfZ2wsIF9mcnVzdHVtICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdG9iamVjdC5yZW5kZXIoIGZ1bmN0aW9uKCBvYmplY3QgKSB7IF90aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApOyB9ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiB1bnJvbGxJbW1lZGlhdGVCdWZmZXJNYXRlcmlhbCAoIGdsb2JqZWN0ICkge1xyXG5cclxuXHRcdHZhciBvYmplY3QgPSBnbG9iamVjdC5vYmplY3QsXHJcblx0XHRcdG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XHJcblxyXG5cdFx0XHRnbG9iamVjdC50cmFuc3BhcmVudCA9IG1hdGVyaWFsO1xyXG5cdFx0XHRnbG9iamVjdC5vcGFxdWUgPSBudWxsO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRnbG9iamVjdC5vcGFxdWUgPSBtYXRlcmlhbDtcclxuXHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gdW5yb2xsQnVmZmVyTWF0ZXJpYWwgKCBnbG9iamVjdCApIHtcclxuXHJcblx0XHR2YXIgb2JqZWN0ID0gZ2xvYmplY3Qub2JqZWN0LFxyXG5cdFx0XHRidWZmZXIgPSBnbG9iamVjdC5idWZmZXIsXHJcblx0XHRcdG1hdGVyaWFsLCBtYXRlcmlhbEluZGV4LCBtZXNoTWF0ZXJpYWw7XHJcblxyXG5cdFx0bWVzaE1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggbWVzaE1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdG1hdGVyaWFsSW5kZXggPSBidWZmZXIubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdG1hdGVyaWFsID0gbWVzaE1hdGVyaWFsLm1hdGVyaWFsc1sgbWF0ZXJpYWxJbmRleCBdO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC50cmFuc3BhcmVudCApIHtcclxuXHJcblx0XHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBtYXRlcmlhbDtcclxuXHRcdFx0XHRnbG9iamVjdC5vcGFxdWUgPSBudWxsO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbWF0ZXJpYWw7XHJcblx0XHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBudWxsO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbCA9IG1lc2hNYXRlcmlhbDtcclxuXHJcblx0XHRcdGlmICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggbWF0ZXJpYWwudHJhbnNwYXJlbnQgKSB7XHJcblxyXG5cdFx0XHRcdFx0Z2xvYmplY3QudHJhbnNwYXJlbnQgPSBtYXRlcmlhbDtcclxuXHRcdFx0XHRcdGdsb2JqZWN0Lm9wYXF1ZSA9IG51bGw7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0Z2xvYmplY3Qub3BhcXVlID0gbWF0ZXJpYWw7XHJcblx0XHRcdFx0XHRnbG9iamVjdC50cmFuc3BhcmVudCA9IG51bGw7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEdlb21ldHJ5IHNwbGl0dGluZ1xyXG5cclxuXHRmdW5jdGlvbiBzb3J0RmFjZXNCeU1hdGVyaWFsICggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHZhciBmLCBmbCwgZmFjZSwgbWF0ZXJpYWxJbmRleCwgdmVydGljZXMsXHJcblx0XHRcdGdyb3VwSGFzaCwgaGFzaF9tYXAgPSB7fTtcclxuXHJcblx0XHR2YXIgbnVtTW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDtcclxuXHRcdHZhciBudW1Nb3JwaE5vcm1hbHMgPSBnZW9tZXRyeS5tb3JwaE5vcm1hbHMubGVuZ3RoO1xyXG5cclxuXHRcdHZhciB1c2VzRmFjZU1hdGVyaWFsID0gbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsO1xyXG5cclxuXHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzID0ge307XHJcblxyXG5cdFx0Zm9yICggZiA9IDAsIGZsID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gZ2VvbWV0cnkuZmFjZXNbIGYgXTtcclxuXHRcdFx0bWF0ZXJpYWxJbmRleCA9IHVzZXNGYWNlTWF0ZXJpYWwgPyBmYWNlLm1hdGVyaWFsSW5kZXggOiAwO1xyXG5cclxuXHRcdFx0aWYgKCBoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdGhhc2hfbWFwWyBtYXRlcmlhbEluZGV4IF0gPSB7ICdoYXNoJzogbWF0ZXJpYWxJbmRleCwgJ2NvdW50ZXInOiAwIH07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRncm91cEhhc2ggPSBoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdLmhhc2ggKyAnXycgKyBoYXNoX21hcFsgbWF0ZXJpYWxJbmRleCBdLmNvdW50ZXI7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBncm91cEhhc2ggXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZ3JvdXBIYXNoIF0gPSB7ICdmYWNlczMnOiBbXSwgJ2ZhY2VzNCc6IFtdLCAnbWF0ZXJpYWxJbmRleCc6IG1hdGVyaWFsSW5kZXgsICd2ZXJ0aWNlcyc6IDAsICdudW1Nb3JwaFRhcmdldHMnOiBudW1Nb3JwaFRhcmdldHMsICdudW1Nb3JwaE5vcm1hbHMnOiBudW1Nb3JwaE5vcm1hbHMgfTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZlcnRpY2VzID0gZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzID8gMyA6IDQ7XHJcblxyXG5cdFx0XHRpZiAoIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBncm91cEhhc2ggXS52ZXJ0aWNlcyArIHZlcnRpY2VzID4gNjU1MzUgKSB7XHJcblxyXG5cdFx0XHRcdGhhc2hfbWFwWyBtYXRlcmlhbEluZGV4IF0uY291bnRlciArPSAxO1xyXG5cdFx0XHRcdGdyb3VwSGFzaCA9IGhhc2hfbWFwWyBtYXRlcmlhbEluZGV4IF0uaGFzaCArICdfJyArIGhhc2hfbWFwWyBtYXRlcmlhbEluZGV4IF0uY291bnRlcjtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZ3JvdXBIYXNoIF0gPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZ3JvdXBIYXNoIF0gPSB7ICdmYWNlczMnOiBbXSwgJ2ZhY2VzNCc6IFtdLCAnbWF0ZXJpYWxJbmRleCc6IG1hdGVyaWFsSW5kZXgsICd2ZXJ0aWNlcyc6IDAsICdudW1Nb3JwaFRhcmdldHMnOiBudW1Nb3JwaFRhcmdldHMsICdudW1Nb3JwaE5vcm1hbHMnOiBudW1Nb3JwaE5vcm1hbHMgfTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzWyBncm91cEhhc2ggXS5mYWNlczMucHVzaCggZiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGdyb3VwSGFzaCBdLmZhY2VzNC5wdXNoKCBmICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZ3JvdXBIYXNoIF0udmVydGljZXMgKz0gdmVydGljZXM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzTGlzdCA9IFtdO1xyXG5cclxuXHRcdGZvciAoIHZhciBnIGluIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzICkge1xyXG5cclxuXHRcdFx0Z2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGcgXS5pZCA9IF9nZW9tZXRyeUdyb3VwQ291bnRlciArKztcclxuXHJcblx0XHRcdGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzTGlzdC5wdXNoKCBnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZyBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBPYmplY3RzIHJlZnJlc2hcclxuXHJcblx0dGhpcy5pbml0V2ViR0xPYmplY3RzID0gZnVuY3Rpb24gKCBzY2VuZSApIHtcclxuXHJcblx0XHRpZiAoICFzY2VuZS5fX3dlYmdsT2JqZWN0cyApIHtcclxuXHJcblx0XHRcdHNjZW5lLl9fd2ViZ2xPYmplY3RzID0gW107XHJcblx0XHRcdHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlID0gW107XHJcblx0XHRcdHNjZW5lLl9fd2ViZ2xTcHJpdGVzID0gW107XHJcblx0XHRcdHNjZW5lLl9fd2ViZ2xGbGFyZXMgPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0d2hpbGUgKCBzY2VuZS5fX29iamVjdHNBZGRlZC5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRhZGRPYmplY3QoIHNjZW5lLl9fb2JqZWN0c0FkZGVkWyAwIF0sIHNjZW5lICk7XHJcblx0XHRcdHNjZW5lLl9fb2JqZWN0c0FkZGVkLnNwbGljZSggMCwgMSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR3aGlsZSAoIHNjZW5lLl9fb2JqZWN0c1JlbW92ZWQubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0cmVtb3ZlT2JqZWN0KCBzY2VuZS5fX29iamVjdHNSZW1vdmVkWyAwIF0sIHNjZW5lICk7XHJcblx0XHRcdHNjZW5lLl9fb2JqZWN0c1JlbW92ZWQuc3BsaWNlKCAwLCAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHVwZGF0ZSBtdXN0IGJlIGNhbGxlZCBhZnRlciBvYmplY3RzIGFkZGluZyAvIHJlbW92YWxcclxuXHJcblx0XHRmb3IgKCB2YXIgbyA9IDAsIG9sID0gc2NlbmUuX193ZWJnbE9iamVjdHMubGVuZ3RoOyBvIDwgb2w7IG8gKysgKSB7XHJcblxyXG5cdFx0XHR1cGRhdGVPYmplY3QoIHNjZW5lLl9fd2ViZ2xPYmplY3RzWyBvIF0ub2JqZWN0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBPYmplY3RzIGFkZGluZ1xyXG5cclxuXHRmdW5jdGlvbiBhZGRPYmplY3QgKCBvYmplY3QsIHNjZW5lICkge1xyXG5cclxuXHRcdHZhciBnLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdlb21ldHJ5R3JvdXA7XHJcblxyXG5cdFx0aWYgKCAhIG9iamVjdC5fX3dlYmdsSW5pdCApIHtcclxuXHJcblx0XHRcdG9iamVjdC5fX3dlYmdsSW5pdCA9IHRydWU7XHJcblxyXG5cdFx0XHRvYmplY3QuX21vZGVsVmlld01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHRcdG9iamVjdC5fbm9ybWFsTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0Lmdlb21ldHJ5ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0Lmdlb21ldHJ5Ll9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5nZW9tZXRyeS5fX3dlYmdsSW5pdCA9IHRydWU7XHJcblx0XHRcdFx0b2JqZWN0Lmdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XHJcblx0XHRcdFx0bWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5HZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5Lmdlb21ldHJ5R3JvdXBzID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzb3J0RmFjZXNCeU1hdGVyaWFsKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Ly8gY3JlYXRlIHNlcGFyYXRlIFZCT3MgcGVyIGdlb21ldHJ5IGNodW5rXHJcblxyXG5cdFx0XHRcdFx0Zm9yICggZyBpbiBnZW9tZXRyeS5nZW9tZXRyeUdyb3VwcyApIHtcclxuXHJcblx0XHRcdFx0XHRcdGdlb21ldHJ5R3JvdXAgPSBnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc1sgZyBdO1xyXG5cclxuXHRcdFx0XHRcdFx0Ly8gaW5pdGlhbGlzZSBWQk8gb24gdGhlIGZpcnN0IGFjY2Vzc1xyXG5cclxuXHRcdFx0XHRcdFx0aWYgKCAhIGdlb21ldHJ5R3JvdXAuX193ZWJnbFZlcnRleEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0Y3JlYXRlTWVzaEJ1ZmZlcnMoIGdlb21ldHJ5R3JvdXAgKTtcclxuXHRcdFx0XHRcdFx0XHRpbml0TWVzaEJ1ZmZlcnMoIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRcdGdlb21ldHJ5LnRhbmdlbnRzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdGluaXREaXJlY3RCdWZmZXJzKCBnZW9tZXRyeSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5SaWJib24gKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0XHRpZiAoICEgZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHRjcmVhdGVSaWJib25CdWZmZXJzKCBnZW9tZXRyeSApO1xyXG5cdFx0XHRcdFx0aW5pdFJpYmJvbkJ1ZmZlcnMoIGdlb21ldHJ5LCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblx0XHRcdFx0XHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0XHRpZiAoICEgZ2VvbWV0cnkuX193ZWJnbFZlcnRleEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuR2VvbWV0cnkgKSB7XHJcblxyXG4gICAgICAgICAgICBjcmVhdGVMaW5lQnVmZmVycyggZ2VvbWV0cnkgKTtcclxuICAgICAgICAgICAgaW5pdExpbmVCdWZmZXJzKCBnZW9tZXRyeSwgb2JqZWN0ICk7XHJcblxyXG4gICAgICAgICAgICBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG4gICAgICAgICAgICBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgZ2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIH0gZWxzZSBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpbml0RGlyZWN0QnVmZmVycyggZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkge1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGdlb21ldHJ5Ll9fd2ViZ2xWZXJ0ZXhCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3JlYXRlUGFydGljbGVCdWZmZXJzKCBnZW9tZXRyeSApO1xyXG5cdFx0XHRcdFx0XHRpbml0UGFydGljbGVCdWZmZXJzKCBnZW9tZXRyeSwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW5pdERpcmVjdEJ1ZmZlcnMoIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICEgb2JqZWN0Ll9fd2ViZ2xBY3RpdmUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdFx0YWRkQnVmZmVyKCBzY2VuZS5fX3dlYmdsT2JqZWN0cywgZ2VvbWV0cnksIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIGcgaW4gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHMgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRnZW9tZXRyeUdyb3VwID0gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNbIGcgXTtcclxuXHJcblx0XHRcdFx0XHRcdGFkZEJ1ZmZlciggc2NlbmUuX193ZWJnbE9iamVjdHMsIGdlb21ldHJ5R3JvdXAsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUmliYm9uIHx8XHJcblx0XHRcdFx0XHRcdG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgfHxcclxuXHRcdFx0XHRcdFx0b2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVTeXN0ZW0gKSB7XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xyXG5cdFx0XHRcdGFkZEJ1ZmZlciggc2NlbmUuX193ZWJnbE9iamVjdHMsIGdlb21ldHJ5LCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkltbWVkaWF0ZVJlbmRlck9iamVjdCB8fCBvYmplY3QuaW1tZWRpYXRlUmVuZGVyQ2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHRcdGFkZEJ1ZmZlckltbWVkaWF0ZSggc2NlbmUuX193ZWJnbE9iamVjdHNJbW1lZGlhdGUsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xyXG5cclxuXHRcdFx0XHRzY2VuZS5fX3dlYmdsU3ByaXRlcy5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxlbnNGbGFyZSApIHtcclxuXHJcblx0XHRcdFx0c2NlbmUuX193ZWJnbEZsYXJlcy5wdXNoKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdG9iamVjdC5fX3dlYmdsQWN0aXZlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGFkZEJ1ZmZlciAoIG9iamxpc3QsIGJ1ZmZlciwgb2JqZWN0ICkge1xyXG5cclxuXHRcdG9iamxpc3QucHVzaChcclxuXHRcdFx0e1xyXG5cdFx0XHRcdGJ1ZmZlcjogYnVmZmVyLFxyXG5cdFx0XHRcdG9iamVjdDogb2JqZWN0LFxyXG5cdFx0XHRcdG9wYXF1ZTogbnVsbCxcclxuXHRcdFx0XHR0cmFuc3BhcmVudDogbnVsbFxyXG5cdFx0XHR9XHJcblx0XHQpO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBhZGRCdWZmZXJJbW1lZGlhdGUgKCBvYmpsaXN0LCBvYmplY3QgKSB7XHJcblxyXG5cdFx0b2JqbGlzdC5wdXNoKFxyXG5cdFx0XHR7XHJcblx0XHRcdFx0b2JqZWN0OiBvYmplY3QsXHJcblx0XHRcdFx0b3BhcXVlOiBudWxsLFxyXG5cdFx0XHRcdHRyYW5zcGFyZW50OiBudWxsXHJcblx0XHRcdH1cclxuXHRcdCk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIE9iamVjdHMgdXBkYXRlc1xyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVPYmplY3QgKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5LFxyXG5cdFx0XHRnZW9tZXRyeUdyb3VwLCBjdXN0b21BdHRyaWJ1dGVzRGlydHksIG1hdGVyaWFsO1xyXG5cclxuXHRcdGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCApIHtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlIHx8XHJcblx0XHRcdFx0XHQgZ2VvbWV0cnkudXZzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSB8fFxyXG5cdFx0XHRcdFx0IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRcdHNldERpcmVjdEJ1ZmZlcnMoIGdlb21ldHJ5LCBfZ2wuRFlOQU1JQ19EUkFXLCAhZ2VvbWV0cnkuZHluYW1pYyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS50YW5nZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdC8vIGNoZWNrIGFsbCBnZW9tZXRyeSBncm91cHNcclxuXHJcblx0XHRcdFx0Zm9yKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkuZ2VvbWV0cnlHcm91cHNMaXN0Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGdlb21ldHJ5R3JvdXAgPSBnZW9tZXRyeS5nZW9tZXRyeUdyb3Vwc0xpc3RbIGkgXTtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5R3JvdXAgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmJ1ZmZlcnNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0aW5pdE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlc0RpcnR5ID0gbWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBhcmVDdXN0b21BdHRyaWJ1dGVzRGlydHkoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkubW9ycGhUYXJnZXRzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgfHxcclxuXHRcdFx0XHRcdFx0IGdlb21ldHJ5LnV2c05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgfHxcclxuXHRcdFx0XHRcdFx0IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkudGFuZ2VudHNOZWVkVXBkYXRlIHx8IGN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNldE1lc2hCdWZmZXJzKCBnZW9tZXRyeUdyb3VwLCBvYmplY3QsIF9nbC5EWU5BTUlDX0RSQVcsICFnZW9tZXRyeS5keW5hbWljLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0XHRnZW9tZXRyeS5tb3JwaFRhcmdldHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdFx0Z2VvbWV0cnkuZWxlbWVudHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5LnRhbmdlbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRnZW9tZXRyeS5idWZmZXJzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRtYXRlcmlhbC5hdHRyaWJ1dGVzICYmIGNsZWFyQ3VzdG9tQXR0cmlidXRlcyggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5SaWJib24gKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbCA9IGdldEJ1ZmZlck1hdGVyaWFsKCBvYmplY3QsIGdlb21ldHJ5ICk7XHJcblxyXG5cdFx0XHRjdXN0b21BdHRyaWJ1dGVzRGlydHkgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzICYmIGFyZUN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSggbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgfHwgY3VzdG9tQXR0cmlidXRlc0RpcnR5ICkge1xyXG5cclxuXHRcdFx0XHRzZXRSaWJib25CdWZmZXJzKCBnZW9tZXRyeSwgX2dsLkRZTkFNSUNfRFJBVyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHRcdFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgY2xlYXJDdXN0b21BdHRyaWJ1dGVzKCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkxpbmUgKSB7XHJcblxyXG4gICAgICBpZiAoIGdlb21ldHJ5IGluc3RhbmNlb2YgVEhSRUUuQnVmZmVyR2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0RGlyZWN0QnVmZmVycyggZ2VvbWV0cnksIF9nbC5EWU5BTUlDX0RSQVcsICFnZW9tZXRyeS5keW5hbWljICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Z2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblx0XHRcdFx0Z2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcbiAgICAgICAgbWF0ZXJpYWwgPSBnZXRCdWZmZXJNYXRlcmlhbCggb2JqZWN0LCBnZW9tZXRyeSApO1xyXG5cclxuICAgICAgICBjdXN0b21BdHRyaWJ1dGVzRGlydHkgPSBtYXRlcmlhbC5hdHRyaWJ1dGVzICYmIGFyZUN1c3RvbUF0dHJpYnV0ZXNEaXJ0eSggbWF0ZXJpYWwgKTtcclxuXHJcbiAgICAgICAgaWYgKCBnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgfHwgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzTmVlZFVwZGF0ZSB8fCBjdXN0b21BdHRyaWJ1dGVzRGlydHkgKSB7XHJcblxyXG4gICAgICAgICAgc2V0TGluZUJ1ZmZlcnMoIGdlb21ldHJ5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XHJcblxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcbiAgICAgICAgZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG4gICAgICAgIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XHJcblxyXG4gICAgICAgIG1hdGVyaWFsLmF0dHJpYnV0ZXMgJiYgY2xlYXJDdXN0b21BdHRyaWJ1dGVzKCBtYXRlcmlhbCApO1xyXG5cclxuICAgICAgfVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkge1xyXG5cclxuXHRcdFx0aWYgKCBnZW9tZXRyeSBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSB8fCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlICkge1xyXG5cclxuXHRcdFx0XHRcdHNldERpcmVjdEJ1ZmZlcnMoIGdlb21ldHJ5LCBfZ2wuRFlOQU1JQ19EUkFXLCAhZ2VvbWV0cnkuZHluYW1pYyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdG1hdGVyaWFsID0gZ2V0QnVmZmVyTWF0ZXJpYWwoIG9iamVjdCwgZ2VvbWV0cnkgKTtcclxuXHJcblx0XHRcdFx0Y3VzdG9tQXR0cmlidXRlc0RpcnR5ID0gbWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBhcmVDdXN0b21BdHRyaWJ1dGVzRGlydHkoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRcdGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlIHx8IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgfHwgb2JqZWN0LnNvcnRQYXJ0aWNsZXMgfHwgY3VzdG9tQXR0cmlidXRlc0RpcnR5ICkge1xyXG5cclxuXHRcdFx0XHRcdHNldFBhcnRpY2xlQnVmZmVycyggZ2VvbWV0cnksIF9nbC5EWU5BTUlDX0RSQVcsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHRcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0bWF0ZXJpYWwuYXR0cmlidXRlcyAmJiBjbGVhckN1c3RvbUF0dHJpYnV0ZXMoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBPYmplY3RzIHVwZGF0ZXMgLSBjdXN0b20gYXR0cmlidXRlcyBjaGVja1xyXG5cclxuXHRmdW5jdGlvbiBhcmVDdXN0b21BdHRyaWJ1dGVzRGlydHkgKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgYSBpbiBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5hdHRyaWJ1dGVzWyBhIF0ubmVlZHNVcGRhdGUgKSByZXR1cm4gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjbGVhckN1c3RvbUF0dHJpYnV0ZXMgKCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgYSBpbiBtYXRlcmlhbC5hdHRyaWJ1dGVzICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwuYXR0cmlidXRlc1sgYSBdLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBPYmplY3RzIHJlbW92YWxcclxuXHJcblx0ZnVuY3Rpb24gcmVtb3ZlT2JqZWN0ICggb2JqZWN0LCBzY2VuZSApIHtcclxuXHJcblx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLk1lc2ggIHx8XHJcblx0XHRcdCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSB8fFxyXG5cdFx0XHQgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuUmliYm9uIHx8XHJcblx0XHRcdCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5MaW5lICkge1xyXG5cclxuXHRcdFx0cmVtb3ZlSW5zdGFuY2VzKCBzY2VuZS5fX3dlYmdsT2JqZWN0cywgb2JqZWN0ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU3ByaXRlICkge1xyXG5cclxuXHRcdFx0cmVtb3ZlSW5zdGFuY2VzRGlyZWN0KCBzY2VuZS5fX3dlYmdsU3ByaXRlcywgb2JqZWN0ICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTGVuc0ZsYXJlICkge1xyXG5cclxuXHRcdFx0cmVtb3ZlSW5zdGFuY2VzRGlyZWN0KCBzY2VuZS5fX3dlYmdsRmxhcmVzLCBvYmplY3QgKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QgfHwgb2JqZWN0LmltbWVkaWF0ZVJlbmRlckNhbGxiYWNrICkge1xyXG5cclxuXHRcdFx0cmVtb3ZlSW5zdGFuY2VzKCBzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZSwgb2JqZWN0ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdG9iamVjdC5fX3dlYmdsQWN0aXZlID0gZmFsc2U7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlbW92ZUluc3RhbmNlcyAoIG9iamxpc3QsIG9iamVjdCApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgbyA9IG9iamxpc3QubGVuZ3RoIC0gMTsgbyA+PSAwOyBvIC0tICkge1xyXG5cclxuXHRcdFx0aWYgKCBvYmpsaXN0WyBvIF0ub2JqZWN0ID09PSBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdG9iamxpc3Quc3BsaWNlKCBvLCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZW1vdmVJbnN0YW5jZXNEaXJlY3QgKCBvYmpsaXN0LCBvYmplY3QgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIG8gPSBvYmpsaXN0Lmxlbmd0aCAtIDE7IG8gPj0gMDsgbyAtLSApIHtcclxuXHJcblx0XHRcdGlmICggb2JqbGlzdFsgbyBdID09PSBvYmplY3QgKSB7XHJcblxyXG5cdFx0XHRcdG9iamxpc3Quc3BsaWNlKCBvLCAxICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBNYXRlcmlhbHNcclxuXHJcblx0dGhpcy5pbml0TWF0ZXJpYWwgPSBmdW5jdGlvbiAoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICkge1xyXG5cclxuXHRcdG1hdGVyaWFsLmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25NYXRlcmlhbERpc3Bvc2UgKTtcclxuXHJcblx0XHR2YXIgdSwgYSwgaWRlbnRpZmllcnMsIGksIHBhcmFtZXRlcnMsIG1heExpZ2h0Q291bnQsIG1heEJvbmVzLCBtYXhTaGFkb3dzLCBzaGFkZXJJRDtcclxuXHJcblx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaERlcHRoTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXJJRCA9ICdkZXB0aCc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTm9ybWFsTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXJJRCA9ICdub3JtYWwnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXJJRCA9ICdiYXNpYyc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0c2hhZGVySUQgPSAnbGFtYmVydCc7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNoYWRlcklEID0gJ3Bob25nJztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0c2hhZGVySUQgPSAnYmFzaWMnO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTGluZURhc2hlZE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0c2hhZGVySUQgPSAnZGFzaGVkJztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdHNoYWRlcklEID0gJ3BhcnRpY2xlX2Jhc2ljJztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBzaGFkZXJJRCApIHtcclxuXHJcblx0XHRcdHNldE1hdGVyaWFsU2hhZGVycyggbWF0ZXJpYWwsIFRIUkVFLlNoYWRlckxpYlsgc2hhZGVySUQgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBoZXVyaXN0aWNzIHRvIGNyZWF0ZSBzaGFkZXIgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gbGlnaHRzIGluIHRoZSBzY2VuZVxyXG5cdFx0Ly8gKG5vdCB0byBibG93IG92ZXIgbWF4TGlnaHRzIGJ1ZGdldClcclxuXHJcblx0XHRtYXhMaWdodENvdW50ID0gYWxsb2NhdGVMaWdodHMoIGxpZ2h0cyApO1xyXG5cclxuXHRcdG1heFNoYWRvd3MgPSBhbGxvY2F0ZVNoYWRvd3MoIGxpZ2h0cyApO1xyXG5cclxuXHRcdG1heEJvbmVzID0gYWxsb2NhdGVCb25lcyggb2JqZWN0ICk7XHJcblxyXG5cdFx0cGFyYW1ldGVycyA9IHtcclxuXHJcblx0XHRcdG1hcDogISFtYXRlcmlhbC5tYXAsXHJcblx0XHRcdGVudk1hcDogISFtYXRlcmlhbC5lbnZNYXAsXHJcblx0XHRcdGxpZ2h0TWFwOiAhIW1hdGVyaWFsLmxpZ2h0TWFwLFxyXG5cdFx0XHRidW1wTWFwOiAhIW1hdGVyaWFsLmJ1bXBNYXAsXHJcblx0XHRcdG5vcm1hbE1hcDogISFtYXRlcmlhbC5ub3JtYWxNYXAsXHJcblx0XHRcdHNwZWN1bGFyTWFwOiAhIW1hdGVyaWFsLnNwZWN1bGFyTWFwLFxyXG5cclxuXHRcdFx0dmVydGV4Q29sb3JzOiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMsXHJcblxyXG5cdFx0XHRmb2c6IGZvZyxcclxuXHRcdFx0dXNlRm9nOiBtYXRlcmlhbC5mb2csXHJcblx0XHRcdGZvZ0V4cDogZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMixcclxuXHJcblx0XHRcdHNpemVBdHRlbnVhdGlvbjogbWF0ZXJpYWwuc2l6ZUF0dGVudWF0aW9uLFxyXG5cclxuXHRcdFx0c2tpbm5pbmc6IG1hdGVyaWFsLnNraW5uaW5nLFxyXG5cdFx0XHRtYXhCb25lczogbWF4Qm9uZXMsXHJcblx0XHRcdHVzZVZlcnRleFRleHR1cmU6IF9zdXBwb3J0c0JvbmVUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnVzZVZlcnRleFRleHR1cmUsXHJcblx0XHRcdGJvbmVUZXh0dXJlV2lkdGg6IG9iamVjdCAmJiBvYmplY3QuYm9uZVRleHR1cmVXaWR0aCxcclxuXHRcdFx0Ym9uZVRleHR1cmVIZWlnaHQ6IG9iamVjdCAmJiBvYmplY3QuYm9uZVRleHR1cmVIZWlnaHQsXHJcblxyXG5cdFx0XHRtb3JwaFRhcmdldHM6IG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyxcclxuXHRcdFx0bW9ycGhOb3JtYWxzOiBtYXRlcmlhbC5tb3JwaE5vcm1hbHMsXHJcblx0XHRcdG1heE1vcnBoVGFyZ2V0czogdGhpcy5tYXhNb3JwaFRhcmdldHMsXHJcblx0XHRcdG1heE1vcnBoTm9ybWFsczogdGhpcy5tYXhNb3JwaE5vcm1hbHMsXHJcblxyXG5cdFx0XHRtYXhEaXJMaWdodHM6IG1heExpZ2h0Q291bnQuZGlyZWN0aW9uYWwsXHJcblx0XHRcdG1heFBvaW50TGlnaHRzOiBtYXhMaWdodENvdW50LnBvaW50LFxyXG5cdFx0XHRtYXhTcG90TGlnaHRzOiBtYXhMaWdodENvdW50LnNwb3QsXHJcblx0XHRcdG1heEhlbWlMaWdodHM6IG1heExpZ2h0Q291bnQuaGVtaSxcclxuXHJcblx0XHRcdG1heFNoYWRvd3M6IG1heFNoYWRvd3MsXHJcblx0XHRcdHNoYWRvd01hcEVuYWJsZWQ6IHRoaXMuc2hhZG93TWFwRW5hYmxlZCAmJiBvYmplY3QucmVjZWl2ZVNoYWRvdyxcclxuXHRcdFx0c2hhZG93TWFwVHlwZTogdGhpcy5zaGFkb3dNYXBUeXBlLFxyXG5cdFx0XHRzaGFkb3dNYXBEZWJ1ZzogdGhpcy5zaGFkb3dNYXBEZWJ1ZyxcclxuXHRcdFx0c2hhZG93TWFwQ2FzY2FkZTogdGhpcy5zaGFkb3dNYXBDYXNjYWRlLFxyXG5cclxuXHRcdFx0YWxwaGFUZXN0OiBtYXRlcmlhbC5hbHBoYVRlc3QsXHJcblx0XHRcdG1ldGFsOiBtYXRlcmlhbC5tZXRhbCxcclxuXHRcdFx0cGVyUGl4ZWw6IG1hdGVyaWFsLnBlclBpeGVsLFxyXG5cdFx0XHR3cmFwQXJvdW5kOiBtYXRlcmlhbC53cmFwQXJvdW5kLFxyXG5cdFx0XHRkb3VibGVTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZSxcclxuXHRcdFx0ZmxpcFNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZVxyXG5cclxuXHRcdH07XHJcblxyXG5cdFx0bWF0ZXJpYWwucHJvZ3JhbSA9IGJ1aWxkUHJvZ3JhbSggc2hhZGVySUQsIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyLCBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIsIG1hdGVyaWFsLnVuaWZvcm1zLCBtYXRlcmlhbC5hdHRyaWJ1dGVzLCBtYXRlcmlhbC5kZWZpbmVzLCBwYXJhbWV0ZXJzICk7XHJcblxyXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBtYXRlcmlhbC5wcm9ncmFtLmF0dHJpYnV0ZXM7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5tb3JwaFRhcmdldHMgKSB7XHJcblxyXG5cdFx0XHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgPSAwO1xyXG5cclxuXHRcdFx0dmFyIGlkLCBiYXNlID0gXCJtb3JwaFRhcmdldFwiO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0aWQgPSBiYXNlICsgaTtcclxuXHJcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzWyBpZCBdID49IDAgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhOb3JtYWxzID0gMDtcclxuXHJcblx0XHRcdHZhciBpZCwgYmFzZSA9IFwibW9ycGhOb3JtYWxcIjtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgdGhpcy5tYXhNb3JwaE5vcm1hbHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGlkID0gYmFzZSArIGk7XHJcblxyXG5cdFx0XHRcdGlmICggYXR0cmlidXRlc1sgaWQgXSA+PSAwICkge1xyXG5cclxuXHRcdFx0XHRcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRtYXRlcmlhbC51bmlmb3Jtc0xpc3QgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB1IGluIG1hdGVyaWFsLnVuaWZvcm1zICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWwudW5pZm9ybXNMaXN0LnB1c2goIFsgbWF0ZXJpYWwudW5pZm9ybXNbIHUgXSwgdSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRNYXRlcmlhbFNoYWRlcnMoIG1hdGVyaWFsLCBzaGFkZXJzICkge1xyXG5cclxuXHRcdG1hdGVyaWFsLnVuaWZvcm1zID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSggc2hhZGVycy51bmlmb3JtcyApO1xyXG5cdFx0bWF0ZXJpYWwudmVydGV4U2hhZGVyID0gc2hhZGVycy52ZXJ0ZXhTaGFkZXI7XHJcblx0XHRtYXRlcmlhbC5mcmFnbWVudFNoYWRlciA9IHNoYWRlcnMuZnJhZ21lbnRTaGFkZXI7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldFByb2dyYW0oIGNhbWVyYSwgbGlnaHRzLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0X3VzZWRUZXh0dXJlVW5pdHMgPSAwO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubmVlZHNVcGRhdGUgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsLnByb2dyYW0gKSBkZWFsbG9jYXRlTWF0ZXJpYWwoIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHRfdGhpcy5pbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBsaWdodHMsIGZvZywgb2JqZWN0ICk7XHJcblx0XHRcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0aWYgKCAhIG9iamVjdC5fX3dlYmdsTW9ycGhUYXJnZXRJbmZsdWVuY2VzICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3QuX193ZWJnbE1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIF90aGlzLm1heE1vcnBoVGFyZ2V0cyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcmVmcmVzaE1hdGVyaWFsID0gZmFsc2U7XHJcblxyXG5cdFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbC5wcm9ncmFtLFxyXG5cdFx0XHRwX3VuaWZvcm1zID0gcHJvZ3JhbS51bmlmb3JtcyxcclxuXHRcdFx0bV91bmlmb3JtcyA9IG1hdGVyaWFsLnVuaWZvcm1zO1xyXG5cclxuXHRcdGlmICggcHJvZ3JhbSAhPT0gX2N1cnJlbnRQcm9ncmFtICkge1xyXG5cclxuXHRcdFx0X2dsLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcclxuXHRcdFx0X2N1cnJlbnRQcm9ncmFtID0gcHJvZ3JhbTtcclxuXHJcblx0XHRcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwuaWQgIT09IF9jdXJyZW50TWF0ZXJpYWxJZCApIHtcclxuXHJcblx0XHRcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IG1hdGVyaWFsLmlkO1xyXG5cdFx0XHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xyXG5cclxuXHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHBfdW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCwgZmFsc2UsIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRpZiAoIGNhbWVyYSAhPT0gX2N1cnJlbnRDYW1lcmEgKSBfY3VycmVudENhbWVyYSA9IGNhbWVyYTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gc2tpbm5pbmcgdW5pZm9ybXMgbXVzdCBiZSBzZXQgZXZlbiBpZiBtYXRlcmlhbCBkaWRuJ3QgY2hhbmdlXHJcblx0XHQvLyBhdXRvLXNldHRpbmcgb2YgdGV4dHVyZSB1bml0IGZvciBib25lIHRleHR1cmUgbXVzdCBnbyBiZWZvcmUgb3RoZXIgdGV4dHVyZXNcclxuXHRcdC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5za2lubmluZyApIHtcclxuXHJcblx0XHRcdGlmICggX3N1cHBvcnRzQm9uZVRleHR1cmVzICYmIG9iamVjdC51c2VWZXJ0ZXhUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZVRleHR1cmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCBwX3VuaWZvcm1zLmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cdFx0XHRcdFx0X3RoaXMuc2V0VGV4dHVyZSggb2JqZWN0LmJvbmVUZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuYm9uZUdsb2JhbE1hdHJpY2VzICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtTWF0cml4NGZ2KCBwX3VuaWZvcm1zLmJvbmVHbG9iYWxNYXRyaWNlcywgZmFsc2UsIG9iamVjdC5ib25lTWF0cmljZXMgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIHJlZnJlc2hNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdC8vIHJlZnJlc2ggdW5pZm9ybXMgY29tbW9uIHRvIHNldmVyYWwgbWF0ZXJpYWxzXHJcblxyXG5cdFx0XHRpZiAoIGZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0ZvZyggbV91bmlmb3JtcywgZm9nICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsLmxpZ2h0cyApIHtcclxuXHJcblx0XHRcdFx0aWYgKCBfbGlnaHRzTmVlZFVwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRzZXR1cExpZ2h0cyggcHJvZ3JhbSwgbGlnaHRzICk7XHJcblx0XHRcdFx0XHRfbGlnaHRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpZ2h0cyggbV91bmlmb3JtcywgX2xpZ2h0cyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyByZWZyZXNoIHNpbmdsZSBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMaW5lKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc0xpbmUoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XHJcblx0XHRcdFx0cmVmcmVzaFVuaWZvcm1zRGFzaCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuUGFydGljbGVCYXNpY01hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdHJlZnJlc2hVbmlmb3Jtc1Bob25nKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoTGFtYmVydE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRGVwdGhNYXRlcmlhbCApIHtcclxuXHJcblx0XHRcdFx0bV91bmlmb3Jtcy5tTmVhci52YWx1ZSA9IGNhbWVyYS5uZWFyO1xyXG5cdFx0XHRcdG1fdW5pZm9ybXMubUZhci52YWx1ZSA9IGNhbWVyYS5mYXI7XHJcblx0XHRcdFx0bV91bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRtX3VuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QucmVjZWl2ZVNoYWRvdyAmJiAhIG1hdGVyaWFsLl9zaGFkb3dQYXNzICkge1xyXG5cclxuXHRcdFx0XHRyZWZyZXNoVW5pZm9ybXNTaGFkb3coIG1fdW5pZm9ybXMsIGxpZ2h0cyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gbG9hZCBjb21tb24gdW5pZm9ybXNcclxuXHJcblx0XHRcdGxvYWRVbmlmb3Jtc0dlbmVyaWMoIHByb2dyYW0sIG1hdGVyaWFsLnVuaWZvcm1zTGlzdCApO1xyXG5cclxuXHRcdFx0Ly8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xyXG5cdFx0XHQvLyAoc2hhZGVyIG1hdGVyaWFsIGFsc28gZ2V0cyB0aGVtIGZvciB0aGUgc2FrZSBvZiBnZW5lcmljaXR5KVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwgfHxcclxuXHRcdFx0XHQgbWF0ZXJpYWwuZW52TWFwICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24gIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRcdFx0X3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBjYW1lcmEubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRcdF9nbC51bmlmb3JtM2YoIHBfdW5pZm9ybXMuY2FtZXJhUG9zaXRpb24sIF92ZWN0b3IzLngsIF92ZWN0b3IzLnksIF92ZWN0b3IzLnogKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCB8fFxyXG5cdFx0XHRcdCBtYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLlNoYWRlck1hdGVyaWFsIHx8XHJcblx0XHRcdFx0IG1hdGVyaWFsLnNraW5uaW5nICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIHBfdW5pZm9ybXMudmlld01hdHJpeCAhPT0gbnVsbCApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy52aWV3TWF0cml4LCBmYWxzZSwgY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZS5lbGVtZW50cyApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGxvYWRVbmlmb3Jtc01hdHJpY2VzKCBwX3VuaWZvcm1zLCBvYmplY3QgKTtcclxuXHJcblx0XHRpZiAoIHBfdW5pZm9ybXMubW9kZWxNYXRyaXggIT09IG51bGwgKSB7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDRmdiggcF91bmlmb3Jtcy5tb2RlbE1hdHJpeCwgZmFsc2UsIG9iamVjdC5tYXRyaXhXb3JsZC5lbGVtZW50cyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gVW5pZm9ybXMgKHJlZnJlc2ggdW5pZm9ybXMgb2JqZWN0cylcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zQ29tbW9uICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuXHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUuY29weUdhbW1hVG9MaW5lYXIoIG1hdGVyaWFsLmNvbG9yICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dW5pZm9ybXMubWFwLnZhbHVlID0gbWF0ZXJpYWwubWFwO1xyXG5cdFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcclxuXHRcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5idW1wTWFwICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYnVtcE1hcC52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBNYXA7XHJcblx0XHRcdHVuaWZvcm1zLmJ1bXBTY2FsZS52YWx1ZSA9IG1hdGVyaWFsLmJ1bXBTY2FsZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5ub3JtYWxNYXAudmFsdWUgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XHJcblx0XHRcdHVuaWZvcm1zLm5vcm1hbFNjYWxlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLm5vcm1hbFNjYWxlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHV2IHJlcGVhdCBhbmQgb2Zmc2V0IHNldHRpbmcgcHJpb3JpdGllc1xyXG5cdFx0Ly9cdDEuIGNvbG9yIG1hcFxyXG5cdFx0Ly9cdDIuIHNwZWN1bGFyIG1hcFxyXG5cdFx0Ly9cdDMuIG5vcm1hbCBtYXBcclxuXHRcdC8vXHQ0LiBidW1wIG1hcFxyXG5cclxuXHRcdHZhciB1dlNjYWxlTWFwO1xyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwubWFwICkge1xyXG5cclxuXHRcdFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcclxuXHJcblx0XHRcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5zcGVjdWxhck1hcDtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5ub3JtYWxNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwubm9ybWFsTWFwO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmJ1bXBNYXAgKSB7XHJcblxyXG5cdFx0XHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB1dlNjYWxlTWFwICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gdXZTY2FsZU1hcC5vZmZzZXQ7XHJcblx0XHRcdHZhciByZXBlYXQgPSB1dlNjYWxlTWFwLnJlcGVhdDtcclxuXHJcblx0XHRcdHVuaWZvcm1zLm9mZnNldFJlcGVhdC52YWx1ZS5zZXQoIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcclxuXHRcdHVuaWZvcm1zLmZsaXBFbnZNYXAudmFsdWUgPSAoIG1hdGVyaWFsLmVudk1hcCBpbnN0YW5jZW9mIFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApID8gMSA6IC0xO1xyXG5cclxuXHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcclxuXHJcblx0XHRcdC8vdW5pZm9ybXMucmVmbGVjdGl2aXR5LnZhbHVlID0gbWF0ZXJpYWwucmVmbGVjdGl2aXR5ICogbWF0ZXJpYWwucmVmbGVjdGl2aXR5O1xyXG5cdFx0XHR1bmlmb3Jtcy5yZWZsZWN0aXZpdHkudmFsdWUgPSBtYXRlcmlhbC5yZWZsZWN0aXZpdHk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dW5pZm9ybXMucmVmcmFjdGlvblJhdGlvLnZhbHVlID0gbWF0ZXJpYWwucmVmcmFjdGlvblJhdGlvO1xyXG5cdFx0dW5pZm9ybXMuY29tYmluZS52YWx1ZSA9IG1hdGVyaWFsLmNvbWJpbmU7XHJcblx0XHR1bmlmb3Jtcy51c2VSZWZyYWN0LnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nIGluc3RhbmNlb2YgVEhSRUUuQ3ViZVJlZnJhY3Rpb25NYXBwaW5nO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaW5lICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLmRpZmZ1c2UudmFsdWUgPSBtYXRlcmlhbC5jb2xvcjtcclxuXHRcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLmRhc2hTaXplLnZhbHVlID0gbWF0ZXJpYWwuZGFzaFNpemU7XHJcblx0XHR1bmlmb3Jtcy50b3RhbFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZSArIG1hdGVyaWFsLmdhcFNpemU7XHJcblx0XHR1bmlmb3Jtcy5zY2FsZS52YWx1ZSA9IG1hdGVyaWFsLnNjYWxlO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNQYXJ0aWNsZSAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHR1bmlmb3Jtcy5wc0NvbG9yLnZhbHVlID0gbWF0ZXJpYWwuY29sb3I7XHJcblx0XHR1bmlmb3Jtcy5vcGFjaXR5LnZhbHVlID0gbWF0ZXJpYWwub3BhY2l0eTtcclxuXHRcdHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplO1xyXG5cdFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBfY2FudmFzLmhlaWdodCAvIDIuMDsgLy8gVE9ETzogQ2FjaGUgdGhpcy5cclxuXHJcblx0XHR1bmlmb3Jtcy5tYXAudmFsdWUgPSBtYXRlcmlhbC5tYXA7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0ZvZyAoIHVuaWZvcm1zLCBmb2cgKSB7XHJcblxyXG5cdFx0dW5pZm9ybXMuZm9nQ29sb3IudmFsdWUgPSBmb2cuY29sb3I7XHJcblxyXG5cdFx0aWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2cgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5mb2dOZWFyLnZhbHVlID0gZm9nLm5lYXI7XHJcblx0XHRcdHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggZm9nIGluc3RhbmNlb2YgVEhSRUUuRm9nRXhwMiApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLmZvZ0RlbnNpdHkudmFsdWUgPSBmb2cuZGVuc2l0eTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Bob25nICggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLnNoaW5pbmVzcy52YWx1ZSA9IG1hdGVyaWFsLnNoaW5pbmVzcztcclxuXHJcblx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50LnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5hbWJpZW50ICk7XHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5lbWlzc2l2ZSApO1xyXG5cdFx0XHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZS5jb3B5R2FtbWFUb0xpbmVhciggbWF0ZXJpYWwuc3BlY3VsYXIgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMuYW1iaWVudC52YWx1ZSA9IG1hdGVyaWFsLmFtYmllbnQ7XHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmU7XHJcblx0XHRcdHVuaWZvcm1zLnNwZWN1bGFyLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggbWF0ZXJpYWwud3JhcEFyb3VuZCApIHtcclxuXHJcblx0XHRcdHVuaWZvcm1zLndyYXBSR0IudmFsdWUuY29weSggbWF0ZXJpYWwud3JhcFJHQiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zTGFtYmVydCAoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcclxuXHJcblx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50LnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5hbWJpZW50ICk7XHJcblx0XHRcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHlHYW1tYVRvTGluZWFyKCBtYXRlcmlhbC5lbWlzc2l2ZSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHR1bmlmb3Jtcy5hbWJpZW50LnZhbHVlID0gbWF0ZXJpYWwuYW1iaWVudDtcclxuXHRcdFx0dW5pZm9ybXMuZW1pc3NpdmUudmFsdWUgPSBtYXRlcmlhbC5lbWlzc2l2ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBtYXRlcmlhbC53cmFwQXJvdW5kICkge1xyXG5cclxuXHRcdFx0dW5pZm9ybXMud3JhcFJHQi52YWx1ZS5jb3B5KCBtYXRlcmlhbC53cmFwUkdCICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaWdodHMgKCB1bmlmb3JtcywgbGlnaHRzICkge1xyXG5cclxuXHRcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLmFtYmllbnQ7XHJcblxyXG5cdFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodENvbG9yLnZhbHVlID0gbGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycztcclxuXHRcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuZGlyZWN0aW9uYWwucG9zaXRpb25zO1xyXG5cclxuXHRcdHVuaWZvcm1zLnBvaW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5wb2ludC5jb2xvcnM7XHJcblx0XHR1bmlmb3Jtcy5wb2ludExpZ2h0UG9zaXRpb24udmFsdWUgPSBsaWdodHMucG9pbnQucG9zaXRpb25zO1xyXG5cdFx0dW5pZm9ybXMucG9pbnRMaWdodERpc3RhbmNlLnZhbHVlID0gbGlnaHRzLnBvaW50LmRpc3RhbmNlcztcclxuXHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5zcG90LmNvbG9ycztcclxuXHRcdHVuaWZvcm1zLnNwb3RMaWdodFBvc2l0aW9uLnZhbHVlID0gbGlnaHRzLnNwb3QucG9zaXRpb25zO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0RGlzdGFuY2UudmFsdWUgPSBsaWdodHMuc3BvdC5kaXN0YW5jZXM7XHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHREaXJlY3Rpb24udmFsdWUgPSBsaWdodHMuc3BvdC5kaXJlY3Rpb25zO1xyXG5cdFx0dW5pZm9ybXMuc3BvdExpZ2h0QW5nbGVDb3MudmFsdWUgPSBsaWdodHMuc3BvdC5hbmdsZXNDb3M7XHJcblx0XHR1bmlmb3Jtcy5zcG90TGlnaHRFeHBvbmVudC52YWx1ZSA9IGxpZ2h0cy5zcG90LmV4cG9uZW50cztcclxuXHJcblx0XHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRTa3lDb2xvci52YWx1ZSA9IGxpZ2h0cy5oZW1pLnNreUNvbG9ycztcclxuXHRcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodEdyb3VuZENvbG9yLnZhbHVlID0gbGlnaHRzLmhlbWkuZ3JvdW5kQ29sb3JzO1xyXG5cdFx0dW5pZm9ybXMuaGVtaXNwaGVyZUxpZ2h0RGlyZWN0aW9uLnZhbHVlID0gbGlnaHRzLmhlbWkucG9zaXRpb25zO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNTaGFkb3cgKCB1bmlmb3JtcywgbGlnaHRzICkge1xyXG5cclxuXHRcdGlmICggdW5pZm9ybXMuc2hhZG93TWF0cml4ICkge1xyXG5cclxuXHRcdFx0dmFyIGogPSAwO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGxpZ2h0ID0gbGlnaHRzWyBpIF07XHJcblxyXG5cdFx0XHRcdGlmICggISBsaWdodC5jYXN0U2hhZG93ICkgY29udGludWU7XHJcblxyXG5cdFx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgfHwgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgJiYgISBsaWdodC5zaGFkb3dDYXNjYWRlICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybXMuc2hhZG93TWFwLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXA7XHJcblx0XHRcdFx0XHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dNYXBTaXplO1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd01hdHJpeC52YWx1ZVsgaiBdID0gbGlnaHQuc2hhZG93TWF0cml4O1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0RhcmtuZXNzLnZhbHVlWyBqIF0gPSBsaWdodC5zaGFkb3dEYXJrbmVzcztcclxuXHRcdFx0XHRcdHVuaWZvcm1zLnNoYWRvd0JpYXMudmFsdWVbIGogXSA9IGxpZ2h0LnNoYWRvd0JpYXM7XHJcblxyXG5cdFx0XHRcdFx0aiArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8gVW5pZm9ybXMgKGxvYWQgdG8gR1BVKVxyXG5cclxuXHRmdW5jdGlvbiBsb2FkVW5pZm9ybXNNYXRyaWNlcyAoIHVuaWZvcm1zLCBvYmplY3QgKSB7XHJcblxyXG5cdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIG9iamVjdC5fbW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0aWYgKCB1bmlmb3Jtcy5ub3JtYWxNYXRyaXggKSB7XHJcblxyXG5cdFx0XHRfZ2wudW5pZm9ybU1hdHJpeDNmdiggdW5pZm9ybXMubm9ybWFsTWF0cml4LCBmYWxzZSwgb2JqZWN0Ll9ub3JtYWxNYXRyaXguZWxlbWVudHMgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGdldFRleHR1cmVVbml0KCkge1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlVW5pdCA9IF91c2VkVGV4dHVyZVVuaXRzO1xyXG5cclxuXHRcdGlmICggdGV4dHVyZVVuaXQgPj0gX21heFRleHR1cmVzICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKCBcIldlYkdMUmVuZGVyZXI6IHRyeWluZyB0byB1c2UgXCIgKyB0ZXh0dXJlVW5pdCArIFwiIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSBcIiArIF9tYXhUZXh0dXJlcyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfdXNlZFRleHR1cmVVbml0cyArPSAxO1xyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlVW5pdDtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gbG9hZFVuaWZvcm1zR2VuZXJpYyAoIHByb2dyYW0sIHVuaWZvcm1zICkge1xyXG5cclxuXHRcdHZhciB1bmlmb3JtLCB2YWx1ZSwgdHlwZSwgbG9jYXRpb24sIHRleHR1cmUsIHRleHR1cmVVbml0LCBpLCBpbCwgaiwgamwsIG9mZnNldDtcclxuXHJcblx0XHRmb3IgKCBqID0gMCwgamwgPSB1bmlmb3Jtcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdGxvY2F0aW9uID0gcHJvZ3JhbS51bmlmb3Jtc1sgdW5pZm9ybXNbIGogXVsgMSBdIF07XHJcblx0XHRcdGlmICggIWxvY2F0aW9uICkgY29udGludWU7XHJcblxyXG5cdFx0XHR1bmlmb3JtID0gdW5pZm9ybXNbIGogXVsgMCBdO1xyXG5cclxuXHRcdFx0dHlwZSA9IHVuaWZvcm0udHlwZTtcclxuXHRcdFx0dmFsdWUgPSB1bmlmb3JtLnZhbHVlO1xyXG5cclxuXHRcdFx0aWYgKCB0eXBlID09PSBcImlcIiApIHsgLy8gc2luZ2xlIGludGVnZXJcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImZcIiApIHsgLy8gc2luZ2xlIGZsb2F0XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ2MlwiICkgeyAvLyBzaW5nbGUgVEhSRUUuVmVjdG9yMlxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTJmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ2M1wiICkgeyAvLyBzaW5nbGUgVEhSRUUuVmVjdG9yM1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ2NFwiICkgeyAvLyBzaW5nbGUgVEhSRUUuVmVjdG9yNFxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTRmKCBsb2NhdGlvbiwgdmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJjXCIgKSB7IC8vIHNpbmdsZSBUSFJFRS5Db2xvclxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTNmKCBsb2NhdGlvbiwgdmFsdWUuciwgdmFsdWUuZywgdmFsdWUuYiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJpdjFcIiApIHsgLy8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWl2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiaXZcIiApIHsgLy8gZmxhdCBhcnJheSBvZiBpbnRlZ2VycyB3aXRoIDMgeCBOIHNpemUgKEpTIG9yIHR5cGVkIGFycmF5KVxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTNpdiggbG9jYXRpb24sIHZhbHVlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcImZ2MVwiICkgeyAvLyBmbGF0IGFycmF5IG9mIGZsb2F0cyAoSlMgb3IgdHlwZWQgYXJyYXkpXHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWZ2KCBsb2NhdGlvbiwgdmFsdWUgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZnZcIiApIHsgLy8gZmxhdCBhcnJheSBvZiBmbG9hdHMgd2l0aCAzIHggTiBzaXplIChKUyBvciB0eXBlZCBhcnJheSlcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0zZnYoIGxvY2F0aW9uLCB2YWx1ZSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ2MnZcIiApIHsgLy8gYXJyYXkgb2YgVEhSRUUuVmVjdG9yMlxyXG5cclxuXHRcdFx0XHRpZiAoIHVuaWZvcm0uX2FycmF5ID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCAyICogdmFsdWUubGVuZ3RoICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggaSA9IDAsIGlsID0gdmFsdWUubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2Zmc2V0ID0gaSAqIDI7XHJcblxyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCBdIFx0ID0gdmFsdWVbIGkgXS54O1xyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDEgXSA9IHZhbHVlWyBpIF0ueTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTJmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcInYzdlwiICkgeyAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3IzXHJcblxyXG5cdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDMgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRvZmZzZXQgPSBpICogMztcclxuXHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0IF0gXHQgPSB2YWx1ZVsgaSBdLng7XHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlWyBpIF0uejtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTNmdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcInY0dlwiICkgeyAvLyBhcnJheSBvZiBUSFJFRS5WZWN0b3I0XHJcblxyXG5cdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDQgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRvZmZzZXQgPSBpICogNDtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0IF0gXHQgPSB2YWx1ZVsgaSBdLng7XHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgb2Zmc2V0ICsgMSBdID0gdmFsdWVbIGkgXS55O1xyXG5cdFx0XHRcdFx0dW5pZm9ybS5fYXJyYXlbIG9mZnNldCArIDIgXSA9IHZhbHVlWyBpIF0uejtcclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5WyBvZmZzZXQgKyAzIF0gPSB2YWx1ZVsgaSBdLnc7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm00ZnYoIGxvY2F0aW9uLCB1bmlmb3JtLl9hcnJheSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJtNFwiKSB7IC8vIHNpbmdsZSBUSFJFRS5NYXRyaXg0XHJcblxyXG5cdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIDE2ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFsdWUuZmxhdHRlblRvQXJyYXkoIHVuaWZvcm0uX2FycmF5ICk7XHJcblx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5fYXJyYXkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwibTR2XCIgKSB7IC8vIGFycmF5IG9mIFRIUkVFLk1hdHJpeDRcclxuXHJcblx0XHRcdFx0aWYgKCB1bmlmb3JtLl9hcnJheSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdHVuaWZvcm0uX2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKiB2YWx1ZS5sZW5ndGggKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBpID0gMCwgaWwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YWx1ZVsgaSBdLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCB1bmlmb3JtLl9hcnJheSwgaSAqIDE2ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIGxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5fYXJyYXkgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidFwiICkgeyAvLyBzaW5nbGUgVEhSRUUuVGV4dHVyZSAoMmQgb3IgY3ViZSlcclxuXHJcblx0XHRcdFx0dGV4dHVyZSA9IHZhbHVlO1xyXG5cdFx0XHRcdHRleHR1cmVVbml0ID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xaSggbG9jYXRpb24sIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdGlmICggIXRleHR1cmUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmltYWdlIGluc3RhbmNlb2YgQXJyYXkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q3ViZVRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q3ViZVRleHR1cmVEeW5hbWljKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF90aGlzLnNldFRleHR1cmUoIHRleHR1cmUsIHRleHR1cmVVbml0ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwidHZcIiApIHsgLy8gYXJyYXkgb2YgVEhSRUUuVGV4dHVyZSAoMmQpXHJcblxyXG5cdFx0XHRcdGlmICggdW5pZm9ybS5fYXJyYXkgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheSA9IFtdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZvciggaSA9IDAsIGlsID0gdW5pZm9ybS52YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR1bmlmb3JtLl9hcnJheVsgaSBdID0gZ2V0VGV4dHVyZVVuaXQoKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFpdiggbG9jYXRpb24sIHVuaWZvcm0uX2FycmF5ICk7XHJcblxyXG5cdFx0XHRcdGZvciggaSA9IDAsIGlsID0gdW5pZm9ybS52YWx1ZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlID0gdW5pZm9ybS52YWx1ZVsgaSBdO1xyXG5cdFx0XHRcdFx0dGV4dHVyZVVuaXQgPSB1bmlmb3JtLl9hcnJheVsgaSBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggIXRleHR1cmUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5zZXRUZXh0dXJlKCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXR1cE1hdHJpY2VzICggb2JqZWN0LCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0b2JqZWN0Ll9ub3JtYWxNYXRyaXguZ2V0SW52ZXJzZSggb2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXggKTtcclxuXHRcdG9iamVjdC5fbm9ybWFsTWF0cml4LnRyYW5zcG9zZSgpO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvL1xyXG5cclxuXHRmdW5jdGlvbiBzZXRDb2xvckdhbW1hKCBhcnJheSwgb2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5U3EgKSB7XHJcblxyXG5cdFx0YXJyYXlbIG9mZnNldCBdICAgICA9IGNvbG9yLnIgKiBjb2xvci5yICogaW50ZW5zaXR5U3E7XHJcblx0XHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gY29sb3IuZyAqIGNvbG9yLmcgKiBpbnRlbnNpdHlTcTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSBjb2xvci5iICogY29sb3IuYiAqIGludGVuc2l0eVNxO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRDb2xvckxpbmVhciggYXJyYXksIG9mZnNldCwgY29sb3IsIGludGVuc2l0eSApIHtcclxuXHJcblx0XHRhcnJheVsgb2Zmc2V0IF0gICAgID0gY29sb3IuciAqIGludGVuc2l0eTtcclxuXHRcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSBjb2xvci5nICogaW50ZW5zaXR5O1xyXG5cdFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IGNvbG9yLmIgKiBpbnRlbnNpdHk7XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldHVwTGlnaHRzICggcHJvZ3JhbSwgbGlnaHRzICkge1xyXG5cclxuXHRcdHZhciBsLCBsbCwgbGlnaHQsIG4sXHJcblx0XHRyID0gMCwgZyA9IDAsIGIgPSAwLFxyXG5cdFx0Y29sb3IsIHNreUNvbG9yLCBncm91bmRDb2xvcixcclxuXHRcdGludGVuc2l0eSwgIGludGVuc2l0eVNxLFxyXG5cdFx0cG9zaXRpb24sXHJcblx0XHRkaXN0YW5jZSxcclxuXHJcblx0XHR6bGlnaHRzID0gX2xpZ2h0cyxcclxuXHJcblx0XHRkaXJDb2xvcnMgPSB6bGlnaHRzLmRpcmVjdGlvbmFsLmNvbG9ycyxcclxuXHRcdGRpclBvc2l0aW9ucyA9IHpsaWdodHMuZGlyZWN0aW9uYWwucG9zaXRpb25zLFxyXG5cclxuXHRcdHBvaW50Q29sb3JzID0gemxpZ2h0cy5wb2ludC5jb2xvcnMsXHJcblx0XHRwb2ludFBvc2l0aW9ucyA9IHpsaWdodHMucG9pbnQucG9zaXRpb25zLFxyXG5cdFx0cG9pbnREaXN0YW5jZXMgPSB6bGlnaHRzLnBvaW50LmRpc3RhbmNlcyxcclxuXHJcblx0XHRzcG90Q29sb3JzID0gemxpZ2h0cy5zcG90LmNvbG9ycyxcclxuXHRcdHNwb3RQb3NpdGlvbnMgPSB6bGlnaHRzLnNwb3QucG9zaXRpb25zLFxyXG5cdFx0c3BvdERpc3RhbmNlcyA9IHpsaWdodHMuc3BvdC5kaXN0YW5jZXMsXHJcblx0XHRzcG90RGlyZWN0aW9ucyA9IHpsaWdodHMuc3BvdC5kaXJlY3Rpb25zLFxyXG5cdFx0c3BvdEFuZ2xlc0NvcyA9IHpsaWdodHMuc3BvdC5hbmdsZXNDb3MsXHJcblx0XHRzcG90RXhwb25lbnRzID0gemxpZ2h0cy5zcG90LmV4cG9uZW50cyxcclxuXHJcblx0XHRoZW1pU2t5Q29sb3JzID0gemxpZ2h0cy5oZW1pLnNreUNvbG9ycyxcclxuXHRcdGhlbWlHcm91bmRDb2xvcnMgPSB6bGlnaHRzLmhlbWkuZ3JvdW5kQ29sb3JzLFxyXG5cdFx0aGVtaVBvc2l0aW9ucyA9IHpsaWdodHMuaGVtaS5wb3NpdGlvbnMsXHJcblxyXG5cdFx0ZGlyTGVuZ3RoID0gMCxcclxuXHRcdHBvaW50TGVuZ3RoID0gMCxcclxuXHRcdHNwb3RMZW5ndGggPSAwLFxyXG5cdFx0aGVtaUxlbmd0aCA9IDAsXHJcblxyXG5cdFx0ZGlyQ291bnQgPSAwLFxyXG5cdFx0cG9pbnRDb3VudCA9IDAsXHJcblx0XHRzcG90Q291bnQgPSAwLFxyXG5cdFx0aGVtaUNvdW50ID0gMCxcclxuXHJcblx0XHRkaXJPZmZzZXQgPSAwLFxyXG5cdFx0cG9pbnRPZmZzZXQgPSAwLFxyXG5cdFx0c3BvdE9mZnNldCA9IDAsXHJcblx0XHRoZW1pT2Zmc2V0ID0gMDtcclxuXHJcblx0XHRmb3IgKCBsID0gMCwgbGwgPSBsaWdodHMubGVuZ3RoOyBsIDwgbGw7IGwgKysgKSB7XHJcblxyXG5cdFx0XHRsaWdodCA9IGxpZ2h0c1sgbCBdO1xyXG5cclxuXHRcdFx0aWYgKCBsaWdodC5vbmx5U2hhZG93ICkgY29udGludWU7XHJcblxyXG5cdFx0XHRjb2xvciA9IGxpZ2h0LmNvbG9yO1xyXG5cdFx0XHRpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XHJcblx0XHRcdGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuQW1iaWVudExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0ciArPSBjb2xvci5yICogY29sb3IucjtcclxuXHRcdFx0XHRcdGcgKz0gY29sb3IuZyAqIGNvbG9yLmc7XHJcblx0XHRcdFx0XHRiICs9IGNvbG9yLmIgKiBjb2xvci5iO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHIgKz0gY29sb3IucjtcclxuXHRcdFx0XHRcdGcgKz0gY29sb3IuZztcclxuXHRcdFx0XHRcdGIgKz0gY29sb3IuYjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5EaXJlY3Rpb25hbExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRkaXJDb3VudCArPSAxO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRfZGlyZWN0aW9uLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfdmVjdG9yMy5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xyXG5cdFx0XHRcdF9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdC8vIHNraXAgbGlnaHRzIHdpdGggdW5kZWZpbmVkIGRpcmVjdGlvblxyXG5cdFx0XHRcdC8vIHRoZXNlIGNyZWF0ZSB0cm91YmxlcyBpbiBPcGVuR0wgKG1ha2luZyBwaXhlbCBibGFjaylcclxuXHJcblx0XHRcdFx0aWYgKCBfZGlyZWN0aW9uLnggPT09IDAgJiYgX2RpcmVjdGlvbi55ID09PSAwICYmIF9kaXJlY3Rpb24ueiA9PT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRkaXJPZmZzZXQgPSBkaXJMZW5ndGggKiAzO1xyXG5cclxuXHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCBdICAgICA9IF9kaXJlY3Rpb24ueDtcclxuXHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDEgXSA9IF9kaXJlY3Rpb24ueTtcclxuXHRcdFx0XHRkaXJQb3NpdGlvbnNbIGRpck9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcclxuXHJcblx0XHRcdFx0aWYgKCBfdGhpcy5nYW1tYUlucHV0ICkge1xyXG5cclxuXHRcdFx0XHRcdHNldENvbG9yR2FtbWEoIGRpckNvbG9ycywgZGlyT2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICogaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIGRpckNvbG9ycywgZGlyT2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0ZGlyTGVuZ3RoICs9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLlBvaW50TGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdHBvaW50Q291bnQgKz0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0cG9pbnRPZmZzZXQgPSBwb2ludExlbmd0aCAqIDM7XHJcblxyXG5cdFx0XHRcdGlmICggX3RoaXMuZ2FtbWFJbnB1dCApIHtcclxuXHJcblx0XHRcdFx0XHRzZXRDb2xvckdhbW1hKCBwb2ludENvbG9ycywgcG9pbnRPZmZzZXQsIGNvbG9yLCBpbnRlbnNpdHkgKiBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggcG9pbnRDb2xvcnMsIHBvaW50T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRwb2ludFBvc2l0aW9uc1sgcG9pbnRPZmZzZXQgXSAgICAgPSBfdmVjdG9yMy54O1xyXG5cdFx0XHRcdHBvaW50UG9zaXRpb25zWyBwb2ludE9mZnNldCArIDEgXSA9IF92ZWN0b3IzLnk7XHJcblx0XHRcdFx0cG9pbnRQb3NpdGlvbnNbIHBvaW50T2Zmc2V0ICsgMiBdID0gX3ZlY3RvcjMuejtcclxuXHJcblx0XHRcdFx0cG9pbnREaXN0YW5jZXNbIHBvaW50TGVuZ3RoIF0gPSBkaXN0YW5jZTtcclxuXHJcblx0XHRcdFx0cG9pbnRMZW5ndGggKz0gMTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRzcG90Q291bnQgKz0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCAhIGxpZ2h0LnZpc2libGUgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0c3BvdE9mZnNldCA9IHNwb3RMZW5ndGggKiAzO1xyXG5cclxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q29sb3JHYW1tYSggc3BvdENvbG9ycywgc3BvdE9mZnNldCwgY29sb3IsIGludGVuc2l0eSAqIGludGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHNldENvbG9yTGluZWFyKCBzcG90Q29sb3JzLCBzcG90T2Zmc2V0LCBjb2xvciwgaW50ZW5zaXR5ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0X3ZlY3RvcjMuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCBsaWdodC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0IF0gICAgID0gX3ZlY3RvcjMueDtcclxuXHRcdFx0XHRzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX3ZlY3RvcjMueTtcclxuXHRcdFx0XHRzcG90UG9zaXRpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX3ZlY3RvcjMuejtcclxuXHJcblx0XHRcdFx0c3BvdERpc3RhbmNlc1sgc3BvdExlbmd0aCBdID0gZGlzdGFuY2U7XHJcblxyXG5cdFx0XHRcdF9kaXJlY3Rpb24uY29weSggX3ZlY3RvcjMgKTtcclxuXHRcdFx0XHRfdmVjdG9yMy5nZXRQb3NpdGlvbkZyb21NYXRyaXgoIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdF9kaXJlY3Rpb24uc3ViKCBfdmVjdG9yMyApO1xyXG5cdFx0XHRcdF9kaXJlY3Rpb24ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0IF0gICAgID0gX2RpcmVjdGlvbi54O1xyXG5cdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMSBdID0gX2RpcmVjdGlvbi55O1xyXG5cdFx0XHRcdHNwb3REaXJlY3Rpb25zWyBzcG90T2Zmc2V0ICsgMiBdID0gX2RpcmVjdGlvbi56O1xyXG5cclxuXHRcdFx0XHRzcG90QW5nbGVzQ29zWyBzcG90TGVuZ3RoIF0gPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKTtcclxuXHRcdFx0XHRzcG90RXhwb25lbnRzWyBzcG90TGVuZ3RoIF0gPSBsaWdodC5leHBvbmVudDtcclxuXHJcblx0XHRcdFx0c3BvdExlbmd0aCArPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5IZW1pc3BoZXJlTGlnaHQgKSB7XHJcblxyXG5cdFx0XHRcdGhlbWlDb3VudCArPSAxO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgbGlnaHQudmlzaWJsZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRfZGlyZWN0aW9uLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0XHRfZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHQvLyBza2lwIGxpZ2h0cyB3aXRoIHVuZGVmaW5lZCBkaXJlY3Rpb25cclxuXHRcdFx0XHQvLyB0aGVzZSBjcmVhdGUgdHJvdWJsZXMgaW4gT3BlbkdMIChtYWtpbmcgcGl4ZWwgYmxhY2spXHJcblxyXG5cdFx0XHRcdGlmICggX2RpcmVjdGlvbi54ID09PSAwICYmIF9kaXJlY3Rpb24ueSA9PT0gMCAmJiBfZGlyZWN0aW9uLnogPT09IDAgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdFx0aGVtaU9mZnNldCA9IGhlbWlMZW5ndGggKiAzO1xyXG5cclxuXHRcdFx0XHRoZW1pUG9zaXRpb25zWyBoZW1pT2Zmc2V0IF0gICAgID0gX2RpcmVjdGlvbi54O1xyXG5cdFx0XHRcdGhlbWlQb3NpdGlvbnNbIGhlbWlPZmZzZXQgKyAxIF0gPSBfZGlyZWN0aW9uLnk7XHJcblx0XHRcdFx0aGVtaVBvc2l0aW9uc1sgaGVtaU9mZnNldCArIDIgXSA9IF9kaXJlY3Rpb24uejtcclxuXHJcblx0XHRcdFx0c2t5Q29sb3IgPSBsaWdodC5jb2xvcjtcclxuXHRcdFx0XHRncm91bmRDb2xvciA9IGxpZ2h0Lmdyb3VuZENvbG9yO1xyXG5cclxuXHRcdFx0XHRpZiAoIF90aGlzLmdhbW1hSW5wdXQgKSB7XHJcblxyXG5cdFx0XHRcdFx0aW50ZW5zaXR5U3EgPSBpbnRlbnNpdHkgKiBpbnRlbnNpdHk7XHJcblxyXG5cdFx0XHRcdFx0c2V0Q29sb3JHYW1tYSggaGVtaVNreUNvbG9ycywgaGVtaU9mZnNldCwgc2t5Q29sb3IsIGludGVuc2l0eVNxICk7XHJcblx0XHRcdFx0XHRzZXRDb2xvckdhbW1hKCBoZW1pR3JvdW5kQ29sb3JzLCBoZW1pT2Zmc2V0LCBncm91bmRDb2xvciwgaW50ZW5zaXR5U3EgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRzZXRDb2xvckxpbmVhciggaGVtaVNreUNvbG9ycywgaGVtaU9mZnNldCwgc2t5Q29sb3IsIGludGVuc2l0eSApO1xyXG5cdFx0XHRcdFx0c2V0Q29sb3JMaW5lYXIoIGhlbWlHcm91bmRDb2xvcnMsIGhlbWlPZmZzZXQsIGdyb3VuZENvbG9yLCBpbnRlbnNpdHkgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRoZW1pTGVuZ3RoICs9IDE7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG51bGwgZXZlbnR1YWwgcmVtYWlucyBmcm9tIHJlbW92ZWQgbGlnaHRzXHJcblx0XHQvLyAodGhpcyBpcyB0byBhdm9pZCBpZiBpbiBzaGFkZXIpXHJcblxyXG5cdFx0Zm9yICggbCA9IGRpckxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGRpckNvbG9ycy5sZW5ndGgsIGRpckNvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBkaXJDb2xvcnNbIGwgXSA9IDAuMDtcclxuXHRcdGZvciAoIGwgPSBwb2ludExlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIHBvaW50Q29sb3JzLmxlbmd0aCwgcG9pbnRDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgcG9pbnRDb2xvcnNbIGwgXSA9IDAuMDtcclxuXHRcdGZvciAoIGwgPSBzcG90TGVuZ3RoICogMywgbGwgPSBNYXRoLm1heCggc3BvdENvbG9ycy5sZW5ndGgsIHNwb3RDb3VudCAqIDMgKTsgbCA8IGxsOyBsICsrICkgc3BvdENvbG9yc1sgbCBdID0gMC4wO1xyXG5cdFx0Zm9yICggbCA9IGhlbWlMZW5ndGggKiAzLCBsbCA9IE1hdGgubWF4KCBoZW1pU2t5Q29sb3JzLmxlbmd0aCwgaGVtaUNvdW50ICogMyApOyBsIDwgbGw7IGwgKysgKSBoZW1pU2t5Q29sb3JzWyBsIF0gPSAwLjA7XHJcblx0XHRmb3IgKCBsID0gaGVtaUxlbmd0aCAqIDMsIGxsID0gTWF0aC5tYXgoIGhlbWlHcm91bmRDb2xvcnMubGVuZ3RoLCBoZW1pQ291bnQgKiAzICk7IGwgPCBsbDsgbCArKyApIGhlbWlHcm91bmRDb2xvcnNbIGwgXSA9IDAuMDtcclxuXHJcblx0XHR6bGlnaHRzLmRpcmVjdGlvbmFsLmxlbmd0aCA9IGRpckxlbmd0aDtcclxuXHRcdHpsaWdodHMucG9pbnQubGVuZ3RoID0gcG9pbnRMZW5ndGg7XHJcblx0XHR6bGlnaHRzLnNwb3QubGVuZ3RoID0gc3BvdExlbmd0aDtcclxuXHRcdHpsaWdodHMuaGVtaS5sZW5ndGggPSBoZW1pTGVuZ3RoO1xyXG5cclxuXHRcdHpsaWdodHMuYW1iaWVudFsgMCBdID0gcjtcclxuXHRcdHpsaWdodHMuYW1iaWVudFsgMSBdID0gZztcclxuXHRcdHpsaWdodHMuYW1iaWVudFsgMiBdID0gYjtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gR0wgc3RhdGUgc2V0dGluZ1xyXG5cclxuXHR0aGlzLnNldEZhY2VDdWxsaW5nID0gZnVuY3Rpb24gKCBjdWxsRmFjZSwgZnJvbnRGYWNlRGlyZWN0aW9uICkge1xyXG5cclxuXHRcdGlmICggY3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlTm9uZSApIHtcclxuXHJcblx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlmICggZnJvbnRGYWNlRGlyZWN0aW9uID09PSBUSFJFRS5Gcm9udEZhY2VEaXJlY3Rpb25DVyApIHtcclxuXHJcblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNXICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wuZnJvbnRGYWNlKCBfZ2wuQ0NXICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUJhY2sgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5GUk9OVCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0TWF0ZXJpYWxGYWNlcyA9IGZ1bmN0aW9uICggbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0dmFyIGRvdWJsZVNpZGVkID0gbWF0ZXJpYWwuc2lkZSA9PT0gVEhSRUUuRG91YmxlU2lkZTtcclxuXHRcdHZhciBmbGlwU2lkZWQgPSBtYXRlcmlhbC5zaWRlID09PSBUSFJFRS5CYWNrU2lkZTtcclxuXHJcblx0XHRpZiAoIF9vbGREb3VibGVTaWRlZCAhPT0gZG91YmxlU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGRvdWJsZVNpZGVkICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGlzYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X29sZERvdWJsZVNpZGVkID0gZG91YmxlU2lkZWQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggX29sZEZsaXBTaWRlZCAhPT0gZmxpcFNpZGVkICkge1xyXG5cclxuXHRcdFx0aWYgKCBmbGlwU2lkZWQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DVyApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X29sZEZsaXBTaWRlZCA9IGZsaXBTaWRlZDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0RGVwdGhUZXN0ID0gZnVuY3Rpb24gKCBkZXB0aFRlc3QgKSB7XHJcblxyXG5cdFx0aWYgKCBfb2xkRGVwdGhUZXN0ICE9PSBkZXB0aFRlc3QgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGRlcHRoVGVzdCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmVuYWJsZSggX2dsLkRFUFRIX1RFU1QgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X29sZERlcHRoVGVzdCA9IGRlcHRoVGVzdDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0RGVwdGhXcml0ZSA9IGZ1bmN0aW9uICggZGVwdGhXcml0ZSApIHtcclxuXHJcblx0XHRpZiAoIF9vbGREZXB0aFdyaXRlICE9PSBkZXB0aFdyaXRlICkge1xyXG5cclxuXHRcdFx0X2dsLmRlcHRoTWFzayggZGVwdGhXcml0ZSApO1xyXG5cdFx0XHRfb2xkRGVwdGhXcml0ZSA9IGRlcHRoV3JpdGU7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRMaW5lV2lkdGggKCB3aWR0aCApIHtcclxuXHJcblx0XHRpZiAoIHdpZHRoICE9PSBfb2xkTGluZVdpZHRoICkge1xyXG5cclxuXHRcdFx0X2dsLmxpbmVXaWR0aCggd2lkdGggKTtcclxuXHJcblx0XHRcdF9vbGRMaW5lV2lkdGggPSB3aWR0aDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldFBvbHlnb25PZmZzZXQgKCBwb2x5Z29ub2Zmc2V0LCBmYWN0b3IsIHVuaXRzICkge1xyXG5cclxuXHRcdGlmICggX29sZFBvbHlnb25PZmZzZXQgIT09IHBvbHlnb25vZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHBvbHlnb25vZmZzZXQgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wuZGlzYWJsZSggX2dsLlBPTFlHT05fT0ZGU0VUX0ZJTEwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9vbGRQb2x5Z29uT2Zmc2V0ID0gcG9seWdvbm9mZnNldDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBwb2x5Z29ub2Zmc2V0ICYmICggX29sZFBvbHlnb25PZmZzZXRGYWN0b3IgIT09IGZhY3RvciB8fCBfb2xkUG9seWdvbk9mZnNldFVuaXRzICE9PSB1bml0cyApICkge1xyXG5cclxuXHRcdFx0X2dsLnBvbHlnb25PZmZzZXQoIGZhY3RvciwgdW5pdHMgKTtcclxuXHJcblx0XHRcdF9vbGRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gZmFjdG9yO1xyXG5cdFx0XHRfb2xkUG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnNldEJsZW5kaW5nID0gZnVuY3Rpb24gKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0ICkge1xyXG5cclxuXHRcdGlmICggYmxlbmRpbmcgIT09IF9vbGRCbGVuZGluZyApIHtcclxuXHJcblx0XHRcdGlmICggYmxlbmRpbmcgPT09IFRIUkVFLk5vQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5kaXNhYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5BZGRpdGl2ZUJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHRcdFx0XHRfZ2wuYmxlbmRFcXVhdGlvbiggX2dsLkZVTkNfQUREICk7XHJcblx0XHRcdFx0X2dsLmJsZW5kRnVuYyggX2dsLlNSQ19BTFBIQSwgX2dsLk9ORSApO1xyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggYmxlbmRpbmcgPT09IFRIUkVFLlN1YnRyYWN0aXZlQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRcdC8vIFRPRE86IEZpbmQgYmxlbmRGdW5jU2VwYXJhdGUoKSBjb21iaW5hdGlvblxyXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cdFx0XHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBfZ2wuRlVOQ19BREQgKTtcclxuXHRcdFx0XHRfZ2wuYmxlbmRGdW5jKCBfZ2wuWkVSTywgX2dsLk9ORV9NSU5VU19TUkNfQ09MT1IgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5NdWx0aXBseUJsZW5kaW5nICkge1xyXG5cclxuXHRcdFx0XHQvLyBUT0RPOiBGaW5kIGJsZW5kRnVuY1NlcGFyYXRlKCkgY29tYmluYXRpb25cclxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHRcdFx0XHRfZ2wuYmxlbmRFcXVhdGlvbiggX2dsLkZVTkNfQUREICk7XHJcblx0XHRcdFx0X2dsLmJsZW5kRnVuYyggX2dsLlpFUk8sIF9nbC5TUkNfQ09MT1IgKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIGJsZW5kaW5nID09PSBUSFJFRS5DdXN0b21CbGVuZGluZyApIHtcclxuXHJcblx0XHRcdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHRcdFx0XHRfZ2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBfZ2wuRlVOQ19BREQsIF9nbC5GVU5DX0FERCApO1xyXG5cdFx0XHRcdF9nbC5ibGVuZEZ1bmNTZXBhcmF0ZSggX2dsLlNSQ19BTFBIQSwgX2dsLk9ORV9NSU5VU19TUkNfQUxQSEEsIF9nbC5PTkUsIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRfb2xkQmxlbmRpbmcgPSBibGVuZGluZztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCBibGVuZGluZyA9PT0gVEhSRUUuQ3VzdG9tQmxlbmRpbmcgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGJsZW5kRXF1YXRpb24gIT09IF9vbGRCbGVuZEVxdWF0aW9uICkge1xyXG5cclxuXHRcdFx0XHRfZ2wuYmxlbmRFcXVhdGlvbiggcGFyYW1UaHJlZVRvR0woIGJsZW5kRXF1YXRpb24gKSApO1xyXG5cclxuXHRcdFx0XHRfb2xkQmxlbmRFcXVhdGlvbiA9IGJsZW5kRXF1YXRpb247XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGJsZW5kU3JjICE9PSBfb2xkQmxlbmRTcmMgfHwgYmxlbmREc3QgIT09IF9vbGRCbGVuZERzdCApIHtcclxuXHJcblx0XHRcdFx0X2dsLmJsZW5kRnVuYyggcGFyYW1UaHJlZVRvR0woIGJsZW5kU3JjICksIHBhcmFtVGhyZWVUb0dMKCBibGVuZERzdCApICk7XHJcblxyXG5cdFx0XHRcdF9vbGRCbGVuZFNyYyA9IGJsZW5kU3JjO1xyXG5cdFx0XHRcdF9vbGRCbGVuZERzdCA9IGJsZW5kRHN0O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfb2xkQmxlbmRFcXVhdGlvbiA9IG51bGw7XHJcblx0XHRcdF9vbGRCbGVuZFNyYyA9IG51bGw7XHJcblx0XHRcdF9vbGRCbGVuZERzdCA9IG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBEZWZpbmVzXHJcblxyXG5cdGZ1bmN0aW9uIGdlbmVyYXRlRGVmaW5lcyAoIGRlZmluZXMgKSB7XHJcblxyXG5cdFx0dmFyIHZhbHVlLCBjaHVuaywgY2h1bmtzID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGQgaW4gZGVmaW5lcyApIHtcclxuXHJcblx0XHRcdHZhbHVlID0gZGVmaW5lc1sgZCBdO1xyXG5cdFx0XHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0Y2h1bmsgPSBcIiNkZWZpbmUgXCIgKyBkICsgXCIgXCIgKyB2YWx1ZTtcclxuXHRcdFx0Y2h1bmtzLnB1c2goIGNodW5rICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjaHVua3Muam9pbiggXCJcXG5cIiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBTaGFkZXJzXHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkUHJvZ3JhbSAoIHNoYWRlcklELCBmcmFnbWVudFNoYWRlciwgdmVydGV4U2hhZGVyLCB1bmlmb3JtcywgYXR0cmlidXRlcywgZGVmaW5lcywgcGFyYW1ldGVycyApIHtcclxuXHJcblx0XHR2YXIgcCwgcGwsIGQsIHByb2dyYW0sIGNvZGU7XHJcblx0XHR2YXIgY2h1bmtzID0gW107XHJcblxyXG5cdFx0Ly8gR2VuZXJhdGUgY29kZVxyXG5cclxuXHRcdGlmICggc2hhZGVySUQgKSB7XHJcblxyXG5cdFx0XHRjaHVua3MucHVzaCggc2hhZGVySUQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Y2h1bmtzLnB1c2goIGZyYWdtZW50U2hhZGVyICk7XHJcblx0XHRcdGNodW5rcy5wdXNoKCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggZCBpbiBkZWZpbmVzICkge1xyXG5cclxuXHRcdFx0Y2h1bmtzLnB1c2goIGQgKTtcclxuXHRcdFx0Y2h1bmtzLnB1c2goIGRlZmluZXNbIGQgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBwIGluIHBhcmFtZXRlcnMgKSB7XHJcblxyXG5cdFx0XHRjaHVua3MucHVzaCggcCApO1xyXG5cdFx0XHRjaHVua3MucHVzaCggcGFyYW1ldGVyc1sgcCBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvZGUgPSBjaHVua3Muam9pbigpO1xyXG5cclxuXHRcdC8vIENoZWNrIGlmIGNvZGUgaGFzIGJlZW4gYWxyZWFkeSBjb21waWxlZFxyXG5cclxuXHRcdGZvciAoIHAgPSAwLCBwbCA9IF9wcm9ncmFtcy5sZW5ndGg7IHAgPCBwbDsgcCArKyApIHtcclxuXHJcblx0XHRcdHZhciBwcm9ncmFtSW5mbyA9IF9wcm9ncmFtc1sgcCBdO1xyXG5cclxuXHRcdFx0aWYgKCBwcm9ncmFtSW5mby5jb2RlID09PSBjb2RlICkge1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCBcIkNvZGUgYWxyZWFkeSBjb21waWxlZC5cIiAvKjogXFxuXFxuXCIgKyBjb2RlKi8gKTtcclxuXHJcblx0XHRcdFx0cHJvZ3JhbUluZm8udXNlZFRpbWVzICsrO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcHJvZ3JhbUluZm8ucHJvZ3JhbTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNoYWRvd01hcFR5cGVEZWZpbmUgPSBcIlNIQURPV01BUF9UWVBFX0JBU0lDXCI7XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNoYWRvd01hcCApIHtcclxuXHJcblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSBcIlNIQURPV01BUF9UWVBFX1BDRlwiO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gVEhSRUUuUENGU29mdFNoYWRvd01hcCApIHtcclxuXHJcblx0XHRcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSBcIlNIQURPV01BUF9UWVBFX1BDRl9TT0ZUXCI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vY29uc29sZS5sb2coIFwiYnVpbGRpbmcgbmV3IHByb2dyYW0gXCIgKTtcclxuXHJcblx0XHQvL1xyXG5cclxuXHRcdHZhciBjdXN0b21EZWZpbmVzID0gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICk7XHJcblxyXG5cdFx0Ly9cclxuXHJcblx0XHRwcm9ncmFtID0gX2dsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcblx0XHR2YXIgcHJlZml4X3ZlcnRleCA9IFtcclxuXHJcblx0XHRcdFwicHJlY2lzaW9uIFwiICsgX3ByZWNpc2lvbiArIFwiIGZsb2F0O1wiLFxyXG5cclxuXHRcdFx0Y3VzdG9tRGVmaW5lcyxcclxuXHJcblx0XHRcdF9zdXBwb3J0c1ZlcnRleFRleHR1cmVzID8gXCIjZGVmaW5lIFZFUlRFWF9URVhUVVJFU1wiIDogXCJcIixcclxuXHJcblx0XHRcdF90aGlzLmdhbW1hSW5wdXQgPyBcIiNkZWZpbmUgR0FNTUFfSU5QVVRcIiA6IFwiXCIsXHJcblx0XHRcdF90aGlzLmdhbW1hT3V0cHV0ID8gXCIjZGVmaW5lIEdBTU1BX09VVFBVVFwiIDogXCJcIixcclxuXHRcdFx0X3RoaXMucGh5c2ljYWxseUJhc2VkU2hhZGluZyA/IFwiI2RlZmluZSBQSFlTSUNBTExZX0JBU0VEX1NIQURJTkdcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX1NQT1RfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX0hFTUlfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxyXG5cclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9TSEFET1dTIFwiICsgcGFyYW1ldGVycy5tYXhTaGFkb3dzLFxyXG5cclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9CT05FUyBcIiArIHBhcmFtZXRlcnMubWF4Qm9uZXMsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLm1hcCA/IFwiI2RlZmluZSBVU0VfTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmVudk1hcCA/IFwiI2RlZmluZSBVU0VfRU5WTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gXCIjZGVmaW5lIFVTRV9MSUdIVE1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5idW1wTWFwID8gXCIjZGVmaW5lIFVTRV9CVU1QTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/IFwiI2RlZmluZSBVU0VfTk9STUFMTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNwZWN1bGFyTWFwID8gXCIjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyBcIiNkZWZpbmUgVVNFX0NPTE9SXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5za2lubmluZyA/IFwiI2RlZmluZSBVU0VfU0tJTk5JTkdcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSA/IFwiI2RlZmluZSBCT05FX1RFWFRVUkVcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuYm9uZVRleHR1cmVXaWR0aCA/IFwiI2RlZmluZSBOX0JPTkVfUElYRUxfWCBcIiArIHBhcmFtZXRlcnMuYm9uZVRleHR1cmVXaWR0aC50b0ZpeGVkKCAxICkgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmJvbmVUZXh0dXJlSGVpZ2h0ID8gXCIjZGVmaW5lIE5fQk9ORV9QSVhFTF9ZIFwiICsgcGFyYW1ldGVycy5ib25lVGV4dHVyZUhlaWdodC50b0ZpeGVkKCAxICkgOiBcIlwiLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5tb3JwaFRhcmdldHMgPyBcIiNkZWZpbmUgVVNFX01PUlBIVEFSR0VUU1wiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgPyBcIiNkZWZpbmUgVVNFX01PUlBITk9STUFMU1wiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5wZXJQaXhlbCA/IFwiI2RlZmluZSBQSE9OR19QRVJfUElYRUxcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMud3JhcEFyb3VuZCA/IFwiI2RlZmluZSBXUkFQX0FST1VORFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/IFwiI2RlZmluZSBET1VCTEVfU0lERURcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuZmxpcFNpZGVkID8gXCIjZGVmaW5lIEZMSVBfU0lERURcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyBcIiNkZWZpbmUgVVNFX1NIQURPV01BUFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gXCIjZGVmaW5lIFwiICsgc2hhZG93TWFwVHlwZURlZmluZSA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRGVidWcgPyBcIiNkZWZpbmUgU0hBRE9XTUFQX0RFQlVHXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcENhc2NhZGUgPyBcIiNkZWZpbmUgU0hBRE9XTUFQX0NBU0NBREVcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNpemVBdHRlbnVhdGlvbiA/IFwiI2RlZmluZSBVU0VfU0laRUFUVEVOVUFUSU9OXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXHJcblx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbm9ybWFsO1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2MjtcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFVTRV9DT0xPUlwiLFxyXG5cclxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcIixcclxuXHJcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDA7XCIsXHJcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDE7XCIsXHJcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7XCIsXHJcblx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDM7XCIsXHJcblxyXG5cdFx0XHRcdFwiI2lmZGVmIFVTRV9NT1JQSE5PUk1BTFNcIixcclxuXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMDtcIixcclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwxO1wiLFxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDI7XCIsXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMztcIixcclxuXHJcblx0XHRcdFx0XCIjZWxzZVwiLFxyXG5cclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0O1wiLFxyXG5cdFx0XHRcdFx0XCJhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDU7XCIsXHJcblx0XHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NjtcIixcclxuXHRcdFx0XHRcdFwiYXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3O1wiLFxyXG5cclxuXHRcdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCIjZW5kaWZcIixcclxuXHJcblx0XHRcdFwiI2lmZGVmIFVTRV9TS0lOTklOR1wiLFxyXG5cclxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWM0IHNraW5JbmRleDtcIixcclxuXHRcdFx0XHRcImF0dHJpYnV0ZSB2ZWM0IHNraW5XZWlnaHQ7XCIsXHJcblxyXG5cdFx0XHRcIiNlbmRpZlwiLFxyXG5cclxuXHRcdFx0XCJcIlxyXG5cclxuXHRcdF0uam9pbihcIlxcblwiKTtcclxuXHJcblx0XHR2YXIgcHJlZml4X2ZyYWdtZW50ID0gW1xyXG5cclxuXHRcdFx0XCJwcmVjaXNpb24gXCIgKyBfcHJlY2lzaW9uICsgXCIgZmxvYXQ7XCIsXHJcblxyXG5cdFx0XHQoIHBhcmFtZXRlcnMuYnVtcE1hcCB8fCBwYXJhbWV0ZXJzLm5vcm1hbE1hcCApID8gXCIjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVwiIDogXCJcIixcclxuXHJcblx0XHRcdGN1c3RvbURlZmluZXMsXHJcblxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX0RJUl9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heERpckxpZ2h0cyxcclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9QT0lOVF9MSUdIVFMgXCIgKyBwYXJhbWV0ZXJzLm1heFBvaW50TGlnaHRzLFxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX1NQT1RfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhTcG90TGlnaHRzLFxyXG5cdFx0XHRcIiNkZWZpbmUgTUFYX0hFTUlfTElHSFRTIFwiICsgcGFyYW1ldGVycy5tYXhIZW1pTGlnaHRzLFxyXG5cclxuXHRcdFx0XCIjZGVmaW5lIE1BWF9TSEFET1dTIFwiICsgcGFyYW1ldGVycy5tYXhTaGFkb3dzLFxyXG5cclxuXHRcdFx0cGFyYW1ldGVycy5hbHBoYVRlc3QgPyBcIiNkZWZpbmUgQUxQSEFURVNUIFwiICsgcGFyYW1ldGVycy5hbHBoYVRlc3Q6IFwiXCIsXHJcblxyXG5cdFx0XHRfdGhpcy5nYW1tYUlucHV0ID8gXCIjZGVmaW5lIEdBTU1BX0lOUFVUXCIgOiBcIlwiLFxyXG5cdFx0XHRfdGhpcy5nYW1tYU91dHB1dCA/IFwiI2RlZmluZSBHQU1NQV9PVVRQVVRcIiA6IFwiXCIsXHJcblx0XHRcdF90aGlzLnBoeXNpY2FsbHlCYXNlZFNoYWRpbmcgPyBcIiNkZWZpbmUgUEhZU0lDQUxMWV9CQVNFRF9TSEFESU5HXCIgOiBcIlwiLFxyXG5cclxuXHRcdFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gXCIjZGVmaW5lIFVTRV9GT0dcIiA6IFwiXCIsXHJcblx0XHRcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAgKSA/IFwiI2RlZmluZSBGT0dfRVhQMlwiIDogXCJcIixcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMubWFwID8gXCIjZGVmaW5lIFVTRV9NQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuZW52TWFwID8gXCIjZGVmaW5lIFVTRV9FTlZNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMubGlnaHRNYXAgPyBcIiNkZWZpbmUgVVNFX0xJR0hUTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyBcIiNkZWZpbmUgVVNFX0JVTVBNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMubm9ybWFsTWFwID8gXCIjZGVmaW5lIFVTRV9OT1JNQUxNQVBcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyBcIiNkZWZpbmUgVVNFX1NQRUNVTEFSTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnZlcnRleENvbG9ycyA/IFwiI2RlZmluZSBVU0VfQ09MT1JcIiA6IFwiXCIsXHJcblxyXG5cdFx0XHRwYXJhbWV0ZXJzLm1ldGFsID8gXCIjZGVmaW5lIE1FVEFMXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnBlclBpeGVsID8gXCIjZGVmaW5lIFBIT05HX1BFUl9QSVhFTFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy53cmFwQXJvdW5kID8gXCIjZGVmaW5lIFdSQVBfQVJPVU5EXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLmRvdWJsZVNpZGVkID8gXCIjZGVmaW5lIERPVUJMRV9TSURFRFwiIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyBcIiNkZWZpbmUgRkxJUF9TSURFRFwiIDogXCJcIixcclxuXHJcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/IFwiI2RlZmluZSBVU0VfU0hBRE9XTUFQXCIgOiBcIlwiLFxyXG5cdFx0XHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyBcIiNkZWZpbmUgXCIgKyBzaGFkb3dNYXBUeXBlRGVmaW5lIDogXCJcIixcclxuXHRcdFx0cGFyYW1ldGVycy5zaGFkb3dNYXBEZWJ1ZyA/IFwiI2RlZmluZSBTSEFET1dNQVBfREVCVUdcIiA6IFwiXCIsXHJcblx0XHRcdHBhcmFtZXRlcnMuc2hhZG93TWFwQ2FzY2FkZSA/IFwiI2RlZmluZSBTSEFET1dNQVBfQ0FTQ0FERVwiIDogXCJcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGNhbWVyYVBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcIlwiXHJcblxyXG5cdFx0XS5qb2luKFwiXFxuXCIpO1xyXG5cclxuXHRcdHZhciBnbEZyYWdtZW50U2hhZGVyID0gZ2V0U2hhZGVyKCBcImZyYWdtZW50XCIsIHByZWZpeF9mcmFnbWVudCArIGZyYWdtZW50U2hhZGVyICk7XHJcblx0XHR2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBnZXRTaGFkZXIoIFwidmVydGV4XCIsIHByZWZpeF92ZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHRfZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbFZlcnRleFNoYWRlciApO1xyXG5cdFx0X2dsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgZ2xGcmFnbWVudFNoYWRlciApO1xyXG5cclxuXHRcdF9nbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xyXG5cclxuXHRcdGlmICggIV9nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBfZ2wuTElOS19TVEFUVVMgKSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiQ291bGQgbm90IGluaXRpYWxpc2Ugc2hhZGVyXFxuXCIgKyBcIlZBTElEQVRFX1NUQVRVUzogXCIgKyBfZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgX2dsLlZBTElEQVRFX1NUQVRVUyApICsgXCIsIGdsIGVycm9yIFtcIiArIF9nbC5nZXRFcnJvcigpICsgXCJdXCIgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2xlYW4gdXBcclxuXHJcblx0XHRfZ2wuZGVsZXRlU2hhZGVyKCBnbEZyYWdtZW50U2hhZGVyICk7XHJcblx0XHRfZ2wuZGVsZXRlU2hhZGVyKCBnbFZlcnRleFNoYWRlciApO1xyXG5cclxuXHRcdC8vY29uc29sZS5sb2coIHByZWZpeF9mcmFnbWVudCArIGZyYWdtZW50U2hhZGVyICk7XHJcblx0XHQvL2NvbnNvbGUubG9nKCBwcmVmaXhfdmVydGV4ICsgdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0cHJvZ3JhbS51bmlmb3JtcyA9IHt9O1xyXG5cdFx0cHJvZ3JhbS5hdHRyaWJ1dGVzID0ge307XHJcblxyXG5cdFx0dmFyIGlkZW50aWZpZXJzLCB1LCBhLCBpO1xyXG5cclxuXHRcdC8vIGNhY2hlIHVuaWZvcm0gbG9jYXRpb25zXHJcblxyXG5cdFx0aWRlbnRpZmllcnMgPSBbXHJcblxyXG5cdFx0XHQndmlld01hdHJpeCcsICdtb2RlbFZpZXdNYXRyaXgnLCAncHJvamVjdGlvbk1hdHJpeCcsICdub3JtYWxNYXRyaXgnLCAnbW9kZWxNYXRyaXgnLCAnY2FtZXJhUG9zaXRpb24nLFxyXG5cdFx0XHQnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJ1xyXG5cclxuXHRcdF07XHJcblxyXG5cdFx0aWYgKCBwYXJhbWV0ZXJzLnVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCAnYm9uZVRleHR1cmUnICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdGlkZW50aWZpZXJzLnB1c2goICdib25lR2xvYmFsTWF0cmljZXMnICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIHUgaW4gdW5pZm9ybXMgKSB7XHJcblxyXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCB1ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNhY2hlVW5pZm9ybUxvY2F0aW9ucyggcHJvZ3JhbSwgaWRlbnRpZmllcnMgKTtcclxuXHJcblx0XHQvLyBjYWNoZSBhdHRyaWJ1dGVzIGxvY2F0aW9uc1xyXG5cclxuXHRcdGlkZW50aWZpZXJzID0gW1xyXG5cclxuXHRcdFx0XCJwb3NpdGlvblwiLCBcIm5vcm1hbFwiLCBcInV2XCIsIFwidXYyXCIsIFwidGFuZ2VudFwiLCBcImNvbG9yXCIsXHJcblx0XHRcdFwic2tpbkluZGV4XCIsIFwic2tpbldlaWdodFwiLCBcImxpbmVEaXN0YW5jZVwiXHJcblxyXG5cdFx0XTtcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubWF4TW9ycGhUYXJnZXRzOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggXCJtb3JwaFRhcmdldFwiICsgaSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IHBhcmFtZXRlcnMubWF4TW9ycGhOb3JtYWxzOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWRlbnRpZmllcnMucHVzaCggXCJtb3JwaE5vcm1hbFwiICsgaSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBhIGluIGF0dHJpYnV0ZXMgKSB7XHJcblxyXG5cdFx0XHRpZGVudGlmaWVycy5wdXNoKCBhICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNhY2hlQXR0cmlidXRlTG9jYXRpb25zKCBwcm9ncmFtLCBpZGVudGlmaWVycyApO1xyXG5cclxuXHRcdHByb2dyYW0uaWQgPSBfcHJvZ3JhbXNfY291bnRlciArKztcclxuXHJcblx0XHRfcHJvZ3JhbXMucHVzaCggeyBwcm9ncmFtOiBwcm9ncmFtLCBjb2RlOiBjb2RlLCB1c2VkVGltZXM6IDEgfSApO1xyXG5cclxuXHRcdF90aGlzLmluZm8ubWVtb3J5LnByb2dyYW1zID0gX3Byb2dyYW1zLmxlbmd0aDtcclxuXHJcblx0XHRyZXR1cm4gcHJvZ3JhbTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gU2hhZGVyIHBhcmFtZXRlcnMgY2FjaGVcclxuXHJcblx0ZnVuY3Rpb24gY2FjaGVVbmlmb3JtTG9jYXRpb25zICggcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XHJcblxyXG5cdFx0dmFyIGksIGwsIGlkO1xyXG5cclxuXHRcdGZvciggaSA9IDAsIGwgPSBpZGVudGlmaWVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWQgPSBpZGVudGlmaWVyc1sgaSBdO1xyXG5cdFx0XHRwcm9ncmFtLnVuaWZvcm1zWyBpZCBdID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgaWQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGNhY2hlQXR0cmlidXRlTG9jYXRpb25zICggcHJvZ3JhbSwgaWRlbnRpZmllcnMgKSB7XHJcblxyXG5cdFx0dmFyIGksIGwsIGlkO1xyXG5cclxuXHRcdGZvciggaSA9IDAsIGwgPSBpZGVudGlmaWVycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xyXG5cclxuXHRcdFx0aWQgPSBpZGVudGlmaWVyc1sgaSBdO1xyXG5cdFx0XHRwcm9ncmFtLmF0dHJpYnV0ZXNbIGlkIF0gPSBfZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIGlkICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBhZGRMaW5lTnVtYmVycyAoIHN0cmluZyApIHtcclxuXHJcblx0XHR2YXIgY2h1bmtzID0gc3RyaW5nLnNwbGl0KCBcIlxcblwiICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdC8vIENocm9tZSByZXBvcnRzIHNoYWRlciBlcnJvcnMgb24gbGluZXNcclxuXHRcdFx0Ly8gc3RhcnRpbmcgY291bnRpbmcgZnJvbSAxXHJcblxyXG5cdFx0XHRjaHVua3NbIGkgXSA9ICggaSArIDEgKSArIFwiOiBcIiArIGNodW5rc1sgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2h1bmtzLmpvaW4oIFwiXFxuXCIgKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0U2hhZGVyICggdHlwZSwgc3RyaW5nICkge1xyXG5cclxuXHRcdHZhciBzaGFkZXI7XHJcblxyXG5cdFx0aWYgKCB0eXBlID09PSBcImZyYWdtZW50XCIgKSB7XHJcblxyXG5cdFx0XHRzaGFkZXIgPSBfZ2wuY3JlYXRlU2hhZGVyKCBfZ2wuRlJBR01FTlRfU0hBREVSICk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJ2ZXJ0ZXhcIiApIHtcclxuXHJcblx0XHRcdHNoYWRlciA9IF9nbC5jcmVhdGVTaGFkZXIoIF9nbC5WRVJURVhfU0hBREVSICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9nbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc3RyaW5nICk7XHJcblx0XHRfZ2wuY29tcGlsZVNoYWRlciggc2hhZGVyICk7XHJcblxyXG5cdFx0aWYgKCAhX2dsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBfZ2wuQ09NUElMRV9TVEFUVVMgKSApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIF9nbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSApO1xyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBhZGRMaW5lTnVtYmVycyggc3RyaW5nICkgKTtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzaGFkZXI7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFRleHR1cmVzXHJcblxyXG5cclxuXHRmdW5jdGlvbiBpc1Bvd2VyT2ZUd28gKCB2YWx1ZSApIHtcclxuXHJcblx0XHRyZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMDtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0VGV4dHVyZVBhcmFtZXRlcnMgKCB0ZXh0dXJlVHlwZSwgdGV4dHVyZSwgaXNJbWFnZVBvd2VyT2ZUd28gKSB7XHJcblxyXG5cdFx0aWYgKCBpc0ltYWdlUG93ZXJPZlR3byApIHtcclxuXHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwUyApICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS53cmFwVCApICk7XHJcblxyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgcGFyYW1UaHJlZVRvR0woIHRleHR1cmUubWluRmlsdGVyICkgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cclxuXHRcdFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5tYWdGaWx0ZXIgKSApO1xyXG5cdFx0XHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1pbkZpbHRlciApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggX2dsRXh0ZW5zaW9uVGV4dHVyZUZpbHRlckFuaXNvdHJvcGljICYmIHRleHR1cmUudHlwZSAhPT0gVEhSRUUuRmxvYXRUeXBlICkge1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLmFuaXNvdHJvcHkgPiAxIHx8IHRleHR1cmUuX19vbGRBbmlzb3Ryb3B5ICkge1xyXG5cclxuXHRcdFx0XHRfZ2wudGV4UGFyYW1ldGVyZiggdGV4dHVyZVR5cGUsIF9nbEV4dGVuc2lvblRleHR1cmVGaWx0ZXJBbmlzb3Ryb3BpYy5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgTWF0aC5taW4oIHRleHR1cmUuYW5pc290cm9weSwgX21heEFuaXNvdHJvcHkgKSApO1xyXG5cdFx0XHRcdHRleHR1cmUuX19vbGRBbmlzb3Ryb3B5ID0gdGV4dHVyZS5hbmlzb3Ryb3B5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24gKCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuXHRcdGlmICggdGV4dHVyZS5uZWVkc1VwZGF0ZSApIHtcclxuXHJcblx0XHRcdGlmICggISB0ZXh0dXJlLl9fd2ViZ2xJbml0ICkge1xyXG5cclxuXHRcdFx0XHR0ZXh0dXJlLl9fd2ViZ2xJbml0ID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcclxuXHJcblx0XHRcdFx0dGV4dHVyZS5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XHJcblxyXG5cdFx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcclxuXHRcdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZS5fX3dlYmdsVGV4dHVyZSApO1xyXG5cclxuXHRcdFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdGV4dHVyZS5mbGlwWSApO1xyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRleHR1cmUucHJlbXVsdGlwbHlBbHBoYSApO1xyXG5cdFx0XHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xyXG5cclxuXHRcdFx0dmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZSxcclxuXHRcdFx0aXNJbWFnZVBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSxcclxuXHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggdGV4dHVyZS5mb3JtYXQgKSxcclxuXHRcdFx0Z2xUeXBlID0gcGFyYW1UaHJlZVRvR0woIHRleHR1cmUudHlwZSApO1xyXG5cclxuXHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xyXG5cclxuXHRcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IHRleHR1cmUubWlwbWFwcztcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkRhdGFUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxyXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xyXG5cdFx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xyXG5cclxuXHRcdFx0XHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuXHRcdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdGV4dHVyZSBpbnN0YW5jZW9mIFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlICkge1xyXG5cclxuXHRcdFx0XHQvLyBjb21wcmVzc2VkIHRleHR1cmVzIGNhbiBvbmx5IHVzZSBtYW51YWxseSBjcmVhdGVkIG1pcG1hcHNcclxuXHRcdFx0XHQvLyBXZWJHTCBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBERFMgdGV4dHVyZXNcclxuXHJcblx0XHRcdFx0Zm9yKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XHJcblx0XHRcdFx0XHRfZ2wuY29tcHJlc3NlZFRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBtaXBtYXAuZGF0YSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2UgeyAvLyByZWd1bGFyIFRleHR1cmUgKGltYWdlLCB2aWRlbywgY2FudmFzKVxyXG5cclxuXHRcdFx0XHQvLyB1c2UgbWFudWFsbHkgY3JlYXRlZCBtaXBtYXBzIGlmIGF2YWlsYWJsZVxyXG5cdFx0XHRcdC8vIGlmIHRoZXJlIGFyZSBubyBtYW51YWwgbWlwbWFwc1xyXG5cdFx0XHRcdC8vIHNldCAwIGxldmVsIG1pcG1hcCBhbmQgdGhlbiB1c2UgR0wgdG8gZ2VuZXJhdGUgb3RoZXIgbWlwbWFwIGxldmVsc1xyXG5cclxuXHRcdFx0XHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcclxuXHJcblx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcclxuXHRcdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCBpLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgbWlwbWFwICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgdGV4dHVyZS5pbWFnZSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzICYmIGlzSW1hZ2VQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xyXG5cclxuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0aWYgKCB0ZXh0dXJlLm9uVXBkYXRlICkgdGV4dHVyZS5vblVwZGF0ZSgpO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjbGFtcFRvTWF4U2l6ZSAoIGltYWdlLCBtYXhTaXplICkge1xyXG5cclxuXHRcdGlmICggaW1hZ2Uud2lkdGggPD0gbWF4U2l6ZSAmJiBpbWFnZS5oZWlnaHQgPD0gbWF4U2l6ZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBpbWFnZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gV2FybmluZzogU2NhbGluZyB0aHJvdWdoIHRoZSBjYW52YXMgd2lsbCBvbmx5IHdvcmsgd2l0aCBpbWFnZXMgdGhhdCB1c2VcclxuXHRcdC8vIHByZW11bHRpcGxpZWQgYWxwaGEuXHJcblxyXG5cdFx0dmFyIG1heERpbWVuc2lvbiA9IE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XHJcblx0XHR2YXIgbmV3V2lkdGggPSBNYXRoLmZsb29yKCBpbWFnZS53aWR0aCAqIG1heFNpemUgLyBtYXhEaW1lbnNpb24gKTtcclxuXHRcdHZhciBuZXdIZWlnaHQgPSBNYXRoLmZsb29yKCBpbWFnZS5oZWlnaHQgKiBtYXhTaXplIC8gbWF4RGltZW5zaW9uICk7XHJcblxyXG5cdFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdjYW52YXMnICk7XHJcblx0XHRjYW52YXMud2lkdGggPSBuZXdXaWR0aDtcclxuXHRcdGNhbnZhcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XHJcblxyXG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCBcIjJkXCIgKTtcclxuXHRcdGN0eC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0ICk7XHJcblxyXG5cdFx0cmV0dXJuIGNhbnZhcztcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZSAoIHRleHR1cmUsIHNsb3QgKSB7XHJcblxyXG5cdFx0aWYgKCB0ZXh0dXJlLmltYWdlLmxlbmd0aCA9PT0gNiApIHtcclxuXHJcblx0XHRcdGlmICggdGV4dHVyZS5uZWVkc1VwZGF0ZSApIHtcclxuXHJcblx0XHRcdFx0aWYgKCAhIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRcdFx0XHRfdGhpcy5pbmZvLm1lbW9yeS50ZXh0dXJlcyArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlICk7XHJcblxyXG5cdFx0XHRcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcclxuXHJcblx0XHRcdFx0dmFyIGlzQ29tcHJlc3NlZCA9IHRleHR1cmUgaW5zdGFuY2VvZiBUSFJFRS5Db21wcmVzc2VkVGV4dHVyZTtcclxuXHJcblx0XHRcdFx0dmFyIGN1YmVJbWFnZSA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggX3RoaXMuYXV0b1NjYWxlQ3ViZW1hcHMgJiYgISBpc0NvbXByZXNzZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlWyBpIF0sIF9tYXhDdWJlbWFwU2l6ZSApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHRjdWJlSW1hZ2VbIGkgXSA9IHRleHR1cmUuaW1hZ2VbIGkgXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGltYWdlID0gY3ViZUltYWdlWyAwIF0sXHJcblx0XHRcdFx0aXNJbWFnZVBvd2VyT2ZUd28gPSBpc1Bvd2VyT2ZUd28oIGltYWdlLndpZHRoICkgJiYgaXNQb3dlck9mVHdvKCBpbWFnZS5oZWlnaHQgKSxcclxuXHRcdFx0XHRnbEZvcm1hdCA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLmZvcm1hdCApLFxyXG5cdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCB0ZXh0dXJlLnR5cGUgKTtcclxuXHJcblx0XHRcdFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLCBpc0ltYWdlUG93ZXJPZlR3byApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggaXNDb21wcmVzc2VkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIG1pcG1hcCwgbWlwbWFwcyA9IGN1YmVJbWFnZVsgaSBdLm1pcG1hcHM7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRtaXBtYXAgPSBtaXBtYXBzWyBqIF07XHJcblx0XHRcdFx0XHRcdFx0X2dsLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc0ltYWdlUG93ZXJPZlR3byApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRfZ2wuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHRleHR1cmUuaW1hZ2UuX193ZWJnbFRleHR1cmVDdWJlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXRDdWJlVGV4dHVyZUR5bmFtaWMgKCB0ZXh0dXJlLCBzbG90ICkge1xyXG5cclxuXHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XHJcblx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlLl9fd2ViZ2xUZXh0dXJlICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIFJlbmRlciB0YXJnZXRzXHJcblxyXG5cdGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXIgKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCB0ZXh0dXJlVGFyZ2V0ICkge1xyXG5cclxuXHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcclxuXHRcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHRleHR1cmVUYXJnZXQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSwgMCApO1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBzZXR1cFJlbmRlckJ1ZmZlciAoIHJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICApIHtcclxuXHJcblx0XHRfZ2wuYmluZFJlbmRlcmJ1ZmZlciggX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuXHRcdC8qIEZvciBzb21lIHJlYXNvbiB0aGlzIGlzIG5vdCB3b3JraW5nLiBEZWZhdWx0aW5nIHRvIFJHQkE0LlxyXG5cdFx0fSBlbHNlIGlmKCAhIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuU1RFTkNJTF9JTkRFWDgsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xyXG5cdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLlNURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XHJcblx0XHQqL1xyXG5cdFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xyXG5cclxuXHRcdFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMLCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHRcdFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRfZ2wucmVuZGVyYnVmZmVyU3RvcmFnZSggX2dsLlJFTkRFUkJVRkZFUiwgX2dsLlJHQkE0LCByZW5kZXJUYXJnZXQud2lkdGgsIHJlbmRlclRhcmdldC5oZWlnaHQgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdHRoaXMuc2V0UmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0dmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0IGluc3RhbmNlb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlICk7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgJiYgISByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyICkge1xyXG5cclxuXHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciA9IHRydWU7XHJcblx0XHRcdGlmICggcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgPT09IHVuZGVmaW5lZCApIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyID0gdHJ1ZTtcclxuXHJcblx0XHRcdHJlbmRlclRhcmdldC5hZGRFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xyXG5cclxuXHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xUZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRcdF90aGlzLmluZm8ubWVtb3J5LnRleHR1cmVzICsrO1xyXG5cclxuXHRcdFx0Ly8gU2V0dXAgdGV4dHVyZSwgY3JlYXRlIHJlbmRlciBhbmQgZnJhbWUgYnVmZmVyc1xyXG5cclxuXHRcdFx0dmFyIGlzVGFyZ2V0UG93ZXJPZlR3byA9IGlzUG93ZXJPZlR3byggcmVuZGVyVGFyZ2V0LndpZHRoICkgJiYgaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQuaGVpZ2h0ICksXHJcblx0XHRcdFx0Z2xGb3JtYXQgPSBwYXJhbVRocmVlVG9HTCggcmVuZGVyVGFyZ2V0LmZvcm1hdCApLFxyXG5cdFx0XHRcdGdsVHlwZSA9IHBhcmFtVGhyZWVUb0dMKCByZW5kZXJUYXJnZXQudHlwZSApO1xyXG5cclxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIgPSBbXTtcclxuXHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IFtdO1xyXG5cclxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcclxuXHRcdFx0XHRzZXRUZXh0dXJlUGFyYW1ldGVycyggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHJlbmRlclRhcmdldCwgaXNUYXJnZXRQb3dlck9mVHdvICk7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0XHRcdF9nbC50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xyXG5cclxuXHRcdFx0XHRcdHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0LCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xyXG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggaXNUYXJnZXRQb3dlck9mVHdvICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0cmVuZGVyVGFyZ2V0Ll9fd2ViZ2xGcmFtZWJ1ZmZlciA9IF9nbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0XHRpZiAoIHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbSApIHtcclxuXHJcblx0XHRcdFx0XHRyZW5kZXJUYXJnZXQuX193ZWJnbFJlbmRlcmJ1ZmZlciA9IHJlbmRlclRhcmdldC5zaGFyZURlcHRoRnJvbS5fX3dlYmdsUmVuZGVyYnVmZmVyO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xyXG5cdFx0XHRcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0LCBpc1RhcmdldFBvd2VyT2ZUd28gKTtcclxuXHJcblx0XHRcdFx0X2dsLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBudWxsICk7XHJcblxyXG5cdFx0XHRcdHNldHVwRnJhbWVCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXIsIHJlbmRlclRhcmdldCwgX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuc2hhcmVEZXB0aEZyb20gKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgISByZW5kZXJUYXJnZXQuc3RlbmNpbEJ1ZmZlciApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhCdWZmZXIgJiYgcmVuZGVyVGFyZ2V0LnN0ZW5jaWxCdWZmZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2dsLkRFUFRIX1NURU5DSUxfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyVGFyZ2V0Ll9fd2ViZ2xSZW5kZXJidWZmZXIgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0c2V0dXBSZW5kZXJCdWZmZXIoIHJlbmRlclRhcmdldC5fX3dlYmdsUmVuZGVyYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGlzVGFyZ2V0UG93ZXJPZlR3byApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFJlbGVhc2UgZXZlcnl0aGluZ1xyXG5cclxuXHRcdFx0aWYgKCBpc0N1YmUgKSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIG51bGwgKTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XHJcblx0XHRcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgbnVsbCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZnJhbWVidWZmZXIsIHdpZHRoLCBoZWlnaHQsIHZ4LCB2eTtcclxuXHJcblx0XHRpZiAoIHJlbmRlclRhcmdldCApIHtcclxuXHJcblx0XHRcdGlmICggaXNDdWJlICkge1xyXG5cclxuXHRcdFx0XHRmcmFtZWJ1ZmZlciA9IHJlbmRlclRhcmdldC5fX3dlYmdsRnJhbWVidWZmZXJbIHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSBdO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0ZnJhbWVidWZmZXIgPSByZW5kZXJUYXJnZXQuX193ZWJnbEZyYW1lYnVmZmVyO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0d2lkdGggPSByZW5kZXJUYXJnZXQud2lkdGg7XHJcblx0XHRcdGhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XHJcblxyXG5cdFx0XHR2eCA9IDA7XHJcblx0XHRcdHZ5ID0gMDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0ZnJhbWVidWZmZXIgPSBudWxsO1xyXG5cclxuXHRcdFx0d2lkdGggPSBfdmlld3BvcnRXaWR0aDtcclxuXHRcdFx0aGVpZ2h0ID0gX3ZpZXdwb3J0SGVpZ2h0O1xyXG5cclxuXHRcdFx0dnggPSBfdmlld3BvcnRYO1xyXG5cdFx0XHR2eSA9IF92aWV3cG9ydFk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggZnJhbWVidWZmZXIgIT09IF9jdXJyZW50RnJhbWVidWZmZXIgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XHJcblx0XHRcdF9nbC52aWV3cG9ydCggdngsIHZ5LCB3aWR0aCwgaGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRfY3VycmVudEZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdF9jdXJyZW50V2lkdGggPSB3aWR0aDtcclxuXHRcdF9jdXJyZW50SGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAgKCByZW5kZXJUYXJnZXQgKSB7XHJcblxyXG5cdFx0aWYgKCByZW5kZXJUYXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgKSB7XHJcblxyXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCByZW5kZXJUYXJnZXQuX193ZWJnbFRleHR1cmUgKTtcclxuXHRcdFx0X2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xyXG5cdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCBudWxsICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIHJlbmRlclRhcmdldC5fX3dlYmdsVGV4dHVyZSApO1xyXG5cdFx0XHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFXzJEICk7XHJcblx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIEZhbGxiYWNrIGZpbHRlcnMgZm9yIG5vbi1wb3dlci1vZi0yIHRleHR1cmVzXHJcblxyXG5cdGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrICggZiApIHtcclxuXHJcblx0XHRpZiAoIGYgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcE5lYXJlc3RGaWx0ZXIgfHwgZiA9PT0gVEhSRUUuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciApIHtcclxuXHJcblx0XHRcdHJldHVybiBfZ2wuTkVBUkVTVDtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIF9nbC5MSU5FQVI7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIE1hcCB0aHJlZS5qcyBjb25zdGFudHMgdG8gV2ViR0wgY29uc3RhbnRzXHJcblxyXG5cdGZ1bmN0aW9uIHBhcmFtVGhyZWVUb0dMICggcCApIHtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIF9nbC5SRVBFQVQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcgKSByZXR1cm4gX2dsLkNMQU1QX1RPX0VER0U7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgKSByZXR1cm4gX2dsLk1JUlJPUkVEX1JFUEVBVDtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gX2dsLk5FQVJFU1Q7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5OZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIF9nbC5ORUFSRVNUX01JUE1BUF9MSU5FQVI7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlciApIHJldHVybiBfZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgKSByZXR1cm4gX2dsLkxJTkVBUl9NSVBNQVBfTElORUFSO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfQllURTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRTaG9ydDQ0NDRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF80XzRfNF80O1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0NTU1MVR5cGUgKSByZXR1cm4gX2dsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlVuc2lnbmVkU2hvcnQ1NjVUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9TSE9SVF81XzZfNTtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkJ5dGVUeXBlICkgcmV0dXJuIF9nbC5CWVRFO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5TaG9ydFR5cGUgKSByZXR1cm4gX2dsLlNIT1JUO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5VbnNpZ25lZFNob3J0VHlwZSApIHJldHVybiBfZ2wuVU5TSUdORURfU0hPUlQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkludFR5cGUgKSByZXR1cm4gX2dsLklOVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuIF9nbC5VTlNJR05FRF9JTlQ7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkZsb2F0VHlwZSApIHJldHVybiBfZ2wuRkxPQVQ7XHJcblxyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5BbHBoYUZvcm1hdCApIHJldHVybiBfZ2wuQUxQSEE7XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkZvcm1hdCApIHJldHVybiBfZ2wuUkdCO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBRm9ybWF0ICkgcmV0dXJuIF9nbC5SR0JBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5MdW1pbmFuY2VGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRTtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuTHVtaW5hbmNlQWxwaGFGb3JtYXQgKSByZXR1cm4gX2dsLkxVTUlOQU5DRV9BTFBIQTtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLkFkZEVxdWF0aW9uICkgcmV0dXJuIF9nbC5GVU5DX0FERDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU3VidHJhY3RFcXVhdGlvbiApIHJldHVybiBfZ2wuRlVOQ19TVUJUUkFDVDtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gX2dsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVDtcclxuXHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLlplcm9GYWN0b3IgKSByZXR1cm4gX2dsLlpFUk87XHJcblx0XHRpZiAoIHAgPT09IFRIUkVFLk9uZUZhY3RvciApIHJldHVybiBfZ2wuT05FO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5TcmNDb2xvckZhY3RvciApIHJldHVybiBfZ2wuU1JDX0NPTE9SO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c1NyY0NvbG9yRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0NPTE9SO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5TcmNBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c1NyY0FscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5Ec3RBbHBoYUZhY3RvciApIHJldHVybiBfZ2wuRFNUX0FMUEhBO1xyXG5cdFx0aWYgKCBwID09PSBUSFJFRS5PbmVNaW51c0RzdEFscGhhRmFjdG9yICkgcmV0dXJuIF9nbC5PTkVfTUlOVVNfRFNUX0FMUEhBO1xyXG5cclxuXHRcdGlmICggcCA9PT0gVEhSRUUuRHN0Q29sb3JGYWN0b3IgKSByZXR1cm4gX2dsLkRTVF9DT0xPUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuT25lTWludXNEc3RDb2xvckZhY3RvciApIHJldHVybiBfZ2wuT05FX01JTlVTX0RTVF9DT0xPUjtcclxuXHRcdGlmICggcCA9PT0gVEhSRUUuU3JjQWxwaGFTYXR1cmF0ZUZhY3RvciApIHJldHVybiBfZ2wuU1JDX0FMUEhBX1NBVFVSQVRFO1xyXG5cclxuXHRcdGlmICggX2dsRXh0ZW5zaW9uQ29tcHJlc3NlZFRleHR1cmVTM1RDICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQy5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xyXG5cdFx0XHRpZiAoIHAgPT09IFRIUkVFLlJHQkFfUzNUQ19EWFQxX0Zvcm1hdCApIHJldHVybiBfZ2xFeHRlbnNpb25Db21wcmVzc2VkVGV4dHVyZVMzVEMuQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUMV9FWFQ7XHJcblx0XHRcdGlmICggcCA9PT0gVEhSRUUuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ICkgcmV0dXJuIF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQy5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQzX0VYVDtcclxuXHRcdFx0aWYgKCBwID09PSBUSFJFRS5SR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gX2dsRXh0ZW5zaW9uQ29tcHJlc3NlZFRleHR1cmVTM1RDLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gMDtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gQWxsb2NhdGlvbnNcclxuXHJcblx0ZnVuY3Rpb24gYWxsb2NhdGVCb25lcyAoIG9iamVjdCApIHtcclxuXHJcblx0XHRpZiAoIF9zdXBwb3J0c0JvbmVUZXh0dXJlcyAmJiBvYmplY3QgJiYgb2JqZWN0LnVzZVZlcnRleFRleHR1cmUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gMTAyNDtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Ly8gZGVmYXVsdCBmb3Igd2hlbiBvYmplY3QgaXMgbm90IHNwZWNpZmllZFxyXG5cdFx0XHQvLyAoIGZvciBleGFtcGxlIHdoZW4gcHJlYnVpbGRpbmcgc2hhZGVyXHJcblx0XHRcdC8vICAgdG8gYmUgdXNlZCB3aXRoIG11bHRpcGxlIG9iamVjdHMgKVxyXG5cdFx0XHQvL1xyXG5cdFx0XHQvLyBcdC0gbGVhdmUgc29tZSBleHRyYSBzcGFjZSBmb3Igb3RoZXIgdW5pZm9ybXNcclxuXHRcdFx0Ly8gIC0gbGltaXQgaGVyZSBpcyBBTkdMRSdzIDI1NCBtYXggdW5pZm9ybSB2ZWN0b3JzXHJcblx0XHRcdC8vICAgICh1cCB0byA1NCBzaG91bGQgYmUgc2FmZSlcclxuXHJcblx0XHRcdHZhciBuVmVydGV4VW5pZm9ybXMgPSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcclxuXHRcdFx0dmFyIG5WZXJ0ZXhNYXRyaWNlcyA9IE1hdGguZmxvb3IoICggblZlcnRleFVuaWZvcm1zIC0gMjAgKSAvIDQgKTtcclxuXHJcblx0XHRcdHZhciBtYXhCb25lcyA9IG5WZXJ0ZXhNYXRyaWNlcztcclxuXHJcblx0XHRcdGlmICggb2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XHJcblxyXG5cdFx0XHRcdG1heEJvbmVzID0gTWF0aC5taW4oIG9iamVjdC5ib25lcy5sZW5ndGgsIG1heEJvbmVzICk7XHJcblxyXG5cdFx0XHRcdGlmICggbWF4Qm9uZXMgPCBvYmplY3QuYm9uZXMubGVuZ3RoICkge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUud2FybiggXCJXZWJHTFJlbmRlcmVyOiB0b28gbWFueSBib25lcyAtIFwiICsgb2JqZWN0LmJvbmVzLmxlbmd0aCArIFwiLCB0aGlzIEdQVSBzdXBwb3J0cyBqdXN0IFwiICsgbWF4Qm9uZXMgKyBcIiAodHJ5IE9wZW5HTCBpbnN0ZWFkIG9mIEFOR0xFKVwiICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBtYXhCb25lcztcclxuXHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGFsbG9jYXRlTGlnaHRzICggbGlnaHRzICkge1xyXG5cclxuXHRcdHZhciBsLCBsbCwgbGlnaHQsIGRpckxpZ2h0cywgcG9pbnRMaWdodHMsIHNwb3RMaWdodHMsIGhlbWlMaWdodHM7XHJcblxyXG5cdFx0ZGlyTGlnaHRzID0gcG9pbnRMaWdodHMgPSBzcG90TGlnaHRzID0gaGVtaUxpZ2h0cyA9IDA7XHJcblxyXG5cdFx0Zm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsICsrICkge1xyXG5cclxuXHRcdFx0bGlnaHQgPSBsaWdodHNbIGwgXTtcclxuXHJcblx0XHRcdGlmICggbGlnaHQub25seVNoYWRvdyApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0aWYgKCBsaWdodCBpbnN0YW5jZW9mIFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQgKSBkaXJMaWdodHMgKys7XHJcblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5Qb2ludExpZ2h0ICkgcG9pbnRMaWdodHMgKys7XHJcblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBzcG90TGlnaHRzICsrO1xyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuSGVtaXNwaGVyZUxpZ2h0ICkgaGVtaUxpZ2h0cyArKztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHsgJ2RpcmVjdGlvbmFsJyA6IGRpckxpZ2h0cywgJ3BvaW50JyA6IHBvaW50TGlnaHRzLCAnc3BvdCc6IHNwb3RMaWdodHMsICdoZW1pJzogaGVtaUxpZ2h0cyB9O1xyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBhbGxvY2F0ZVNoYWRvd3MgKCBsaWdodHMgKSB7XHJcblxyXG5cdFx0dmFyIGwsIGxsLCBsaWdodCwgbWF4U2hhZG93cyA9IDA7XHJcblxyXG5cdFx0Zm9yICggbCA9IDAsIGxsID0gbGlnaHRzLmxlbmd0aDsgbCA8IGxsOyBsKysgKSB7XHJcblxyXG5cdFx0XHRsaWdodCA9IGxpZ2h0c1sgbCBdO1xyXG5cclxuXHRcdFx0aWYgKCAhIGxpZ2h0LmNhc3RTaGFkb3cgKSBjb250aW51ZTtcclxuXHJcblx0XHRcdGlmICggbGlnaHQgaW5zdGFuY2VvZiBUSFJFRS5TcG90TGlnaHQgKSBtYXhTaGFkb3dzICsrO1xyXG5cdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCAmJiAhIGxpZ2h0LnNoYWRvd0Nhc2NhZGUgKSBtYXhTaGFkb3dzICsrO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWF4U2hhZG93cztcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gSW5pdGlhbGl6YXRpb25cclxuXHJcblx0ZnVuY3Rpb24gaW5pdEdMICgpIHtcclxuXHJcblx0XHR0cnkge1xyXG5cclxuXHRcdFx0aWYgKCAhICggX2dsID0gX2NhbnZhcy5nZXRDb250ZXh0KCAnZXhwZXJpbWVudGFsLXdlYmdsJywgeyBhbHBoYTogX2FscGhhLCBwcmVtdWx0aXBsaWVkQWxwaGE6IF9wcmVtdWx0aXBsaWVkQWxwaGEsIGFudGlhbGlhczogX2FudGlhbGlhcywgc3RlbmNpbDogX3N0ZW5jaWwsIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogX3ByZXNlcnZlRHJhd2luZ0J1ZmZlciB9ICkgKSApIHtcclxuXHJcblx0XHRcdFx0dGhyb3cgJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQuJztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGNhdGNoICggZXJyb3IgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBlcnJvciApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfZ2xFeHRlbnNpb25UZXh0dXJlRmxvYXQgPSBfZ2wuZ2V0RXh0ZW5zaW9uKCAnT0VTX3RleHR1cmVfZmxvYXQnICk7XHJcblx0XHRfZ2xFeHRlbnNpb25TdGFuZGFyZERlcml2YXRpdmVzID0gX2dsLmdldEV4dGVuc2lvbiggJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycgKTtcclxuXHJcblx0XHRfZ2xFeHRlbnNpb25UZXh0dXJlRmlsdGVyQW5pc290cm9waWMgPSBfZ2wuZ2V0RXh0ZW5zaW9uKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8XHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgICBfZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKSB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICAgX2dsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XHJcblxyXG5cclxuXHRcdF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQyA9IF9nbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X2dsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKSB8fFxyXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0X2dsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcclxuXHJcblx0XHRpZiAoICEgX2dsRXh0ZW5zaW9uVGV4dHVyZUZsb2F0ICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBGbG9hdCB0ZXh0dXJlcyBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIF9nbEV4dGVuc2lvblN0YW5kYXJkRGVyaXZhdGl2ZXMgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFN0YW5kYXJkIGRlcml2YXRpdmVzIG5vdCBzdXBwb3J0ZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoICEgX2dsRXh0ZW5zaW9uVGV4dHVyZUZpbHRlckFuaXNvdHJvcGljICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBBbmlzb3Ryb3BpYyB0ZXh0dXJlIGZpbHRlcmluZyBub3Qgc3VwcG9ydGVkLicgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIF9nbEV4dGVuc2lvbkNvbXByZXNzZWRUZXh0dXJlUzNUQyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogUzNUQyBjb21wcmVzc2VkIHRleHR1cmVzIG5vdCBzdXBwb3J0ZWQuJyApO1xyXG5cclxuXHRcdH1cclxuXHRcdFxyXG5cdFx0aWYgKCBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID09PSB1bmRlZmluZWQgKSB7XHJcblx0XHRcdFxyXG5cdFx0XHRfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID0gZnVuY3Rpb24oKSB7IFxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHJldHVybiB7XHJcblx0XHRcdFx0XHRcInJhbmdlTWluXCIgIDogMSxcclxuXHRcdFx0XHRcdFwicmFuZ2VNYXhcIiAgOiAxLFxyXG5cdFx0XHRcdFx0XCJwcmVjaXNpb25cIiA6IDFcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHRcdFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHNldERlZmF1bHRHTFN0YXRlICgpIHtcclxuXHJcblx0XHRfZ2wuY2xlYXJDb2xvciggMCwgMCwgMCwgMSApO1xyXG5cdFx0X2dsLmNsZWFyRGVwdGgoIDEgKTtcclxuXHRcdF9nbC5jbGVhclN0ZW5jaWwoIDAgKTtcclxuXHJcblx0XHRfZ2wuZW5hYmxlKCBfZ2wuREVQVEhfVEVTVCApO1xyXG5cdFx0X2dsLmRlcHRoRnVuYyggX2dsLkxFUVVBTCApO1xyXG5cclxuXHRcdF9nbC5mcm9udEZhY2UoIF9nbC5DQ1cgKTtcclxuXHRcdF9nbC5jdWxsRmFjZSggX2dsLkJBQ0sgKTtcclxuXHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHRcdF9nbC5ibGVuZEVxdWF0aW9uKCBfZ2wuRlVOQ19BREQgKTtcclxuXHRcdF9nbC5ibGVuZEZ1bmMoIF9nbC5TUkNfQUxQSEEsIF9nbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XHJcblxyXG5cdFx0X2dsLmNsZWFyQ29sb3IoIF9jbGVhckNvbG9yLnIsIF9jbGVhckNvbG9yLmcsIF9jbGVhckNvbG9yLmIsIF9jbGVhckFscGhhICk7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIGRlZmF1bHQgcGx1Z2lucyAob3JkZXIgaXMgaW1wb3J0YW50KVxyXG5cclxuXHR0aGlzLnNoYWRvd01hcFBsdWdpbiA9IG5ldyBUSFJFRS5TaGFkb3dNYXBQbHVnaW4oKTtcclxuXHR0aGlzLmFkZFByZVBsdWdpbiggdGhpcy5zaGFkb3dNYXBQbHVnaW4gKTtcclxuXHJcblx0dGhpcy5hZGRQb3N0UGx1Z2luKCBuZXcgVEhSRUUuU3ByaXRlUGx1Z2luKCkgKTtcclxuXHR0aGlzLmFkZFBvc3RQbHVnaW4oIG5ldyBUSFJFRS5MZW5zRmxhcmVQbHVnaW4oKSApO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgb3B0aW9ucyApIHtcclxuXHJcblx0VEhSRUUuRXZlbnREaXNwYXRjaGVyLmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0dGhpcy53cmFwUyA9IG9wdGlvbnMud3JhcFMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMud3JhcFMgOiBUSFJFRS5DbGFtcFRvRWRnZVdyYXBwaW5nO1xyXG5cdHRoaXMud3JhcFQgPSBvcHRpb25zLndyYXBUICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLndyYXBUIDogVEhSRUUuQ2xhbXBUb0VkZ2VXcmFwcGluZztcclxuXHJcblx0dGhpcy5tYWdGaWx0ZXIgPSBvcHRpb25zLm1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tYWdGaWx0ZXIgOiBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblx0dGhpcy5taW5GaWx0ZXIgPSBvcHRpb25zLm1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5taW5GaWx0ZXIgOiBUSFJFRS5MaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXI7XHJcblxyXG5cdHRoaXMuYW5pc290cm9weSA9IG9wdGlvbnMuYW5pc290cm9weSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbmlzb3Ryb3B5IDogMTtcclxuXHJcblx0dGhpcy5vZmZzZXQgPSBuZXcgVEhSRUUuVmVjdG9yMiggMCwgMCApO1xyXG5cdHRoaXMucmVwZWF0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIDEsIDEgKTtcclxuXHJcblx0dGhpcy5mb3JtYXQgPSBvcHRpb25zLmZvcm1hdCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5mb3JtYXQgOiBUSFJFRS5SR0JBRm9ybWF0O1xyXG5cdHRoaXMudHlwZSA9IG9wdGlvbnMudHlwZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy50eXBlIDogVEhSRUUuVW5zaWduZWRCeXRlVHlwZTtcclxuXHJcblx0dGhpcy5kZXB0aEJ1ZmZlciA9IG9wdGlvbnMuZGVwdGhCdWZmZXIgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhCdWZmZXIgOiB0cnVlO1xyXG5cdHRoaXMuc3RlbmNpbEJ1ZmZlciA9IG9wdGlvbnMuc3RlbmNpbEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zdGVuY2lsQnVmZmVyIDogdHJ1ZTtcclxuXHJcblx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSB0cnVlO1xyXG5cclxuXHR0aGlzLnNoYXJlRGVwdGhGcm9tID0gbnVsbDtcclxuXHJcbn07XHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dmFyIHRtcCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldCggdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQgKTtcclxuXHJcblx0dG1wLndyYXBTID0gdGhpcy53cmFwUztcclxuXHR0bXAud3JhcFQgPSB0aGlzLndyYXBUO1xyXG5cclxuXHR0bXAubWFnRmlsdGVyID0gdGhpcy5tYWdGaWx0ZXI7XHJcblx0dG1wLm1pbkZpbHRlciA9IHRoaXMubWluRmlsdGVyO1xyXG5cclxuXHR0bXAuYW5pc290cm9weSA9IHRoaXMuYW5pc290cm9weTtcclxuXHJcblx0dG1wLm9mZnNldC5jb3B5KCB0aGlzLm9mZnNldCApO1xyXG5cdHRtcC5yZXBlYXQuY29weSggdGhpcy5yZXBlYXQgKTtcclxuXHJcblx0dG1wLmZvcm1hdCA9IHRoaXMuZm9ybWF0O1xyXG5cdHRtcC50eXBlID0gdGhpcy50eXBlO1xyXG5cclxuXHR0bXAuZGVwdGhCdWZmZXIgPSB0aGlzLmRlcHRoQnVmZmVyO1xyXG5cdHRtcC5zdGVuY2lsQnVmZmVyID0gdGhpcy5zdGVuY2lsQnVmZmVyO1xyXG5cclxuXHR0bXAuZ2VuZXJhdGVNaXBtYXBzID0gdGhpcy5nZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG5cdHRtcC5zaGFyZURlcHRoRnJvbSA9IHRoaXMuc2hhcmVEZXB0aEZyb207XHJcblxyXG5cdHJldHVybiB0bXA7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb21cclxuICovXHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0LmNhbGwoIHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcclxuXHJcblx0dGhpcy5hY3RpdmVDdWJlRmFjZSA9IDA7IC8vIFBYIDAsIE5YIDEsIFBZIDIsIE5ZIDMsIFBaIDQsIE5aIDVcclxuXHJcbn07XHJcblxyXG5USFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlJlbmRlcmFibGVWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMucG9zaXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3I0KCk7XHJcblxyXG5cdHRoaXMudmlzaWJsZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUmVuZGVyYWJsZVZlcnRleC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggdmVydGV4ICkge1xyXG5cclxuXHR0aGlzLnBvc2l0aW9uV29ybGQuY29weSggdmVydGV4LnBvc2l0aW9uV29ybGQgKTtcclxuXHR0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHZlcnRleC5wb3NpdGlvblNjcmVlbiApO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUmVuZGVyYWJsZUZhY2UzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLnYxID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKTtcclxuXHR0aGlzLnYyID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKTtcclxuXHR0aGlzLnYzID0gbmV3IFRIUkVFLlJlbmRlcmFibGVWZXJ0ZXgoKTtcclxuXHJcblx0dGhpcy5jZW50cm9pZE1vZGVsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dGhpcy5ub3JtYWxNb2RlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5ub3JtYWxNb2RlbFZpZXcgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHR0aGlzLnZlcnRleE5vcm1hbHNMZW5ndGggPSAwO1xyXG5cdHRoaXMudmVydGV4Tm9ybWFsc01vZGVsID0gWyBuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMygpIF07XHJcblx0dGhpcy52ZXJ0ZXhOb3JtYWxzTW9kZWxWaWV3ID0gWyBuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBuZXcgVEhSRUUuVmVjdG9yMygpIF07XHJcblxyXG5cdHRoaXMuY29sb3IgPSBudWxsO1xyXG5cdHRoaXMubWF0ZXJpYWwgPSBudWxsO1xyXG5cdHRoaXMudXZzID0gW1tdXTtcclxuXHJcblx0dGhpcy56ID0gbnVsbDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlJlbmRlcmFibGVGYWNlNCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy52MSA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblx0dGhpcy52MiA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblx0dGhpcy52MyA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblx0dGhpcy52NCA9IG5ldyBUSFJFRS5SZW5kZXJhYmxlVmVydGV4KCk7XHJcblxyXG5cdHRoaXMuY2VudHJvaWRNb2RlbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdHRoaXMubm9ybWFsTW9kZWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMubm9ybWFsTW9kZWxWaWV3ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dGhpcy52ZXJ0ZXhOb3JtYWxzTGVuZ3RoID0gMDtcclxuXHR0aGlzLnZlcnRleE5vcm1hbHNNb2RlbCA9IFsgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xyXG5cdHRoaXMudmVydGV4Tm9ybWFsc01vZGVsVmlldyA9IFsgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoKSBdO1xyXG5cclxuXHR0aGlzLmNvbG9yID0gbnVsbDtcclxuXHR0aGlzLm1hdGVyaWFsID0gbnVsbDtcclxuXHR0aGlzLnV2cyA9IFtbXV07XHJcblxyXG5cdHRoaXMueiA9IG51bGw7XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5SZW5kZXJhYmxlT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR0aGlzLm9iamVjdCA9IG51bGw7XHJcblx0dGhpcy56ID0gbnVsbDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlJlbmRlcmFibGVQYXJ0aWNsZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5vYmplY3QgPSBudWxsO1xyXG5cclxuXHR0aGlzLnggPSBudWxsO1xyXG5cdHRoaXMueSA9IG51bGw7XHJcblx0dGhpcy56ID0gbnVsbDtcclxuXHJcblx0dGhpcy5yb3RhdGlvbiA9IG51bGw7XHJcblx0dGhpcy5zY2FsZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdHRoaXMubWF0ZXJpYWwgPSBudWxsO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuUmVuZGVyYWJsZUxpbmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHRoaXMueiA9IG51bGw7XHJcblxyXG5cdHRoaXMudjEgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xyXG5cdHRoaXMudjIgPSBuZXcgVEhSRUUuUmVuZGVyYWJsZVZlcnRleCgpO1xyXG5cclxuXHR0aGlzLm1hdGVyaWFsID0gbnVsbDtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkdlb21ldHJ5VXRpbHMgPSB7XHJcblxyXG5cdC8vIE1lcmdlIHR3byBnZW9tZXRyaWVzIG9yIGdlb21ldHJ5IGFuZCBnZW9tZXRyeSBmcm9tIG9iamVjdCAodXNpbmcgb2JqZWN0J3MgdHJhbnNmb3JtKVxyXG5cclxuXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeTEsIG9iamVjdDIgLyogbWVzaCB8IGdlb21ldHJ5ICovICkge1xyXG5cclxuXHRcdHZhciBtYXRyaXgsIG5vcm1hbE1hdHJpeCxcclxuXHRcdHZlcnRleE9mZnNldCA9IGdlb21ldHJ5MS52ZXJ0aWNlcy5sZW5ndGgsXHJcblx0XHR1dlBvc2l0aW9uID0gZ2VvbWV0cnkxLmZhY2VWZXJ0ZXhVdnNbIDAgXS5sZW5ndGgsXHJcblx0XHRnZW9tZXRyeTIgPSBvYmplY3QyIGluc3RhbmNlb2YgVEhSRUUuTWVzaCA/IG9iamVjdDIuZ2VvbWV0cnkgOiBvYmplY3QyLFxyXG5cdFx0dmVydGljZXMxID0gZ2VvbWV0cnkxLnZlcnRpY2VzLFxyXG5cdFx0dmVydGljZXMyID0gZ2VvbWV0cnkyLnZlcnRpY2VzLFxyXG5cdFx0ZmFjZXMxID0gZ2VvbWV0cnkxLmZhY2VzLFxyXG5cdFx0ZmFjZXMyID0gZ2VvbWV0cnkyLmZhY2VzLFxyXG5cdFx0dXZzMSA9IGdlb21ldHJ5MS5mYWNlVmVydGV4VXZzWyAwIF0sXHJcblx0XHR1dnMyID0gZ2VvbWV0cnkyLmZhY2VWZXJ0ZXhVdnNbIDAgXTtcclxuXHJcblx0XHRpZiAoIG9iamVjdDIgaW5zdGFuY2VvZiBUSFJFRS5NZXNoICkge1xyXG5cclxuXHRcdFx0b2JqZWN0Mi5tYXRyaXhBdXRvVXBkYXRlICYmIG9iamVjdDIudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdFx0XHRtYXRyaXggPSBvYmplY3QyLm1hdHJpeDtcclxuXHJcblx0XHRcdG5vcm1hbE1hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XHJcblx0XHRcdG5vcm1hbE1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXggKTtcclxuXHRcdFx0bm9ybWFsTWF0cml4LnRyYW5zcG9zZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB2ZXJ0aWNlc1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gdmVydGljZXMyWyBpIF07XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4Q29weSA9IHZlcnRleC5jbG9uZSgpO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRyaXggKSB2ZXJ0ZXhDb3B5LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlczEucHVzaCggdmVydGV4Q29weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBmYWNlc1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGZhY2VzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gZmFjZXMyWyBpIF0sIGZhY2VDb3B5LCBub3JtYWwsIGNvbG9yLFxyXG5cdFx0XHRmYWNlVmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscyxcclxuXHRcdFx0ZmFjZVZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xyXG5cclxuXHRcdFx0aWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTMgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VDb3B5ID0gbmV3IFRIUkVFLkZhY2UzKCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0ICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VDb3B5ID0gbmV3IFRIUkVFLkZhY2U0KCBmYWNlLmEgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYiArIHZlcnRleE9mZnNldCwgZmFjZS5jICsgdmVydGV4T2Zmc2V0LCBmYWNlLmQgKyB2ZXJ0ZXhPZmZzZXQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZhY2VDb3B5Lm5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xyXG5cclxuXHRcdFx0aWYgKCBub3JtYWxNYXRyaXggKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VDb3B5Lm5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRub3JtYWwgPSBmYWNlVmVydGV4Tm9ybWFsc1sgaiBdLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdGlmICggbm9ybWFsTWF0cml4ICkge1xyXG5cclxuXHRcdFx0XHRcdG5vcm1hbC5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZhY2VDb3B5LnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmYWNlQ29weS5jb2xvci5jb3B5KCBmYWNlLmNvbG9yICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmFjZVZlcnRleENvbG9ycy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0Y29sb3IgPSBmYWNlVmVydGV4Q29sb3JzWyBqIF07XHJcblx0XHRcdFx0ZmFjZUNvcHkudmVydGV4Q29sb3JzLnB1c2goIGNvbG9yLmNsb25lKCkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZhY2VDb3B5Lm1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXg7XHJcblxyXG5cdFx0XHRmYWNlQ29weS5jZW50cm9pZC5jb3B5KCBmYWNlLmNlbnRyb2lkICk7XHJcblxyXG5cdFx0XHRpZiAoIG1hdHJpeCApIHtcclxuXHJcblx0XHRcdFx0ZmFjZUNvcHkuY2VudHJvaWQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyB1dnNcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHV2ID0gdXZzMlsgaSBdLCB1dkNvcHkgPSBbXTtcclxuXHJcblx0XHRcdGZvciAoIHZhciBqID0gMCwgamwgPSB1di5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dXZDb3B5LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1dlsgaiBdLngsIHV2WyBqIF0ueSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR1dnMxLnB1c2goIHV2Q29weSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fSxcclxuXHJcblx0cmVtb3ZlTWF0ZXJpYWxzOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbEluZGV4QXJyYXkgKSB7XHJcblxyXG5cdFx0dmFyIG1hdGVyaWFsSW5kZXhNYXAgPSB7fTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWF0ZXJpYWxJbmRleEFycmF5Lmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0bWF0ZXJpYWxJbmRleE1hcFsgbWF0ZXJpYWxJbmRleEFycmF5W2ldIF0gPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmFjZSwgbmV3RmFjZXMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gZ2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gZ2VvbWV0cnkuZmFjZXNbIGkgXTtcclxuXHRcdFx0aWYgKCAhICggZmFjZS5tYXRlcmlhbEluZGV4IGluIG1hdGVyaWFsSW5kZXhNYXAgKSApIG5ld0ZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Z2VvbWV0cnkuZmFjZXMgPSBuZXdGYWNlcztcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHJhbmRvbSBwb2ludCBpbiB0cmlhbmdsZSAodmlhIGJhcnljZW50cmljIGNvb3JkaW5hdGVzKVxyXG5cdC8vIFx0KHVuaWZvcm0gZGlzdHJpYnV0aW9uKVxyXG5cdC8vIFx0aHR0cDovL3d3dy5jZ2FmYXEuaW5mby93aWtpL1JhbmRvbV9Qb2ludF9Jbl9UcmlhbmdsZVxyXG5cclxuXHRyYW5kb21Qb2ludEluVHJpYW5nbGU6IGZ1bmN0aW9uICggdmVjdG9yQSwgdmVjdG9yQiwgdmVjdG9yQyApIHtcclxuXHJcblx0XHR2YXIgYSwgYiwgYyxcclxuXHRcdFx0cG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMygpLFxyXG5cdFx0XHR0bXAgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLl9fdjE7XHJcblxyXG5cdFx0YSA9IFRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tKCk7XHJcblx0XHRiID0gVEhSRUUuR2VvbWV0cnlVdGlscy5yYW5kb20oKTtcclxuXHJcblx0XHRpZiAoICggYSArIGIgKSA+IDEgKSB7XHJcblxyXG5cdFx0XHRhID0gMSAtIGE7XHJcblx0XHRcdGIgPSAxIC0gYjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0YyA9IDEgLSBhIC0gYjtcclxuXHJcblx0XHRwb2ludC5jb3B5KCB2ZWN0b3JBICk7XHJcblx0XHRwb2ludC5tdWx0aXBseVNjYWxhciggYSApO1xyXG5cclxuXHRcdHRtcC5jb3B5KCB2ZWN0b3JCICk7XHJcblx0XHR0bXAubXVsdGlwbHlTY2FsYXIoIGIgKTtcclxuXHJcblx0XHRwb2ludC5hZGQoIHRtcCApO1xyXG5cclxuXHRcdHRtcC5jb3B5KCB2ZWN0b3JDICk7XHJcblx0XHR0bXAubXVsdGlwbHlTY2FsYXIoIGMgKTtcclxuXHJcblx0XHRwb2ludC5hZGQoIHRtcCApO1xyXG5cclxuXHRcdHJldHVybiBwb2ludDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHJhbmRvbSBwb2ludCBpbiBmYWNlICh0cmlhbmdsZSAvIHF1YWQpXHJcblx0Ly8gKHVuaWZvcm0gZGlzdHJpYnV0aW9uKVxyXG5cclxuXHRyYW5kb21Qb2ludEluRmFjZTogZnVuY3Rpb24gKCBmYWNlLCBnZW9tZXRyeSwgdXNlQ2FjaGVkQXJlYXMgKSB7XHJcblxyXG5cdFx0dmFyIHZBLCB2QiwgdkMsIHZEO1xyXG5cclxuXHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0dkEgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZmFjZS5hIF07XHJcblx0XHRcdHZCID0gZ2VvbWV0cnkudmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHR2QyA9IGdlb21ldHJ5LnZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdHJldHVybiBUSFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbVBvaW50SW5UcmlhbmdsZSggdkEsIHZCLCB2QyApO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGZhY2UgaW5zdGFuY2VvZiBUSFJFRS5GYWNlNCApIHtcclxuXHJcblx0XHRcdHZBID0gZ2VvbWV0cnkudmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHR2QiA9IGdlb21ldHJ5LnZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0dkMgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgZmFjZS5jIF07XHJcblx0XHRcdHZEID0gZ2VvbWV0cnkudmVydGljZXNbIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0dmFyIGFyZWExLCBhcmVhMjtcclxuXHJcblx0XHRcdGlmICggdXNlQ2FjaGVkQXJlYXMgKSB7XHJcblxyXG5cdFx0XHRcdGlmICggZmFjZS5fYXJlYTEgJiYgZmFjZS5fYXJlYTIgKSB7XHJcblxyXG5cdFx0XHRcdFx0YXJlYTEgPSBmYWNlLl9hcmVhMTtcclxuXHRcdFx0XHRcdGFyZWEyID0gZmFjZS5fYXJlYTI7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0YXJlYTEgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkEsIHZCLCB2RCApO1xyXG5cdFx0XHRcdFx0YXJlYTIgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkIsIHZDLCB2RCApO1xyXG5cclxuXHRcdFx0XHRcdGZhY2UuX2FyZWExID0gYXJlYTE7XHJcblx0XHRcdFx0XHRmYWNlLl9hcmVhMiA9IGFyZWEyO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRhcmVhMSA9IFRIUkVFLkdlb21ldHJ5VXRpbHMudHJpYW5nbGVBcmVhKCB2QSwgdkIsIHZEICksXHJcblx0XHRcdFx0YXJlYTIgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkIsIHZDLCB2RCApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHIgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbSgpICogKCBhcmVhMSArIGFyZWEyICk7XHJcblxyXG5cdFx0XHRpZiAoIHIgPCBhcmVhMSApIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIFRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tUG9pbnRJblRyaWFuZ2xlKCB2QSwgdkIsIHZEICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gVEhSRUUuR2VvbWV0cnlVdGlscy5yYW5kb21Qb2ludEluVHJpYW5nbGUoIHZCLCB2QywgdkQgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIEdldCB1bmlmb3JtbHkgZGlzdHJpYnV0ZWQgcmFuZG9tIHBvaW50cyBpbiBtZXNoXHJcblx0Ly8gXHQtIGNyZWF0ZSBhcnJheSB3aXRoIGN1bXVsYXRpdmUgc3VtcyBvZiBmYWNlIGFyZWFzXHJcblx0Ly8gIC0gcGljayByYW5kb20gbnVtYmVyIGZyb20gMCB0byB0b3RhbCBhcmVhXHJcblx0Ly8gIC0gZmluZCBjb3JyZXNwb25kaW5nIHBsYWNlIGluIGFyZWEgYXJyYXkgYnkgYmluYXJ5IHNlYXJjaFxyXG5cdC8vXHQtIGdldCByYW5kb20gcG9pbnQgaW4gZmFjZVxyXG5cclxuXHRyYW5kb21Qb2ludHNJbkdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBuICkge1xyXG5cclxuXHRcdHZhciBmYWNlLCBpLFxyXG5cdFx0XHRmYWNlcyA9IGdlb21ldHJ5LmZhY2VzLFxyXG5cdFx0XHR2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzLFxyXG5cdFx0XHRpbCA9IGZhY2VzLmxlbmd0aCxcclxuXHRcdFx0dG90YWxBcmVhID0gMCxcclxuXHRcdFx0Y3VtdWxhdGl2ZUFyZWFzID0gW10sXHJcblx0XHRcdHZBLCB2QiwgdkMsIHZEO1xyXG5cclxuXHRcdC8vIHByZWNvbXB1dGUgZmFjZSBhcmVhc1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2UzICkge1xyXG5cclxuXHRcdFx0XHR2QSA9IHZlcnRpY2VzWyBmYWNlLmEgXTtcclxuXHRcdFx0XHR2QiA9IHZlcnRpY2VzWyBmYWNlLmIgXTtcclxuXHRcdFx0XHR2QyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcclxuXHJcblx0XHRcdFx0ZmFjZS5fYXJlYSA9IFRIUkVFLkdlb21ldHJ5VXRpbHMudHJpYW5nbGVBcmVhKCB2QSwgdkIsIHZDICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBmYWNlIGluc3RhbmNlb2YgVEhSRUUuRmFjZTQgKSB7XHJcblxyXG5cdFx0XHRcdHZBID0gdmVydGljZXNbIGZhY2UuYSBdO1xyXG5cdFx0XHRcdHZCID0gdmVydGljZXNbIGZhY2UuYiBdO1xyXG5cdFx0XHRcdHZDID0gdmVydGljZXNbIGZhY2UuYyBdO1xyXG5cdFx0XHRcdHZEID0gdmVydGljZXNbIGZhY2UuZCBdO1xyXG5cclxuXHRcdFx0XHRmYWNlLl9hcmVhMSA9IFRIUkVFLkdlb21ldHJ5VXRpbHMudHJpYW5nbGVBcmVhKCB2QSwgdkIsIHZEICk7XHJcblx0XHRcdFx0ZmFjZS5fYXJlYTIgPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnRyaWFuZ2xlQXJlYSggdkIsIHZDLCB2RCApO1xyXG5cclxuXHRcdFx0XHRmYWNlLl9hcmVhID0gZmFjZS5fYXJlYTEgKyBmYWNlLl9hcmVhMjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRvdGFsQXJlYSArPSBmYWNlLl9hcmVhO1xyXG5cclxuXHRcdFx0Y3VtdWxhdGl2ZUFyZWFzWyBpIF0gPSB0b3RhbEFyZWE7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGJpbmFyeSBzZWFyY2ggY3VtdWxhdGl2ZSBhcmVhcyBhcnJheVxyXG5cclxuXHRcdGZ1bmN0aW9uIGJpbmFyeVNlYXJjaEluZGljZXMoIHZhbHVlICkge1xyXG5cclxuXHRcdFx0ZnVuY3Rpb24gYmluYXJ5U2VhcmNoKCBzdGFydCwgZW5kICkge1xyXG5cclxuXHRcdFx0XHQvLyByZXR1cm4gY2xvc2VzdCBsYXJnZXIgaW5kZXhcclxuXHRcdFx0XHQvLyBpZiBleGFjdCBudW1iZXIgaXMgbm90IGZvdW5kXHJcblxyXG5cdFx0XHRcdGlmICggZW5kIDwgc3RhcnQgKVxyXG5cdFx0XHRcdFx0cmV0dXJuIHN0YXJ0O1xyXG5cclxuXHRcdFx0XHR2YXIgbWlkID0gc3RhcnQgKyBNYXRoLmZsb29yKCAoIGVuZCAtIHN0YXJ0ICkgLyAyICk7XHJcblxyXG5cdFx0XHRcdGlmICggY3VtdWxhdGl2ZUFyZWFzWyBtaWQgXSA+IHZhbHVlICkge1xyXG5cclxuXHRcdFx0XHRcdHJldHVybiBiaW5hcnlTZWFyY2goIHN0YXJ0LCBtaWQgLSAxICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGN1bXVsYXRpdmVBcmVhc1sgbWlkIF0gPCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gYmluYXJ5U2VhcmNoKCBtaWQgKyAxLCBlbmQgKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRyZXR1cm4gbWlkO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcmVzdWx0ID0gYmluYXJ5U2VhcmNoKCAwLCBjdW11bGF0aXZlQXJlYXMubGVuZ3RoIC0gMSApXHJcblx0XHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHBpY2sgcmFuZG9tIGZhY2Ugd2VpZ2h0ZWQgYnkgZmFjZSBhcmVhXHJcblxyXG5cdFx0dmFyIHIsIGluZGV4LFxyXG5cdFx0XHRyZXN1bHQgPSBbXTtcclxuXHJcblx0XHR2YXIgc3RhdHMgPSB7fTtcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IG47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRyID0gVEhSRUUuR2VvbWV0cnlVdGlscy5yYW5kb20oKSAqIHRvdGFsQXJlYTtcclxuXHJcblx0XHRcdGluZGV4ID0gYmluYXJ5U2VhcmNoSW5kaWNlcyggciApO1xyXG5cclxuXHRcdFx0cmVzdWx0WyBpIF0gPSBUSFJFRS5HZW9tZXRyeVV0aWxzLnJhbmRvbVBvaW50SW5GYWNlKCBmYWNlc1sgaW5kZXggXSwgZ2VvbWV0cnksIHRydWUgKTtcclxuXHJcblx0XHRcdGlmICggISBzdGF0c1sgaW5kZXggXSApIHtcclxuXHJcblx0XHRcdFx0c3RhdHNbIGluZGV4IF0gPSAxO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0c3RhdHNbIGluZGV4IF0gKz0gMTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gR2V0IHRyaWFuZ2xlIGFyZWEgKGhhbGYgb2YgcGFyYWxsZWxvZ3JhbSlcclxuXHQvL1x0aHR0cDovL21hdGh3b3JsZC53b2xmcmFtLmNvbS9UcmlhbmdsZUFyZWEuaHRtbFxyXG5cclxuXHR0cmlhbmdsZUFyZWE6IGZ1bmN0aW9uICggdmVjdG9yQSwgdmVjdG9yQiwgdmVjdG9yQyApIHtcclxuXHJcblx0XHR2YXIgdG1wMSA9IFRIUkVFLkdlb21ldHJ5VXRpbHMuX192MSxcclxuXHRcdFx0dG1wMiA9IFRIUkVFLkdlb21ldHJ5VXRpbHMuX192MjtcclxuXHJcblx0XHR0bXAxLnN1YlZlY3RvcnMoIHZlY3RvckIsIHZlY3RvckEgKTtcclxuXHRcdHRtcDIuc3ViVmVjdG9ycyggdmVjdG9yQywgdmVjdG9yQSApO1xyXG5cdFx0dG1wMS5jcm9zcyggdG1wMiApO1xyXG5cclxuXHRcdHJldHVybiAwLjUgKiB0bXAxLmxlbmd0aCgpO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBDZW50ZXIgZ2VvbWV0cnkgc28gdGhhdCAwLDAsMCBpcyBpbiBjZW50ZXIgb2YgYm91bmRpbmcgYm94XHJcblxyXG5cdGNlbnRlcjogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcclxuXHJcblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHR2YXIgYmIgPSBnZW9tZXRyeS5ib3VuZGluZ0JveDtcclxuXHJcblx0XHR2YXIgb2Zmc2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRvZmZzZXQuYWRkVmVjdG9ycyggYmIubWluLCBiYi5tYXggKTtcclxuXHRcdG9mZnNldC5tdWx0aXBseVNjYWxhciggLTAuNSApO1xyXG5cclxuXHRcdGdlb21ldHJ5LmFwcGx5TWF0cml4KCBuZXcgVEhSRUUuTWF0cml4NCgpLm1ha2VUcmFuc2xhdGlvbiggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApICk7XHJcblx0XHRnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcclxuXHJcblx0XHRyZXR1cm4gb2Zmc2V0O1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBOb3JtYWxpemUgVVZzIHRvIGJlIGZyb20gPDAsMT5cclxuXHQvLyAoZm9yIG5vdyBqdXN0IHRoZSBmaXJzdCBzZXQgb2YgVVZzKVxyXG5cclxuXHRub3JtYWxpemVVVnM6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIHV2U2V0ID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgMCBdO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1dlNldC5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB1dnMgPSB1dlNldFsgaSBdO1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0Ly8gdGV4dHVyZSByZXBlYXRcclxuXHJcblx0XHRcdFx0aWYoIHV2c1sgaiBdLnggIT09IDEuMCApIHV2c1sgaiBdLnggPSB1dnNbIGogXS54IC0gTWF0aC5mbG9vciggdXZzWyBqIF0ueCApO1xyXG5cdFx0XHRcdGlmKCB1dnNbIGogXS55ICE9PSAxLjAgKSB1dnNbIGogXS55ID0gdXZzWyBqIF0ueSAtIE1hdGguZmxvb3IoIHV2c1sgaiBdLnkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH0sXHJcblxyXG5cdHRyaWFuZ3VsYXRlUXVhZHM6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XHJcblxyXG5cdFx0dmFyIGksIGlsLCBqLCBqbDtcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBbXTtcclxuXHRcdHZhciBmYWNlVXZzID0gW107XHJcblx0XHR2YXIgZmFjZVZlcnRleFV2cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGdlb21ldHJ5LmZhY2VVdnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlVXZzWyBpIF0gPSBbXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZhY2VWZXJ0ZXhVdnNbIGkgXSA9IFtdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBnZW9tZXRyeS5mYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gZ2VvbWV0cnkuZmFjZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggZmFjZSBpbnN0YW5jZW9mIFRIUkVFLkZhY2U0ICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYSA9IGZhY2UuYTtcclxuXHRcdFx0XHR2YXIgYiA9IGZhY2UuYjtcclxuXHRcdFx0XHR2YXIgYyA9IGZhY2UuYztcclxuXHRcdFx0XHR2YXIgZCA9IGZhY2UuZDtcclxuXHJcblx0XHRcdFx0dmFyIHRyaUEgPSBuZXcgVEhSRUUuRmFjZTMoKTtcclxuXHRcdFx0XHR2YXIgdHJpQiA9IG5ldyBUSFJFRS5GYWNlMygpO1xyXG5cclxuXHRcdFx0XHR0cmlBLmNvbG9yLmNvcHkoIGZhY2UuY29sb3IgKTtcclxuXHRcdFx0XHR0cmlCLmNvbG9yLmNvcHkoIGZhY2UuY29sb3IgKTtcclxuXHJcblx0XHRcdFx0dHJpQS5tYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xyXG5cdFx0XHRcdHRyaUIubWF0ZXJpYWxJbmRleCA9IGZhY2UubWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdFx0dHJpQS5hID0gYTtcclxuXHRcdFx0XHR0cmlBLmIgPSBiO1xyXG5cdFx0XHRcdHRyaUEuYyA9IGQ7XHJcblxyXG5cdFx0XHRcdHRyaUIuYSA9IGI7XHJcblx0XHRcdFx0dHJpQi5iID0gYztcclxuXHRcdFx0XHR0cmlCLmMgPSBkO1xyXG5cclxuXHRcdFx0XHRpZiAoIGZhY2UudmVydGV4Q29sb3JzLmxlbmd0aCA9PT0gNCApIHtcclxuXHJcblx0XHRcdFx0XHR0cmlBLnZlcnRleENvbG9yc1sgMCBdID0gZmFjZS52ZXJ0ZXhDb2xvcnNbIDAgXS5jbG9uZSgpO1xyXG5cdFx0XHRcdFx0dHJpQS52ZXJ0ZXhDb2xvcnNbIDEgXSA9IGZhY2UudmVydGV4Q29sb3JzWyAxIF0uY2xvbmUoKTtcclxuXHRcdFx0XHRcdHRyaUEudmVydGV4Q29sb3JzWyAyIF0gPSBmYWNlLnZlcnRleENvbG9yc1sgMyBdLmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdFx0dHJpQi52ZXJ0ZXhDb2xvcnNbIDAgXSA9IGZhY2UudmVydGV4Q29sb3JzWyAxIF0uY2xvbmUoKTtcclxuXHRcdFx0XHRcdHRyaUIudmVydGV4Q29sb3JzWyAxIF0gPSBmYWNlLnZlcnRleENvbG9yc1sgMiBdLmNsb25lKCk7XHJcblx0XHRcdFx0XHR0cmlCLnZlcnRleENvbG9yc1sgMiBdID0gZmFjZS52ZXJ0ZXhDb2xvcnNbIDMgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goIHRyaUEsIHRyaUIgKTtcclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGogXS5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdXZzID0gZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaiBdWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdXZBID0gdXZzWyAwIF07XHJcblx0XHRcdFx0XHRcdHZhciB1dkIgPSB1dnNbIDEgXTtcclxuXHRcdFx0XHRcdFx0dmFyIHV2QyA9IHV2c1sgMiBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgdXZEID0gdXZzWyAzIF07XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgdXZzVHJpQSA9IFsgdXZBLmNsb25lKCksIHV2Qi5jbG9uZSgpLCB1dkQuY2xvbmUoKSBdO1xyXG5cdFx0XHRcdFx0XHR2YXIgdXZzVHJpQiA9IFsgdXZCLmNsb25lKCksIHV2Qy5jbG9uZSgpLCB1dkQuY2xvbmUoKSBdO1xyXG5cclxuXHRcdFx0XHRcdFx0ZmFjZVZlcnRleFV2c1sgaiBdLnB1c2goIHV2c1RyaUEsIHV2c1RyaUIgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gZ2VvbWV0cnkuZmFjZVV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGdlb21ldHJ5LmZhY2VVdnNbIGogXS5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZmFjZVV2ID0gZ2VvbWV0cnkuZmFjZVV2c1sgaiBdWyBpIF07XHJcblxyXG5cdFx0XHRcdFx0XHRmYWNlVXZzWyBqIF0ucHVzaCggZmFjZVV2LCBmYWNlVXYgKTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHJcblx0XHRcdFx0Zm9yICggaiA9IDAsIGpsID0gZ2VvbWV0cnkuZmFjZVV2cy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRmYWNlVXZzWyBqIF0ucHVzaCggZ2VvbWV0cnkuZmFjZVV2c1sgaiBdWyBpIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2VWZXJ0ZXhVdnNbIGogXS5wdXNoKCBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBqIF1bIGkgXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGdlb21ldHJ5LmZhY2VzID0gZmFjZXM7XHJcblx0XHRnZW9tZXRyeS5mYWNlVXZzID0gZmFjZVV2cztcclxuXHRcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzO1xyXG5cclxuXHRcdGdlb21ldHJ5LmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHRcdGdlb21ldHJ5LmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdFx0Z2VvbWV0cnkuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0XHRpZiAoIGdlb21ldHJ5Lmhhc1RhbmdlbnRzICkgZ2VvbWV0cnkuY29tcHV0ZVRhbmdlbnRzKCk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldE1hdGVyaWFsSW5kZXg6IGZ1bmN0aW9uICggZ2VvbWV0cnksIGluZGV4LCBzdGFydEZhY2UsIGVuZEZhY2UgKXtcclxuXHJcblx0XHR2YXIgZmFjZXMgPSBnZW9tZXRyeS5mYWNlcztcclxuXHRcdHZhciBzdGFydCA9IHN0YXJ0RmFjZSB8fCAwO1xyXG5cdFx0dmFyIGVuZCA9IGVuZEZhY2UgfHwgZmFjZXMubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZhY2VzW2ldLm1hdGVyaWFsSW5kZXggPSBpbmRleDtcclxuXHJcblx0XHR9XHJcblxyXG4gICAgfVxyXG5cclxufTtcclxuXHJcblRIUkVFLkdlb21ldHJ5VXRpbHMucmFuZG9tID0gVEhSRUUuTWF0aC5yYW5kb20xNjtcclxuXHJcblRIUkVFLkdlb21ldHJ5VXRpbHMuX192MSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblRIUkVFLkdlb21ldHJ5VXRpbHMuX192MiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkltYWdlVXRpbHMgPSB7XHJcblxyXG5cdGNyb3NzT3JpZ2luOiAnYW5vbnltb3VzJyxcclxuXHJcblx0bG9hZFRleHR1cmU6IGZ1bmN0aW9uICggdXJsLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcblx0XHR2YXIgdGV4dHVyZSA9IG5ldyBUSFJFRS5UZXh0dXJlKCBpbWFnZSwgbWFwcGluZyApO1xyXG5cclxuXHRcdHZhciBsb2FkZXIgPSBuZXcgVEhSRUUuSW1hZ2VMb2FkZXIoKTtcclxuXHJcblx0XHRsb2FkZXIuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xyXG5cclxuXHRcdFx0dGV4dHVyZS5pbWFnZSA9IGV2ZW50LmNvbnRlbnQ7XHJcblx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHR9ICk7XHJcblxyXG5cdFx0bG9hZGVyLmFkZEV2ZW50TGlzdGVuZXIoICdlcnJvcicsIGZ1bmN0aW9uICggZXZlbnQgKSB7XHJcblxyXG5cdFx0XHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudC5tZXNzYWdlICk7XHJcblxyXG5cdFx0fSApO1xyXG5cclxuXHRcdGxvYWRlci5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XHJcblx0XHRsb2FkZXIubG9hZCggdXJsLCBpbWFnZSApO1xyXG5cclxuXHRcdHRleHR1cmUuc291cmNlRmlsZSA9IHVybDtcclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fSxcclxuXHJcblx0bG9hZENvbXByZXNzZWRUZXh0dXJlOiBmdW5jdGlvbiAoIHVybCwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlKCk7XHJcblx0XHR0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xyXG5cclxuXHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG5cdFx0cmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHR2YXIgYnVmZmVyID0gcmVxdWVzdC5yZXNwb25zZTtcclxuXHRcdFx0dmFyIGRkcyA9IFRIUkVFLkltYWdlVXRpbHMucGFyc2VERFMoIGJ1ZmZlciwgdHJ1ZSApO1xyXG5cclxuXHRcdFx0dGV4dHVyZS5mb3JtYXQgPSBkZHMuZm9ybWF0O1xyXG5cclxuXHRcdFx0dGV4dHVyZS5taXBtYXBzID0gZGRzLm1pcG1hcHM7XHJcblx0XHRcdHRleHR1cmUuaW1hZ2Uud2lkdGggPSBkZHMud2lkdGg7XHJcblx0XHRcdHRleHR1cmUuaW1hZ2UuaGVpZ2h0ID0gZGRzLmhlaWdodDtcclxuXHJcblx0XHRcdC8vIGdsLmdlbmVyYXRlTWlwbWFwIGZhaWxzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXHJcblx0XHRcdC8vIG1pcG1hcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiB0aGUgRERTIGZpbGVcclxuXHRcdFx0Ly8gb3IgdGV4dHVyZSBmaWx0ZXJzIG11c3Qgbm90IHVzZSBtaXBtYXBwaW5nXHJcblxyXG5cdFx0XHR0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0XHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXF1ZXN0Lm9uZXJyb3IgPSBvbkVycm9yO1xyXG5cclxuXHRcdHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xyXG5cdFx0cmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblx0XHRyZXF1ZXN0LnNlbmQoIG51bGwgKTtcclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fSxcclxuXHJcblx0bG9hZFRleHR1cmVDdWJlOiBmdW5jdGlvbiAoIGFycmF5LCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XHJcblxyXG5cdFx0dmFyIGltYWdlcyA9IFtdO1xyXG5cdFx0aW1hZ2VzLmxvYWRDb3VudCA9IDA7XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuVGV4dHVyZSgpO1xyXG5cdFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlcztcclxuXHRcdGlmICggbWFwcGluZyAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcclxuXHJcblx0XHQvLyBubyBmbGlwcGluZyBuZWVkZWQgZm9yIGN1YmUgdGV4dHVyZXNcclxuXHJcblx0XHR0ZXh0dXJlLmZsaXBZID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xyXG5cclxuXHRcdFx0dmFyIGN1YmVJbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG5cdFx0XHRpbWFnZXNbIGkgXSA9IGN1YmVJbWFnZTtcclxuXHJcblx0XHRcdGN1YmVJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0XHRcdGltYWdlcy5sb2FkQ291bnQgKz0gMTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbWFnZXMubG9hZENvdW50ID09PSA2ICkge1xyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fTtcclxuXHJcblx0XHRcdGN1YmVJbWFnZS5vbmVycm9yID0gb25FcnJvcjtcclxuXHJcblx0XHRcdGN1YmVJbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XHJcblx0XHRcdGN1YmVJbWFnZS5zcmMgPSBhcnJheVsgaSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGV4dHVyZTtcclxuXHJcblx0fSxcclxuXHJcblx0bG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCBhcnJheSwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xyXG5cclxuXHRcdHZhciBpbWFnZXMgPSBbXTtcclxuXHRcdGltYWdlcy5sb2FkQ291bnQgPSAwO1xyXG5cclxuXHRcdHZhciB0ZXh0dXJlID0gbmV3IFRIUkVFLkNvbXByZXNzZWRUZXh0dXJlKCk7XHJcblx0XHR0ZXh0dXJlLmltYWdlID0gaW1hZ2VzO1xyXG5cdFx0aWYgKCBtYXBwaW5nICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1hcHBpbmcgPSBtYXBwaW5nO1xyXG5cclxuXHRcdC8vIG5vIGZsaXBwaW5nIGZvciBjdWJlIHRleHR1cmVzXHJcblx0XHQvLyAoYWxzbyBmbGlwcGluZyBkb2Vzbid0IHdvcmsgZm9yIGNvbXByZXNzZWQgdGV4dHVyZXMgKVxyXG5cclxuXHRcdHRleHR1cmUuZmxpcFkgPSBmYWxzZTtcclxuXHJcblx0XHQvLyBjYW4ndCBnZW5lcmF0ZSBtaXBtYXBzIGZvciBjb21wcmVzc2VkIHRleHR1cmVzXHJcblx0XHQvLyBtaXBzIG11c3QgYmUgZW1iZWRkZWQgaW4gRERTIGZpbGVzXHJcblxyXG5cdFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcclxuXHJcblx0XHR2YXIgZ2VuZXJhdGVDdWJlRmFjZUNhbGxiYWNrID0gZnVuY3Rpb24gKCBycSwgaW1nICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRcdFx0dmFyIGJ1ZmZlciA9IHJxLnJlc3BvbnNlO1xyXG5cdFx0XHRcdHZhciBkZHMgPSBUSFJFRS5JbWFnZVV0aWxzLnBhcnNlRERTKCBidWZmZXIsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0aW1nLmZvcm1hdCA9IGRkcy5mb3JtYXQ7XHJcblxyXG5cdFx0XHRcdGltZy5taXBtYXBzID0gZGRzLm1pcG1hcHM7XHJcblx0XHRcdFx0aW1nLndpZHRoID0gZGRzLndpZHRoO1xyXG5cdFx0XHRcdGltZy5oZWlnaHQgPSBkZHMuaGVpZ2h0O1xyXG5cclxuXHRcdFx0XHRpbWFnZXMubG9hZENvdW50ICs9IDE7XHJcblxyXG5cdFx0XHRcdGlmICggaW1hZ2VzLmxvYWRDb3VudCA9PT0gNiApIHtcclxuXHJcblx0XHRcdFx0XHR0ZXh0dXJlLmZvcm1hdCA9IGRkcy5mb3JtYXQ7XHJcblx0XHRcdFx0XHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGlmICggb25Mb2FkICkgb25Mb2FkKCB0ZXh0dXJlICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmVzIGFzIDYgc2VwYXJhdGUgRERTIGZpbGVzXHJcblxyXG5cdFx0aWYgKCBhcnJheSBpbnN0YW5jZW9mIEFycmF5ICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGlsOyArKyBpICkge1xyXG5cclxuXHRcdFx0XHR2YXIgY3ViZUltYWdlID0ge307XHJcblx0XHRcdFx0aW1hZ2VzWyBpIF0gPSBjdWJlSW1hZ2U7XHJcblxyXG5cdFx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcblxyXG5cdFx0XHRcdHJlcXVlc3Qub25sb2FkID0gZ2VuZXJhdGVDdWJlRmFjZUNhbGxiYWNrKCByZXF1ZXN0LCBjdWJlSW1hZ2UgKTtcclxuXHRcdFx0XHRyZXF1ZXN0Lm9uZXJyb3IgPSBvbkVycm9yO1xyXG5cclxuXHRcdFx0XHR2YXIgdXJsID0gYXJyYXlbIGkgXTtcclxuXHJcblx0XHRcdFx0cmVxdWVzdC5vcGVuKCAnR0VUJywgdXJsLCB0cnVlICk7XHJcblx0XHRcdFx0cmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XHJcblx0XHRcdFx0cmVxdWVzdC5zZW5kKCBudWxsICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0Ly8gY29tcHJlc3NlZCBjdWJlbWFwIHRleHR1cmUgc3RvcmVkIGluIGEgc2luZ2xlIEREUyBmaWxlXHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdHZhciB1cmwgPSBhcnJheTtcclxuXHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuXHJcblx0XHRcdHJlcXVlc3Qub25sb2FkID0gZnVuY3Rpb24oICkge1xyXG5cclxuXHRcdFx0XHR2YXIgYnVmZmVyID0gcmVxdWVzdC5yZXNwb25zZTtcclxuXHRcdFx0XHR2YXIgZGRzID0gVEhSRUUuSW1hZ2VVdGlscy5wYXJzZUREUyggYnVmZmVyLCB0cnVlICk7XHJcblxyXG5cdFx0XHRcdGlmICggZGRzLmlzQ3ViZW1hcCApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgZmFjZXMgPSBkZHMubWlwbWFwcy5sZW5ndGggLyBkZHMubWlwbWFwQ291bnQ7XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIGYgPSAwOyBmIDwgZmFjZXM7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpbWFnZXNbIGYgXSA9IHsgbWlwbWFwcyA6IFtdIH07XHJcblxyXG5cdFx0XHRcdFx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkZHMubWlwbWFwQ291bnQ7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggZGRzLm1pcG1hcHNbIGYgKiBkZHMubWlwbWFwQ291bnQgKyBpIF0gKTtcclxuXHRcdFx0XHRcdFx0XHRpbWFnZXNbIGYgXS5mb3JtYXQgPSBkZHMuZm9ybWF0O1xyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLndpZHRoID0gZGRzLndpZHRoO1xyXG5cdFx0XHRcdFx0XHRcdGltYWdlc1sgZiBdLmhlaWdodCA9IGRkcy5oZWlnaHQ7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdHRleHR1cmUuZm9ybWF0ID0gZGRzLmZvcm1hdDtcclxuXHRcdFx0XHRcdHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdFx0XHRcdFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcclxuXHJcblx0XHRcdHJlcXVlc3Qub3BlbiggJ0dFVCcsIHVybCwgdHJ1ZSApO1xyXG5cdFx0XHRyZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcclxuXHRcdFx0cmVxdWVzdC5zZW5kKCBudWxsICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0ZXh0dXJlO1xyXG5cclxuXHR9LFxyXG5cclxuXHRwYXJzZUREUzogZnVuY3Rpb24gKCBidWZmZXIsIGxvYWRNaXBtYXBzICkge1xyXG5cclxuXHRcdHZhciBkZHMgPSB7IG1pcG1hcHM6IFtdLCB3aWR0aDogMCwgaGVpZ2h0OiAwLCBmb3JtYXQ6IG51bGwsIG1pcG1hcENvdW50OiAxIH07XHJcblxyXG5cdFx0Ly8gQWRhcHRlZCBmcm9tIEB0b2ppJ3MgRERTIHV0aWxzXHJcblx0XHQvL1x0aHR0cHM6Ly9naXRodWIuY29tL3Rvamkvd2ViZ2wtdGV4dHVyZS11dGlscy9ibG9iL21hc3Rlci90ZXh0dXJlLXV0aWwvZGRzLmpzXHJcblxyXG5cdFx0Ly8gQWxsIHZhbHVlcyBhbmQgc3RydWN0dXJlcyByZWZlcmVuY2VkIGZyb206XHJcblx0XHQvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvYmI5NDM5OTEuYXNweC9cclxuXHJcblx0XHR2YXIgRERTX01BR0lDID0gMHgyMDUzNDQ0NDtcclxuXHJcblx0XHR2YXIgRERTRF9DQVBTID0gMHgxLFxyXG5cdFx0XHRERFNEX0hFSUdIVCA9IDB4MixcclxuXHRcdFx0RERTRF9XSURUSCA9IDB4NCxcclxuXHRcdFx0RERTRF9QSVRDSCA9IDB4OCxcclxuXHRcdFx0RERTRF9QSVhFTEZPUk1BVCA9IDB4MTAwMCxcclxuXHRcdFx0RERTRF9NSVBNQVBDT1VOVCA9IDB4MjAwMDAsXHJcblx0XHRcdEREU0RfTElORUFSU0laRSA9IDB4ODAwMDAsXHJcblx0XHRcdEREU0RfREVQVEggPSAweDgwMDAwMDtcclxuXHJcblx0XHR2YXIgRERTQ0FQU19DT01QTEVYID0gMHg4LFxyXG5cdFx0XHRERFNDQVBTX01JUE1BUCA9IDB4NDAwMDAwLFxyXG5cdFx0XHRERFNDQVBTX1RFWFRVUkUgPSAweDEwMDA7XHJcblxyXG5cdFx0dmFyIEREU0NBUFMyX0NVQkVNQVAgPSAweDIwMCxcclxuXHRcdFx0RERTQ0FQUzJfQ1VCRU1BUF9QT1NJVElWRVggPSAweDQwMCxcclxuXHRcdFx0RERTQ0FQUzJfQ1VCRU1BUF9ORUdBVElWRVggPSAweDgwMCxcclxuXHRcdFx0RERTQ0FQUzJfQ1VCRU1BUF9QT1NJVElWRVkgPSAweDEwMDAsXHJcblx0XHRcdEREU0NBUFMyX0NVQkVNQVBfTkVHQVRJVkVZID0gMHgyMDAwLFxyXG5cdFx0XHRERFNDQVBTMl9DVUJFTUFQX1BPU0lUSVZFWiA9IDB4NDAwMCxcclxuXHRcdFx0RERTQ0FQUzJfQ1VCRU1BUF9ORUdBVElWRVogPSAweDgwMDAsXHJcblx0XHRcdEREU0NBUFMyX1ZPTFVNRSA9IDB4MjAwMDAwO1xyXG5cclxuXHRcdHZhciBERFBGX0FMUEhBUElYRUxTID0gMHgxLFxyXG5cdFx0XHRERFBGX0FMUEhBID0gMHgyLFxyXG5cdFx0XHRERFBGX0ZPVVJDQyA9IDB4NCxcclxuXHRcdFx0RERQRl9SR0IgPSAweDQwLFxyXG5cdFx0XHRERFBGX1lVViA9IDB4MjAwLFxyXG5cdFx0XHRERFBGX0xVTUlOQU5DRSA9IDB4MjAwMDA7XHJcblxyXG5cdFx0ZnVuY3Rpb24gZm91ckNDVG9JbnQzMiggdmFsdWUgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4gdmFsdWUuY2hhckNvZGVBdCgwKSArXHJcblx0XHRcdFx0KHZhbHVlLmNoYXJDb2RlQXQoMSkgPDwgOCkgK1xyXG5cdFx0XHRcdCh2YWx1ZS5jaGFyQ29kZUF0KDIpIDw8IDE2KSArXHJcblx0XHRcdFx0KHZhbHVlLmNoYXJDb2RlQXQoMykgPDwgMjQpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBpbnQzMlRvRm91ckNDKCB2YWx1ZSApIHtcclxuXHJcblx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKFxyXG5cdFx0XHRcdHZhbHVlICYgMHhmZixcclxuXHRcdFx0XHQodmFsdWUgPj4gOCkgJiAweGZmLFxyXG5cdFx0XHRcdCh2YWx1ZSA+PiAxNikgJiAweGZmLFxyXG5cdFx0XHRcdCh2YWx1ZSA+PiAyNCkgJiAweGZmXHJcblx0XHRcdCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIEZPVVJDQ19EWFQxID0gZm91ckNDVG9JbnQzMihcIkRYVDFcIik7XHJcblx0XHR2YXIgRk9VUkNDX0RYVDMgPSBmb3VyQ0NUb0ludDMyKFwiRFhUM1wiKTtcclxuXHRcdHZhciBGT1VSQ0NfRFhUNSA9IGZvdXJDQ1RvSW50MzIoXCJEWFQ1XCIpO1xyXG5cclxuXHRcdHZhciBoZWFkZXJMZW5ndGhJbnQgPSAzMTsgLy8gVGhlIGhlYWRlciBsZW5ndGggaW4gMzIgYml0IGludHNcclxuXHJcblx0XHQvLyBPZmZzZXRzIGludG8gdGhlIGhlYWRlciBhcnJheVxyXG5cclxuXHRcdHZhciBvZmZfbWFnaWMgPSAwO1xyXG5cclxuXHRcdHZhciBvZmZfc2l6ZSA9IDE7XHJcblx0XHR2YXIgb2ZmX2ZsYWdzID0gMjtcclxuXHRcdHZhciBvZmZfaGVpZ2h0ID0gMztcclxuXHRcdHZhciBvZmZfd2lkdGggPSA0O1xyXG5cclxuXHRcdHZhciBvZmZfbWlwbWFwQ291bnQgPSA3O1xyXG5cclxuXHRcdHZhciBvZmZfcGZGbGFncyA9IDIwO1xyXG5cdFx0dmFyIG9mZl9wZkZvdXJDQyA9IDIxO1xyXG5cclxuXHRcdHZhciBvZmZfY2FwcyA9IDI3O1xyXG5cdFx0dmFyIG9mZl9jYXBzMiA9IDI4O1xyXG5cdFx0dmFyIG9mZl9jYXBzMyA9IDI5O1xyXG5cdFx0dmFyIG9mZl9jYXBzNCA9IDMwO1xyXG5cclxuXHRcdC8vIFBhcnNlIGhlYWRlclxyXG5cclxuXHRcdHZhciBoZWFkZXIgPSBuZXcgSW50MzJBcnJheSggYnVmZmVyLCAwLCBoZWFkZXJMZW5ndGhJbnQgKTtcclxuXHJcblx0XHRpZiAoIGhlYWRlclsgb2ZmX21hZ2ljIF0gIT09IEREU19NQUdJQyApIHtcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiSW1hZ2VVdGlscy5wYXJzZUREUygpOiBJbnZhbGlkIG1hZ2ljIG51bWJlciBpbiBERFMgaGVhZGVyXCIgKTtcclxuXHRcdFx0cmV0dXJuIGRkcztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCAhIGhlYWRlclsgb2ZmX3BmRmxhZ3MgXSAmIEREUEZfRk9VUkNDICkge1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggXCJJbWFnZVV0aWxzLnBhcnNlRERTKCk6IFVuc3VwcG9ydGVkIGZvcm1hdCwgbXVzdCBjb250YWluIGEgRm91ckNDIGNvZGVcIiApO1xyXG5cdFx0XHRyZXR1cm4gZGRzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYmxvY2tCeXRlcztcclxuXHJcblx0XHR2YXIgZm91ckNDID0gaGVhZGVyWyBvZmZfcGZGb3VyQ0MgXTtcclxuXHJcblx0XHRzd2l0Y2ggKCBmb3VyQ0MgKSB7XHJcblxyXG5cdFx0XHRjYXNlIEZPVVJDQ19EWFQxOlxyXG5cclxuXHRcdFx0XHRibG9ja0J5dGVzID0gODtcclxuXHRcdFx0XHRkZHMuZm9ybWF0ID0gVEhSRUUuUkdCX1MzVENfRFhUMV9Gb3JtYXQ7XHJcblx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRjYXNlIEZPVVJDQ19EWFQzOlxyXG5cclxuXHRcdFx0XHRibG9ja0J5dGVzID0gMTY7XHJcblx0XHRcdFx0ZGRzLmZvcm1hdCA9IFRIUkVFLlJHQkFfUzNUQ19EWFQzX0Zvcm1hdDtcclxuXHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdGNhc2UgRk9VUkNDX0RYVDU6XHJcblxyXG5cdFx0XHRcdGJsb2NrQnl0ZXMgPSAxNjtcclxuXHRcdFx0XHRkZHMuZm9ybWF0ID0gVEhSRUUuUkdCQV9TM1RDX0RYVDVfRm9ybWF0O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0ZGVmYXVsdDpcclxuXHJcblx0XHRcdFx0Y29uc29sZS5lcnJvciggXCJJbWFnZVV0aWxzLnBhcnNlRERTKCk6IFVuc3VwcG9ydGVkIEZvdXJDQyBjb2RlOiBcIiwgaW50MzJUb0ZvdXJDQyggZm91ckNDICkgKTtcclxuXHRcdFx0XHRyZXR1cm4gZGRzO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRkZHMubWlwbWFwQ291bnQgPSAxO1xyXG5cclxuXHRcdGlmICggaGVhZGVyWyBvZmZfZmxhZ3MgXSAmIEREU0RfTUlQTUFQQ09VTlQgJiYgbG9hZE1pcG1hcHMgIT09IGZhbHNlICkge1xyXG5cclxuXHRcdFx0ZGRzLm1pcG1hcENvdW50ID0gTWF0aC5tYXgoIDEsIGhlYWRlclsgb2ZmX21pcG1hcENvdW50IF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly9UT0RPOiBWZXJpZnkgdGhhdCBhbGwgZmFjZXMgb2YgdGhlIGN1YmVtYXAgYXJlIHByZXNlbnQgd2l0aCBERFNDQVBTMl9DVUJFTUFQX1BPU0lUSVZFWCwgZXRjLlxyXG5cclxuXHRcdGRkcy5pc0N1YmVtYXAgPSBoZWFkZXJbIG9mZl9jYXBzMiBdICYgRERTQ0FQUzJfQ1VCRU1BUCA/IHRydWUgOiBmYWxzZTtcclxuXHJcblx0XHRkZHMud2lkdGggPSBoZWFkZXJbIG9mZl93aWR0aCBdO1xyXG5cdFx0ZGRzLmhlaWdodCA9IGhlYWRlclsgb2ZmX2hlaWdodCBdO1xyXG5cclxuXHRcdHZhciBkYXRhT2Zmc2V0ID0gaGVhZGVyWyBvZmZfc2l6ZSBdICsgNDtcclxuXHJcblx0XHQvLyBFeHRyYWN0IG1pcG1hcHMgYnVmZmVyc1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGRkcy53aWR0aDtcclxuXHRcdHZhciBoZWlnaHQgPSBkZHMuaGVpZ2h0O1xyXG5cclxuXHRcdHZhciBmYWNlcyA9IGRkcy5pc0N1YmVtYXAgPyA2IDogMTtcclxuXHJcblx0XHRmb3IgKCB2YXIgZmFjZSA9IDA7IGZhY2UgPCBmYWNlczsgZmFjZSArKyApIHtcclxuXHJcblx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IGRkcy5taXBtYXBDb3VudDsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGRhdGFMZW5ndGggPSBNYXRoLm1heCggNCwgd2lkdGggKSAvIDQgKiBNYXRoLm1heCggNCwgaGVpZ2h0ICkgLyA0ICogYmxvY2tCeXRlcztcclxuXHRcdFx0XHR2YXIgYnl0ZUFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoIGJ1ZmZlciwgZGF0YU9mZnNldCwgZGF0YUxlbmd0aCApO1xyXG5cclxuXHRcdFx0XHR2YXIgbWlwbWFwID0geyBcImRhdGFcIjogYnl0ZUFycmF5LCBcIndpZHRoXCI6IHdpZHRoLCBcImhlaWdodFwiOiBoZWlnaHQgfTtcclxuXHRcdFx0XHRkZHMubWlwbWFwcy5wdXNoKCBtaXBtYXAgKTtcclxuXHJcblx0XHRcdFx0ZGF0YU9mZnNldCArPSBkYXRhTGVuZ3RoO1xyXG5cclxuXHRcdFx0XHR3aWR0aCA9IE1hdGgubWF4KCB3aWR0aCAqIDAuNSwgMSApO1xyXG5cdFx0XHRcdGhlaWdodCA9IE1hdGgubWF4KCBoZWlnaHQgKiAwLjUsIDEgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHdpZHRoID0gZGRzLndpZHRoO1xyXG5cdFx0XHRoZWlnaHQgPSBkZHMuaGVpZ2h0O1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZGRzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZXROb3JtYWxNYXA6IGZ1bmN0aW9uICggaW1hZ2UsIGRlcHRoICkge1xyXG5cclxuXHRcdC8vIEFkYXB0ZWQgZnJvbSBodHRwOi8vd3d3LnBhdWxicnVudC5jby51ay9sYWIvaGVpZ2h0bm9ybWFsL1xyXG5cclxuXHRcdHZhciBjcm9zcyA9IGZ1bmN0aW9uICggYSwgYiApIHtcclxuXHJcblx0XHRcdHJldHVybiBbIGFbIDEgXSAqIGJbIDIgXSAtIGFbIDIgXSAqIGJbIDEgXSwgYVsgMiBdICogYlsgMCBdIC0gYVsgMCBdICogYlsgMiBdLCBhWyAwIF0gKiBiWyAxIF0gLSBhWyAxIF0gKiBiWyAwIF0gXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN1YnRyYWN0ID0gZnVuY3Rpb24gKCBhLCBiICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIFsgYVsgMCBdIC0gYlsgMCBdLCBhWyAxIF0gLSBiWyAxIF0sIGFbIDIgXSAtIGJbIDIgXSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gKCBhICkge1xyXG5cclxuXHRcdFx0dmFyIGwgPSBNYXRoLnNxcnQoIGFbIDAgXSAqIGFbIDAgXSArIGFbIDEgXSAqIGFbIDEgXSArIGFbIDIgXSAqIGFbIDIgXSApO1xyXG5cdFx0XHRyZXR1cm4gWyBhWyAwIF0gLyBsLCBhWyAxIF0gLyBsLCBhWyAyIF0gLyBsIF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGRlcHRoID0gZGVwdGggfCAxO1xyXG5cclxuXHRcdHZhciB3aWR0aCA9IGltYWdlLndpZHRoO1xyXG5cdFx0dmFyIGhlaWdodCA9IGltYWdlLmhlaWdodDtcclxuXHJcblx0XHR2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2NhbnZhcycgKTtcclxuXHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG5cdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcblx0XHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XHJcblx0XHRjb250ZXh0LmRyYXdJbWFnZSggaW1hZ2UsIDAsIDAgKTtcclxuXHJcblx0XHR2YXIgZGF0YSA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICkuZGF0YTtcclxuXHRcdHZhciBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSggd2lkdGgsIGhlaWdodCApO1xyXG5cdFx0dmFyIG91dHB1dCA9IGltYWdlRGF0YS5kYXRhO1xyXG5cclxuXHRcdGZvciAoIHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4ICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICsrICkge1xyXG5cclxuXHRcdFx0XHR2YXIgbHkgPSB5IC0gMSA8IDAgPyAwIDogeSAtIDE7XHJcblx0XHRcdFx0dmFyIHV5ID0geSArIDEgPiBoZWlnaHQgLSAxID8gaGVpZ2h0IC0gMSA6IHkgKyAxO1xyXG5cdFx0XHRcdHZhciBseCA9IHggLSAxIDwgMCA/IDAgOiB4IC0gMTtcclxuXHRcdFx0XHR2YXIgdXggPSB4ICsgMSA+IHdpZHRoIC0gMSA/IHdpZHRoIC0gMSA6IHggKyAxO1xyXG5cclxuXHRcdFx0XHR2YXIgcG9pbnRzID0gW107XHJcblx0XHRcdFx0dmFyIG9yaWdpbiA9IFsgMCwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyB4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIC0gMSwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIC0gMSwgLSAxLCBkYXRhWyAoIGx5ICogd2lkdGggKyBseCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIDAsIC0gMSwgZGF0YVsgKCBseSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbICAxLCAtIDEsIGRhdGFbICggbHkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgMSwgMCwgZGF0YVsgKCB5ICogd2lkdGggKyB1eCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIDEsIDEsIGRhdGFbICggdXkgKiB3aWR0aCArIHV4ICkgKiA0IF0gLyAyNTUgKiBkZXB0aCBdICk7XHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIFsgMCwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgeCApICogNCBdIC8gMjU1ICogZGVwdGggXSApO1xyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBbIC0gMSwgMSwgZGF0YVsgKCB1eSAqIHdpZHRoICsgbHggKSAqIDQgXSAvIDI1NSAqIGRlcHRoIF0gKTtcclxuXHJcblx0XHRcdFx0dmFyIG5vcm1hbHMgPSBbXTtcclxuXHRcdFx0XHR2YXIgbnVtX3BvaW50cyA9IHBvaW50cy5sZW5ndGg7XHJcblxyXG5cdFx0XHRcdGZvciAoIHZhciBpID0gMDsgaSA8IG51bV9wb2ludHM7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHYxID0gcG9pbnRzWyBpIF07XHJcblx0XHRcdFx0XHR2YXIgdjIgPSBwb2ludHNbICggaSArIDEgKSAlIG51bV9wb2ludHMgXTtcclxuXHRcdFx0XHRcdHYxID0gc3VidHJhY3QoIHYxLCBvcmlnaW4gKTtcclxuXHRcdFx0XHRcdHYyID0gc3VidHJhY3QoIHYyLCBvcmlnaW4gKTtcclxuXHRcdFx0XHRcdG5vcm1hbHMucHVzaCggbm9ybWFsaXplKCBjcm9zcyggdjEsIHYyICkgKSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHZhciBub3JtYWwgPSBbIDAsIDAsIDAgXTtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbm9ybWFscy5sZW5ndGg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0bm9ybWFsWyAwIF0gKz0gbm9ybWFsc1sgaSBdWyAwIF07XHJcblx0XHRcdFx0XHRub3JtYWxbIDEgXSArPSBub3JtYWxzWyBpIF1bIDEgXTtcclxuXHRcdFx0XHRcdG5vcm1hbFsgMiBdICs9IG5vcm1hbHNbIGkgXVsgMiBdO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdG5vcm1hbFsgMCBdIC89IG5vcm1hbHMubGVuZ3RoO1xyXG5cdFx0XHRcdG5vcm1hbFsgMSBdIC89IG5vcm1hbHMubGVuZ3RoO1xyXG5cdFx0XHRcdG5vcm1hbFsgMiBdIC89IG5vcm1hbHMubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHR2YXIgaWR4ID0gKCB5ICogd2lkdGggKyB4ICkgKiA0O1xyXG5cclxuXHRcdFx0XHRvdXRwdXRbIGlkeCBdID0gKCAoIG5vcm1hbFsgMCBdICsgMS4wICkgLyAyLjAgKiAyNTUgKSB8IDA7XHJcblx0XHRcdFx0b3V0cHV0WyBpZHggKyAxIF0gPSAoICggbm9ybWFsWyAxIF0gKyAxLjAgKSAvIDIuMCAqIDI1NSApIHwgMDtcclxuXHRcdFx0XHRvdXRwdXRbIGlkeCArIDIgXSA9ICggbm9ybWFsWyAyIF0gKiAyNTUgKSB8IDA7XHJcblx0XHRcdFx0b3V0cHV0WyBpZHggKyAzIF0gPSAyNTU7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnRleHQucHV0SW1hZ2VEYXRhKCBpbWFnZURhdGEsIDAsIDAgKTtcclxuXHJcblx0XHRyZXR1cm4gY2FudmFzO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZURhdGFUZXh0dXJlOiBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGNvbG9yICkge1xyXG5cclxuXHRcdHZhciBzaXplID0gd2lkdGggKiBoZWlnaHQ7XHJcblx0XHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KCAzICogc2l6ZSApO1xyXG5cclxuXHRcdHZhciByID0gTWF0aC5mbG9vciggY29sb3IuciAqIDI1NSApO1xyXG5cdFx0dmFyIGcgPSBNYXRoLmZsb29yKCBjb2xvci5nICogMjU1ICk7XHJcblx0XHR2YXIgYiA9IE1hdGguZmxvb3IoIGNvbG9yLmIgKiAyNTUgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBzaXplOyBpICsrICkge1xyXG5cclxuXHRcdFx0ZGF0YVsgaSAqIDMgXSBcdCAgPSByO1xyXG5cdFx0XHRkYXRhWyBpICogMyArIDEgXSA9IGc7XHJcblx0XHRcdGRhdGFbIGkgKiAzICsgMiBdID0gYjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRleHR1cmUgPSBuZXcgVEhSRUUuRGF0YVRleHR1cmUoIGRhdGEsIHdpZHRoLCBoZWlnaHQsIFRIUkVFLlJHQkZvcm1hdCApO1xyXG5cdFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XHJcblxyXG5cdFx0cmV0dXJuIHRleHR1cmU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLlNjZW5lVXRpbHMgPSB7XHJcblxyXG5cdGNyZWF0ZU11bHRpTWF0ZXJpYWxPYmplY3Q6IGZ1bmN0aW9uICggZ2VvbWV0cnksIG1hdGVyaWFscyApIHtcclxuXHJcblx0XHR2YXIgZ3JvdXAgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBtYXRlcmlhbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGdyb3VwLmFkZCggbmV3IFRIUkVFLk1lc2goIGdlb21ldHJ5LCBtYXRlcmlhbHNbIGkgXSApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBncm91cDtcclxuXHJcblx0fSxcclxuXHJcblx0ZGV0YWNoIDogZnVuY3Rpb24gKCBjaGlsZCwgcGFyZW50LCBzY2VuZSApIHtcclxuXHJcblx0XHRjaGlsZC5hcHBseU1hdHJpeCggcGFyZW50Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRwYXJlbnQucmVtb3ZlKCBjaGlsZCApO1xyXG5cdFx0c2NlbmUuYWRkKCBjaGlsZCApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRhdHRhY2g6IGZ1bmN0aW9uICggY2hpbGQsIHNjZW5lLCBwYXJlbnQgKSB7XHJcblxyXG5cdFx0dmFyIG1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblx0XHRtYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRjaGlsZC5hcHBseU1hdHJpeCggbWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0c2NlbmUucmVtb3ZlKCBjaGlsZCApO1xyXG5cdFx0cGFyZW50LmFkZCggY2hpbGQgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogRm9yIFRleHQgb3BlcmF0aW9ucyBpbiB0aHJlZS5qcyAoU2VlIFRleHRHZW9tZXRyeSlcclxuICpcclxuICogSXQgdXNlcyB0ZWNobmlxdWVzIHVzZWQgaW46XHJcbiAqXHJcbiAqIFx0dHlwZWZhY2UuanMgYW5kIGNhbnZhc3RleHRcclxuICogXHRcdEZvciBjb252ZXJ0aW5nIGZvbnRzIGFuZCByZW5kZXJpbmcgd2l0aCBqYXZhc2NyaXB0XHJcbiAqXHRcdGh0dHA6Ly90eXBlZmFjZS5uZW9jcmFjeS5vcmdcclxuICpcclxuICpcdFRyaWFuZ3VsYXRpb24gcG9ydGVkIGZyb20gQVMzXHJcbiAqXHRcdFNpbXBsZSBQb2x5Z29uIFRyaWFuZ3VsYXRpb25cclxuICpcdFx0aHR0cDovL2FjdGlvbnNuaXBwZXQuY29tLz9wPTE0NjJcclxuICpcclxuICogXHRBIE1ldGhvZCB0byB0cmlhbmd1bGF0ZSBzaGFwZXMgd2l0aCBob2xlc1xyXG4gKlx0XHRodHRwOi8vd3d3LnNha3JpLm5ldC9ibG9nLzIwMDkvMDYvMTIvYW4tYXBwcm9hY2gtdG8tdHJpYW5ndWxhdGluZy1wb2x5Z29ucy13aXRoLWhvbGVzL1xyXG4gKlxyXG4gKi9cclxuXHJcblRIUkVFLkZvbnRVdGlscyA9IHtcclxuXHJcblx0ZmFjZXMgOiB7fSxcclxuXHJcblx0Ly8gSnVzdCBmb3Igbm93LiBmYWNlW3dlaWdodF1bc3R5bGVdXHJcblxyXG5cdGZhY2UgOiBcImhlbHZldGlrZXJcIixcclxuXHR3ZWlnaHQ6IFwibm9ybWFsXCIsXHJcblx0c3R5bGUgOiBcIm5vcm1hbFwiLFxyXG5cdHNpemUgOiAxNTAsXHJcblx0ZGl2aXNpb25zIDogMTAsXHJcblxyXG5cdGdldEZhY2UgOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5mYWNlc1sgdGhpcy5mYWNlIF1bIHRoaXMud2VpZ2h0IF1bIHRoaXMuc3R5bGUgXTtcclxuXHJcblx0fSxcclxuXHJcblx0bG9hZEZhY2UgOiBmdW5jdGlvbiggZGF0YSApIHtcclxuXHJcblx0XHR2YXIgZmFtaWx5ID0gZGF0YS5mYW1pbHlOYW1lLnRvTG93ZXJDYXNlKCk7XHJcblxyXG5cdFx0dmFyIFRocmVlRm9udCA9IHRoaXM7XHJcblxyXG5cdFx0VGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF0gfHwge307XHJcblxyXG5cdFx0VGhyZWVGb250LmZhY2VzWyBmYW1pbHkgXVsgZGF0YS5jc3NGb250V2VpZ2h0IF0gPSBUaHJlZUZvbnQuZmFjZXNbIGZhbWlseSBdWyBkYXRhLmNzc0ZvbnRXZWlnaHQgXSB8fCB7fTtcclxuXHRcdFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcclxuXHJcblx0XHR2YXIgZmFjZSA9IFRocmVlRm9udC5mYWNlc1sgZmFtaWx5IF1bIGRhdGEuY3NzRm9udFdlaWdodCBdWyBkYXRhLmNzc0ZvbnRTdHlsZSBdID0gZGF0YTtcclxuXHJcblx0XHRyZXR1cm4gZGF0YTtcclxuXHJcblx0fSxcclxuXHJcblx0ZHJhd1RleHQgOiBmdW5jdGlvbiggdGV4dCApIHtcclxuXHJcblx0XHR2YXIgY2hhcmFjdGVyUHRzID0gW10sIGFsbFB0cyA9IFtdO1xyXG5cclxuXHRcdC8vIFJlbmRlclRleHRcclxuXHJcblx0XHR2YXIgaSwgcCxcclxuXHRcdFx0ZmFjZSA9IHRoaXMuZ2V0RmFjZSgpLFxyXG5cdFx0XHRzY2FsZSA9IHRoaXMuc2l6ZSAvIGZhY2UucmVzb2x1dGlvbixcclxuXHRcdFx0b2Zmc2V0ID0gMCxcclxuXHRcdFx0Y2hhcnMgPSBTdHJpbmcoIHRleHQgKS5zcGxpdCggJycgKSxcclxuXHRcdFx0bGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xyXG5cclxuXHRcdHZhciBmb250UGF0aHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBwYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcblx0XHRcdHZhciByZXQgPSB0aGlzLmV4dHJhY3RHbHlwaFBvaW50cyggY2hhcnNbIGkgXSwgZmFjZSwgc2NhbGUsIG9mZnNldCwgcGF0aCApO1xyXG5cdFx0XHRvZmZzZXQgKz0gcmV0Lm9mZnNldDtcclxuXHJcblx0XHRcdGZvbnRQYXRocy5wdXNoKCByZXQucGF0aCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBnZXQgdGhlIHdpZHRoXHJcblxyXG5cdFx0dmFyIHdpZHRoID0gb2Zmc2V0IC8gMjtcclxuXHRcdC8vXHJcblx0XHQvLyBmb3IgKCBwID0gMDsgcCA8IGFsbFB0cy5sZW5ndGg7IHArKyApIHtcclxuXHRcdC8vXHJcblx0XHQvLyBcdGFsbFB0c1sgcCBdLnggLT0gd2lkdGg7XHJcblx0XHQvL1xyXG5cdFx0Ly8gfVxyXG5cclxuXHRcdC8vdmFyIGV4dHJhY3QgPSB0aGlzLmV4dHJhY3RQb2ludHMoIGFsbFB0cywgY2hhcmFjdGVyUHRzICk7XHJcblx0XHQvL2V4dHJhY3QuY29udG91ciA9IGFsbFB0cztcclxuXHJcblx0XHQvL2V4dHJhY3QucGF0aHMgPSBmb250UGF0aHM7XHJcblx0XHQvL2V4dHJhY3Qub2Zmc2V0ID0gd2lkdGg7XHJcblxyXG5cdFx0cmV0dXJuIHsgcGF0aHMgOiBmb250UGF0aHMsIG9mZnNldCA6IHdpZHRoIH07XHJcblxyXG5cdH0sXHJcblxyXG5cclxuXHJcblxyXG5cdGV4dHJhY3RHbHlwaFBvaW50cyA6IGZ1bmN0aW9uKCBjLCBmYWNlLCBzY2FsZSwgb2Zmc2V0LCBwYXRoICkge1xyXG5cclxuXHRcdHZhciBwdHMgPSBbXTtcclxuXHJcblx0XHR2YXIgaSwgaTIsIGRpdmlzaW9ucyxcclxuXHRcdFx0b3V0bGluZSwgYWN0aW9uLCBsZW5ndGgsXHJcblx0XHRcdHNjYWxlWCwgc2NhbGVZLFxyXG5cdFx0XHR4LCB5LCBjcHgsIGNweSwgY3B4MCwgY3B5MCwgY3B4MSwgY3B5MSwgY3B4MiwgY3B5MixcclxuXHRcdFx0bGFzdGUsXHJcblx0XHRcdGdseXBoID0gZmFjZS5nbHlwaHNbIGMgXSB8fCBmYWNlLmdseXBoc1sgJz8nIF07XHJcblxyXG5cdFx0aWYgKCAhZ2x5cGggKSByZXR1cm47XHJcblxyXG5cdFx0aWYgKCBnbHlwaC5vICkge1xyXG5cclxuXHRcdFx0b3V0bGluZSA9IGdseXBoLl9jYWNoZWRPdXRsaW5lIHx8ICggZ2x5cGguX2NhY2hlZE91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCAnICcgKSApO1xyXG5cdFx0XHRsZW5ndGggPSBvdXRsaW5lLmxlbmd0aDtcclxuXHJcblx0XHRcdHNjYWxlWCA9IHNjYWxlO1xyXG5cdFx0XHRzY2FsZVkgPSBzY2FsZTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoOyApIHtcclxuXHJcblx0XHRcdFx0YWN0aW9uID0gb3V0bGluZVsgaSArKyBdO1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKCBhY3Rpb24gKTtcclxuXHJcblx0XHRcdFx0c3dpdGNoKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0XHRcdGNhc2UgJ20nOlxyXG5cclxuXHRcdFx0XHRcdC8vIE1vdmUgVG9cclxuXHJcblx0XHRcdFx0XHR4ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVggKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHR5ID0gb3V0bGluZVsgaSsrIF0gKiBzY2FsZVk7XHJcblxyXG5cdFx0XHRcdFx0cGF0aC5tb3ZlVG8oIHgsIHkgKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdsJzpcclxuXHJcblx0XHRcdFx0XHQvLyBMaW5lIFRvXHJcblxyXG5cdFx0XHRcdFx0eCA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0eSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xyXG5cdFx0XHRcdFx0cGF0aC5saW5lVG8oeCx5KTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0XHRjYXNlICdxJzpcclxuXHJcblx0XHRcdFx0XHQvLyBRdWFkcmF0aWNDdXJ2ZVRvXHJcblxyXG5cdFx0XHRcdFx0Y3B4ICA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0Y3B5ICA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xyXG5cdFx0XHRcdFx0Y3B4MSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVYICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0Y3B5MSA9IG91dGxpbmVbIGkrKyBdICogc2NhbGVZO1xyXG5cclxuXHRcdFx0XHRcdHBhdGgucXVhZHJhdGljQ3VydmVUbyhjcHgxLCBjcHkxLCBjcHgsIGNweSk7XHJcblxyXG5cdFx0XHRcdFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBsYXN0ZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xyXG5cdFx0XHRcdFx0XHRjcHkwID0gbGFzdGUueTtcclxuXHJcblx0XHRcdFx0XHRcdGZvciAoIGkyID0gMSwgZGl2aXNpb25zID0gdGhpcy5kaXZpc2lvbnM7IGkyIDw9IGRpdmlzaW9uczsgaTIgKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciB0ID0gaTIgLyBkaXZpc2lvbnM7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweDAsIGNweDEsIGNweCApO1xyXG5cdFx0XHRcdFx0XHRcdHZhciB0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCBjcHkwLCBjcHkxLCBjcHkgKTtcclxuXHRcdFx0XHRcdCAgfVxyXG5cclxuXHRcdFx0XHQgIH1cclxuXHJcblx0XHRcdFx0ICBicmVhaztcclxuXHJcblx0XHRcdFx0Y2FzZSAnYic6XHJcblxyXG5cdFx0XHRcdFx0Ly8gQ3ViaWMgQmV6aWVyIEN1cnZlXHJcblxyXG5cdFx0XHRcdFx0Y3B4ICA9IG91dGxpbmVbIGkrKyBdICogIHNjYWxlWCArIG9mZnNldDtcclxuXHRcdFx0XHRcdGNweSAgPSBvdXRsaW5lWyBpKysgXSAqICBzY2FsZVk7XHJcblx0XHRcdFx0XHRjcHgxID0gb3V0bGluZVsgaSsrIF0gKiAgc2NhbGVYICsgb2Zmc2V0O1xyXG5cdFx0XHRcdFx0Y3B5MSA9IG91dGxpbmVbIGkrKyBdICogLXNjYWxlWTtcclxuXHRcdFx0XHRcdGNweDIgPSBvdXRsaW5lWyBpKysgXSAqICBzY2FsZVggKyBvZmZzZXQ7XHJcblx0XHRcdFx0XHRjcHkyID0gb3V0bGluZVsgaSsrIF0gKiAtc2NhbGVZO1xyXG5cclxuXHRcdFx0XHRcdHBhdGguYmV6aWVyQ3VydmVUbyggY3B4LCBjcHksIGNweDEsIGNweTEsIGNweDIsIGNweTIgKTtcclxuXHJcblx0XHRcdFx0XHRsYXN0ZSA9IHB0c1sgcHRzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGxhc3RlICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XHJcblx0XHRcdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggaTIgPSAxLCBkaXZpc2lvbnMgPSB0aGlzLmRpdmlzaW9uczsgaTIgPD0gZGl2aXNpb25zOyBpMiArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0dmFyIHQgPSBpMiAvIGRpdmlzaW9ucztcclxuXHRcdFx0XHRcdFx0XHR2YXIgdHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B4MCwgY3B4MSwgY3B4MiwgY3B4ICk7XHJcblx0XHRcdFx0XHRcdFx0dmFyIHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIGNweTAsIGNweTEsIGNweTIsIGNweSApO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHJcblxyXG5cdFx0cmV0dXJuIHsgb2Zmc2V0OiBnbHlwaC5oYSpzY2FsZSwgcGF0aDpwYXRofTtcclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyA9IGZ1bmN0aW9uKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHQvLyBQYXJhbWV0ZXJzIFxyXG5cclxuXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcclxuXHJcblx0dmFyIHNpemUgPSBwYXJhbWV0ZXJzLnNpemUgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuc2l6ZSA6IDEwMDtcclxuXHR2YXIgY3VydmVTZWdtZW50cyA9IHBhcmFtZXRlcnMuY3VydmVTZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzOiA0O1xyXG5cclxuXHR2YXIgZm9udCA9IHBhcmFtZXRlcnMuZm9udCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5mb250IDogXCJoZWx2ZXRpa2VyXCI7XHJcblx0dmFyIHdlaWdodCA9IHBhcmFtZXRlcnMud2VpZ2h0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLndlaWdodCA6IFwibm9ybWFsXCI7XHJcblx0dmFyIHN0eWxlID0gcGFyYW1ldGVycy5zdHlsZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdHlsZSA6IFwibm9ybWFsXCI7XHJcblxyXG5cdFRIUkVFLkZvbnRVdGlscy5zaXplID0gc2l6ZTtcclxuXHRUSFJFRS5Gb250VXRpbHMuZGl2aXNpb25zID0gY3VydmVTZWdtZW50cztcclxuXHJcblx0VEhSRUUuRm9udFV0aWxzLmZhY2UgPSBmb250O1xyXG5cdFRIUkVFLkZvbnRVdGlscy53ZWlnaHQgPSB3ZWlnaHQ7XHJcblx0VEhSRUUuRm9udFV0aWxzLnN0eWxlID0gc3R5bGU7XHJcblxyXG5cdC8vIEdldCBhIEZvbnQgZGF0YSBqc29uIG9iamVjdFxyXG5cclxuXHR2YXIgZGF0YSA9IFRIUkVFLkZvbnRVdGlscy5kcmF3VGV4dCggdGV4dCApO1xyXG5cclxuXHR2YXIgcGF0aHMgPSBkYXRhLnBhdGhzO1xyXG5cdHZhciBzaGFwZXMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIHAgPSAwLCBwbCA9IHBhdGhzLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xyXG5cclxuXHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBzaGFwZXMsIHBhdGhzWyBwIF0udG9TaGFwZXMoKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBzaGFwZXM7XHJcblxyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGlzIGNvZGUgaXMgYSBxdWljayBwb3J0IG9mIGNvZGUgd3JpdHRlbiBpbiBDKysgd2hpY2ggd2FzIHN1Ym1pdHRlZCB0b1xyXG4gKiBmbGlwY29kZS5jb20gYnkgSm9obiBXLiBSYXRjbGlmZiAgLy8gSnVseSAyMiwgMjAwMFxyXG4gKiBTZWUgb3JpZ2luYWwgY29kZSBhbmQgbW9yZSBpbmZvcm1hdGlvbiBoZXJlOlxyXG4gKiBodHRwOi8vd3d3LmZsaXBjb2RlLmNvbS9hcmNoaXZlcy9FZmZpY2llbnRfUG9seWdvbl9Ucmlhbmd1bGF0aW9uLnNodG1sXHJcbiAqXHJcbiAqIHBvcnRlZCB0byBhY3Rpb25zY3JpcHQgYnkgWmV2YW4gUm9zc2VyXHJcbiAqIHd3dy5hY3Rpb25zbmlwcGV0LmNvbVxyXG4gKlxyXG4gKiBwb3J0ZWQgdG8gamF2YXNjcmlwdCBieSBKb3NodWEgS29vXHJcbiAqIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICovXHJcblxyXG5cclxuKCBmdW5jdGlvbiggbmFtZXNwYWNlICkge1xyXG5cclxuXHR2YXIgRVBTSUxPTiA9IDAuMDAwMDAwMDAwMTtcclxuXHJcblx0Ly8gdGFrZXMgaW4gYW4gY29udG91ciBhcnJheSBhbmQgcmV0dXJuc1xyXG5cclxuXHR2YXIgcHJvY2VzcyA9IGZ1bmN0aW9uKCBjb250b3VyLCBpbmRpY2VzICkge1xyXG5cclxuXHRcdHZhciBuID0gY29udG91ci5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKCBuIDwgMyApIHJldHVybiBudWxsO1xyXG5cclxuXHRcdHZhciByZXN1bHQgPSBbXSxcclxuXHRcdFx0dmVydHMgPSBbXSxcclxuXHRcdFx0dmVydEluZGljZXMgPSBbXTtcclxuXHJcblx0XHQvKiB3ZSB3YW50IGEgY291bnRlci1jbG9ja3dpc2UgcG9seWdvbiBpbiB2ZXJ0cyAqL1xyXG5cclxuXHRcdHZhciB1LCB2LCB3O1xyXG5cclxuXHRcdGlmICggYXJlYSggY29udG91ciApID4gMC4wICkge1xyXG5cclxuXHRcdFx0Zm9yICggdiA9IDA7IHYgPCBuOyB2KysgKSB2ZXJ0c1sgdiBdID0gdjtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0Zm9yICggdiA9IDA7IHYgPCBuOyB2KysgKSB2ZXJ0c1sgdiBdID0gKCBuIC0gMSApIC0gdjtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIG52ID0gbjtcclxuXHJcblx0XHQvKiAgcmVtb3ZlIG52IC0gMiB2ZXJ0aWNlcywgY3JlYXRpbmcgMSB0cmlhbmdsZSBldmVyeSB0aW1lICovXHJcblxyXG5cdFx0dmFyIGNvdW50ID0gMiAqIG52OyAgIC8qIGVycm9yIGRldGVjdGlvbiAqL1xyXG5cclxuXHRcdGZvciggdiA9IG52IC0gMTsgbnYgPiAyOyApIHtcclxuXHJcblx0XHRcdC8qIGlmIHdlIGxvb3AsIGl0IGlzIHByb2JhYmx5IGEgbm9uLXNpbXBsZSBwb2x5Z29uICovXHJcblxyXG5cdFx0XHRpZiAoICggY291bnQtLSApIDw9IDAgKSB7XHJcblxyXG5cdFx0XHRcdC8vKiogVHJpYW5ndWxhdGU6IEVSUk9SIC0gcHJvYmFibGUgYmFkIHBvbHlnb24hXHJcblxyXG5cdFx0XHRcdC8vdGhyb3cgKCBcIldhcm5pbmcsIHVuYWJsZSB0byB0cmlhbmd1bGF0ZSBwb2x5Z29uIVwiICk7XHJcblx0XHRcdFx0Ly9yZXR1cm4gbnVsbDtcclxuXHRcdFx0XHQvLyBTb21ldGltZXMgd2FybmluZyBpcyBmaW5lLCBlc3BlY2lhbGx5IHBvbHlnb25zIGFyZSB0cmlhbmd1bGF0ZWQgaW4gcmV2ZXJzZS5cclxuXHRcdFx0XHRjb25zb2xlLmxvZyggXCJXYXJuaW5nLCB1bmFibGUgdG8gdHJpYW5ndWxhdGUgcG9seWdvbiFcIiApO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGljZXMgKSByZXR1cm4gdmVydEluZGljZXM7XHJcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8qIHRocmVlIGNvbnNlY3V0aXZlIHZlcnRpY2VzIGluIGN1cnJlbnQgcG9seWdvbiwgPHUsdix3PiAqL1xyXG5cclxuXHRcdFx0dSA9IHY7IFx0IFx0aWYgKCBudiA8PSB1ICkgdSA9IDA7ICAgICAvKiBwcmV2aW91cyAqL1xyXG5cdFx0XHR2ID0gdSArIDE7ICBpZiAoIG52IDw9IHYgKSB2ID0gMDsgICAgIC8qIG5ldyB2ICAgICovXHJcblx0XHRcdHcgPSB2ICsgMTsgIGlmICggbnYgPD0gdyApIHcgPSAwOyAgICAgLyogbmV4dCAgICAgKi9cclxuXHJcblx0XHRcdGlmICggc25pcCggY29udG91ciwgdSwgdiwgdywgbnYsIHZlcnRzICkgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhLCBiLCBjLCBzLCB0O1xyXG5cclxuXHRcdFx0XHQvKiB0cnVlIG5hbWVzIG9mIHRoZSB2ZXJ0aWNlcyAqL1xyXG5cclxuXHRcdFx0XHRhID0gdmVydHNbIHUgXTtcclxuXHRcdFx0XHRiID0gdmVydHNbIHYgXTtcclxuXHRcdFx0XHRjID0gdmVydHNbIHcgXTtcclxuXHJcblx0XHRcdFx0Lyogb3V0cHV0IFRyaWFuZ2xlICovXHJcblxyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKCBbIGNvbnRvdXJbIGEgXSxcclxuXHRcdFx0XHRcdGNvbnRvdXJbIGIgXSxcclxuXHRcdFx0XHRcdGNvbnRvdXJbIGMgXSBdICk7XHJcblxyXG5cclxuXHRcdFx0XHR2ZXJ0SW5kaWNlcy5wdXNoKCBbIHZlcnRzWyB1IF0sIHZlcnRzWyB2IF0sIHZlcnRzWyB3IF0gXSApO1xyXG5cclxuXHRcdFx0XHQvKiByZW1vdmUgdiBmcm9tIHRoZSByZW1haW5pbmcgcG9seWdvbiAqL1xyXG5cclxuXHRcdFx0XHRmb3IoIHMgPSB2LCB0ID0gdiArIDE7IHQgPCBudjsgcysrLCB0KysgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmVydHNbIHMgXSA9IHZlcnRzWyB0IF07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0bnYtLTtcclxuXHJcblx0XHRcdFx0LyogcmVzZXQgZXJyb3IgZGV0ZWN0aW9uIGNvdW50ZXIgKi9cclxuXHJcblx0XHRcdFx0Y291bnQgPSAyICogbnY7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggaW5kaWNlcyApIHJldHVybiB2ZXJ0SW5kaWNlcztcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblxyXG5cdH07XHJcblxyXG5cdC8vIGNhbGN1bGF0ZSBhcmVhIG9mIHRoZSBjb250b3VyIHBvbHlnb25cclxuXHJcblx0dmFyIGFyZWEgPSBmdW5jdGlvbiAoIGNvbnRvdXIgKSB7XHJcblxyXG5cdFx0dmFyIG4gPSBjb250b3VyLmxlbmd0aDtcclxuXHRcdHZhciBhID0gMC4wO1xyXG5cclxuXHRcdGZvciggdmFyIHAgPSBuIC0gMSwgcSA9IDA7IHEgPCBuOyBwID0gcSsrICkge1xyXG5cclxuXHRcdFx0YSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGEgKiAwLjU7XHJcblxyXG5cdH07XHJcblxyXG5cdHZhciBzbmlwID0gZnVuY3Rpb24gKCBjb250b3VyLCB1LCB2LCB3LCBuLCB2ZXJ0cyApIHtcclxuXHJcblx0XHR2YXIgcDtcclxuXHRcdHZhciBheCwgYXksIGJ4LCBieTtcclxuXHRcdHZhciBjeCwgY3ksIHB4LCBweTtcclxuXHJcblx0XHRheCA9IGNvbnRvdXJbIHZlcnRzWyB1IF0gXS54O1xyXG5cdFx0YXkgPSBjb250b3VyWyB2ZXJ0c1sgdSBdIF0ueTtcclxuXHJcblx0XHRieCA9IGNvbnRvdXJbIHZlcnRzWyB2IF0gXS54O1xyXG5cdFx0YnkgPSBjb250b3VyWyB2ZXJ0c1sgdiBdIF0ueTtcclxuXHJcblx0XHRjeCA9IGNvbnRvdXJbIHZlcnRzWyB3IF0gXS54O1xyXG5cdFx0Y3kgPSBjb250b3VyWyB2ZXJ0c1sgdyBdIF0ueTtcclxuXHJcblx0XHRpZiAoIEVQU0lMT04gPiAoKChieC1heCkqKGN5LWF5KSkgLSAoKGJ5LWF5KSooY3gtYXgpKSkgKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0dmFyIGFYLCBhWSwgYlgsIGJZLCBjWCwgY1k7XHJcblx0XHR2YXIgYXB4LCBhcHksIGJweCwgYnB5LCBjcHgsIGNweTtcclxuXHRcdHZhciBjQ1JPU1NhcCwgYkNST1NTY3AsIGFDUk9TU2JwO1xyXG5cclxuXHRcdGFYID0gY3ggLSBieDsgIGFZID0gY3kgLSBieTtcclxuXHRcdGJYID0gYXggLSBjeDsgIGJZID0gYXkgLSBjeTtcclxuXHRcdGNYID0gYnggLSBheDsgIGNZID0gYnkgLSBheTtcclxuXHJcblx0XHRmb3IgKCBwID0gMDsgcCA8IG47IHArKyApIHtcclxuXHJcblx0XHRcdGlmKCAocCA9PT0gdSkgfHwgKHAgPT09IHYpIHx8IChwID09PSB3KSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0cHggPSBjb250b3VyWyB2ZXJ0c1sgcCBdIF0ueFxyXG5cdFx0XHRweSA9IGNvbnRvdXJbIHZlcnRzWyBwIF0gXS55XHJcblxyXG5cdFx0XHRhcHggPSBweCAtIGF4OyAgYXB5ID0gcHkgLSBheTtcclxuXHRcdFx0YnB4ID0gcHggLSBieDsgIGJweSA9IHB5IC0gYnk7XHJcblx0XHRcdGNweCA9IHB4IC0gY3g7ICBjcHkgPSBweSAtIGN5O1xyXG5cclxuXHRcdFx0Ly8gc2VlIGlmIHAgaXMgaW5zaWRlIHRyaWFuZ2xlIGFiY1xyXG5cclxuXHRcdFx0YUNST1NTYnAgPSBhWCpicHkgLSBhWSpicHg7XHJcblx0XHRcdGNDUk9TU2FwID0gY1gqYXB5IC0gY1kqYXB4O1xyXG5cdFx0XHRiQ1JPU1NjcCA9IGJYKmNweSAtIGJZKmNweDtcclxuXHJcblx0XHRcdGlmICggKGFDUk9TU2JwID49IDAuMCkgJiYgKGJDUk9TU2NwID49IDAuMCkgJiYgKGNDUk9TU2FwID49IDAuMCkgKSByZXR1cm4gZmFsc2U7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cclxuXHR9O1xyXG5cclxuXHJcblx0bmFtZXNwYWNlLlRyaWFuZ3VsYXRlID0gcHJvY2VzcztcclxuXHRuYW1lc3BhY2UuVHJpYW5ndWxhdGUuYXJlYSA9IGFyZWE7XHJcblxyXG5cdHJldHVybiBuYW1lc3BhY2U7XHJcblxyXG59KShUSFJFRS5Gb250VXRpbHMpO1xyXG5cclxuLy8gVG8gdXNlIHRoZSB0eXBlZmFjZS5qcyBmYWNlIGZpbGVzLCBob29rIHVwIHRoZSBBUElcclxuc2VsZi5fdHlwZWZhY2VfanMgPSB7IGZhY2VzOiBUSFJFRS5Gb250VXRpbHMuZmFjZXMsIGxvYWRGYWNlOiBUSFJFRS5Gb250VXRpbHMubG9hZEZhY2UgfTsvKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdFxyXG4gKlxyXG4gKiBTb21lIGNvbW1vbiBvZiBDdXJ2ZSBtZXRob2RzXHJcbiAqIC5nZXRQb2ludCh0KSwgZ2V0VGFuZ2VudCh0KVxyXG4gKiAuZ2V0UG9pbnRBdCh1KSwgZ2V0VGFnZW50QXQodSlcclxuICogLmdldFBvaW50cygpLCAuZ2V0U3BhY2VkUG9pbnRzKClcclxuICogLmdldExlbmd0aCgpXHJcbiAqIC51cGRhdGVBcmNMZW5ndGhzKClcclxuICpcclxuICogVGhpcyBmaWxlIGNvbnRhaW5zIGZvbGxvd2luZyBjbGFzc2VzOlxyXG4gKlxyXG4gKiAtLSAyZCBjbGFzc2VzIC0tXHJcbiAqIFRIUkVFLkN1cnZlXHJcbiAqIFRIUkVFLkxpbmVDdXJ2ZVxyXG4gKiBUSFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZVxyXG4gKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXHJcbiAqIFRIUkVFLlNwbGluZUN1cnZlXHJcbiAqIFRIUkVFLkFyY0N1cnZlXHJcbiAqIFRIUkVFLkVsbGlwc2VDdXJ2ZVxyXG4gKlxyXG4gKiAtLSAzZCBjbGFzc2VzIC0tXHJcbiAqIFRIUkVFLkxpbmVDdXJ2ZTNcclxuICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUzXHJcbiAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXHJcbiAqIFRIUkVFLlNwbGluZUN1cnZlM1xyXG4gKiBUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTNcclxuICpcclxuICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aFxyXG4gKlxyXG4gKiovXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3NcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3VydmUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG59O1xyXG5cclxuLy8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXHJcbi8vXHQtIHQgWzAgLi4gMV1cclxuXHJcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0Y29uc29sZS5sb2coIFwiV2FybmluZywgZ2V0UG9pbnQoKSBub3QgaW1wbGVtZW50ZWQhXCIgKTtcclxuXHRyZXR1cm4gbnVsbDtcclxuXHJcbn07XHJcblxyXG4vLyBHZXQgcG9pbnQgYXQgcmVsYXRpdmUgcG9zaXRpb24gaW4gY3VydmUgYWNjb3JkaW5nIHRvIGFyYyBsZW5ndGhcclxuLy8gLSB1IFswIC4uIDFdXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnRBdCA9IGZ1bmN0aW9uICggdSApIHtcclxuXHJcblx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XHJcblx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQgKTtcclxuXHJcbn07XHJcblxyXG4vLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcclxuXHJcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0aWYgKCAhZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcclxuXHJcblx0dmFyIGQsIHB0cyA9IFtdO1xyXG5cclxuXHRmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XHJcblxyXG5cdFx0cHRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGQgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBwdHM7XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IHNlcXVlbmNlIG9mIHBvaW50cyB1c2luZyBnZXRQb2ludEF0KCB1IClcclxuXHJcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRTcGFjZWRQb2ludHMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0aWYgKCAhZGl2aXNpb25zICkgZGl2aXNpb25zID0gNTtcclxuXHJcblx0dmFyIGQsIHB0cyA9IFtdO1xyXG5cclxuXHRmb3IgKCBkID0gMDsgZCA8PSBkaXZpc2lvbnM7IGQgKysgKSB7XHJcblxyXG5cdFx0cHRzLnB1c2goIHRoaXMuZ2V0UG9pbnRBdCggZCAvIGRpdmlzaW9ucyApICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIHB0cztcclxuXHJcbn07XHJcblxyXG4vLyBHZXQgdG90YWwgY3VydmUgYXJjIGxlbmd0aFxyXG5cclxuVEhSRUUuQ3VydmUucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcclxuXHRyZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IGxpc3Qgb2YgY3VtdWxhdGl2ZSBzZWdtZW50IGxlbmd0aHNcclxuXHJcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRMZW5ndGhzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdGlmICggIWRpdmlzaW9ucyApIGRpdmlzaW9ucyA9ICh0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zKSA/ICh0aGlzLl9fYXJjTGVuZ3RoRGl2aXNpb25zKTogMjAwO1xyXG5cclxuXHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzXHJcblx0XHQmJiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzLmxlbmd0aCA9PSBkaXZpc2lvbnMgKyAxIClcclxuXHRcdCYmICF0aGlzLm5lZWRzVXBkYXRlKSB7XHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZyggXCJjYWNoZWRcIiwgdGhpcy5jYWNoZUFyY0xlbmd0aHMgKTtcclxuXHRcdHJldHVybiB0aGlzLmNhY2hlQXJjTGVuZ3RocztcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdHZhciBjYWNoZSA9IFtdO1xyXG5cdHZhciBjdXJyZW50LCBsYXN0ID0gdGhpcy5nZXRQb2ludCggMCApO1xyXG5cdHZhciBwLCBzdW0gPSAwO1xyXG5cclxuXHRjYWNoZS5wdXNoKCAwICk7XHJcblxyXG5cdGZvciAoIHAgPSAxOyBwIDw9IGRpdmlzaW9uczsgcCArKyApIHtcclxuXHJcblx0XHRjdXJyZW50ID0gdGhpcy5nZXRQb2ludCAoIHAgLyBkaXZpc2lvbnMgKTtcclxuXHRcdHN1bSArPSBjdXJyZW50LmRpc3RhbmNlVG8oIGxhc3QgKTtcclxuXHRcdGNhY2hlLnB1c2goIHN1bSApO1xyXG5cdFx0bGFzdCA9IGN1cnJlbnQ7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jYWNoZUFyY0xlbmd0aHMgPSBjYWNoZTtcclxuXHJcblx0cmV0dXJuIGNhY2hlOyAvLyB7IHN1bXM6IGNhY2hlLCBzdW06c3VtIH07IFN1bSBpcyBpbiB0aGUgbGFzdCBlbGVtZW50LlxyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUudXBkYXRlQXJjTGVuZ3RocyA9IGZ1bmN0aW9uKCkge1xyXG5cdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cdHRoaXMuZ2V0TGVuZ3RocygpO1xyXG59O1xyXG5cclxuLy8gR2l2ZW4gdSAoIDAgLi4gMSApLCBnZXQgYSB0IHRvIGZpbmQgcC4gVGhpcyBnaXZlcyB5b3UgcG9pbnRzIHdoaWNoIGFyZSBlcXVpIGRpc3RhbmNlXHJcblxyXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0VXRvVG1hcHBpbmcgPSBmdW5jdGlvbiAoIHUsIGRpc3RhbmNlICkge1xyXG5cclxuXHR2YXIgYXJjTGVuZ3RocyA9IHRoaXMuZ2V0TGVuZ3RocygpO1xyXG5cclxuXHR2YXIgaSA9IDAsIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XHJcblxyXG5cdHZhciB0YXJnZXRBcmNMZW5ndGg7IC8vIFRoZSB0YXJnZXRlZCB1IGRpc3RhbmNlIHZhbHVlIHRvIGdldFxyXG5cclxuXHRpZiAoIGRpc3RhbmNlICkge1xyXG5cclxuXHRcdHRhcmdldEFyY0xlbmd0aCA9IGRpc3RhbmNlO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzWyBpbCAtIDEgXTtcclxuXHJcblx0fVxyXG5cclxuXHQvL3ZhciB0aW1lID0gRGF0ZS5ub3coKTtcclxuXHJcblx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcclxuXHJcblx0dmFyIGxvdyA9IDAsIGhpZ2ggPSBpbCAtIDEsIGNvbXBhcmlzb247XHJcblxyXG5cdHdoaWxlICggbG93IDw9IGhpZ2ggKSB7XHJcblxyXG5cdFx0aSA9IE1hdGguZmxvb3IoIGxvdyArICggaGlnaCAtIGxvdyApIC8gMiApOyAvLyBsZXNzIGxpa2VseSB0byBvdmVyZmxvdywgdGhvdWdoIHByb2JhYmx5IG5vdCBpc3N1ZSBoZXJlLCBKUyBkb2Vzbid0IHJlYWxseSBoYXZlIGludGVnZXJzLCBhbGwgbnVtYmVycyBhcmUgZmxvYXRzXHJcblxyXG5cdFx0Y29tcGFyaXNvbiA9IGFyY0xlbmd0aHNbIGkgXSAtIHRhcmdldEFyY0xlbmd0aDtcclxuXHJcblx0XHRpZiAoIGNvbXBhcmlzb24gPCAwICkge1xyXG5cclxuXHRcdFx0bG93ID0gaSArIDE7XHJcblx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoIGNvbXBhcmlzb24gPiAwICkge1xyXG5cclxuXHRcdFx0aGlnaCA9IGkgLSAxO1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0aGlnaCA9IGk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Ly8gRE9ORVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRpID0gaGlnaDtcclxuXHJcblx0Ly9jb25zb2xlLmxvZygnYicgLCBpLCBsb3csIGhpZ2gsIERhdGUubm93KCktIHRpbWUpO1xyXG5cclxuXHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PSB0YXJnZXRBcmNMZW5ndGggKSB7XHJcblxyXG5cdFx0dmFyIHQgPSBpIC8gKCBpbCAtIDEgKTtcclxuXHRcdHJldHVybiB0O1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHdlIGNvdWxkIGdldCBmaW5lciBncmFpbiBhdCBsZW5ndGhzLCBvciB1c2Ugc2ltcGxlIGludGVycG9sYXRhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcclxuXHJcblx0dmFyIGxlbmd0aEJlZm9yZSA9IGFyY0xlbmd0aHNbIGkgXTtcclxuICAgIHZhciBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XHJcblxyXG4gICAgdmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTtcclxuXHJcbiAgICAvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xyXG5cclxuICAgIHZhciBzZWdtZW50RnJhY3Rpb24gPSAoIHRhcmdldEFyY0xlbmd0aCAtIGxlbmd0aEJlZm9yZSApIC8gc2VnbWVudExlbmd0aDtcclxuXHJcbiAgICAvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XHJcblxyXG4gICAgdmFyIHQgPSAoIGkgKyBzZWdtZW50RnJhY3Rpb24gKSAvICggaWwgLTEgKTtcclxuXHJcblx0cmV0dXJuIHQ7XHJcblxyXG59O1xyXG5cclxuLy8gUmV0dXJucyBhIHVuaXQgdmVjdG9yIHRhbmdlbnQgYXQgdFxyXG4vLyBJbiBjYXNlIGFueSBzdWIgY3VydmUgZG9lcyBub3QgaW1wbGVtZW50IGl0cyB0YW5nZW50IGRlcml2YXRpb24sXHJcbi8vIDIgcG9pbnRzIGEgc21hbGwgZGVsdGEgYXBhcnQgd2lsbCBiZSB1c2VkIHRvIGZpbmQgaXRzIGdyYWRpZW50XHJcbi8vIHdoaWNoIHNlZW1zIHRvIGdpdmUgYSByZWFzb25hYmxlIGFwcHJveGltYXRpb25cclxuXHJcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciBkZWx0YSA9IDAuMDAwMTtcclxuXHR2YXIgdDEgPSB0IC0gZGVsdGE7XHJcblx0dmFyIHQyID0gdCArIGRlbHRhO1xyXG5cclxuXHQvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXHJcblxyXG5cdGlmICggdDEgPCAwICkgdDEgPSAwO1xyXG5cdGlmICggdDIgPiAxICkgdDIgPSAxO1xyXG5cclxuXHR2YXIgcHQxID0gdGhpcy5nZXRQb2ludCggdDEgKTtcclxuXHR2YXIgcHQyID0gdGhpcy5nZXRQb2ludCggdDIgKTtcclxuXHJcblx0dmFyIHZlYyA9IHB0Mi5jbG9uZSgpLnN1YihwdDEpO1xyXG5cdHJldHVybiB2ZWMubm9ybWFsaXplKCk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xyXG5cdHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcclxuXHJcbn07XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdExpbmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuTGluZUN1cnZlID0gZnVuY3Rpb24gKCB2MSwgdjIgKSB7XHJcblxyXG5cdHRoaXMudjEgPSB2MTtcclxuXHR0aGlzLnYyID0gdjI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIHBvaW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1Yih0aGlzLnYxKTtcclxuXHRwb2ludC5tdWx0aXBseVNjYWxhciggdCApLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRyZXR1cm4gcG9pbnQ7XHJcblxyXG59O1xyXG5cclxuLy8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XHJcblxyXG5USFJFRS5MaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUgKSB7XHJcblxyXG5cdHJldHVybiB0aGlzLmdldFBvaW50KCB1ICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGluZUN1cnZlLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcblxyXG5cdHZhciB0YW5nZW50ID0gdGhpcy52Mi5jbG9uZSgpLnN1Yih0aGlzLnYxKTtcclxuXHJcblx0cmV0dXJuIHRhbmdlbnQubm9ybWFsaXplKCk7XHJcblxyXG59O1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRRdWFkcmF0aWMgQmV6aWVyIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiApIHtcclxuXHJcblx0dGhpcy52MCA9IHYwO1xyXG5cdHRoaXMudjEgPSB2MTtcclxuXHR0aGlzLnYyID0gdjI7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmUucHJvdG90eXBlICk7XHJcblxyXG5cclxuVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHR2YXIgdHgsIHR5O1xyXG5cclxuXHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XHJcblx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMiggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSApO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApO1xyXG5cclxufTtcclxuXHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uKCB0ICkge1xyXG5cclxuXHR2YXIgdHgsIHR5O1xyXG5cclxuXHR0eCA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRRdWFkcmF0aWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLnggKTtcclxuXHR0eSA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRRdWFkcmF0aWNCZXppZXIoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnkgKTtcclxuXHJcblx0Ly8gcmV0dXJucyB1bml0IHZlY3RvclxyXG5cclxuXHR2YXIgdGFuZ2VudCA9IG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcclxuXHR0YW5nZW50Lm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRyZXR1cm4gdGFuZ2VudDtcclxuXHJcbn07XHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdWJpYyBCZXppZXIgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZSA9IGZ1bmN0aW9uICggdjAsIHYxLCB2MiwgdjMgKSB7XHJcblxyXG5cdHRoaXMudjAgPSB2MDtcclxuXHR0aGlzLnYxID0gdjE7XHJcblx0dGhpcy52MiA9IHYyO1xyXG5cdHRoaXMudjMgPSB2MztcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdWJpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQ3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdHZhciB0eCwgdHk7XHJcblxyXG5cdHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xyXG5cdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueSwgdGhpcy52MS55LCB0aGlzLnYyLnksIHRoaXMudjMueSApO1xyXG5cclxuXHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbiggdCApIHtcclxuXHJcblx0dmFyIHR4LCB0eTtcclxuXHJcblx0dHggPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50Q3ViaWNCZXppZXIoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xyXG5cdHR5ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudEN1YmljQmV6aWVyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55LCB0aGlzLnYzLnkgKTtcclxuXHJcblx0dmFyIHRhbmdlbnQgPSBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICk7XHJcblx0dGFuZ2VudC5ub3JtYWxpemUoKTtcclxuXHJcblx0cmV0dXJuIHRhbmdlbnQ7XHJcblxyXG59O1xyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0U3BsaW5lIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLlNwbGluZUN1cnZlID0gZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcclxuXHJcblx0dGhpcy5wb2ludHMgPSAocG9pbnRzID09IHVuZGVmaW5lZCkgPyBbXSA6IHBvaW50cztcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcGxpbmVDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLlNwbGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0dmFyIHYgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5cdHZhciBjID0gW107XHJcblx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLCBwb2ludCwgaW50UG9pbnQsIHdlaWdodDtcclxuXHRwb2ludCA9ICggcG9pbnRzLmxlbmd0aCAtIDEgKSAqIHQ7XHJcblxyXG5cdGludFBvaW50ID0gTWF0aC5mbG9vciggcG9pbnQgKTtcclxuXHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuXHRjWyAwIF0gPSBpbnRQb2ludCA9PSAwID8gaW50UG9pbnQgOiBpbnRQb2ludCAtIDE7XHJcblx0Y1sgMSBdID0gaW50UG9pbnQ7XHJcblx0Y1sgMiBdID0gaW50UG9pbnQgID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0xIDogaW50UG9pbnQgKyAxO1xyXG5cdGNbIDMgXSA9IGludFBvaW50ICA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtMSA6IGludFBvaW50ICsgMjtcclxuXHJcblx0di54ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50c1sgY1sgMCBdIF0ueCwgcG9pbnRzWyBjWyAxIF0gXS54LCBwb2ludHNbIGNbIDIgXSBdLngsIHBvaW50c1sgY1sgMyBdIF0ueCwgd2VpZ2h0ICk7XHJcblx0di55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUoIHBvaW50c1sgY1sgMCBdIF0ueSwgcG9pbnRzWyBjWyAxIF0gXS55LCBwb2ludHNbIGNbIDIgXSBdLnksIHBvaW50c1sgY1sgMyBdIF0ueSwgd2VpZ2h0ICk7XHJcblxyXG5cdHJldHVybiB2O1xyXG5cclxufTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0RWxsaXBzZSBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5FbGxpcHNlQ3VydmUgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLFxyXG5cdFx0XHRcdFx0XHRcdGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdHRoaXMuYVggPSBhWDtcclxuXHR0aGlzLmFZID0gYVk7XHJcblxyXG5cdHRoaXMueFJhZGl1cyA9IHhSYWRpdXM7XHJcblx0dGhpcy55UmFkaXVzID0geVJhZGl1cztcclxuXHJcblx0dGhpcy5hU3RhcnRBbmdsZSA9IGFTdGFydEFuZ2xlO1xyXG5cdHRoaXMuYUVuZEFuZ2xlID0gYUVuZEFuZ2xlO1xyXG5cclxuXHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG5cdHZhciBkZWx0YUFuZ2xlID0gdGhpcy5hRW5kQW5nbGUgLSB0aGlzLmFTdGFydEFuZ2xlO1xyXG5cclxuXHRpZiAoICF0aGlzLmFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdFx0dCA9IDEgLSB0O1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcclxuXHJcblx0dmFyIHR4ID0gdGhpcy5hWCArIHRoaXMueFJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdHZhciB0eSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcblx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKTtcclxuXHJcbn07XHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdEFyYyBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5BcmNDdXJ2ZSA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHRUSFJFRS5FbGxpcHNlQ3VydmUuY2FsbCggdGhpcywgYVgsIGFZLCBhUmFkaXVzLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcbn07XHJcblxyXG5USFJFRS5BcmNDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FbGxpcHNlQ3VydmUucHJvdG90eXBlICk7XHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRVdGlsc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5DdXJ2ZS5VdGlscyA9IHtcclxuXHJcblx0dGFuZ2VudFF1YWRyYXRpY0JlemllcjogZnVuY3Rpb24gKCB0LCBwMCwgcDEsIHAyICkge1xyXG5cclxuXHRcdHJldHVybiAyICogKCAxIC0gdCApICogKCBwMSAtIHAwICkgKyAyICogdCAqICggcDIgLSBwMSApO1xyXG5cclxuXHR9LFxyXG5cclxuXHQvLyBQdWF5IEJpbmcsIHRoYW5rcyBmb3IgaGVscGluZyB3aXRoIHRoaXMgZGVyaXZhdGl2ZSFcclxuXHJcblx0dGFuZ2VudEN1YmljQmV6aWVyOiBmdW5jdGlvbiAodCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIC0zICogcDAgKiAoMSAtIHQpICogKDEgLSB0KSAgK1xyXG5cdFx0XHQzICogcDEgKiAoMSAtIHQpICogKDEtdCkgLSA2ICp0ICpwMSAqICgxLXQpICtcclxuXHRcdFx0NiAqIHQgKiAgcDIgKiAoMS10KSAtIDMgKiB0ICogdCAqIHAyICtcclxuXHRcdFx0MyAqIHQgKiB0ICogcDM7XHJcblx0fSxcclxuXHJcblxyXG5cdHRhbmdlbnRTcGxpbmU6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG5cdFx0Ly8gVG8gY2hlY2sgaWYgbXkgZm9ybXVsYXMgYXJlIGNvcnJlY3RcclxuXHJcblx0XHR2YXIgaDAwID0gNiAqIHQgKiB0IC0gNiAqIHQ7IFx0Ly8gZGVyaXZlZCBmcm9tIDJ0XjMg4oiSIDN0XjIgKyAxXHJcblx0XHR2YXIgaDEwID0gMyAqIHQgKiB0IC0gNCAqIHQgKyAxOyAvLyB0XjMg4oiSIDJ0XjIgKyB0XHJcblx0XHR2YXIgaDAxID0gLTYgKiB0ICogdCArIDYgKiB0OyBcdC8vIOKIkiAydDMgKyAzdDJcclxuXHRcdHZhciBoMTEgPSAzICogdCAqIHQgLSAyICogdDtcdC8vIHQzIOKIkiB0MlxyXG5cclxuXHRcdHJldHVybiBoMDAgKyBoMTAgKyBoMDEgKyBoMTE7XHJcblxyXG5cdH0sXHJcblxyXG5cdC8vIENhdG11bGwtUm9tXHJcblxyXG5cdGludGVycG9sYXRlOiBmdW5jdGlvbiggcDAsIHAxLCBwMiwgcDMsIHQgKSB7XHJcblxyXG5cdFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjU7XHJcblx0XHR2YXIgdjEgPSAoIHAzIC0gcDEgKSAqIDAuNTtcclxuXHRcdHZhciB0MiA9IHQgKiB0O1xyXG5cdFx0dmFyIHQzID0gdCAqIHQyO1xyXG5cdFx0cmV0dXJuICggMiAqIHAxIC0gMiAqIHAyICsgdjAgKyB2MSApICogdDMgKyAoIC0gMyAqIHAxICsgMyAqIHAyIC0gMiAqIHYwIC0gdjEgKSAqIHQyICsgdjAgKiB0ICsgcDE7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5cclxuLy8gVE9ETzogVHJhbnNmb3JtYXRpb24gZm9yIEN1cnZlcz9cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0M0QgQ3VydmVzXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcbi8vIEEgRmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIG5ldyBjdXJ2ZSBzdWJjbGFzc2VzXHJcblxyXG5USFJFRS5DdXJ2ZS5jcmVhdGUgPSBmdW5jdGlvbiAoIGNvbnN0cnVjdG9yLCBnZXRQb2ludEZ1bmMgKSB7XHJcblxyXG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkN1cnZlLnByb3RvdHlwZSApO1xyXG5cdGNvbnN0cnVjdG9yLnByb3RvdHlwZS5nZXRQb2ludCA9IGdldFBvaW50RnVuYztcclxuXHJcblx0cmV0dXJuIGNvbnN0cnVjdG9yO1xyXG5cclxufTtcclxuXHJcblxyXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICpcdExpbmUzRFxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5MaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRmdW5jdGlvbiAoIHYxLCB2MiApIHtcclxuXHJcblx0XHR0aGlzLnYxID0gdjE7XHJcblx0XHR0aGlzLnYyID0gdjI7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHR2YXIgciA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cclxuXHRcdHIuc3ViVmVjdG9ycyggdGhpcy52MiwgdGhpcy52MSApOyAvLyBkaWZmXHJcblx0XHRyLm11bHRpcGx5U2NhbGFyKCB0ICk7XHJcblx0XHRyLmFkZCggdGhpcy52MSApO1xyXG5cclxuXHRcdHJldHVybiByO1xyXG5cclxuXHR9XHJcblxyXG4pO1xyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0UXVhZHJhdGljIEJlemllciAzRCBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5USFJFRS5RdWFkcmF0aWNCZXppZXJDdXJ2ZTMgPSBUSFJFRS5DdXJ2ZS5jcmVhdGUoXHJcblxyXG5cdGZ1bmN0aW9uICggdjAsIHYxLCB2MiApIHtcclxuXHJcblx0XHR0aGlzLnYwID0gdjA7XHJcblx0XHR0aGlzLnYxID0gdjE7XHJcblx0XHR0aGlzLnYyID0gdjI7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHR2YXIgdHgsIHR5LCB0ejtcclxuXHJcblx0XHR0eCA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLngsIHRoaXMudjEueCwgdGhpcy52Mi54ICk7XHJcblx0XHR0eSA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnksIHRoaXMudjEueSwgdGhpcy52Mi55ICk7XHJcblx0XHR0eiA9IFRIUkVFLlNoYXBlLlV0aWxzLmIyKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56ICk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IzKCB0eCwgdHksIHR6ICk7XHJcblxyXG5cdH1cclxuXHJcbik7XHJcblxyXG5cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3ViaWMgQmV6aWVyIDNEIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkN1YmljQmV6aWVyQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRmdW5jdGlvbiAoIHYwLCB2MSwgdjIsIHYzICkge1xyXG5cclxuXHRcdHRoaXMudjAgPSB2MDtcclxuXHRcdHRoaXMudjEgPSB2MTtcclxuXHRcdHRoaXMudjIgPSB2MjtcclxuXHRcdHRoaXMudjMgPSB2MztcclxuXHJcblx0fSxcclxuXHJcblx0ZnVuY3Rpb24gKCB0ICkge1xyXG5cclxuXHRcdHZhciB0eCwgdHksIHR6O1xyXG5cclxuXHRcdHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjMoIHQsIHRoaXMudjAueCwgdGhpcy52MS54LCB0aGlzLnYyLngsIHRoaXMudjMueCApO1xyXG5cdFx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgdGhpcy52MC55LCB0aGlzLnYxLnksIHRoaXMudjIueSwgdGhpcy52My55ICk7XHJcblx0XHR0eiA9IFRIUkVFLlNoYXBlLlV0aWxzLmIzKCB0LCB0aGlzLnYwLnosIHRoaXMudjEueiwgdGhpcy52Mi56LCB0aGlzLnYzLnogKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjMoIHR4LCB0eSwgdHogKTtcclxuXHJcblx0fVxyXG5cclxuKTtcclxuXHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRTcGxpbmUgM0QgY3VydmVcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcblRIUkVFLlNwbGluZUN1cnZlMyA9IFRIUkVFLkN1cnZlLmNyZWF0ZShcclxuXHJcblx0ZnVuY3Rpb24gKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMyAqLykge1xyXG5cclxuXHRcdHRoaXMucG9pbnRzID0gKHBvaW50cyA9PSB1bmRlZmluZWQpID8gW10gOiBwb2ludHM7XHJcblxyXG5cdH0sXHJcblxyXG5cdGZ1bmN0aW9uICggdCApIHtcclxuXHJcblx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHR2YXIgYyA9IFtdO1xyXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLCBwb2ludCwgaW50UG9pbnQsIHdlaWdodDtcclxuXHRcdHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcblx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcblx0XHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuXHRcdGNbIDAgXSA9IGludFBvaW50ID09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcclxuXHRcdGNbIDEgXSA9IGludFBvaW50O1xyXG5cdFx0Y1sgMiBdID0gaW50UG9pbnQgID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcclxuXHRcdGNbIDMgXSA9IGludFBvaW50ICA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDI7XHJcblxyXG5cdFx0dmFyIHB0MCA9IHBvaW50c1sgY1swXSBdLFxyXG5cdFx0XHRwdDEgPSBwb2ludHNbIGNbMV0gXSxcclxuXHRcdFx0cHQyID0gcG9pbnRzWyBjWzJdIF0sXHJcblx0XHRcdHB0MyA9IHBvaW50c1sgY1szXSBdO1xyXG5cclxuXHRcdHYueCA9IFRIUkVFLkN1cnZlLlV0aWxzLmludGVycG9sYXRlKHB0MC54LCBwdDEueCwgcHQyLngsIHB0My54LCB3ZWlnaHQpO1xyXG5cdFx0di55ID0gVEhSRUUuQ3VydmUuVXRpbHMuaW50ZXJwb2xhdGUocHQwLnksIHB0MS55LCBwdDIueSwgcHQzLnksIHdlaWdodCk7XHJcblx0XHR2LnogPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZShwdDAueiwgcHQxLnosIHB0Mi56LCBwdDMueiwgd2VpZ2h0KTtcclxuXHJcblx0XHRyZXR1cm4gdjtcclxuXHJcblx0fVxyXG5cclxuKTtcclxuXHJcblxyXG4vLyBUSFJFRS5TcGxpbmVDdXJ2ZTMucHJvdG90eXBlLmdldFRhbmdlbnQgPSBmdW5jdGlvbih0KSB7XHJcbi8vIFx0XHR2YXIgdiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcbi8vIFx0XHR2YXIgYyA9IFtdO1xyXG4vLyBcdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLCBwb2ludCwgaW50UG9pbnQsIHdlaWdodDtcclxuLy8gXHRcdHBvaW50ID0gKCBwb2ludHMubGVuZ3RoIC0gMSApICogdDtcclxuXHJcbi8vIFx0XHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcbi8vIFx0XHR3ZWlnaHQgPSBwb2ludCAtIGludFBvaW50O1xyXG5cclxuLy8gXHRcdGNbIDAgXSA9IGludFBvaW50ID09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcclxuLy8gXHRcdGNbIDEgXSA9IGludFBvaW50O1xyXG4vLyBcdFx0Y1sgMiBdID0gaW50UG9pbnQgID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMTtcclxuLy8gXHRcdGNbIDMgXSA9IGludFBvaW50ICA+IHBvaW50cy5sZW5ndGggLSAzID8gcG9pbnRzLmxlbmd0aCAtIDEgOiBpbnRQb2ludCArIDI7XHJcblxyXG4vLyBcdFx0dmFyIHB0MCA9IHBvaW50c1sgY1swXSBdLFxyXG4vLyBcdFx0XHRwdDEgPSBwb2ludHNbIGNbMV0gXSxcclxuLy8gXHRcdFx0cHQyID0gcG9pbnRzWyBjWzJdIF0sXHJcbi8vIFx0XHRcdHB0MyA9IHBvaW50c1sgY1szXSBdO1xyXG5cclxuLy8gXHQvLyB0ID0gd2VpZ2h0O1xyXG4vLyBcdHYueCA9IFRIUkVFLkN1cnZlLlV0aWxzLnRhbmdlbnRTcGxpbmUoIHQsIHB0MC54LCBwdDEueCwgcHQyLngsIHB0My54ICk7XHJcbi8vIFx0di55ID0gVEhSRUUuQ3VydmUuVXRpbHMudGFuZ2VudFNwbGluZSggdCwgcHQwLnksIHB0MS55LCBwdDIueSwgcHQzLnkgKTtcclxuLy8gXHR2LnogPSBUSFJFRS5DdXJ2ZS5VdGlscy50YW5nZW50U3BsaW5lKCB0LCBwdDAueiwgcHQxLnosIHB0Mi56LCBwdDMueiApO1xyXG5cclxuLy8gXHRyZXR1cm4gdjtcclxuXHJcbi8vIH1cclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q2xvc2VkIFNwbGluZSAzRCBjdXJ2ZVxyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cclxuVEhSRUUuQ2xvc2VkU3BsaW5lQ3VydmUzID0gVEhSRUUuQ3VydmUuY3JlYXRlKFxyXG5cclxuXHRmdW5jdGlvbiAoIHBvaW50cyAvKiBhcnJheSBvZiBWZWN0b3IzICovKSB7XHJcblxyXG5cdFx0dGhpcy5wb2ludHMgPSAocG9pbnRzID09IHVuZGVmaW5lZCkgPyBbXSA6IHBvaW50cztcclxuXHJcblx0fSxcclxuXHJcbiAgICBmdW5jdGlvbiAoIHQgKSB7XHJcblxyXG4gICAgICAgIHZhciB2ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuICAgICAgICB2YXIgYyA9IFtdO1xyXG4gICAgICAgIHZhciBwb2ludHMgPSB0aGlzLnBvaW50cywgcG9pbnQsIGludFBvaW50LCB3ZWlnaHQ7XHJcbiAgICAgICAgcG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAwICkgKiB0O1xyXG4gICAgICAgICAgICAvLyBUaGlzIG5lZWRzIHRvIGJlIGZyb20gMC1sZW5ndGggKzFcclxuXHJcbiAgICAgICAgaW50UG9pbnQgPSBNYXRoLmZsb29yKCBwb2ludCApO1xyXG4gICAgICAgIHdlaWdodCA9IHBvaW50IC0gaW50UG9pbnQ7XHJcblxyXG4gICAgICAgIGludFBvaW50ICs9IGludFBvaW50ID4gMCA/IDAgOiAoIE1hdGguZmxvb3IoIE1hdGguYWJzKCBpbnRQb2ludCApIC8gcG9pbnRzLmxlbmd0aCApICsgMSApICogcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBjWyAwIF0gPSAoIGludFBvaW50IC0gMSApICUgcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBjWyAxIF0gPSAoIGludFBvaW50ICkgJSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIGNbIDIgXSA9ICggaW50UG9pbnQgKyAxICkgJSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIGNbIDMgXSA9ICggaW50UG9pbnQgKyAyICkgJSBwb2ludHMubGVuZ3RoO1xyXG5cclxuICAgICAgICB2LnggPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnRzWyBjWyAwIF0gXS54LCBwb2ludHNbIGNbIDEgXSBdLngsIHBvaW50c1sgY1sgMiBdIF0ueCwgcG9pbnRzWyBjWyAzIF0gXS54LCB3ZWlnaHQgKTtcclxuICAgICAgICB2LnkgPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnRzWyBjWyAwIF0gXS55LCBwb2ludHNbIGNbIDEgXSBdLnksIHBvaW50c1sgY1sgMiBdIF0ueSwgcG9pbnRzWyBjWyAzIF0gXS55LCB3ZWlnaHQgKTtcclxuICAgICAgICB2LnogPSBUSFJFRS5DdXJ2ZS5VdGlscy5pbnRlcnBvbGF0ZSggcG9pbnRzWyBjWyAwIF0gXS56LCBwb2ludHNbIGNbIDEgXSBdLnosIHBvaW50c1sgY1sgMiBdIF0ueiwgcG9pbnRzWyBjWyAzIF0gXS56LCB3ZWlnaHQgKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHY7XHJcblxyXG4gICAgfVxyXG5cclxuKTtcclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICpcclxuICoqL1xyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRDdXJ2ZWQgUGF0aCAtIGEgY3VydmUgcGF0aCBpcyBzaW1wbHkgYSBhcnJheSBvZiBjb25uZWN0ZWRcclxuICogIGN1cnZlcywgYnV0IHJldGFpbnMgdGhlIGFwaSBvZiBhIGN1cnZlXHJcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblRIUkVFLkN1cnZlUGF0aCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5jdXJ2ZXMgPSBbXTtcclxuXHR0aGlzLmJlbmRzID0gW107XHJcblx0XHJcblx0dGhpcy5hdXRvQ2xvc2UgPSBmYWxzZTsgLy8gQXV0b21hdGljYWxseSBjbG9zZXMgdGhlIHBhdGhcclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5DdXJ2ZS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCBjdXJ2ZSApIHtcclxuXHJcblx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdC8vIFRPRE9cclxuXHQvLyBJZiB0aGUgZW5kaW5nIG9mIGN1cnZlIGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlIHN0YXJ0aW5nXHJcblx0Ly8gb3IgdGhlIG5leHQgY3VydmUsIHRoZW4sIHRoaXMgaXMgbm90IGEgcmVhbCBwYXRoXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmNsb3NlUGF0aCA9IGZ1bmN0aW9uKCkge1xyXG5cdC8vIFRPRE8gVGVzdFxyXG5cdC8vIGFuZCB2ZXJpZnkgZm9yIHZlY3RvcjMgKG5lZWRzIHRvIGltcGxlbWVudCBlcXVhbHMpXHJcblx0Ly8gQWRkIGEgbGluZSBjdXJ2ZSBpZiBzdGFydCBhbmQgZW5kIG9mIGxpbmVzIGFyZSBub3QgY29ubmVjdGVkXHJcblx0dmFyIHN0YXJ0UG9pbnQgPSB0aGlzLmN1cnZlc1swXS5nZXRQb2ludCgwKTtcclxuXHR2YXIgZW5kUG9pbnQgPSB0aGlzLmN1cnZlc1t0aGlzLmN1cnZlcy5sZW5ndGgtMV0uZ2V0UG9pbnQoMSk7XHJcblx0XHJcblx0aWYgKCFzdGFydFBvaW50LmVxdWFscyhlbmRQb2ludCkpIHtcclxuXHRcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBUSFJFRS5MaW5lQ3VydmUoZW5kUG9pbnQsIHN0YXJ0UG9pbnQpICk7XHJcblx0fVxyXG5cdFxyXG59O1xyXG5cclxuLy8gVG8gZ2V0IGFjY3VyYXRlIHBvaW50IHdpdGggcmVmZXJlbmNlIHRvXHJcbi8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcclxuLy8gZm9sbG93aW5nIGhhcyB0byBiZSBkb25lOlxyXG5cclxuLy8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxyXG4vLyAyLiBMb2NhdGUgYW5kIGlkZW50aWZ5IHR5cGUgb2YgY3VydmVcclxuLy8gMy4gR2V0IHQgZm9yIHRoZSBjdXJ2ZVxyXG4vLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiggdCApIHtcclxuXHJcblx0dmFyIGQgPSB0ICogdGhpcy5nZXRMZW5ndGgoKTtcclxuXHR2YXIgY3VydmVMZW5ndGhzID0gdGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcclxuXHR2YXIgaSA9IDAsIGRpZmYsIGN1cnZlO1xyXG5cclxuXHQvLyBUbyB0aGluayBhYm91dCBib3VuZGFyaWVzIHBvaW50cy5cclxuXHJcblx0d2hpbGUgKCBpIDwgY3VydmVMZW5ndGhzLmxlbmd0aCApIHtcclxuXHJcblx0XHRpZiAoIGN1cnZlTGVuZ3Roc1sgaSBdID49IGQgKSB7XHJcblxyXG5cdFx0XHRkaWZmID0gY3VydmVMZW5ndGhzWyBpIF0gLSBkO1xyXG5cdFx0XHRjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XHJcblxyXG5cdFx0XHR2YXIgdSA9IDEgLSBkaWZmIC8gY3VydmUuZ2V0TGVuZ3RoKCk7XHJcblxyXG5cdFx0XHRyZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCggdSApO1xyXG5cclxuXHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblxyXG5cdFx0aSArKztcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbnVsbDtcclxuXHJcblx0Ly8gbG9vcCB3aGVyZSBzdW0gIT0gMCwgc3VtID4gZCAsIHN1bSsxIDxkXHJcblxyXG59O1xyXG5cclxuLypcclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUYW5nZW50ID0gZnVuY3Rpb24oIHQgKSB7XHJcbn07Ki9cclxuXHJcblxyXG4vLyBXZSBjYW5ub3QgdXNlIHRoZSBkZWZhdWx0IFRIUkVFLkN1cnZlIGdldFBvaW50KCkgd2l0aCBnZXRMZW5ndGgoKSBiZWNhdXNlIGluXHJcbi8vIFRIUkVFLkN1cnZlLCBnZXRMZW5ndGgoKSBkZXBlbmRzIG9uIGdldFBvaW50KCkgYnV0IGluIFRIUkVFLkN1cnZlUGF0aFxyXG4vLyBnZXRQb2ludCgpIGRlcGVuZHMgb24gZ2V0TGVuZ3RoXHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR2YXIgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XHJcblx0cmV0dXJuIGxlbnNbIGxlbnMubGVuZ3RoIC0gMSBdO1xyXG5cclxufTtcclxuXHJcbi8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxyXG4vLyBXZSBjYW5ub3Qgb3ZlcndyaXRlIGdldExlbmd0aHMoKSBiZWNhdXNlIFV0b1QgbWFwcGluZyB1c2VzIGl0LlxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRDdXJ2ZUxlbmd0aHMgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0Ly8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxyXG5cclxuXHRpZiAoIHRoaXMuY2FjaGVMZW5ndGhzICYmIHRoaXMuY2FjaGVMZW5ndGhzLmxlbmd0aCA9PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzO1xyXG5cclxuXHR9O1xyXG5cclxuXHQvLyBHZXQgbGVuZ3RoIG9mIHN1YnN1cnZlXHJcblx0Ly8gUHVzaCBzdW1zIGludG8gY2FjaGVkIGFycmF5XHJcblxyXG5cdHZhciBsZW5ndGhzID0gW10sIHN1bXMgPSAwO1xyXG5cdHZhciBpLCBpbCA9IHRoaXMuY3VydmVzLmxlbmd0aDtcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRzdW1zICs9IHRoaXMuY3VydmVzWyBpIF0uZ2V0TGVuZ3RoKCk7XHJcblx0XHRsZW5ndGhzLnB1c2goIHN1bXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmNhY2hlTGVuZ3RocyA9IGxlbmd0aHM7XHJcblxyXG5cdHJldHVybiBsZW5ndGhzO1xyXG5cclxufTtcclxuXHJcblxyXG5cclxuLy8gUmV0dXJucyBtaW4gYW5kIG1heCBjb29yZGluYXRlcywgYXMgd2VsbCBhcyBjZW50cm9pZFxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dmFyIHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCk7XHJcblxyXG5cdHZhciBtYXhYLCBtYXhZLCBtYXhaO1xyXG5cdHZhciBtaW5YLCBtaW5ZLCBtaW5aO1xyXG5cclxuXHRtYXhYID0gbWF4WSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcclxuXHRtaW5YID0gbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuXHJcblx0dmFyIHAsIGksIGlsLCBzdW07XHJcblxyXG5cdHZhciB2MyA9IHBvaW50c1swXSBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjM7XHJcblxyXG5cdHN1bSA9IHYzID8gbmV3IFRIUkVFLlZlY3RvcjMoKSA6IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblxyXG5cdGZvciAoIGkgPSAwLCBpbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRwID0gcG9pbnRzWyBpIF07XHJcblxyXG5cdFx0aWYgKCBwLnggPiBtYXhYICkgbWF4WCA9IHAueDtcclxuXHRcdGVsc2UgaWYgKCBwLnggPCBtaW5YICkgbWluWCA9IHAueDtcclxuXHJcblx0XHRpZiAoIHAueSA+IG1heFkgKSBtYXhZID0gcC55O1xyXG5cdFx0ZWxzZSBpZiAoIHAueSA8IG1pblkgKSBtaW5ZID0gcC55O1xyXG5cclxuXHRcdGlmICggdjMgKSB7XHJcblxyXG5cdFx0XHRpZiAoIHAueiA+IG1heFogKSBtYXhaID0gcC56O1xyXG5cdFx0XHRlbHNlIGlmICggcC56IDwgbWluWiApIG1pblogPSBwLno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHN1bS5hZGQoIHAgKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgcmV0ID0ge1xyXG5cclxuXHRcdG1pblg6IG1pblgsXHJcblx0XHRtaW5ZOiBtaW5ZLFxyXG5cdFx0bWF4WDogbWF4WCxcclxuXHRcdG1heFk6IG1heFksXHJcblx0XHRjZW50cm9pZDogc3VtLmRpdmlkZVNjYWxhciggaWwgKVxyXG5cclxuXHR9O1xyXG5cclxuXHRpZiAoIHYzICkge1xyXG5cclxuXHRcdHJldC5tYXhaID0gbWF4WjtcclxuXHRcdHJldC5taW5aID0gbWluWjtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gcmV0O1xyXG5cclxufTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0Q3JlYXRlIEdlb21ldHJpZXMgSGVscGVyc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vLy8gR2VuZXJhdGUgZ2VvbWV0cnkgZnJvbSBwYXRoIHBvaW50cyAoZm9yIExpbmUgb3IgUGFydGljbGVTeXN0ZW0gb2JqZWN0cylcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlUG9pbnRzR2VvbWV0cnkgPSBmdW5jdGlvbiggZGl2aXNpb25zICkge1xyXG5cclxuXHR2YXIgcHRzID0gdGhpcy5nZXRQb2ludHMoIGRpdmlzaW9ucywgdHJ1ZSApO1xyXG5cdHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcclxuXHJcbn07XHJcblxyXG4vLyBHZW5lcmF0ZSBnZW9tZXRyeSBmcm9tIGVxdWlkaXN0YW5jZSBzYW1wbGluZyBhbG9uZyB0aGUgcGF0aFxyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5jcmVhdGVTcGFjZWRQb2ludHNHZW9tZXRyeSA9IGZ1bmN0aW9uKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBwdHMgPSB0aGlzLmdldFNwYWNlZFBvaW50cyggZGl2aXNpb25zLCB0cnVlICk7XHJcblx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiggcG9pbnRzICkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArKyApIHtcclxuXHJcblx0XHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggcG9pbnRzWyBpIF0ueCwgcG9pbnRzWyBpIF0ueSwgcG9pbnRzWyBpIF0ueiB8fCAwKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBnZW9tZXRyeTtcclxuXHJcbn07XHJcblxyXG5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAqXHRCZW5kIC8gV3JhcCBIZWxwZXIgTWV0aG9kc1xyXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcblxyXG4vLyBXcmFwIHBhdGggLyBCZW5kIG1vZGlmaWVycz9cclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuYWRkV3JhcFBhdGggPSBmdW5jdGlvbiAoIGJlbmRwYXRoICkge1xyXG5cclxuXHR0aGlzLmJlbmRzLnB1c2goIGJlbmRwYXRoICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFBvaW50cyA9IGZ1bmN0aW9uKCBzZWdtZW50cywgYmVuZHMgKSB7XHJcblxyXG5cdHZhciBvbGRQdHMgPSB0aGlzLmdldFBvaW50cyggc2VnbWVudHMgKTsgLy8gZ2V0UG9pbnRzIGdldFNwYWNlZFBvaW50c1xyXG5cdHZhciBpLCBpbDtcclxuXHJcblx0aWYgKCAhYmVuZHMgKSB7XHJcblxyXG5cdFx0YmVuZHMgPSB0aGlzLmJlbmRzO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIGkgPSAwLCBpbCA9IGJlbmRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdG9sZFB0cyA9IHRoaXMuZ2V0V3JhcFBvaW50cyggb2xkUHRzLCBiZW5kc1sgaSBdICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG9sZFB0cztcclxuXHJcbn07XHJcblxyXG5USFJFRS5DdXJ2ZVBhdGgucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzID0gZnVuY3Rpb24oIHNlZ21lbnRzLCBiZW5kcyApIHtcclxuXHJcblx0dmFyIG9sZFB0cyA9IHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBzZWdtZW50cyApO1xyXG5cclxuXHR2YXIgaSwgaWw7XHJcblxyXG5cdGlmICggIWJlbmRzICkge1xyXG5cclxuXHRcdGJlbmRzID0gdGhpcy5iZW5kcztcclxuXHJcblx0fVxyXG5cclxuXHRmb3IgKCBpID0gMCwgaWwgPSBiZW5kcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRvbGRQdHMgPSB0aGlzLmdldFdyYXBQb2ludHMoIG9sZFB0cywgYmVuZHNbIGkgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBvbGRQdHM7XHJcblxyXG59O1xyXG5cclxuLy8gVGhpcyByZXR1cm5zIGdldFBvaW50cygpIGJlbmQvd3JhcHBlZCBhcm91bmQgdGhlIGNvbnRvdXIgb2YgYSBwYXRoLlxyXG4vLyBSZWFkIGh0dHA6Ly93d3cucGxhbmV0Y2xlZ2cuY29tL3Byb2plY3RzL1dhcnBpbmdUZXh0VG9TcGxpbmVzLmh0bWxcclxuXHJcblRIUkVFLkN1cnZlUGF0aC5wcm90b3R5cGUuZ2V0V3JhcFBvaW50cyA9IGZ1bmN0aW9uICggb2xkUHRzLCBwYXRoICkge1xyXG5cclxuXHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZGluZ0JveCgpO1xyXG5cclxuXHR2YXIgaSwgaWwsIHAsIG9sZFgsIG9sZFksIHhOb3JtO1xyXG5cclxuXHRmb3IgKCBpID0gMCwgaWwgPSBvbGRQdHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0cCA9IG9sZFB0c1sgaSBdO1xyXG5cclxuXHRcdG9sZFggPSBwLng7XHJcblx0XHRvbGRZID0gcC55O1xyXG5cclxuXHRcdHhOb3JtID0gb2xkWCAvIGJvdW5kcy5tYXhYO1xyXG5cclxuXHRcdC8vIElmIHVzaW5nIGFjdHVhbCBkaXN0YW5jZSwgZm9yIGxlbmd0aCA+IHBhdGgsIHJlcXVpcmVzIGxpbmUgZXh0cnVzaW9uc1xyXG5cdFx0Ly94Tm9ybSA9IHBhdGguZ2V0VXRvVG1hcHBpbmcoeE5vcm0sIG9sZFgpOyAvLyAzIHN0eWxlcy4gMSkgd3JhcCBzdHJldGNoZWQuIDIpIHdyYXAgc3RyZXRjaCBieSBhcmMgbGVuZ3RoIDMpIHdhcnAgYnkgYWN0dWFsIGRpc3RhbmNlXHJcblxyXG5cdFx0eE5vcm0gPSBwYXRoLmdldFV0b1RtYXBwaW5nKCB4Tm9ybSwgb2xkWCApO1xyXG5cclxuXHRcdC8vIGNoZWNrIGZvciBvdXQgb2YgYm91bmRzP1xyXG5cclxuXHRcdHZhciBwYXRoUHQgPSBwYXRoLmdldFBvaW50KCB4Tm9ybSApO1xyXG5cdFx0dmFyIG5vcm1hbCA9IHBhdGguZ2V0Tm9ybWFsVmVjdG9yKCB4Tm9ybSApLm11bHRpcGx5U2NhbGFyKCBvbGRZICk7XHJcblxyXG5cdFx0cC54ID0gcGF0aFB0LnggKyBub3JtYWwueDtcclxuXHRcdHAueSA9IHBhdGhQdC55ICsgbm9ybWFsLnk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIG9sZFB0cztcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5HeXJvc2NvcGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkID0gZnVuY3Rpb24gKCBmb3JjZSApIHtcclxuXHJcblx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlICYmIHRoaXMudXBkYXRlTWF0cml4KCk7XHJcblxyXG5cdC8vIHVwZGF0ZSBtYXRyaXhXb3JsZFxyXG5cclxuXHRpZiAoIHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSB8fCBmb3JjZSApIHtcclxuXHJcblx0XHRpZiAoIHRoaXMucGFyZW50ICkge1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5tdWx0aXBseU1hdHJpY2VzKCB0aGlzLnBhcmVudC5tYXRyaXhXb3JsZCwgdGhpcy5tYXRyaXggKTtcclxuXHJcblx0XHRcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCB0aGlzLnRyYW5zbGF0aW9uV29ybGQsIHRoaXMucm90YXRpb25Xb3JsZCwgdGhpcy5zY2FsZVdvcmxkICk7XHJcblx0XHRcdHRoaXMubWF0cml4LmRlY29tcG9zZSggdGhpcy50cmFuc2xhdGlvbk9iamVjdCwgdGhpcy5yb3RhdGlvbk9iamVjdCwgdGhpcy5zY2FsZU9iamVjdCApO1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb21wb3NlKCB0aGlzLnRyYW5zbGF0aW9uV29ybGQsIHRoaXMucm90YXRpb25PYmplY3QsIHRoaXMuc2NhbGVXb3JsZCApO1xyXG5cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCB0aGlzLm1hdHJpeCApO1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0Zm9yY2UgPSB0cnVlO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHVwZGF0ZSBjaGlsZHJlblxyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5jaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS50cmFuc2xhdGlvbldvcmxkID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuVEhSRUUuR3lyb3Njb3BlLnByb3RvdHlwZS50cmFuc2xhdGlvbk9iamVjdCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUucm90YXRpb25Xb3JsZCA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcblRIUkVFLkd5cm9zY29wZS5wcm90b3R5cGUucm90YXRpb25PYmplY3QgPSBuZXcgVEhSRUUuUXVhdGVybmlvbigpO1xyXG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLnNjYWxlV29ybGQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5USFJFRS5HeXJvc2NvcGUucHJvdG90eXBlLnNjYWxlT2JqZWN0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXHJcbiAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxyXG4gKlxyXG4gKiovXHJcblxyXG5USFJFRS5QYXRoID0gZnVuY3Rpb24gKCBwb2ludHMgKSB7XHJcblxyXG5cdFRIUkVFLkN1cnZlUGF0aC5jYWxsKHRoaXMpO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMgPSBbXTtcclxuXHJcblx0aWYgKCBwb2ludHMgKSB7XHJcblxyXG5cdFx0dGhpcy5mcm9tUG9pbnRzKCBwb2ludHMgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuQ3VydmVQYXRoLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuUGF0aEFjdGlvbnMgPSB7XHJcblxyXG5cdE1PVkVfVE86ICdtb3ZlVG8nLFxyXG5cdExJTkVfVE86ICdsaW5lVG8nLFxyXG5cdFFVQURSQVRJQ19DVVJWRV9UTzogJ3F1YWRyYXRpY0N1cnZlVG8nLCAvLyBCZXppZXIgcXVhZHJhdGljIGN1cnZlXHJcblx0QkVaSUVSX0NVUlZFX1RPOiAnYmV6aWVyQ3VydmVUbycsIFx0XHQvLyBCZXppZXIgY3ViaWMgY3VydmVcclxuXHRDU1BMSU5FX1RIUlU6ICdzcGxpbmVUaHJ1JyxcdFx0XHRcdC8vIENhdG11bGwtcm9tIHNwbGluZVxyXG5cdEFSQzogJ2FyYycsXHRcdFx0XHRcdFx0XHRcdC8vIENpcmNsZVxyXG5cdEVMTElQU0U6ICdlbGxpcHNlJ1xyXG59O1xyXG5cclxuLy8gVE9ETyBDbGVhbiB1cCBQQVRIIEFQSVxyXG5cclxuLy8gQ3JlYXRlIHBhdGggdXNpbmcgc3RyYWlnaHQgbGluZXMgdG8gY29ubmVjdCBhbGwgcG9pbnRzXHJcbi8vIC0gdmVjdG9yczogYXJyYXkgb2YgVmVjdG9yMlxyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZnJvbVBvaW50cyA9IGZ1bmN0aW9uICggdmVjdG9ycyApIHtcclxuXHJcblx0dGhpcy5tb3ZlVG8oIHZlY3RvcnNbIDAgXS54LCB2ZWN0b3JzWyAwIF0ueSApO1xyXG5cclxuXHRmb3IgKCB2YXIgdiA9IDEsIHZsZW4gPSB2ZWN0b3JzLmxlbmd0aDsgdiA8IHZsZW47IHYgKysgKSB7XHJcblxyXG5cdFx0dGhpcy5saW5lVG8oIHZlY3RvcnNbIHYgXS54LCB2ZWN0b3JzWyB2IF0ueSApO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8vIHN0YXJ0UGF0aCgpIGVuZFBhdGgoKT9cclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICggeCwgeSApIHtcclxuXHJcblx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XHJcblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5saW5lVG8gPSBmdW5jdGlvbiAoIHgsIHkgKSB7XHJcblxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG5cclxuXHR2YXIgY3VydmUgPSBuZXcgVEhSRUUuTGluZUN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksIG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICkgKTtcclxuXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xyXG5cclxuXHR0aGlzLmFjdGlvbnMucHVzaCggeyBhY3Rpb246IFRIUkVFLlBhdGhBY3Rpb25zLkxJTkVfVE8sIGFyZ3M6IGFyZ3MgfSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLnF1YWRyYXRpY0N1cnZlVG8gPSBmdW5jdGlvbiggYUNQeCwgYUNQeSwgYVgsIGFZICkge1xyXG5cclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcclxuXHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlKCBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1B4LCBhQ1B5ICksXHJcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKSApO1xyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuUVVBRFJBVElDX0NVUlZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24oIGFDUDF4LCBhQ1AxeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhQ1AyeCwgYUNQMnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYVgsIGFZICkge1xyXG5cclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcclxuXHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMSBdLmFyZ3M7XHJcblxyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dmFyIGN1cnZlID0gbmV3IFRIUkVFLkN1YmljQmV6aWVyQ3VydmUoIG5ldyBUSFJFRS5WZWN0b3IyKCB4MCwgeTAgKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AxeCwgYUNQMXkgKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhQ1AyeCwgYUNQMnkgKSxcclxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBhWCwgYVkgKSApO1xyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXRoLnByb3RvdHlwZS5zcGxpbmVUaHJ1ID0gZnVuY3Rpb24oIHB0cyAvKkFycmF5IG9mIFZlY3RvciovICkge1xyXG5cclxuXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBhcmd1bWVudHMgKTtcclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxIF0uYXJncztcclxuXHJcblx0dmFyIHgwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDIgXTtcclxuXHR2YXIgeTAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMSBdO1xyXG4vLy0tLVxyXG5cdHZhciBucHRzID0gWyBuZXcgVEhSRUUuVmVjdG9yMiggeDAsIHkwICkgXTtcclxuXHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSggbnB0cywgcHRzICk7XHJcblxyXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5TcGxpbmVDdXJ2ZSggbnB0cyApO1xyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHRoaXMuYWN0aW9ucy5wdXNoKCB7IGFjdGlvbjogVEhSRUUuUGF0aEFjdGlvbnMuQ1NQTElORV9USFJVLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbn07XHJcblxyXG4vLyBGVVRVUkU6IENoYW5nZSB0aGUgQVBJIG9yIGZvbGxvdyBjYW52YXMgQVBJP1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYXJjID0gZnVuY3Rpb24gKCBhWCwgYVksIGFSYWRpdXMsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0dmFyIGxhc3RhcmdzID0gdGhpcy5hY3Rpb25zWyB0aGlzLmFjdGlvbnMubGVuZ3RoIC0gMV0uYXJncztcclxuXHR2YXIgeDAgPSBsYXN0YXJnc1sgbGFzdGFyZ3MubGVuZ3RoIC0gMiBdO1xyXG5cdHZhciB5MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAxIF07XHJcblxyXG5cdHRoaXMuYWJzYXJjKGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXHJcblx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcblx0XHJcbiB9O1xyXG5cclxuIFRIUkVFLlBhdGgucHJvdG90eXBlLmFic2FyYyA9IGZ1bmN0aW9uICggYVgsIGFZLCBhUmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblx0dGhpcy5hYnNlbGxpcHNlKGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSk7XHJcbiB9O1xyXG4gXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLmVsbGlwc2UgPSBmdW5jdGlvbiAoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHR2YXIgbGFzdGFyZ3MgPSB0aGlzLmFjdGlvbnNbIHRoaXMuYWN0aW9ucy5sZW5ndGggLSAxXS5hcmdzO1xyXG5cdHZhciB4MCA9IGxhc3RhcmdzWyBsYXN0YXJncy5sZW5ndGggLSAyIF07XHJcblx0dmFyIHkwID0gbGFzdGFyZ3NbIGxhc3RhcmdzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0dGhpcy5hYnNlbGxpcHNlKGFYICsgeDAsIGFZICsgeTAsIHhSYWRpdXMsIHlSYWRpdXMsXHJcblx0XHRhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICk7XHJcblxyXG4gfTtcclxuIFxyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuYWJzZWxsaXBzZSA9IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKSB7XHJcblxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xyXG5cdHZhciBjdXJ2ZSA9IG5ldyBUSFJFRS5FbGxpcHNlQ3VydmUoIGFYLCBhWSwgeFJhZGl1cywgeVJhZGl1cyxcclxuXHRcdFx0XHRcdFx0XHRcdFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xyXG5cdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XHJcblxyXG5cdHZhciBsYXN0UG9pbnQgPSBjdXJ2ZS5nZXRQb2ludChhQ2xvY2t3aXNlID8gMSA6IDApO1xyXG5cdGFyZ3MucHVzaChsYXN0UG9pbnQueCk7XHJcblx0YXJncy5wdXNoKGxhc3RQb2ludC55KTtcclxuXHJcblx0dGhpcy5hY3Rpb25zLnB1c2goIHsgYWN0aW9uOiBUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFLCBhcmdzOiBhcmdzIH0gKTtcclxuXHJcbiB9O1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0U3BhY2VkUG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKSB7XHJcblxyXG5cdGlmICggISBkaXZpc2lvbnMgKSBkaXZpc2lvbnMgPSA0MDtcclxuXHJcblx0dmFyIHBvaW50cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkaXZpc2lvbnM7IGkgKysgKSB7XHJcblxyXG5cdFx0cG9pbnRzLnB1c2goIHRoaXMuZ2V0UG9pbnQoIGkgLyBkaXZpc2lvbnMgKSApO1xyXG5cclxuXHRcdC8vaWYoICF0aGlzLmdldFBvaW50KCBpIC8gZGl2aXNpb25zICkgKSB0aHJvdyBcIkRJRVwiO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGlmICggY2xvc2VkUGF0aCApIHtcclxuXHQvL1xyXG5cdC8vIFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XHJcblx0Ly9cclxuXHQvLyB9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuLyogUmV0dXJuIGFuIGFycmF5IG9mIHZlY3RvcnMgYmFzZWQgb24gY29udG91ciBvZiB0aGUgcGF0aCAqL1xyXG5cclxuVEhSRUUuUGF0aC5wcm90b3R5cGUuZ2V0UG9pbnRzID0gZnVuY3Rpb24oIGRpdmlzaW9ucywgY2xvc2VkUGF0aCApIHtcclxuXHJcblx0aWYgKHRoaXMudXNlU3BhY2VkUG9pbnRzKSB7XHJcblx0XHRjb25zb2xlLmxvZygndGF0YScpO1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMsIGNsb3NlZFBhdGggKTtcclxuXHR9XHJcblxyXG5cdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxMjtcclxuXHJcblx0dmFyIHBvaW50cyA9IFtdO1xyXG5cclxuXHR2YXIgaSwgaWwsIGl0ZW0sIGFjdGlvbiwgYXJncztcclxuXHR2YXIgY3B4LCBjcHksIGNweDIsIGNweTIsIGNweDEsIGNweTEsIGNweDAsIGNweTAsXHJcblx0XHRsYXN0ZSwgaixcclxuXHRcdHQsIHR4LCB0eTtcclxuXHJcblx0Zm9yICggaSA9IDAsIGlsID0gdGhpcy5hY3Rpb25zLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdGl0ZW0gPSB0aGlzLmFjdGlvbnNbIGkgXTtcclxuXHJcblx0XHRhY3Rpb24gPSBpdGVtLmFjdGlvbjtcclxuXHRcdGFyZ3MgPSBpdGVtLmFyZ3M7XHJcblxyXG5cdFx0c3dpdGNoKCBhY3Rpb24gKSB7XHJcblxyXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPOlxyXG5cclxuXHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBhcmdzWyAwIF0sIGFyZ3NbIDEgXSApICk7XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkxJTkVfVE86XHJcblxyXG5cdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIGFyZ3NbIDAgXSwgYXJnc1sgMSBdICkgKTtcclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuUVVBRFJBVElDX0NVUlZFX1RPOlxyXG5cclxuXHRcdFx0Y3B4ICA9IGFyZ3NbIDIgXTtcclxuXHRcdFx0Y3B5ICA9IGFyZ3NbIDMgXTtcclxuXHJcblx0XHRcdGNweDEgPSBhcmdzWyAwIF07XHJcblx0XHRcdGNweTEgPSBhcmdzWyAxIF07XHJcblxyXG5cdFx0XHRpZiAoIHBvaW50cy5sZW5ndGggPiAwICkge1xyXG5cclxuXHRcdFx0XHRsYXN0ZSA9IHBvaW50c1sgcG9pbnRzLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdFx0Y3B4MCA9IGxhc3RlLng7XHJcblx0XHRcdFx0Y3B5MCA9IGxhc3RlLnk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRsYXN0ZSA9IHRoaXMuYWN0aW9uc1sgaSAtIDEgXS5hcmdzO1xyXG5cclxuXHRcdFx0XHRjcHgwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDIgXTtcclxuXHRcdFx0XHRjcHkwID0gbGFzdGVbIGxhc3RlLmxlbmd0aCAtIDEgXTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGZvciAoIGogPSAxOyBqIDw9IGRpdmlzaW9uczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dCA9IGogLyBkaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRcdHR4ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweDAsIGNweDEsIGNweCApO1xyXG5cdFx0XHRcdHR5ID0gVEhSRUUuU2hhcGUuVXRpbHMuYjIoIHQsIGNweTAsIGNweTEsIGNweSApO1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG5cdFx0ICBcdH1cclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQkVaSUVSX0NVUlZFX1RPOlxyXG5cclxuXHRcdFx0Y3B4ICA9IGFyZ3NbIDQgXTtcclxuXHRcdFx0Y3B5ICA9IGFyZ3NbIDUgXTtcclxuXHJcblx0XHRcdGNweDEgPSBhcmdzWyAwIF07XHJcblx0XHRcdGNweTEgPSBhcmdzWyAxIF07XHJcblxyXG5cdFx0XHRjcHgyID0gYXJnc1sgMiBdO1xyXG5cdFx0XHRjcHkyID0gYXJnc1sgMyBdO1xyXG5cclxuXHRcdFx0aWYgKCBwb2ludHMubGVuZ3RoID4gMCApIHtcclxuXHJcblx0XHRcdFx0bGFzdGUgPSBwb2ludHNbIHBvaW50cy5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHRcdGNweDAgPSBsYXN0ZS54O1xyXG5cdFx0XHRcdGNweTAgPSBsYXN0ZS55O1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcclxuXHJcblx0XHRcdFx0Y3B4MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF07XHJcblx0XHRcdFx0Y3B5MCA9IGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF07XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Zm9yICggaiA9IDE7IGogPD0gZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR0ID0gaiAvIGRpdmlzaW9ucztcclxuXHJcblx0XHRcdFx0dHggPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B4MCwgY3B4MSwgY3B4MiwgY3B4ICk7XHJcblx0XHRcdFx0dHkgPSBUSFJFRS5TaGFwZS5VdGlscy5iMyggdCwgY3B5MCwgY3B5MSwgY3B5MiwgY3B5ICk7XHJcblxyXG5cdFx0XHRcdHBvaW50cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggdHgsIHR5ICkgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgVEhSRUUuUGF0aEFjdGlvbnMuQ1NQTElORV9USFJVOlxyXG5cclxuXHRcdFx0bGFzdGUgPSB0aGlzLmFjdGlvbnNbIGkgLSAxIF0uYXJncztcclxuXHJcblx0XHRcdHZhciBsYXN0ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAyIF0sIGxhc3RlWyBsYXN0ZS5sZW5ndGggLSAxIF0gKTtcclxuXHRcdFx0dmFyIHNwdHMgPSBbIGxhc3QgXTtcclxuXHJcblx0XHRcdHZhciBuID0gZGl2aXNpb25zICogYXJnc1sgMCBdLmxlbmd0aDtcclxuXHJcblx0XHRcdHNwdHMgPSBzcHRzLmNvbmNhdCggYXJnc1sgMCBdICk7XHJcblxyXG5cdFx0XHR2YXIgc3BsaW5lID0gbmV3IFRIUkVFLlNwbGluZUN1cnZlKCBzcHRzICk7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSBuOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggc3BsaW5lLmdldFBvaW50QXQoIGogLyBuICkgKSA7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIFRIUkVFLlBhdGhBY3Rpb25zLkFSQzpcclxuXHJcblx0XHRcdHZhciBhWCA9IGFyZ3NbIDAgXSwgYVkgPSBhcmdzWyAxIF0sXHJcblx0XHRcdFx0YVJhZGl1cyA9IGFyZ3NbIDIgXSxcclxuXHRcdFx0XHRhU3RhcnRBbmdsZSA9IGFyZ3NbIDMgXSwgYUVuZEFuZ2xlID0gYXJnc1sgNCBdLFxyXG5cdFx0XHRcdGFDbG9ja3dpc2UgPSAhIWFyZ3NbIDUgXTtcclxuXHJcblx0XHRcdHZhciBkZWx0YUFuZ2xlID0gYUVuZEFuZ2xlIC0gYVN0YXJ0QW5nbGU7XHJcblx0XHRcdHZhciBhbmdsZTtcclxuXHRcdFx0dmFyIHRkaXZpc2lvbnMgPSBkaXZpc2lvbnMgKiAyO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDE7IGogPD0gdGRpdmlzaW9uczsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0dCA9IGogLyB0ZGl2aXNpb25zO1xyXG5cclxuXHRcdFx0XHRpZiAoICEgYUNsb2Nrd2lzZSApIHtcclxuXHJcblx0XHRcdFx0XHR0ID0gMSAtIHQ7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YW5nbGUgPSBhU3RhcnRBbmdsZSArIHQgKiBkZWx0YUFuZ2xlO1xyXG5cclxuXHRcdFx0XHR0eCA9IGFYICsgYVJhZGl1cyAqIE1hdGguY29zKCBhbmdsZSApO1xyXG5cdFx0XHRcdHR5ID0gYVkgKyBhUmFkaXVzICogTWF0aC5zaW4oIGFuZ2xlICk7XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ3QnLCB0LCAnYW5nbGUnLCBhbmdsZSwgJ3R4JywgdHgsICd0eScsIHR5KTtcclxuXHJcblx0XHRcdFx0cG9pbnRzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB0eCwgdHkgKSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhwb2ludHMpO1xyXG5cclxuXHRcdCAgYnJlYWs7XHJcblx0XHQgIFxyXG5cdFx0Y2FzZSBUSFJFRS5QYXRoQWN0aW9ucy5FTExJUFNFOlxyXG5cclxuXHRcdFx0dmFyIGFYID0gYXJnc1sgMCBdLCBhWSA9IGFyZ3NbIDEgXSxcclxuXHRcdFx0XHR4UmFkaXVzID0gYXJnc1sgMiBdLFxyXG5cdFx0XHRcdHlSYWRpdXMgPSBhcmdzWyAzIF0sXHJcblx0XHRcdFx0YVN0YXJ0QW5nbGUgPSBhcmdzWyA0IF0sIGFFbmRBbmdsZSA9IGFyZ3NbIDUgXSxcclxuXHRcdFx0XHRhQ2xvY2t3aXNlID0gISFhcmdzWyA2IF07XHJcblxyXG5cclxuXHRcdFx0dmFyIGRlbHRhQW5nbGUgPSBhRW5kQW5nbGUgLSBhU3RhcnRBbmdsZTtcclxuXHRcdFx0dmFyIGFuZ2xlO1xyXG5cdFx0XHR2YXIgdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyAqIDI7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMTsgaiA8PSB0ZGl2aXNpb25zOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR0ID0gaiAvIHRkaXZpc2lvbnM7XHJcblxyXG5cdFx0XHRcdGlmICggISBhQ2xvY2t3aXNlICkge1xyXG5cclxuXHRcdFx0XHRcdHQgPSAxIC0gdDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRhbmdsZSA9IGFTdGFydEFuZ2xlICsgdCAqIGRlbHRhQW5nbGU7XHJcblxyXG5cdFx0XHRcdHR4ID0gYVggKyB4UmFkaXVzICogTWF0aC5jb3MoIGFuZ2xlICk7XHJcblx0XHRcdFx0dHkgPSBhWSArIHlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcclxuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZygndCcsIHQsICdhbmdsZScsIGFuZ2xlLCAndHgnLCB0eCwgJ3R5JywgdHkpO1xyXG5cclxuXHRcdFx0XHRwb2ludHMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjIoIHR4LCB0eSApICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKHBvaW50cyk7XHJcblxyXG5cdFx0ICBicmVhaztcclxuXHJcblx0XHR9IC8vIGVuZCBzd2l0Y2hcclxuXHJcblx0fVxyXG5cclxuXHJcblxyXG5cdC8vIE5vcm1hbGl6ZSB0byByZW1vdmUgdGhlIGNsb3NpbmcgcG9pbnQgYnkgZGVmYXVsdC5cclxuXHR2YXIgbGFzdFBvaW50ID0gcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMV07XHJcblx0dmFyIEVQU0lMT04gPSAwLjAwMDAwMDAwMDE7XHJcblx0aWYgKCBNYXRoLmFicyhsYXN0UG9pbnQueCAtIHBvaW50c1sgMCBdLngpIDwgRVBTSUxPTiAmJlxyXG4gICAgICAgICAgICAgTWF0aC5hYnMobGFzdFBvaW50LnkgLSBwb2ludHNbIDAgXS55KSA8IEVQU0lMT04pXHJcblx0XHRwb2ludHMuc3BsaWNlKCBwb2ludHMubGVuZ3RoIC0gMSwgMSk7XHJcblx0aWYgKCBjbG9zZWRQYXRoICkge1xyXG5cclxuXHRcdHBvaW50cy5wdXNoKCBwb2ludHNbIDAgXSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcblxyXG59O1xyXG5cclxuLy8gQnJlYWtzIHBhdGggaW50byBzaGFwZXNcclxuXHJcblRIUkVFLlBhdGgucHJvdG90eXBlLnRvU2hhcGVzID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHZhciBpLCBpbCwgaXRlbSwgYWN0aW9uLCBhcmdzO1xyXG5cclxuXHR2YXIgc3ViUGF0aHMgPSBbXSwgbGFzdFBhdGggPSBuZXcgVEhSRUUuUGF0aCgpO1xyXG5cclxuXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmFjdGlvbnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0aXRlbSA9IHRoaXMuYWN0aW9uc1sgaSBdO1xyXG5cclxuXHRcdGFyZ3MgPSBpdGVtLmFyZ3M7XHJcblx0XHRhY3Rpb24gPSBpdGVtLmFjdGlvbjtcclxuXHJcblx0XHRpZiAoIGFjdGlvbiA9PSBUSFJFRS5QYXRoQWN0aW9ucy5NT1ZFX1RPICkge1xyXG5cclxuXHRcdFx0aWYgKCBsYXN0UGF0aC5hY3Rpb25zLmxlbmd0aCAhPSAwICkge1xyXG5cclxuXHRcdFx0XHRzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xyXG5cdFx0XHRcdGxhc3RQYXRoID0gbmV3IFRIUkVFLlBhdGgoKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0bGFzdFBhdGhbIGFjdGlvbiBdLmFwcGx5KCBsYXN0UGF0aCwgYXJncyApO1xyXG5cclxuXHR9XHJcblxyXG5cdGlmICggbGFzdFBhdGguYWN0aW9ucy5sZW5ndGggIT0gMCApIHtcclxuXHJcblx0XHRzdWJQYXRocy5wdXNoKCBsYXN0UGF0aCApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIGNvbnNvbGUubG9nKHN1YlBhdGhzKTtcclxuXHJcblx0aWYgKCBzdWJQYXRocy5sZW5ndGggPT0gMCApIHJldHVybiBbXTtcclxuXHJcblx0dmFyIHRtcFBhdGgsIHRtcFNoYXBlLCBzaGFwZXMgPSBbXTtcclxuXHJcblx0dmFyIGhvbGVzRmlyc3QgPSAhVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHN1YlBhdGhzWyAwIF0uZ2V0UG9pbnRzKCkgKTtcclxuXHQvLyBjb25zb2xlLmxvZyhcIkhvbGVzIGZpcnN0XCIsIGhvbGVzRmlyc3QpO1xyXG5cclxuXHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PSAxKSB7XHJcblx0XHR0bXBQYXRoID0gc3ViUGF0aHNbMF07XHJcblx0XHR0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xyXG5cdFx0dG1wU2hhcGUuYWN0aW9ucyA9IHRtcFBhdGguYWN0aW9ucztcclxuXHRcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xyXG5cdFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XHJcblx0XHRyZXR1cm4gc2hhcGVzO1xyXG5cdH07XHJcblxyXG5cdGlmICggaG9sZXNGaXJzdCApIHtcclxuXHJcblx0XHR0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IHN1YlBhdGhzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dG1wUGF0aCA9IHN1YlBhdGhzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB0bXBQYXRoLmdldFBvaW50cygpICkgKSB7XHJcblxyXG5cdFx0XHRcdHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XHJcblx0XHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblxyXG5cdFx0XHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cdFx0XHRcdHRtcFNoYXBlID0gbmV3IFRIUkVFLlNoYXBlKCk7XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2N3JywgaSk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBQYXRoICk7XHJcblxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coJ2NjdycsIGkpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHQvLyBTaGFwZXMgZmlyc3RcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xyXG5cclxuXHRcdFx0aWYgKCBUSFJFRS5TaGFwZS5VdGlscy5pc0Nsb2NrV2lzZSggdG1wUGF0aC5nZXRQb2ludHMoKSApICkge1xyXG5cclxuXHJcblx0XHRcdFx0aWYgKCB0bXBTaGFwZSApIHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cclxuXHRcdFx0XHR0bXBTaGFwZSA9IG5ldyBUSFJFRS5TaGFwZSgpO1xyXG5cdFx0XHRcdHRtcFNoYXBlLmFjdGlvbnMgPSB0bXBQYXRoLmFjdGlvbnM7XHJcblx0XHRcdFx0dG1wU2hhcGUuY3VydmVzID0gdG1wUGF0aC5jdXJ2ZXM7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0bXBTaGFwZS5ob2xlcy5wdXNoKCB0bXBQYXRoICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vY29uc29sZS5sb2coXCJzaGFwZVwiLCBzaGFwZXMpO1xyXG5cclxuXHRyZXR1cm4gc2hhcGVzO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogRGVmaW5lcyBhIDJkIHNoYXBlIHBsYW5lIHVzaW5nIHBhdGhzLlxyXG4gKiovXHJcblxyXG4vLyBTVEVQIDEgQ3JlYXRlIGEgcGF0aC5cclxuLy8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxyXG4vLyBTVEVQIDMgRXh0cnVkZUdlb21ldHJ5IHRha2VzIGluIFNoYXBlL1NoYXBlc1xyXG4vLyBTVEVQIDNhIC0gRXh0cmFjdCBwb2ludHMgZnJvbSBlYWNoIHNoYXBlLCB0dXJuIHRvIHZlcnRpY2VzXHJcbi8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXHJcblxyXG5USFJFRS5TaGFwZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0VEhSRUUuUGF0aC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XHJcblx0dGhpcy5ob2xlcyA9IFtdO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLlBhdGgucHJvdG90eXBlICk7XHJcblxyXG4vLyBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmV0dXJuIEV4dHJ1ZGVHZW9tZXRyeVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmV4dHJ1ZGUgPSBmdW5jdGlvbiAoIG9wdGlvbnMgKSB7XHJcblxyXG5cdHZhciBleHRydWRlZCA9IG5ldyBUSFJFRS5FeHRydWRlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcclxuXHRyZXR1cm4gZXh0cnVkZWQ7XHJcblxyXG59O1xyXG5cclxuLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJldHVybiBTaGFwZUdlb21ldHJ5XHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUubWFrZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBvcHRpb25zICkge1xyXG5cclxuXHR2YXIgZ2VvbWV0cnkgPSBuZXcgVEhSRUUuU2hhcGVHZW9tZXRyeSggdGhpcywgb3B0aW9ucyApO1xyXG5cdHJldHVybiBnZW9tZXRyeTtcclxuXHJcbn07XHJcblxyXG4vLyBHZXQgcG9pbnRzIG9mIGhvbGVzXHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZ2V0UG9pbnRzSG9sZXMgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcclxuXHJcblx0dmFyIGksIGlsID0gdGhpcy5ob2xlcy5sZW5ndGgsIGhvbGVzUHRzID0gW107XHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0aG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRUcmFuc2Zvcm1lZFBvaW50cyggZGl2aXNpb25zLCB0aGlzLmJlbmRzICk7XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGhvbGVzUHRzO1xyXG5cclxufTtcclxuXHJcbi8vIEdldCBwb2ludHMgb2YgaG9sZXMgKHNwYWNlZCBieSByZWd1bGFyIGRpc3RhbmNlKVxyXG5cclxuVEhSRUUuU2hhcGUucHJvdG90eXBlLmdldFNwYWNlZFBvaW50c0hvbGVzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdHZhciBpLCBpbCA9IHRoaXMuaG9sZXMubGVuZ3RoLCBob2xlc1B0cyA9IFtdO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdGhvbGVzUHRzWyBpIF0gPSB0aGlzLmhvbGVzWyBpIF0uZ2V0VHJhbnNmb3JtZWRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucywgdGhpcy5iZW5kcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiBob2xlc1B0cztcclxuXHJcbn07XHJcblxyXG5cclxuLy8gR2V0IHBvaW50cyBvZiBzaGFwZSBhbmQgaG9sZXMgKGtleXBvaW50cyBiYXNlZCBvbiBzZWdtZW50cyBwYXJhbWV0ZXIpXHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdHNoYXBlOiB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCBkaXZpc2lvbnMgKSxcclxuXHRcdGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0UG9pbnRzID0gZnVuY3Rpb24gKCBkaXZpc2lvbnMgKSB7XHJcblxyXG5cdGlmICh0aGlzLnVzZVNwYWNlZFBvaW50cykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyhkaXZpc2lvbnMpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHRoaXMuZXh0cmFjdEFsbFBvaW50cyhkaXZpc2lvbnMpO1xyXG5cclxufTtcclxuXHJcbi8vXHJcbi8vIFRIUkVFLlNoYXBlLnByb3RvdHlwZS5leHRyYWN0QWxsUG9pbnRzV2l0aEJlbmQgPSBmdW5jdGlvbiAoIGRpdmlzaW9ucywgYmVuZCApIHtcclxuLy9cclxuLy8gXHRyZXR1cm4ge1xyXG4vL1xyXG4vLyBcdFx0c2hhcGU6IHRoaXMudHJhbnNmb3JtKCBiZW5kLCBkaXZpc2lvbnMgKSxcclxuLy8gXHRcdGhvbGVzOiB0aGlzLmdldFBvaW50c0hvbGVzKCBkaXZpc2lvbnMsIGJlbmQgKVxyXG4vL1xyXG4vLyBcdH07XHJcbi8vXHJcbi8vIH07XHJcblxyXG4vLyBHZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoc3BhY2VkIGJ5IHJlZ3VsYXIgZGlzdGFuY2UpXHJcblxyXG5USFJFRS5TaGFwZS5wcm90b3R5cGUuZXh0cmFjdEFsbFNwYWNlZFBvaW50cyA9IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cclxuXHRcdHNoYXBlOiB0aGlzLmdldFRyYW5zZm9ybWVkU3BhY2VkUG9pbnRzKCBkaXZpc2lvbnMgKSxcclxuXHRcdGhvbGVzOiB0aGlzLmdldFNwYWNlZFBvaW50c0hvbGVzKCBkaXZpc2lvbnMgKVxyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKlx0VXRpbHNcclxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuVEhSRUUuU2hhcGUuVXRpbHMgPSB7XHJcblxyXG5cdC8qXHJcblx0XHRjb250b3VyIC0gYXJyYXkgb2YgdmVjdG9yMiBmb3IgY29udG91clxyXG5cdFx0aG9sZXMgICAtIGFycmF5IG9mIGFycmF5IG9mIHZlY3RvcjJcclxuXHQqL1xyXG5cclxuXHRyZW1vdmVIb2xlczogZnVuY3Rpb24gKCBjb250b3VyLCBob2xlcyApIHtcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBjb250b3VyLmNvbmNhdCgpOyAvLyB3b3JrIG9uIHRoaXMgc2hhcGVcclxuXHRcdHZhciBhbGxwb2ludHMgPSBzaGFwZS5jb25jYXQoKTtcclxuXHJcblx0XHQvKiBGb3IgZWFjaCBpc29sYXRlZCBzaGFwZSwgZmluZCB0aGUgY2xvc2VzdCBwb2ludHMgYW5kIGJyZWFrIHRvIHRoZSBob2xlIHRvIGFsbG93IHRyaWFuZ3VsYXRpb24gKi9cclxuXHJcblxyXG5cdFx0dmFyIHByZXZTaGFwZVZlcnQsIG5leHRTaGFwZVZlcnQsXHJcblx0XHRcdHByZXZIb2xlVmVydCwgbmV4dEhvbGVWZXJ0LFxyXG5cdFx0XHRob2xlSW5kZXgsIHNoYXBlSW5kZXgsXHJcblx0XHRcdHNoYXBlSWQsIHNoYXBlR3JvdXAsXHJcblx0XHRcdGgsIGgyLFxyXG5cdFx0XHRob2xlLCBzaG9ydGVzdCwgZCxcclxuXHRcdFx0cCwgcHRzMSwgcHRzMixcclxuXHRcdFx0dG1wU2hhcGUxLCB0bXBTaGFwZTIsXHJcblx0XHRcdHRtcEhvbGUxLCB0bXBIb2xlMixcclxuXHRcdFx0dmVydHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKCBoID0gMDsgaCA8IGhvbGVzLmxlbmd0aDsgaCArKyApIHtcclxuXHJcblx0XHRcdGhvbGUgPSBob2xlc1sgaCBdO1xyXG5cclxuXHRcdFx0LypcclxuXHRcdFx0c2hhcGVob2xlc1sgaCBdLmNvbmNhdCgpOyAvLyBwcmVzZXJ2ZXMgb3JpZ2luYWxcclxuXHRcdFx0aG9sZXMucHVzaCggaG9sZSApO1xyXG5cdFx0XHQqL1xyXG5cclxuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkoIGFsbHBvaW50cywgaG9sZSApO1xyXG5cclxuXHRcdFx0c2hvcnRlc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcblxyXG5cclxuXHRcdFx0Ly8gRmluZCB0aGUgc2hvcnRlc3QgcGFpciBvZiBwdHMgYmV0d2VlbiBzaGFwZSBhbmQgaG9sZVxyXG5cclxuXHRcdFx0Ly8gTm90ZTogQWN0dWFsbHksIEknbSBub3Qgc3VyZSBub3cgaWYgd2UgY291bGQgb3B0aW1pemUgdGhpcyB0byBiZSBmYXN0ZXIgdGhhbiBPKG0qbilcclxuXHRcdFx0Ly8gVXNpbmcgZGlzdGFuY2VUb1NxdWFyZWQoKSBpbnRlYWQgb2YgZGlzdGFuY2VUbygpIHNob3VsZCBzcGVlZCBhIGxpdHRsZVxyXG5cdFx0XHQvLyBzaW5jZSBydW5uaW5nIHNxdWFyZSByb290cyBvcGVyYXRpb25zIGFyZSByZWR1Y2VkLlxyXG5cclxuXHRcdFx0Zm9yICggaDIgPSAwOyBoMiA8IGhvbGUubGVuZ3RoOyBoMiArKyApIHtcclxuXHJcblx0XHRcdFx0cHRzMSA9IGhvbGVbIGgyIF07XHJcblx0XHRcdFx0dmFyIGRpc3QgPSBbXTtcclxuXHJcblx0XHRcdFx0Zm9yICggcCA9IDA7IHAgPCBzaGFwZS5sZW5ndGg7IHArKyApIHtcclxuXHJcblx0XHRcdFx0XHRwdHMyID0gc2hhcGVbIHAgXTtcclxuXHRcdFx0XHRcdGQgPSBwdHMxLmRpc3RhbmNlVG9TcXVhcmVkKCBwdHMyICk7XHJcblx0XHRcdFx0XHRkaXN0LnB1c2goIGQgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIGQgPCBzaG9ydGVzdCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHNob3J0ZXN0ID0gZDtcclxuXHRcdFx0XHRcdFx0aG9sZUluZGV4ID0gaDI7XHJcblx0XHRcdFx0XHRcdHNoYXBlSW5kZXggPSBwO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhcInNob3J0ZXN0XCIsIHNob3J0ZXN0LCBkaXN0KTtcclxuXHJcblx0XHRcdHByZXZTaGFwZVZlcnQgPSAoIHNoYXBlSW5kZXggLSAxICkgPj0gMCA/IHNoYXBlSW5kZXggLSAxIDogc2hhcGUubGVuZ3RoIC0gMTtcclxuXHRcdFx0cHJldkhvbGVWZXJ0ID0gKCBob2xlSW5kZXggLSAxICkgPj0gMCA/IGhvbGVJbmRleCAtIDEgOiBob2xlLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHR2YXIgYXJlYWFwdHMgPSBbXHJcblxyXG5cdFx0XHRcdGhvbGVbIGhvbGVJbmRleCBdLFxyXG5cdFx0XHRcdHNoYXBlWyBzaGFwZUluZGV4IF0sXHJcblx0XHRcdFx0c2hhcGVbIHByZXZTaGFwZVZlcnQgXVxyXG5cclxuXHRcdFx0XTtcclxuXHJcblx0XHRcdHZhciBhcmVhYSA9IFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKCBhcmVhYXB0cyApO1xyXG5cclxuXHRcdFx0dmFyIGFyZWFicHRzID0gW1xyXG5cclxuXHRcdFx0XHRob2xlWyBob2xlSW5kZXggXSxcclxuXHRcdFx0XHRob2xlWyBwcmV2SG9sZVZlcnQgXSxcclxuXHRcdFx0XHRzaGFwZVsgc2hhcGVJbmRleCBdXHJcblxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0dmFyIGFyZWFiID0gVEhSRUUuRm9udFV0aWxzLlRyaWFuZ3VsYXRlLmFyZWEoIGFyZWFicHRzICk7XHJcblxyXG5cdFx0XHR2YXIgc2hhcGVPZmZzZXQgPSAxO1xyXG5cdFx0XHR2YXIgaG9sZU9mZnNldCA9IC0xO1xyXG5cclxuXHRcdFx0dmFyIG9sZFNoYXBlSW5kZXggPSBzaGFwZUluZGV4LCBvbGRIb2xlSW5kZXggPSBob2xlSW5kZXg7XHJcblx0XHRcdHNoYXBlSW5kZXggKz0gc2hhcGVPZmZzZXQ7XHJcblx0XHRcdGhvbGVJbmRleCArPSBob2xlT2Zmc2V0O1xyXG5cclxuXHRcdFx0aWYgKCBzaGFwZUluZGV4IDwgMCApIHsgc2hhcGVJbmRleCArPSBzaGFwZS5sZW5ndGg7ICB9XHJcblx0XHRcdHNoYXBlSW5kZXggJT0gc2hhcGUubGVuZ3RoO1xyXG5cclxuXHRcdFx0aWYgKCBob2xlSW5kZXggPCAwICkgeyBob2xlSW5kZXggKz0gaG9sZS5sZW5ndGg7ICB9XHJcblx0XHRcdGhvbGVJbmRleCAlPSBob2xlLmxlbmd0aDtcclxuXHJcblx0XHRcdHByZXZTaGFwZVZlcnQgPSAoIHNoYXBlSW5kZXggLSAxICkgPj0gMCA/IHNoYXBlSW5kZXggLSAxIDogc2hhcGUubGVuZ3RoIC0gMTtcclxuXHRcdFx0cHJldkhvbGVWZXJ0ID0gKCBob2xlSW5kZXggLSAxICkgPj0gMCA/IGhvbGVJbmRleCAtIDEgOiBob2xlLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHRhcmVhYXB0cyA9IFtcclxuXHJcblx0XHRcdFx0aG9sZVsgaG9sZUluZGV4IF0sXHJcblx0XHRcdFx0c2hhcGVbIHNoYXBlSW5kZXggXSxcclxuXHRcdFx0XHRzaGFwZVsgcHJldlNoYXBlVmVydCBdXHJcblxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0dmFyIGFyZWFhMiA9IFRIUkVFLkZvbnRVdGlscy5Ucmlhbmd1bGF0ZS5hcmVhKCBhcmVhYXB0cyApO1xyXG5cclxuXHRcdFx0YXJlYWJwdHMgPSBbXHJcblxyXG5cdFx0XHRcdGhvbGVbIGhvbGVJbmRleCBdLFxyXG5cdFx0XHRcdGhvbGVbIHByZXZIb2xlVmVydCBdLFxyXG5cdFx0XHRcdHNoYXBlWyBzaGFwZUluZGV4IF1cclxuXHJcblx0XHRcdF07XHJcblxyXG5cdFx0XHR2YXIgYXJlYWIyID0gVEhSRUUuRm9udFV0aWxzLlRyaWFuZ3VsYXRlLmFyZWEoIGFyZWFicHRzICk7XHJcblx0XHRcdC8vY29uc29sZS5sb2coYXJlYWEsYXJlYWIgLGFyZWFhMixhcmVhYjIsICggYXJlYWEgKyBhcmVhYiApLCAgKCBhcmVhYTIgKyBhcmVhYjIgKSk7XHJcblxyXG5cdFx0XHRpZiAoICggYXJlYWEgKyBhcmVhYiApID4gKCBhcmVhYTIgKyBhcmVhYjIgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gSW4gY2FzZSBhcmVhcyBhcmUgbm90IGNvcnJlY3QuXHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhcIlVTRSBUSElTXCIpO1xyXG5cclxuXHRcdFx0XHRzaGFwZUluZGV4ID0gb2xkU2hhcGVJbmRleDtcclxuXHRcdFx0XHRob2xlSW5kZXggPSBvbGRIb2xlSW5kZXggO1xyXG5cclxuXHRcdFx0XHRpZiAoIHNoYXBlSW5kZXggPCAwICkgeyBzaGFwZUluZGV4ICs9IHNoYXBlLmxlbmd0aDsgIH1cclxuXHRcdFx0XHRzaGFwZUluZGV4ICU9IHNoYXBlLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0aWYgKCBob2xlSW5kZXggPCAwICkgeyBob2xlSW5kZXggKz0gaG9sZS5sZW5ndGg7ICB9XHJcblx0XHRcdFx0aG9sZUluZGV4ICU9IGhvbGUubGVuZ3RoO1xyXG5cclxuXHRcdFx0XHRwcmV2U2hhcGVWZXJ0ID0gKCBzaGFwZUluZGV4IC0gMSApID49IDAgPyBzaGFwZUluZGV4IC0gMSA6IHNoYXBlLmxlbmd0aCAtIDE7XHJcblx0XHRcdFx0cHJldkhvbGVWZXJ0ID0gKCBob2xlSW5kZXggLSAxICkgPj0gMCA/IGhvbGVJbmRleCAtIDEgOiBob2xlLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvL2NvbnNvbGUubG9nKFwiVVNFIFRIQVQgXCIpXHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0bXBTaGFwZTEgPSBzaGFwZS5zbGljZSggMCwgc2hhcGVJbmRleCApO1xyXG5cdFx0XHR0bXBTaGFwZTIgPSBzaGFwZS5zbGljZSggc2hhcGVJbmRleCApO1xyXG5cdFx0XHR0bXBIb2xlMSA9IGhvbGUuc2xpY2UoIGhvbGVJbmRleCApO1xyXG5cdFx0XHR0bXBIb2xlMiA9IGhvbGUuc2xpY2UoIDAsIGhvbGVJbmRleCApO1xyXG5cclxuXHRcdFx0Ly8gU2hvdWxkIGNoZWNrIG9yZGVycyBoZXJlIGFnYWluP1xyXG5cclxuXHRcdFx0dmFyIHRyaWFuZ2xlYSA9IFtcclxuXHJcblx0XHRcdFx0aG9sZVsgaG9sZUluZGV4IF0sXHJcblx0XHRcdFx0c2hhcGVbIHNoYXBlSW5kZXggXSxcclxuXHRcdFx0XHRzaGFwZVsgcHJldlNoYXBlVmVydCBdXHJcblxyXG5cdFx0XHRdO1xyXG5cclxuXHRcdFx0dmFyIHRyaWFuZ2xlYiA9IFtcclxuXHJcblx0XHRcdFx0aG9sZVsgaG9sZUluZGV4IF0gLFxyXG5cdFx0XHRcdGhvbGVbIHByZXZIb2xlVmVydCBdLFxyXG5cdFx0XHRcdHNoYXBlWyBzaGFwZUluZGV4IF1cclxuXHJcblx0XHRcdF07XHJcblxyXG5cdFx0XHR2ZXJ0cy5wdXNoKCB0cmlhbmdsZWEgKTtcclxuXHRcdFx0dmVydHMucHVzaCggdHJpYW5nbGViICk7XHJcblxyXG5cdFx0XHRzaGFwZSA9IHRtcFNoYXBlMS5jb25jYXQoIHRtcEhvbGUxICkuY29uY2F0KCB0bXBIb2xlMiApLmNvbmNhdCggdG1wU2hhcGUyICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblxyXG5cdFx0XHRzaGFwZTpzaGFwZSwgXHRcdC8qIHNoYXBlIHdpdGggbm8gaG9sZXMgKi9cclxuXHRcdFx0aXNvbGF0ZWRQdHM6IHZlcnRzLCAvKiBpc29sYXRlZCBmYWNlcyAqL1xyXG5cdFx0XHRhbGxwb2ludHM6IGFsbHBvaW50c1xyXG5cclxuXHRcdH1cclxuXHJcblxyXG5cdH0sXHJcblxyXG5cdHRyaWFuZ3VsYXRlU2hhcGU6IGZ1bmN0aW9uICggY29udG91ciwgaG9sZXMgKSB7XHJcblxyXG5cdFx0dmFyIHNoYXBlV2l0aG91dEhvbGVzID0gVEhSRUUuU2hhcGUuVXRpbHMucmVtb3ZlSG9sZXMoIGNvbnRvdXIsIGhvbGVzICk7XHJcblxyXG5cdFx0dmFyIHNoYXBlID0gc2hhcGVXaXRob3V0SG9sZXMuc2hhcGUsXHJcblx0XHRcdGFsbHBvaW50cyA9IHNoYXBlV2l0aG91dEhvbGVzLmFsbHBvaW50cyxcclxuXHRcdFx0aXNvbGF0ZWRQdHMgPSBzaGFwZVdpdGhvdXRIb2xlcy5pc29sYXRlZFB0cztcclxuXHJcblx0XHR2YXIgdHJpYW5nbGVzID0gVEhSRUUuRm9udFV0aWxzLlRyaWFuZ3VsYXRlKCBzaGFwZSwgZmFsc2UgKTsgLy8gVHJ1ZSByZXR1cm5zIGluZGljZXMgZm9yIHBvaW50cyBvZiBzcG9vbGVkIHNoYXBlXHJcblxyXG5cdFx0Ly8gVG8gbWFpbnRhaW4gcmVmZXJlbmNlIHRvIG9sZCBzaGFwZSwgb25lIG11c3QgbWF0Y2ggY29vcmRpbmF0ZXMsIG9yIG9mZnNldCB0aGUgaW5kaWNlcyBmcm9tIG9yaWdpbmFsIGFycmF5cy4gSXQncyBwcm9iYWJseSBlYXNpZXIgdG8gZG8gdGhlIGZpcnN0LlxyXG5cclxuXHRcdC8vY29uc29sZS5sb2coIFwidHJpYW5nbGVzXCIsdHJpYW5nbGVzLCB0cmlhbmdsZXMubGVuZ3RoICk7XHJcblx0XHQvL2NvbnNvbGUubG9nKCBcImFsbHBvaW50c1wiLGFsbHBvaW50cywgYWxscG9pbnRzLmxlbmd0aCApO1xyXG5cclxuXHRcdHZhciBpLCBpbCwgZiwgZmFjZSxcclxuXHRcdFx0a2V5LCBpbmRleCxcclxuXHRcdFx0YWxsUG9pbnRzTWFwID0ge30sXHJcblx0XHRcdGlzb2xhdGVkUG9pbnRzTWFwID0ge307XHJcblxyXG5cdFx0Ly8gcHJlcGFyZSBhbGwgcG9pbnRzIG1hcFxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFsbHBvaW50cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGtleSA9IGFsbHBvaW50c1sgaSBdLnggKyBcIjpcIiArIGFsbHBvaW50c1sgaSBdLnk7XHJcblxyXG5cdFx0XHRpZiAoIGFsbFBvaW50c01hcFsga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5sb2coIFwiRHVwbGljYXRlIHBvaW50XCIsIGtleSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0YWxsUG9pbnRzTWFwWyBrZXkgXSA9IGk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNoZWNrIGFsbCBmYWNlIHZlcnRpY2VzIGFnYWluc3QgYWxsIHBvaW50cyBtYXBcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSB0cmlhbmdsZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlID0gdHJpYW5nbGVzWyBpIF07XHJcblxyXG5cdFx0XHRmb3IgKCBmID0gMDsgZiA8IDM7IGYgKysgKSB7XHJcblxyXG5cdFx0XHRcdGtleSA9IGZhY2VbIGYgXS54ICsgXCI6XCIgKyBmYWNlWyBmIF0ueTtcclxuXHJcblx0XHRcdFx0aW5kZXggPSBhbGxQb2ludHNNYXBbIGtleSBdO1xyXG5cclxuXHRcdFx0XHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmFjZVsgZiBdID0gaW5kZXg7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gY2hlY2sgaXNvbGF0ZWQgcG9pbnRzIHZlcnRpY2VzIGFnYWluc3QgYWxsIHBvaW50cyBtYXBcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBpc29sYXRlZFB0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRcdGZhY2UgPSBpc29sYXRlZFB0c1sgaSBdO1xyXG5cclxuXHRcdFx0Zm9yICggZiA9IDA7IGYgPCAzOyBmICsrICkge1xyXG5cclxuXHRcdFx0XHRrZXkgPSBmYWNlWyBmIF0ueCArIFwiOlwiICsgZmFjZVsgZiBdLnk7XHJcblxyXG5cdFx0XHRcdGluZGV4ID0gYWxsUG9pbnRzTWFwWyBrZXkgXTtcclxuXHJcblx0XHRcdFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdGZhY2VbIGYgXSA9IGluZGV4O1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cmlhbmdsZXMuY29uY2F0KCBpc29sYXRlZFB0cyApO1xyXG5cclxuXHR9LCAvLyBlbmQgdHJpYW5ndWxhdGUgc2hhcGVzXHJcblxyXG5cdC8qXHJcblx0dHJpYW5ndWxhdGUyIDogZnVuY3Rpb24oIHB0cywgaG9sZXMgKSB7XHJcblxyXG5cdFx0Ly8gRm9yIHVzZSB3aXRoIFBvbHkyVHJpLmpzXHJcblxyXG5cdFx0dmFyIGFsbHB0cyA9IHB0cy5jb25jYXQoKTtcclxuXHRcdHZhciBzaGFwZSA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgcCBpbiBwdHMpIHtcclxuXHRcdFx0c2hhcGUucHVzaChuZXcganMucG9seTJ0cmkuUG9pbnQocHRzW3BdLngsIHB0c1twXS55KSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN3Y3R4ID0gbmV3IGpzLnBvbHkydHJpLlN3ZWVwQ29udGV4dChzaGFwZSk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaCBpbiBob2xlcykge1xyXG5cdFx0XHR2YXIgYUhvbGUgPSBob2xlc1toXTtcclxuXHRcdFx0dmFyIG5ld0hvbGUgPSBbXVxyXG5cdFx0XHRmb3IgKGkgaW4gYUhvbGUpIHtcclxuXHRcdFx0XHRuZXdIb2xlLnB1c2gobmV3IGpzLnBvbHkydHJpLlBvaW50KGFIb2xlW2ldLngsIGFIb2xlW2ldLnkpKTtcclxuXHRcdFx0XHRhbGxwdHMucHVzaChhSG9sZVtpXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3djdHguQWRkSG9sZShuZXdIb2xlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmluZDtcclxuXHRcdHZhciBmaW5kSW5kZXhGb3JQdCA9IGZ1bmN0aW9uIChwdCkge1xyXG5cdFx0XHRmaW5kID0gbmV3IFRIUkVFLlZlY3RvcjIocHQueCwgcHQueSk7XHJcblx0XHRcdHZhciBwO1xyXG5cdFx0XHRmb3IgKHA9MCwgcGwgPSBhbGxwdHMubGVuZ3RoOyBwPHBsOyBwKyspIHtcclxuXHRcdFx0XHRpZiAoYWxscHRzW3BdLmVxdWFscyhmaW5kKSkgcmV0dXJuIHA7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fTtcclxuXHJcblx0XHQvLyB0cmlhbmd1bGF0ZVxyXG5cdFx0anMucG9seTJ0cmkuc3dlZXAuVHJpYW5ndWxhdGUoc3djdHgpO1xyXG5cclxuXHRcdHZhciB0cmlhbmdsZXMgPSAgc3djdHguR2V0VHJpYW5nbGVzKCk7XHJcblx0XHR2YXIgdHIgO1xyXG5cdFx0dmFyIGZhY2VzUHRzID0gW107XHJcblx0XHRmb3IgKHZhciB0IGluIHRyaWFuZ2xlcykge1xyXG5cdFx0XHR0ciA9ICB0cmlhbmdsZXNbdF07XHJcblx0XHRcdGZhY2VzUHRzLnB1c2goW1xyXG5cdFx0XHRcdGZpbmRJbmRleEZvclB0KHRyLkdldFBvaW50KDApKSxcclxuXHRcdFx0XHRmaW5kSW5kZXhGb3JQdCh0ci5HZXRQb2ludCgxKSksXHJcblx0XHRcdFx0ZmluZEluZGV4Rm9yUHQodHIuR2V0UG9pbnQoMikpXHJcblx0XHRcdFx0XHRdKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdC8vXHRjb25zb2xlLmxvZyhmYWNlc1B0cyk7XHJcblx0Ly9cdGNvbnNvbGUubG9nKFwidHJpYW5nbGVzXCIsIHRyaWFuZ2xlcy5sZW5ndGgsIHRyaWFuZ2xlcyk7XHJcblxyXG5cdFx0Ly8gUmV0dXJucyBhcnJheSBvZiBmYWNlcyB3aXRoIDMgZWxlbWVudCBlYWNoXHJcblx0cmV0dXJuIGZhY2VzUHRzO1xyXG5cdH0sXHJcbiovXHJcblxyXG5cdGlzQ2xvY2tXaXNlOiBmdW5jdGlvbiAoIHB0cyApIHtcclxuXHJcblx0XHRyZXR1cm4gVEhSRUUuRm9udFV0aWxzLlRyaWFuZ3VsYXRlLmFyZWEoIHB0cyApIDwgMDtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXHJcblx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9jdXJ2ZVxyXG5cclxuXHQvLyBRdWFkIEJlemllciBGdW5jdGlvbnNcclxuXHJcblx0YjJwMDogZnVuY3Rpb24gKCB0LCBwICkge1xyXG5cclxuXHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRyZXR1cm4gayAqIGsgKiBwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRiMnAxOiBmdW5jdGlvbiAoIHQsIHAgKSB7XHJcblxyXG5cdFx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiB0ICogcDtcclxuXHJcblx0fSxcclxuXHJcblx0YjJwMjogZnVuY3Rpb24gKCB0LCBwICkge1xyXG5cclxuXHRcdHJldHVybiB0ICogdCAqIHA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGIyOiBmdW5jdGlvbiAoIHQsIHAwLCBwMSwgcDIgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYjJwMCggdCwgcDAgKSArIHRoaXMuYjJwMSggdCwgcDEgKSArIHRoaXMuYjJwMiggdCwgcDIgKTtcclxuXHJcblx0fSxcclxuXHJcblx0Ly8gQ3ViaWMgQmV6aWVyIEZ1bmN0aW9uc1xyXG5cclxuXHRiM3AwOiBmdW5jdGlvbiAoIHQsIHAgKSB7XHJcblxyXG5cdFx0dmFyIGsgPSAxIC0gdDtcclxuXHRcdHJldHVybiBrICogayAqIGsgKiBwO1xyXG5cclxuXHR9LFxyXG5cclxuXHRiM3AxOiBmdW5jdGlvbiAoIHQsIHAgKSB7XHJcblxyXG5cdFx0dmFyIGsgPSAxIC0gdDtcclxuXHRcdHJldHVybiAzICogayAqIGsgKiB0ICogcDtcclxuXHJcblx0fSxcclxuXHJcblx0YjNwMjogZnVuY3Rpb24gKCB0LCBwICkge1xyXG5cclxuXHRcdHZhciBrID0gMSAtIHQ7XHJcblx0XHRyZXR1cm4gMyAqIGsgKiB0ICogdCAqIHA7XHJcblxyXG5cdH0sXHJcblxyXG5cdGIzcDM6IGZ1bmN0aW9uICggdCwgcCApIHtcclxuXHJcblx0XHRyZXR1cm4gdCAqIHQgKiB0ICogcDtcclxuXHJcblx0fSxcclxuXHJcblx0YjM6IGZ1bmN0aW9uICggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuYjNwMCggdCwgcDAgKSArIHRoaXMuYjNwMSggdCwgcDEgKSArIHRoaXMuYjNwMiggdCwgcDIgKSArICB0aGlzLmIzcDMoIHQsIHAzICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICovXHJcblxyXG5USFJFRS5BbmltYXRpb25IYW5kbGVyID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuXHR2YXIgcGxheWluZyA9IFtdO1xyXG5cdHZhciBsaWJyYXJ5ID0ge307XHJcblx0dmFyIHRoYXQgICAgPSB7fTtcclxuXHJcblxyXG5cdC8vLS0tIHVwZGF0ZSAtLS1cclxuXHJcblx0dGhhdC51cGRhdGUgPSBmdW5jdGlvbiggZGVsdGFUaW1lTVMgKSB7XHJcblxyXG5cdFx0Zm9yKCB2YXIgaSA9IDA7IGkgPCBwbGF5aW5nLmxlbmd0aDsgaSArKyApXHJcblx0XHRcdHBsYXlpbmdbIGkgXS51cGRhdGUoIGRlbHRhVGltZU1TICk7XHJcblxyXG5cdH07XHJcblxyXG5cclxuXHQvLy0tLSBhZGQgLS0tXHJcblxyXG5cdHRoYXQuYWRkVG9VcGRhdGUgPSBmdW5jdGlvbiggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGlmICggcGxheWluZy5pbmRleE9mKCBhbmltYXRpb24gKSA9PT0gLTEgKVxyXG5cdFx0XHRwbGF5aW5nLnB1c2goIGFuaW1hdGlvbiApO1xyXG5cclxuXHR9O1xyXG5cclxuXHJcblx0Ly8tLS0gcmVtb3ZlIC0tLVxyXG5cclxuXHR0aGF0LnJlbW92ZUZyb21VcGRhdGUgPSBmdW5jdGlvbiggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdHZhciBpbmRleCA9IHBsYXlpbmcuaW5kZXhPZiggYW5pbWF0aW9uICk7XHJcblxyXG5cdFx0aWYoIGluZGV4ICE9PSAtMSApXHJcblx0XHRcdHBsYXlpbmcuc3BsaWNlKCBpbmRleCwgMSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHJcblx0Ly8tLS0gYWRkIC0tLVxyXG5cclxuXHR0aGF0LmFkZCA9IGZ1bmN0aW9uKCBkYXRhICkge1xyXG5cclxuXHRcdGlmICggbGlicmFyeVsgZGF0YS5uYW1lIF0gIT09IHVuZGVmaW5lZCApXHJcblx0XHRcdGNvbnNvbGUubG9nKCBcIlRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkOiBXYXJuaW5nISBcIiArIGRhdGEubmFtZSArIFwiIGFscmVhZHkgZXhpc3RzIGluIGxpYnJhcnkuIE92ZXJ3cml0aW5nLlwiICk7XHJcblxyXG5cdFx0bGlicmFyeVsgZGF0YS5uYW1lIF0gPSBkYXRhO1xyXG5cdFx0aW5pdERhdGEoIGRhdGEgKTtcclxuXHJcblx0fTtcclxuXHJcblxyXG5cdC8vLS0tIGdldCAtLS1cclxuXHJcblx0dGhhdC5nZXQgPSBmdW5jdGlvbiggbmFtZSApIHtcclxuXHJcblx0XHRpZiAoIHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiICkge1xyXG5cclxuXHRcdFx0aWYgKCBsaWJyYXJ5WyBuYW1lIF0gKSB7XHJcblxyXG5cdFx0XHRcdHJldHVybiBsaWJyYXJ5WyBuYW1lIF07XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmxvZyggXCJUSFJFRS5BbmltYXRpb25IYW5kbGVyLmdldDogQ291bGRuJ3QgZmluZCBhbmltYXRpb24gXCIgKyBuYW1lICk7XHJcblx0XHRcdFx0cmV0dXJuIG51bGw7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIHRvZG86IGFkZCBzaW1wbGUgdHdlZW4gbGlicmFyeVxyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcblx0Ly8tLS0gcGFyc2UgLS0tXHJcblxyXG5cdHRoYXQucGFyc2UgPSBmdW5jdGlvbiggcm9vdCApIHtcclxuXHJcblx0XHQvLyBzZXR1cCBoaWVyYXJjaHlcclxuXHJcblx0XHR2YXIgaGllcmFyY2h5ID0gW107XHJcblxyXG5cdFx0aWYgKCByb290IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggKSB7XHJcblxyXG5cdFx0XHRmb3IoIHZhciBiID0gMDsgYiA8IHJvb3QuYm9uZXMubGVuZ3RoOyBiKysgKSB7XHJcblxyXG5cdFx0XHRcdGhpZXJhcmNoeS5wdXNoKCByb290LmJvbmVzWyBiIF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cGFyc2VSZWN1cnNlSGllcmFyY2h5KCByb290LCBoaWVyYXJjaHkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGhpZXJhcmNoeTtcclxuXHJcblx0fTtcclxuXHJcblx0dmFyIHBhcnNlUmVjdXJzZUhpZXJhcmNoeSA9IGZ1bmN0aW9uKCByb290LCBoaWVyYXJjaHkgKSB7XHJcblxyXG5cdFx0aGllcmFyY2h5LnB1c2goIHJvb3QgKTtcclxuXHJcblx0XHRmb3IoIHZhciBjID0gMDsgYyA8IHJvb3QuY2hpbGRyZW4ubGVuZ3RoOyBjKysgKVxyXG5cdFx0XHRwYXJzZVJlY3Vyc2VIaWVyYXJjaHkoIHJvb3QuY2hpbGRyZW5bIGMgXSwgaGllcmFyY2h5ICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vLS0tIGluaXQgZGF0YSAtLS1cclxuXHJcblx0dmFyIGluaXREYXRhID0gZnVuY3Rpb24oIGRhdGEgKSB7XHJcblxyXG5cdFx0aWYoIGRhdGEuaW5pdGlhbGl6ZWQgPT09IHRydWUgKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cclxuXHRcdC8vIGxvb3AgdGhyb3VnaCBhbGwga2V5c1xyXG5cclxuXHRcdGZvciggdmFyIGggPSAwOyBoIDwgZGF0YS5oaWVyYXJjaHkubGVuZ3RoOyBoICsrICkge1xyXG5cclxuXHRcdFx0Zm9yKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHQvLyByZW1vdmUgbWludXMgdGltZXNcclxuXHJcblx0XHRcdFx0aWYoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPCAwIClcclxuXHRcdFx0XHRcdGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPSAwO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gY3JlYXRlIHF1YXRlcm5pb25zXHJcblxyXG5cdFx0XHRcdGlmKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgIT09IHVuZGVmaW5lZCAmJlxyXG5cdFx0XHRcdCAhKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgaW5zdGFuY2VvZiBUSFJFRS5RdWF0ZXJuaW9uICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHF1YXQgPSBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3Q7XHJcblx0XHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5yb3QgPSBuZXcgVEhSRUUuUXVhdGVybmlvbiggcXVhdFswXSwgcXVhdFsxXSwgcXVhdFsyXSwgcXVhdFszXSApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cclxuXHRcdFx0Ly8gcHJlcGFyZSBtb3JwaCB0YXJnZXQga2V5c1xyXG5cclxuXHRcdFx0aWYoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGggJiYgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF0ubW9ycGhUYXJnZXRzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdC8vIGdldCBhbGwgdXNlZFxyXG5cclxuXHRcdFx0XHR2YXIgdXNlZE1vcnBoVGFyZ2V0cyA9IHt9O1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBtID0gMDsgbSA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IG0gKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgbW9ycGhUYXJnZXROYW1lID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzWyBtIF07XHJcblx0XHRcdFx0XHRcdHVzZWRNb3JwaFRhcmdldHNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gLTE7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRhdGEuaGllcmFyY2h5WyBoIF0udXNlZE1vcnBoVGFyZ2V0cyA9IHVzZWRNb3JwaFRhcmdldHM7XHJcblxyXG5cclxuXHRcdFx0XHQvLyBzZXQgYWxsIHVzZWQgb24gYWxsIGZyYW1lc1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgayA9IDA7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBpbmZsdWVuY2VzID0ge307XHJcblxyXG5cdFx0XHRcdFx0Zm9yICggdmFyIG1vcnBoVGFyZ2V0TmFtZSBpbiB1c2VkTW9ycGhUYXJnZXRzICkge1xyXG5cclxuXHRcdFx0XHRcdFx0Zm9yICggdmFyIG0gPSAwOyBtIDwgZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aDsgbSArKyApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aWYgKCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNbIG0gXSA9PT0gbW9ycGhUYXJnZXROYW1lICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGluZmx1ZW5jZXNbIG1vcnBoVGFyZ2V0TmFtZSBdID0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzSW5mbHVlbmNlc1sgbSBdO1xyXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRcdGlmICggbSA9PT0gZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyBrIF0ubW9ycGhUYXJnZXRzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0aW5mbHVlbmNlc1sgbW9ycGhUYXJnZXROYW1lIF0gPSAwO1xyXG5cclxuXHRcdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHRkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIGsgXS5tb3JwaFRhcmdldHNJbmZsdWVuY2VzID0gaW5mbHVlbmNlcztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdC8vIHJlbW92ZSBhbGwga2V5cyB0aGF0IGFyZSBvbiB0aGUgc2FtZSB0aW1lXHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgayA9IDE7IGsgPCBkYXRhLmhpZXJhcmNoeVsgaCBdLmtleXMubGVuZ3RoOyBrICsrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLnRpbWUgPT09IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayAtIDEgXS50aW1lICkge1xyXG5cclxuXHRcdFx0XHRcdGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5zcGxpY2UoIGssIDEgKTtcclxuXHRcdFx0XHRcdGsgLS07XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblxyXG5cdFx0XHQvLyBzZXQgaW5kZXhcclxuXHJcblx0XHRcdGZvciAoIHZhciBrID0gMDsgayA8IGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cy5sZW5ndGg7IGsgKysgKSB7XHJcblxyXG5cdFx0XHRcdGRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgayBdLmluZGV4ID0gaztcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIEpJVFxyXG5cclxuXHRcdHZhciBsZW5ndGhJbkZyYW1lcyA9IHBhcnNlSW50KCBkYXRhLmxlbmd0aCAqIGRhdGEuZnBzLCAxMCApO1xyXG5cclxuXHRcdGRhdGEuSklUID0ge307XHJcblx0XHRkYXRhLkpJVC5oaWVyYXJjaHkgPSBbXTtcclxuXHJcblx0XHRmb3IoIHZhciBoID0gMDsgaCA8IGRhdGEuaGllcmFyY2h5Lmxlbmd0aDsgaCArKyApXHJcblx0XHRcdGRhdGEuSklULmhpZXJhcmNoeS5wdXNoKCBuZXcgQXJyYXkoIGxlbmd0aEluRnJhbWVzICkgKTtcclxuXHJcblxyXG5cdFx0Ly8gZG9uZVxyXG5cclxuXHRcdGRhdGEuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuXHR9O1xyXG5cclxuXHJcblx0Ly8gaW50ZXJwb2xhdGlvbiB0eXBlc1xyXG5cclxuXHR0aGF0LkxJTkVBUiA9IDA7XHJcblx0dGhhdC5DQVRNVUxMUk9NID0gMTtcclxuXHR0aGF0LkNBVE1VTExST01fRk9SV0FSRCA9IDI7XHJcblxyXG5cdHJldHVybiB0aGF0O1xyXG5cclxufSgpKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uID0gZnVuY3Rpb24gKCByb290LCBuYW1lLCBpbnRlcnBvbGF0aW9uVHlwZSApIHtcclxuXHJcblx0dGhpcy5yb290ID0gcm9vdDtcclxuXHR0aGlzLmRhdGEgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLmdldCggbmFtZSApO1xyXG5cdHRoaXMuaGllcmFyY2h5ID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wYXJzZSggcm9vdCApO1xyXG5cclxuXHR0aGlzLmN1cnJlbnRUaW1lID0gMDtcclxuXHR0aGlzLnRpbWVTY2FsZSA9IDE7XHJcblxyXG5cdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XHJcblx0dGhpcy5pc1BhdXNlZCA9IHRydWU7XHJcblx0dGhpcy5sb29wID0gdHJ1ZTtcclxuXHJcblx0dGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9IGludGVycG9sYXRpb25UeXBlICE9PSB1bmRlZmluZWQgPyBpbnRlcnBvbGF0aW9uVHlwZSA6IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuTElORUFSO1xyXG5cclxuXHR0aGlzLnBvaW50cyA9IFtdO1xyXG5cdHRoaXMudGFyZ2V0ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAoIGxvb3AsIHN0YXJ0VGltZU1TICkge1xyXG5cclxuXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSBmYWxzZSApIHtcclxuXHJcblx0XHR0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcblx0XHR0aGlzLmxvb3AgPSBsb29wICE9PSB1bmRlZmluZWQgPyBsb29wIDogdHJ1ZTtcclxuXHRcdHRoaXMuY3VycmVudFRpbWUgPSBzdGFydFRpbWVNUyAhPT0gdW5kZWZpbmVkID8gc3RhcnRUaW1lTVMgOiAwO1xyXG5cclxuXHRcdC8vIHJlc2V0IGtleSBjYWNoZVxyXG5cclxuXHRcdHZhciBoLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aCxcclxuXHRcdFx0b2JqZWN0O1xyXG5cclxuXHRcdGZvciAoIGggPSAwOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xyXG5cclxuXHRcdFx0aWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlICE9PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LnVzZVF1YXRlcm5pb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0b2JqZWN0Lm1hdHJpeEF1dG9VcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBvYmplY3QuYW5pbWF0aW9uQ2FjaGUgPT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlID0ge307XHJcblx0XHRcdFx0b2JqZWN0LmFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSB7IHBvczogMCwgcm90OiAwLCBzY2w6IDAgfTtcclxuXHRcdFx0XHRvYmplY3QuYW5pbWF0aW9uQ2FjaGUubmV4dEtleSA9IHsgcG9zOiAwLCByb3Q6IDAsIHNjbDogMCB9O1xyXG5cdFx0XHRcdG9iamVjdC5hbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeCA9IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgPyBvYmplY3Quc2tpbk1hdHJpeCA6IG9iamVjdC5tYXRyaXg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgcHJldktleSA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5wcmV2S2V5O1xyXG5cdFx0XHR2YXIgbmV4dEtleSA9IG9iamVjdC5hbmltYXRpb25DYWNoZS5uZXh0S2V5O1xyXG5cclxuXHRcdFx0cHJldktleS5wb3MgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sgMCBdO1xyXG5cdFx0XHRwcmV2S2V5LnJvdCA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzWyAwIF07XHJcblx0XHRcdHByZXZLZXkuc2NsID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcclxuXHJcblx0XHRcdG5leHRLZXkucG9zID0gdGhpcy5nZXROZXh0S2V5V2l0aCggXCJwb3NcIiwgaCwgMSApO1xyXG5cdFx0XHRuZXh0S2V5LnJvdCA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIFwicm90XCIsIGgsIDEgKTtcclxuXHRcdFx0bmV4dEtleS5zY2wgPSB0aGlzLmdldE5leHRLZXlXaXRoKCBcInNjbFwiLCBoLCAxICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMudXBkYXRlKCAwICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG5cclxuXHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLmFkZFRvVXBkYXRlKCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0aWYgKCB0aGlzLmlzUGF1c2VkID09PSB0cnVlICkge1xyXG5cclxuXHRcdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkVG9VcGRhdGUoIHRoaXMgKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRUSFJFRS5BbmltYXRpb25IYW5kbGVyLnJlbW92ZUZyb21VcGRhdGUoIHRoaXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmlzUGF1c2VkID0gIXRoaXMuaXNQYXVzZWQ7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xyXG5cdHRoaXMuaXNQYXVzZWQgID0gZmFsc2U7XHJcblx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5yZW1vdmVGcm9tVXBkYXRlKCB0aGlzICk7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBkZWx0YVRpbWVNUyApIHtcclxuXHJcblx0Ly8gZWFybHkgb3V0XHJcblxyXG5cdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IGZhbHNlICkgcmV0dXJuO1xyXG5cclxuXHJcblx0Ly8gdmFyc1xyXG5cclxuXHR2YXIgdHlwZXMgPSBbIFwicG9zXCIsIFwicm90XCIsIFwic2NsXCIgXTtcclxuXHR2YXIgdHlwZTtcclxuXHR2YXIgc2NhbGU7XHJcblx0dmFyIHZlY3RvcjtcclxuXHR2YXIgcHJldlhZWiwgbmV4dFhZWjtcclxuXHR2YXIgcHJldktleSwgbmV4dEtleTtcclxuXHR2YXIgb2JqZWN0O1xyXG5cdHZhciBhbmltYXRpb25DYWNoZTtcclxuXHR2YXIgZnJhbWU7XHJcblx0dmFyIEpJVGhpZXJhcmNoeSA9IHRoaXMuZGF0YS5KSVQuaGllcmFyY2h5O1xyXG5cdHZhciBjdXJyZW50VGltZSwgdW5sb29wZWRDdXJyZW50VGltZTtcclxuXHR2YXIgY3VycmVudFBvaW50LCBmb3J3YXJkUG9pbnQsIGFuZ2xlO1xyXG5cclxuXHJcblx0dGhpcy5jdXJyZW50VGltZSArPSBkZWx0YVRpbWVNUyAqIHRoaXMudGltZVNjYWxlO1xyXG5cclxuXHR1bmxvb3BlZEN1cnJlbnRUaW1lID0gdGhpcy5jdXJyZW50VGltZTtcclxuXHRjdXJyZW50VGltZSA9IHRoaXMuY3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lICUgdGhpcy5kYXRhLmxlbmd0aDtcclxuXHRmcmFtZSA9IHBhcnNlSW50KCBNYXRoLm1pbiggY3VycmVudFRpbWUgKiB0aGlzLmRhdGEuZnBzLCB0aGlzLmRhdGEubGVuZ3RoICogdGhpcy5kYXRhLmZwcyApLCAxMCApO1xyXG5cclxuXHJcblx0Zm9yICggdmFyIGggPSAwLCBobCA9IHRoaXMuaGllcmFyY2h5Lmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdG9iamVjdCA9IHRoaXMuaGllcmFyY2h5WyBoIF07XHJcblx0XHRhbmltYXRpb25DYWNoZSA9IG9iamVjdC5hbmltYXRpb25DYWNoZTtcclxuXHJcblx0XHQvLyBsb29wIHRocm91Z2ggcG9zL3JvdC9zY2xcclxuXHJcblx0XHRmb3IgKCB2YXIgdCA9IDA7IHQgPCAzOyB0ICsrICkge1xyXG5cclxuXHRcdFx0Ly8gZ2V0IGtleXNcclxuXHJcblx0XHRcdHR5cGUgICAgPSB0eXBlc1sgdCBdO1xyXG5cdFx0XHRwcmV2S2V5ID0gYW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdO1xyXG5cdFx0XHRuZXh0S2V5ID0gYW5pbWF0aW9uQ2FjaGUubmV4dEtleVsgdHlwZSBdO1xyXG5cclxuXHRcdFx0Ly8gc3dpdGNoIGtleXM/XHJcblxyXG5cdFx0XHRpZiAoIG5leHRLZXkudGltZSA8PSB1bmxvb3BlZEN1cnJlbnRUaW1lICkge1xyXG5cclxuXHRcdFx0XHQvLyBkaWQgd2UgbG9vcD9cclxuXHJcblx0XHRcdFx0aWYgKCBjdXJyZW50VGltZSA8IHVubG9vcGVkQ3VycmVudFRpbWUgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmxvb3AgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRwcmV2S2V5ID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcclxuXHRcdFx0XHRcdFx0bmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIDEgKTtcclxuXHJcblx0XHRcdFx0XHRcdHdoaWxlKCBuZXh0S2V5LnRpbWUgPCBjdXJyZW50VGltZSApIHtcclxuXHJcblx0XHRcdFx0XHRcdFx0cHJldktleSA9IG5leHRLZXk7XHJcblx0XHRcdFx0XHRcdFx0bmV4dEtleSA9IHRoaXMuZ2V0TmV4dEtleVdpdGgoIHR5cGUsIGgsIG5leHRLZXkuaW5kZXggKyAxICk7XHJcblxyXG5cdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdHRoaXMuc3RvcCgpO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGRvIHtcclxuXHJcblx0XHRcdFx0XHRcdHByZXZLZXkgPSBuZXh0S2V5O1xyXG5cdFx0XHRcdFx0XHRuZXh0S2V5ID0gdGhpcy5nZXROZXh0S2V5V2l0aCggdHlwZSwgaCwgbmV4dEtleS5pbmRleCArIDEgKTtcclxuXHJcblx0XHRcdFx0XHR9IHdoaWxlKCBuZXh0S2V5LnRpbWUgPCBjdXJyZW50VGltZSApXHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0YW5pbWF0aW9uQ2FjaGUucHJldktleVsgdHlwZSBdID0gcHJldktleTtcclxuXHRcdFx0XHRhbmltYXRpb25DYWNoZS5uZXh0S2V5WyB0eXBlIF0gPSBuZXh0S2V5O1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHJcblx0XHRcdG9iamVjdC5tYXRyaXhBdXRvVXBkYXRlID0gdHJ1ZTtcclxuXHRcdFx0b2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0c2NhbGUgPSAoIGN1cnJlbnRUaW1lIC0gcHJldktleS50aW1lICkgLyAoIG5leHRLZXkudGltZSAtIHByZXZLZXkudGltZSApO1xyXG5cdFx0XHRwcmV2WFlaID0gcHJldktleVsgdHlwZSBdO1xyXG5cdFx0XHRuZXh0WFlaID0gbmV4dEtleVsgdHlwZSBdO1xyXG5cclxuXHJcblx0XHRcdC8vIGNoZWNrIHNjYWxlIGVycm9yXHJcblxyXG5cdFx0XHRpZiAoIHNjYWxlIDwgMCB8fCBzY2FsZSA+IDEgKSB7XHJcblxyXG5cdFx0XHRcdGNvbnNvbGUubG9nKCBcIlRIUkVFLkFuaW1hdGlvbi51cGRhdGU6IFdhcm5pbmchIFNjYWxlIG91dCBvZiBib3VuZHM6XCIgKyBzY2FsZSArIFwiIG9uIGJvbmUgXCIgKyBoICk7XHJcblx0XHRcdFx0c2NhbGUgPSBzY2FsZSA8IDAgPyAwIDogMTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGludGVycG9sYXRlXHJcblxyXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwicG9zXCIgKSB7XHJcblxyXG5cdFx0XHRcdHZlY3RvciA9IG9iamVjdC5wb3NpdGlvbjtcclxuXHJcblx0XHRcdFx0aWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkxJTkVBUiApIHtcclxuXHJcblx0XHRcdFx0XHR2ZWN0b3IueCA9IHByZXZYWVpbIDAgXSArICggbmV4dFhZWlsgMCBdIC0gcHJldlhZWlsgMCBdICkgKiBzY2FsZTtcclxuXHRcdFx0XHRcdHZlY3Rvci55ID0gcHJldlhZWlsgMSBdICsgKCBuZXh0WFlaWyAxIF0gLSBwcmV2WFlaWyAxIF0gKSAqIHNjYWxlO1xyXG5cdFx0XHRcdFx0dmVjdG9yLnogPSBwcmV2WFlaWyAyIF0gKyAoIG5leHRYWVpbIDIgXSAtIHByZXZYWVpbIDIgXSApICogc2NhbGU7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMuaW50ZXJwb2xhdGlvblR5cGUgPT09IFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuQ0FUTVVMTFJPTSB8fFxyXG5cdFx0XHRcdFx0XHQgICAgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XHJcblxyXG5cdFx0XHRcdFx0dGhpcy5wb2ludHNbIDAgXSA9IHRoaXMuZ2V0UHJldktleVdpdGgoIFwicG9zXCIsIGgsIHByZXZLZXkuaW5kZXggLSAxIClbIFwicG9zXCIgXTtcclxuXHRcdFx0XHRcdHRoaXMucG9pbnRzWyAxIF0gPSBwcmV2WFlaO1xyXG5cdFx0XHRcdFx0dGhpcy5wb2ludHNbIDIgXSA9IG5leHRYWVo7XHJcblx0XHRcdFx0XHR0aGlzLnBvaW50c1sgMyBdID0gdGhpcy5nZXROZXh0S2V5V2l0aCggXCJwb3NcIiwgaCwgbmV4dEtleS5pbmRleCArIDEgKVsgXCJwb3NcIiBdO1xyXG5cclxuXHRcdFx0XHRcdHNjYWxlID0gc2NhbGUgKiAwLjMzICsgMC4zMztcclxuXHJcblx0XHRcdFx0XHRjdXJyZW50UG9pbnQgPSB0aGlzLmludGVycG9sYXRlQ2F0bXVsbFJvbSggdGhpcy5wb2ludHMsIHNjYWxlICk7XHJcblxyXG5cdFx0XHRcdFx0dmVjdG9yLnggPSBjdXJyZW50UG9pbnRbIDAgXTtcclxuXHRcdFx0XHRcdHZlY3Rvci55ID0gY3VycmVudFBvaW50WyAxIF07XHJcblx0XHRcdFx0XHR2ZWN0b3IueiA9IGN1cnJlbnRQb2ludFsgMiBdO1xyXG5cclxuXHRcdFx0XHRcdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRmb3J3YXJkUG9pbnQgPSB0aGlzLmludGVycG9sYXRlQ2F0bXVsbFJvbSggdGhpcy5wb2ludHMsIHNjYWxlICogMS4wMSApO1xyXG5cclxuXHRcdFx0XHRcdFx0dGhpcy50YXJnZXQuc2V0KCBmb3J3YXJkUG9pbnRbIDAgXSwgZm9yd2FyZFBvaW50WyAxIF0sIGZvcndhcmRQb2ludFsgMiBdICk7XHJcblx0XHRcdFx0XHRcdHRoaXMudGFyZ2V0LnN1YiggdmVjdG9yICk7XHJcblx0XHRcdFx0XHRcdHRoaXMudGFyZ2V0LnkgPSAwO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnRhcmdldC5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdFx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMiggdGhpcy50YXJnZXQueCwgdGhpcy50YXJnZXQueiApO1xyXG5cdFx0XHRcdFx0XHRvYmplY3Qucm90YXRpb24uc2V0KCAwLCBhbmdsZSwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJyb3RcIiApIHtcclxuXHJcblx0XHRcdFx0VEhSRUUuUXVhdGVybmlvbi5zbGVycCggcHJldlhZWiwgbmV4dFhZWiwgb2JqZWN0LnF1YXRlcm5pb24sIHNjYWxlICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSBcInNjbFwiICkge1xyXG5cclxuXHRcdFx0XHR2ZWN0b3IgPSBvYmplY3Quc2NhbGU7XHJcblxyXG5cdFx0XHRcdHZlY3Rvci54ID0gcHJldlhZWlsgMCBdICsgKCBuZXh0WFlaWyAwIF0gLSBwcmV2WFlaWyAwIF0gKSAqIHNjYWxlO1xyXG5cdFx0XHRcdHZlY3Rvci55ID0gcHJldlhZWlsgMSBdICsgKCBuZXh0WFlaWyAxIF0gLSBwcmV2WFlaWyAxIF0gKSAqIHNjYWxlO1xyXG5cdFx0XHRcdHZlY3Rvci56ID0gcHJldlhZWlsgMiBdICsgKCBuZXh0WFlaWyAyIF0gLSBwcmV2WFlaWyAyIF0gKSAqIHNjYWxlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcbi8vIENhdG11bGwtUm9tIHNwbGluZVxyXG5cclxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5pbnRlcnBvbGF0ZUNhdG11bGxSb20gPSBmdW5jdGlvbiAoIHBvaW50cywgc2NhbGUgKSB7XHJcblxyXG5cdHZhciBjID0gW10sIHYzID0gW10sXHJcblx0cG9pbnQsIGludFBvaW50LCB3ZWlnaHQsIHcyLCB3MyxcclxuXHRwYSwgcGIsIHBjLCBwZDtcclxuXHJcblx0cG9pbnQgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiBzY2FsZTtcclxuXHRpbnRQb2ludCA9IE1hdGguZmxvb3IoIHBvaW50ICk7XHJcblx0d2VpZ2h0ID0gcG9pbnQgLSBpbnRQb2ludDtcclxuXHJcblx0Y1sgMCBdID0gaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMTtcclxuXHRjWyAxIF0gPSBpbnRQb2ludDtcclxuXHRjWyAyIF0gPSBpbnRQb2ludCA+IHBvaW50cy5sZW5ndGggLSAyID8gaW50UG9pbnQgOiBpbnRQb2ludCArIDE7XHJcblx0Y1sgMyBdID0gaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IGludFBvaW50IDogaW50UG9pbnQgKyAyO1xyXG5cclxuXHRwYSA9IHBvaW50c1sgY1sgMCBdIF07XHJcblx0cGIgPSBwb2ludHNbIGNbIDEgXSBdO1xyXG5cdHBjID0gcG9pbnRzWyBjWyAyIF0gXTtcclxuXHRwZCA9IHBvaW50c1sgY1sgMyBdIF07XHJcblxyXG5cdHcyID0gd2VpZ2h0ICogd2VpZ2h0O1xyXG5cdHczID0gd2VpZ2h0ICogdzI7XHJcblxyXG5cdHYzWyAwIF0gPSB0aGlzLmludGVycG9sYXRlKCBwYVsgMCBdLCBwYlsgMCBdLCBwY1sgMCBdLCBwZFsgMCBdLCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cdHYzWyAxIF0gPSB0aGlzLmludGVycG9sYXRlKCBwYVsgMSBdLCBwYlsgMSBdLCBwY1sgMSBdLCBwZFsgMSBdLCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cdHYzWyAyIF0gPSB0aGlzLmludGVycG9sYXRlKCBwYVsgMiBdLCBwYlsgMiBdLCBwY1sgMiBdLCBwZFsgMiBdLCB3ZWlnaHQsIHcyLCB3MyApO1xyXG5cclxuXHRyZXR1cm4gdjM7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQW5pbWF0aW9uLnByb3RvdHlwZS5pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uICggcDAsIHAxLCBwMiwgcDMsIHQsIHQyLCB0MyApIHtcclxuXHJcblx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjUsXHJcblx0XHR2MSA9ICggcDMgLSBwMSApICogMC41O1xyXG5cclxuXHRyZXR1cm4gKCAyICogKCBwMSAtIHAyICkgKyB2MCArIHYxICkgKiB0MyArICggLSAzICogKCBwMSAtIHAyICkgLSAyICogdjAgLSB2MSApICogdDIgKyB2MCAqIHQgKyBwMTtcclxuXHJcbn07XHJcblxyXG5cclxuXHJcbi8vIEdldCBuZXh0IGtleSB3aXRoXHJcblxyXG5USFJFRS5BbmltYXRpb24ucHJvdG90eXBlLmdldE5leHRLZXlXaXRoID0gZnVuY3Rpb24gKCB0eXBlLCBoLCBrZXkgKSB7XHJcblxyXG5cdHZhciBrZXlzID0gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXM7XHJcblxyXG5cdGlmICggdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NIHx8XHJcblx0XHQgdGhpcy5pbnRlcnBvbGF0aW9uVHlwZSA9PT0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5DQVRNVUxMUk9NX0ZPUldBUkQgKSB7XHJcblxyXG5cdFx0a2V5ID0ga2V5IDwga2V5cy5sZW5ndGggLSAxID8ga2V5IDoga2V5cy5sZW5ndGggLSAxO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGtleSA9IGtleSAlIGtleXMubGVuZ3RoO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIDsga2V5IDwga2V5cy5sZW5ndGg7IGtleSsrICkge1xyXG5cclxuXHRcdGlmICgga2V5c1sga2V5IF1bIHR5cGUgXSAhPT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGtleXNbIGtleSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcy5kYXRhLmhpZXJhcmNoeVsgaCBdLmtleXNbIDAgXTtcclxuXHJcbn07XHJcblxyXG4vLyBHZXQgcHJldmlvdXMga2V5IHdpdGhcclxuXHJcblRIUkVFLkFuaW1hdGlvbi5wcm90b3R5cGUuZ2V0UHJldktleVdpdGggPSBmdW5jdGlvbiAoIHR5cGUsIGgsIGtleSApIHtcclxuXHJcblx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcclxuXHJcblx0aWYgKCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST00gfHxcclxuXHRcdCB0aGlzLmludGVycG9sYXRpb25UeXBlID09PSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLkNBVE1VTExST01fRk9SV0FSRCApIHtcclxuXHJcblx0XHRrZXkgPSBrZXkgPiAwID8ga2V5IDogMDtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHRrZXkgPSBrZXkgPj0gMCA/IGtleSA6IGtleSArIGtleXMubGVuZ3RoO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHRmb3IgKCA7IGtleSA+PSAwOyBrZXkgLS0gKSB7XHJcblxyXG5cdFx0aWYgKCBrZXlzWyBrZXkgXVsgdHlwZSBdICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRyZXR1cm4ga2V5c1sga2V5IF07XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5c1sga2V5cy5sZW5ndGggLSAxIF07XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICogQGF1dGhvciBraGFuZyBkdW9uZ1xyXG4gKiBAYXV0aG9yIGVyaWsga2l0c29uXHJcbiAqL1xyXG5cclxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24gPSBmdW5jdGlvbiggcm9vdCwgZGF0YSwgSklUQ29tcGlsZSApIHtcclxuXHJcblx0dGhpcy5yb290ID0gcm9vdDtcclxuXHR0aGlzLmRhdGEgPSBUSFJFRS5BbmltYXRpb25IYW5kbGVyLmdldCggZGF0YSApO1xyXG5cdHRoaXMuaGllcmFyY2h5ID0gVEhSRUUuQW5pbWF0aW9uSGFuZGxlci5wYXJzZSggcm9vdCApO1xyXG5cdHRoaXMuY3VycmVudFRpbWUgPSAwO1xyXG5cdHRoaXMudGltZVNjYWxlID0gMC4wMDE7XHJcblx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHR0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcclxuXHR0aGlzLmxvb3AgPSB0cnVlO1xyXG5cdHRoaXMuSklUQ29tcGlsZSA9IEpJVENvbXBpbGUgIT09IHVuZGVmaW5lZCA/IEpJVENvbXBpbGUgOiB0cnVlO1xyXG5cclxuXHQvLyBpbml0aWFsaXplIHRvIGZpcnN0IGtleWZyYW1lc1xyXG5cclxuXHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcclxuXHJcblx0XHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0ua2V5cyxcclxuXHRcdFx0c2lkcyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0uc2lkcyxcclxuXHRcdFx0b2JqID0gdGhpcy5oaWVyYXJjaHlbaF07XHJcblxyXG5cdFx0aWYgKCBrZXlzLmxlbmd0aCAmJiBzaWRzICkge1xyXG5cclxuXHRcdFx0Zm9yICggdmFyIHMgPSAwOyBzIDwgc2lkcy5sZW5ndGg7IHMrKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIHNpZCA9IHNpZHNbIHMgXSxcclxuXHRcdFx0XHRcdG5leHQgPSB0aGlzLmdldE5leHRLZXlXaXRoKCBzaWQsIGgsIDAgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBuZXh0ICkge1xyXG5cclxuXHRcdFx0XHRcdG5leHQuYXBwbHkoIHNpZCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRvYmoubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cdFx0XHR0aGlzLmRhdGEuaGllcmFyY2h5W2hdLm5vZGUudXBkYXRlTWF0cml4KCk7XHJcblx0XHRcdG9iai5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG4vLyBQbGF5XHJcblxyXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uKCBsb29wLCBzdGFydFRpbWVNUyApIHtcclxuXHJcblx0aWYoICF0aGlzLmlzUGxheWluZyApIHtcclxuXHJcblx0XHR0aGlzLmlzUGxheWluZyA9IHRydWU7XHJcblx0XHR0aGlzLmxvb3AgPSBsb29wICE9PSB1bmRlZmluZWQgPyBsb29wIDogdHJ1ZTtcclxuXHRcdHRoaXMuY3VycmVudFRpbWUgPSBzdGFydFRpbWVNUyAhPT0gdW5kZWZpbmVkID8gc3RhcnRUaW1lTVMgOiAwO1xyXG5cdFx0dGhpcy5zdGFydFRpbWVNcyA9IHN0YXJ0VGltZU1TO1xyXG5cdFx0dGhpcy5zdGFydFRpbWUgPSAxMDAwMDAwMDtcclxuXHRcdHRoaXMuZW5kVGltZSA9IC10aGlzLnN0YXJ0VGltZTtcclxuXHJcblxyXG5cdFx0Ly8gcmVzZXQga2V5IGNhY2hlXHJcblxyXG5cdFx0dmFyIGgsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoLFxyXG5cdFx0XHRvYmplY3QsXHJcblx0XHRcdG5vZGU7XHJcblxyXG5cdFx0Zm9yICggaCA9IDA7IGggPCBobDsgaCsrICkge1xyXG5cclxuXHRcdFx0b2JqZWN0ID0gdGhpcy5oaWVyYXJjaHlbIGggXTtcclxuXHRcdFx0bm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcclxuXHRcdFx0b2JqZWN0LnVzZVF1YXRlcm5pb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKCBub2RlLmFuaW1hdGlvbkNhY2hlID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRcdG5vZGUuYW5pbWF0aW9uQ2FjaGUgPSB7fTtcclxuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBudWxsO1xyXG5cdFx0XHRcdG5vZGUuYW5pbWF0aW9uQ2FjaGUubmV4dEtleSA9IG51bGw7XHJcblx0XHRcdFx0bm9kZS5hbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeCA9IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLkJvbmUgPyBvYmplY3Quc2tpbk1hdHJpeCA6IG9iamVjdC5tYXRyaXg7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0ua2V5cztcclxuXHJcblx0XHRcdGlmIChrZXlzLmxlbmd0aCkge1xyXG5cclxuXHRcdFx0XHRub2RlLmFuaW1hdGlvbkNhY2hlLnByZXZLZXkgPSBrZXlzWyAwIF07XHJcblx0XHRcdFx0bm9kZS5hbmltYXRpb25DYWNoZS5uZXh0S2V5ID0ga2V5c1sgMSBdO1xyXG5cclxuXHRcdFx0XHR0aGlzLnN0YXJ0VGltZSA9IE1hdGgubWluKCBrZXlzWzBdLnRpbWUsIHRoaXMuc3RhcnRUaW1lICk7XHJcblx0XHRcdFx0dGhpcy5lbmRUaW1lID0gTWF0aC5tYXgoIGtleXNba2V5cy5sZW5ndGggLSAxXS50aW1lLCB0aGlzLmVuZFRpbWUgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoIDAgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmlzUGF1c2VkID0gZmFsc2U7XHJcblxyXG5cdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIuYWRkVG9VcGRhdGUoIHRoaXMgKTtcclxuXHJcbn07XHJcblxyXG5cclxuXHJcbi8vIFBhdXNlXHJcblxyXG5USFJFRS5LZXlGcmFtZUFuaW1hdGlvbi5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0aWYoIHRoaXMuaXNQYXVzZWQgKSB7XHJcblxyXG5cdFx0VEhSRUUuQW5pbWF0aW9uSGFuZGxlci5hZGRUb1VwZGF0ZSggdGhpcyApO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucmVtb3ZlRnJvbVVwZGF0ZSggdGhpcyApO1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuaXNQYXVzZWQgPSAhdGhpcy5pc1BhdXNlZDtcclxuXHJcbn07XHJcblxyXG5cclxuLy8gU3RvcFxyXG5cclxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlLnN0b3AgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcclxuXHR0aGlzLmlzUGF1c2VkICA9IGZhbHNlO1xyXG5cdFRIUkVFLkFuaW1hdGlvbkhhbmRsZXIucmVtb3ZlRnJvbVVwZGF0ZSggdGhpcyApO1xyXG5cclxuXHJcblx0Ly8gcmVzZXQgSklUIG1hdHJpeCBhbmQgcmVtb3ZlIGNhY2hlXHJcblxyXG5cdGZvciAoIHZhciBoID0gMDsgaCA8IHRoaXMuZGF0YS5oaWVyYXJjaHkubGVuZ3RoOyBoKysgKSB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuaGllcmFyY2h5WyBoIF07XHJcblx0XHR2YXIgbm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcclxuXHJcblx0XHRpZiAoIG5vZGUuYW5pbWF0aW9uQ2FjaGUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdHZhciBvcmlnaW5hbCA9IG5vZGUuYW5pbWF0aW9uQ2FjaGUub3JpZ2luYWxNYXRyaXg7XHJcblxyXG5cdFx0XHRpZiggb2JqIGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcclxuXHJcblx0XHRcdFx0b3JpZ2luYWwuY29weSggb2JqLnNraW5NYXRyaXggKTtcclxuXHRcdFx0XHRvYmouc2tpbk1hdHJpeCA9IG9yaWdpbmFsO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0b3JpZ2luYWwuY29weSggb2JqLm1hdHJpeCApO1xyXG5cdFx0XHRcdG9iai5tYXRyaXggPSBvcmlnaW5hbDtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGRlbGV0ZSBub2RlLmFuaW1hdGlvbkNhY2hlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblxyXG4vLyBVcGRhdGVcclxuXHJcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiggZGVsdGFUaW1lTVMgKSB7XHJcblxyXG5cdC8vIGVhcmx5IG91dFxyXG5cclxuXHRpZiggIXRoaXMuaXNQbGF5aW5nICkgcmV0dXJuO1xyXG5cclxuXHJcblx0Ly8gdmFyc1xyXG5cclxuXHR2YXIgcHJldktleSwgbmV4dEtleTtcclxuXHR2YXIgb2JqZWN0O1xyXG5cdHZhciBub2RlO1xyXG5cdHZhciBmcmFtZTtcclxuXHR2YXIgSklUaGllcmFyY2h5ID0gdGhpcy5kYXRhLkpJVC5oaWVyYXJjaHk7XHJcblx0dmFyIGN1cnJlbnRUaW1lLCB1bmxvb3BlZEN1cnJlbnRUaW1lO1xyXG5cdHZhciBsb29wZWQ7XHJcblxyXG5cclxuXHQvLyB1cGRhdGVcclxuXHJcblx0dGhpcy5jdXJyZW50VGltZSArPSBkZWx0YVRpbWVNUyAqIHRoaXMudGltZVNjYWxlO1xyXG5cclxuXHR1bmxvb3BlZEN1cnJlbnRUaW1lID0gdGhpcy5jdXJyZW50VGltZTtcclxuXHRjdXJyZW50VGltZSAgICAgICAgID0gdGhpcy5jdXJyZW50VGltZSA9IHRoaXMuY3VycmVudFRpbWUgJSB0aGlzLmRhdGEubGVuZ3RoO1xyXG5cclxuXHQvLyBpZiBsb29wZWQgYXJvdW5kLCB0aGUgY3VycmVudCB0aW1lIHNob3VsZCBiZSBiYXNlZCBvbiB0aGUgc3RhcnRUaW1lXHJcblx0aWYgKCBjdXJyZW50VGltZSA8IHRoaXMuc3RhcnRUaW1lTXMgKSB7XHJcblxyXG5cdFx0Y3VycmVudFRpbWUgPSB0aGlzLmN1cnJlbnRUaW1lID0gdGhpcy5zdGFydFRpbWVNcyArIGN1cnJlbnRUaW1lO1xyXG5cclxuXHR9XHJcblxyXG5cdGZyYW1lICAgICAgICAgICAgICAgPSBwYXJzZUludCggTWF0aC5taW4oIGN1cnJlbnRUaW1lICogdGhpcy5kYXRhLmZwcywgdGhpcy5kYXRhLmxlbmd0aCAqIHRoaXMuZGF0YS5mcHMgKSwgMTAgKTtcclxuXHRsb29wZWQgXHRcdFx0XHQ9IGN1cnJlbnRUaW1lIDwgdW5sb29wZWRDdXJyZW50VGltZTtcclxuXHJcblx0aWYgKCBsb29wZWQgJiYgIXRoaXMubG9vcCApIHtcclxuXHJcblx0XHQvLyBTZXQgdGhlIGFuaW1hdGlvbiB0byB0aGUgbGFzdCBrZXlmcmFtZXMgYW5kIHN0b3BcclxuXHRcdGZvciAoIHZhciBoID0gMCwgaGwgPSB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGggPCBobDsgaCsrICkge1xyXG5cclxuXHRcdFx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5W2hdLmtleXMsXHJcblx0XHRcdFx0c2lkcyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0uc2lkcyxcclxuXHRcdFx0XHRlbmQgPSBrZXlzLmxlbmd0aC0xLFxyXG5cdFx0XHRcdG9iaiA9IHRoaXMuaGllcmFyY2h5W2hdO1xyXG5cclxuXHRcdFx0aWYgKCBrZXlzLmxlbmd0aCApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIHMgPSAwOyBzIDwgc2lkcy5sZW5ndGg7IHMrKyApIHtcclxuXHJcblx0XHRcdFx0XHR2YXIgc2lkID0gc2lkc1sgcyBdLFxyXG5cdFx0XHRcdFx0XHRwcmV2ID0gdGhpcy5nZXRQcmV2S2V5V2l0aCggc2lkLCBoLCBlbmQgKTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHByZXYgKSB7XHJcblx0XHRcdFx0XHRcdHByZXYuYXBwbHkoIHNpZCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR0aGlzLmRhdGEuaGllcmFyY2h5W2hdLm5vZGUudXBkYXRlTWF0cml4KCk7XHJcblx0XHRcdFx0b2JqLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnN0b3AoKTtcclxuXHRcdHJldHVybjtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBjaGVjayBwcmUtaW5maW5pdHlcclxuXHRpZiAoIGN1cnJlbnRUaW1lIDwgdGhpcy5zdGFydFRpbWUgKSB7XHJcblxyXG5cdFx0cmV0dXJuO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIHVwZGF0ZVxyXG5cclxuXHRmb3IgKCB2YXIgaCA9IDAsIGhsID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoOyBoIDwgaGw7IGgrKyApIHtcclxuXHJcblx0XHRvYmplY3QgPSB0aGlzLmhpZXJhcmNoeVsgaCBdO1xyXG5cdFx0bm9kZSA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXTtcclxuXHJcblx0XHR2YXIga2V5cyA9IG5vZGUua2V5cyxcclxuXHRcdFx0YW5pbWF0aW9uQ2FjaGUgPSBub2RlLmFuaW1hdGlvbkNhY2hlO1xyXG5cclxuXHRcdC8vIHVzZSBKSVQ/XHJcblxyXG5cdFx0aWYgKCB0aGlzLkpJVENvbXBpbGUgJiYgSklUaGllcmFyY2h5WyBoIF1bIGZyYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHRcdGlmKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xyXG5cclxuXHRcdFx0XHRvYmplY3Quc2tpbk1hdHJpeCA9IEpJVGhpZXJhcmNoeVsgaCBdWyBmcmFtZSBdO1xyXG5cdFx0XHRcdG9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRvYmplY3QubWF0cml4ID0gSklUaGllcmFyY2h5WyBoIF1bIGZyYW1lIF07XHJcblx0XHRcdFx0b2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdC8vIHVzZSBpbnRlcnBvbGF0aW9uXHJcblxyXG5cdFx0fSBlbHNlIGlmICgga2V5cy5sZW5ndGggKSB7XHJcblxyXG5cdFx0XHQvLyBtYWtlIHN1cmUgc28gb3JpZ2luYWwgbWF0cml4IGFuZCBub3QgSklUIG1hdHJpeCBpcyBzZXRcclxuXHJcblx0XHRcdGlmICggdGhpcy5KSVRDb21waWxlICYmIGFuaW1hdGlvbkNhY2hlICkge1xyXG5cclxuXHRcdFx0XHRpZiggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuQm9uZSApIHtcclxuXHJcblx0XHRcdFx0XHRvYmplY3Quc2tpbk1hdHJpeCA9IGFuaW1hdGlvbkNhY2hlLm9yaWdpbmFsTWF0cml4O1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5tYXRyaXggPSBhbmltYXRpb25DYWNoZS5vcmlnaW5hbE1hdHJpeDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cHJldktleSA9IGFuaW1hdGlvbkNhY2hlLnByZXZLZXk7XHJcblx0XHRcdG5leHRLZXkgPSBhbmltYXRpb25DYWNoZS5uZXh0S2V5O1xyXG5cclxuXHRcdFx0aWYgKCBwcmV2S2V5ICYmIG5leHRLZXkgKSB7XHJcblxyXG5cdFx0XHRcdC8vIHN3aXRjaCBrZXlzP1xyXG5cclxuXHRcdFx0XHRpZiAoIG5leHRLZXkudGltZSA8PSB1bmxvb3BlZEN1cnJlbnRUaW1lICkge1xyXG5cclxuXHRcdFx0XHRcdC8vIGRpZCB3ZSBsb29wP1xyXG5cclxuXHRcdFx0XHRcdGlmICggbG9vcGVkICYmIHRoaXMubG9vcCApIHtcclxuXHJcblx0XHRcdFx0XHRcdHByZXZLZXkgPSBrZXlzWyAwIF07XHJcblx0XHRcdFx0XHRcdG5leHRLZXkgPSBrZXlzWyAxIF07XHJcblxyXG5cdFx0XHRcdFx0XHR3aGlsZSAoIG5leHRLZXkudGltZSA8IGN1cnJlbnRUaW1lICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRwcmV2S2V5ID0gbmV4dEtleTtcclxuXHRcdFx0XHRcdFx0XHRuZXh0S2V5ID0ga2V5c1sgcHJldktleS5pbmRleCArIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCAhbG9vcGVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmFyIGxhc3RJbmRleCA9IGtleXMubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdFx0XHRcdHdoaWxlICggbmV4dEtleS50aW1lIDwgY3VycmVudFRpbWUgJiYgbmV4dEtleS5pbmRleCAhPT0gbGFzdEluZGV4ICkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHRwcmV2S2V5ID0gbmV4dEtleTtcclxuXHRcdFx0XHRcdFx0XHRuZXh0S2V5ID0ga2V5c1sgcHJldktleS5pbmRleCArIDEgXTtcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0YW5pbWF0aW9uQ2FjaGUucHJldktleSA9IHByZXZLZXk7XHJcblx0XHRcdFx0XHRhbmltYXRpb25DYWNoZS5uZXh0S2V5ID0gbmV4dEtleTtcclxuXHJcblx0XHRcdFx0fVxyXG4gICAgICAgICAgICAgICAgaWYobmV4dEtleS50aW1lID49IGN1cnJlbnRUaW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZLZXkuaW50ZXJwb2xhdGUoIG5leHRLZXksIGN1cnJlbnRUaW1lICk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcHJldktleS5pbnRlcnBvbGF0ZSggbmV4dEtleSwgbmV4dEtleS50aW1lKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuZGF0YS5oaWVyYXJjaHlbaF0ubm9kZS51cGRhdGVNYXRyaXgoKTtcclxuXHRcdFx0b2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyB1cGRhdGUgSklUP1xyXG5cclxuXHRpZiAoIHRoaXMuSklUQ29tcGlsZSApIHtcclxuXHJcblx0XHRpZiAoIEpJVGhpZXJhcmNoeVsgMCBdWyBmcmFtZSBdID09PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmhpZXJhcmNoeVsgMCBdLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaCA9IDA7IGggPCB0aGlzLmhpZXJhcmNoeS5sZW5ndGg7IGgrKyApIHtcclxuXHJcblx0XHRcdFx0aWYoIHRoaXMuaGllcmFyY2h5WyBoIF0gaW5zdGFuY2VvZiBUSFJFRS5Cb25lICkge1xyXG5cclxuXHRcdFx0XHRcdEpJVGhpZXJhcmNoeVsgaCBdWyBmcmFtZSBdID0gdGhpcy5oaWVyYXJjaHlbIGggXS5za2luTWF0cml4LmNsb25lKCk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0SklUaGllcmFyY2h5WyBoIF1bIGZyYW1lIF0gPSB0aGlzLmhpZXJhcmNoeVsgaCBdLm1hdHJpeC5jbG9uZSgpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gR2V0IG5leHQga2V5IHdpdGhcclxuXHJcblRIUkVFLktleUZyYW1lQW5pbWF0aW9uLnByb3RvdHlwZS5nZXROZXh0S2V5V2l0aCA9IGZ1bmN0aW9uKCBzaWQsIGgsIGtleSApIHtcclxuXHJcblx0dmFyIGtleXMgPSB0aGlzLmRhdGEuaGllcmFyY2h5WyBoIF0ua2V5cztcclxuXHRrZXkgPSBrZXkgJSBrZXlzLmxlbmd0aDtcclxuXHJcblx0Zm9yICggOyBrZXkgPCBrZXlzLmxlbmd0aDsga2V5KysgKSB7XHJcblxyXG5cdFx0aWYgKCBrZXlzWyBrZXkgXS5oYXNUYXJnZXQoIHNpZCApICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGtleXNbIGtleSBdO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4ga2V5c1sgMCBdO1xyXG5cclxufTtcclxuXHJcbi8vIEdldCBwcmV2aW91cyBrZXkgd2l0aFxyXG5cclxuVEhSRUUuS2V5RnJhbWVBbmltYXRpb24ucHJvdG90eXBlLmdldFByZXZLZXlXaXRoID0gZnVuY3Rpb24oIHNpZCwgaCwga2V5ICkge1xyXG5cclxuXHR2YXIga2V5cyA9IHRoaXMuZGF0YS5oaWVyYXJjaHlbIGggXS5rZXlzO1xyXG5cdGtleSA9IGtleSA+PSAwID8ga2V5IDoga2V5ICsga2V5cy5sZW5ndGg7XHJcblxyXG5cdGZvciAoIDsga2V5ID49IDA7IGtleS0tICkge1xyXG5cclxuXHRcdGlmICgga2V5c1sga2V5IF0uaGFzVGFyZ2V0KCBzaWQgKSApIHtcclxuXHJcblx0XHRcdHJldHVybiBrZXlzWyBrZXkgXTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGtleXNbIGtleXMubGVuZ3RoIC0gMSBdO1xyXG5cclxufTtcclxuLyoqXHJcbiAqIENhbWVyYSBmb3IgcmVuZGVyaW5nIGN1YmUgbWFwc1xyXG4gKlx0LSByZW5kZXJzIHNjZW5lIGludG8gYXhpcy1hbGlnbmVkIGN1YmVcclxuICpcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DdWJlQ2FtZXJhID0gZnVuY3Rpb24gKCBuZWFyLCBmYXIsIGN1YmVSZXNvbHV0aW9uICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHZhciBmb3YgPSA5MCwgYXNwZWN0ID0gMTtcclxuXHJcblx0dmFyIGNhbWVyYVBYID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhUFgudXAuc2V0KCAwLCAtMSwgMCApO1xyXG5cdGNhbWVyYVBYLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDEsIDAsIDAgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFQWCApO1xyXG5cclxuXHR2YXIgY2FtZXJhTlggPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFOWC51cC5zZXQoIDAsIC0xLCAwICk7XHJcblx0Y2FtZXJhTlgubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggLTEsIDAsIDAgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFOWCApO1xyXG5cclxuXHR2YXIgY2FtZXJhUFkgPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcclxuXHRjYW1lcmFQWS5sb29rQXQoIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhUFkgKTtcclxuXHJcblx0dmFyIGNhbWVyYU5ZID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhTlkudXAuc2V0KCAwLCAwLCAtMSApO1xyXG5cdGNhbWVyYU5ZLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0xLCAwICkgKTtcclxuXHR0aGlzLmFkZCggY2FtZXJhTlkgKTtcclxuXHJcblx0dmFyIGNhbWVyYVBaID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XHJcblx0Y2FtZXJhUFoudXAuc2V0KCAwLCAtMSwgMCApO1xyXG5cdGNhbWVyYVBaLmxvb2tBdCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFQWiApO1xyXG5cclxuXHR2YXIgY2FtZXJhTlogPSBuZXcgVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcclxuXHRjYW1lcmFOWi51cC5zZXQoIDAsIC0xLCAwICk7XHJcblx0Y2FtZXJhTloubG9va0F0KCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgLTEgKSApO1xyXG5cdHRoaXMuYWRkKCBjYW1lcmFOWiApO1xyXG5cclxuXHR0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwgeyBmb3JtYXQ6IFRIUkVFLlJHQkZvcm1hdCwgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsIG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyIH0gKTtcclxuXHJcblx0dGhpcy51cGRhdGVDdWJlTWFwID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUgKSB7XHJcblxyXG5cdFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xyXG5cdFx0dmFyIGdlbmVyYXRlTWlwbWFwcyA9IHJlbmRlclRhcmdldC5nZW5lcmF0ZU1pcG1hcHM7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDA7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMTtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYU5YLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSAyO1xyXG5cdFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhUFksIHJlbmRlclRhcmdldCApO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDM7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNDtcclxuXHRcdHJlbmRlcmVyLnJlbmRlciggc2NlbmUsIGNhbWVyYVBaLCByZW5kZXJUYXJnZXQgKTtcclxuXHJcblx0XHRyZW5kZXJUYXJnZXQuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xyXG5cclxuXHRcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDU7XHJcblx0XHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWiwgcmVuZGVyVGFyZ2V0ICk7XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViZUNhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuLypcclxuICpcdEBhdXRob3Igeno4NSAvIGh0dHA6Ly90d2l0dGVyLmNvbS9ibHVyc3BsaW5lIC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKlxyXG4gKlx0QSBnZW5lcmFsIHBlcnBvc2UgY2FtZXJhLCBmb3Igc2V0dGluZyBGT1YsIExlbnMgRm9jYWwgTGVuZ3RoLFxyXG4gKlx0XHRhbmQgc3dpdGNoaW5nIGJldHdlZW4gcGVyc3BlY3RpdmUgYW5kIG9ydGhvZ3JhcGhpYyB2aWV3cyBlYXNpbHkuXHJcbiAqXHRcdFVzZSB0aGlzIG9ubHkgaWYgeW91IGRvIG5vdCB3aXNoIHRvIG1hbmFnZVxyXG4gKlx0XHRib3RoIGEgT3J0aG9ncmFwaGljIGFuZCBQZXJzcGVjdGl2ZSBDYW1lcmFcclxuICpcclxuICovXHJcblxyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIGZvdiwgbmVhciwgZmFyLCBvcnRob05lYXIsIG9ydGhvRmFyICkge1xyXG5cclxuXHRUSFJFRS5DYW1lcmEuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmZvdiA9IGZvdjtcclxuXHJcblx0dGhpcy5sZWZ0ID0gLXdpZHRoIC8gMjtcclxuXHR0aGlzLnJpZ2h0ID0gd2lkdGggLyAyXHJcblx0dGhpcy50b3AgPSBoZWlnaHQgLyAyO1xyXG5cdHRoaXMuYm90dG9tID0gLWhlaWdodCAvIDI7XHJcblxyXG5cdC8vIFdlIGNvdWxkIGFsc28gaGFuZGxlIHRoZSBwcm9qZWN0aW9uTWF0cml4IGludGVybmFsbHksIGJ1dCBqdXN0IHdhbnRlZCB0byB0ZXN0IG5lc3RlZCBjYW1lcmEgb2JqZWN0c1xyXG5cclxuXHR0aGlzLmNhbWVyYU8gPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCB3aWR0aCAvIC0gMiwgd2lkdGggLyAyLCBoZWlnaHQgLyAyLCBoZWlnaHQgLyAtIDIsIFx0b3J0aG9OZWFyLCBvcnRob0ZhciApO1xyXG5cdHRoaXMuY2FtZXJhUCA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggZm92LCB3aWR0aCAvIGhlaWdodCwgbmVhciwgZmFyICk7XHJcblxyXG5cdHRoaXMuem9vbSA9IDE7XHJcblxyXG5cdHRoaXMudG9QZXJzcGVjdGl2ZSgpO1xyXG5cclxuXHR2YXIgYXNwZWN0ID0gd2lkdGgvaGVpZ2h0O1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkNhbWVyYS5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b1BlcnNwZWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHQvLyBTd2l0Y2hlcyB0byB0aGUgUGVyc3BlY3RpdmUgQ2FtZXJhXHJcblxyXG5cdHRoaXMubmVhciA9IHRoaXMuY2FtZXJhUC5uZWFyO1xyXG5cdHRoaXMuZmFyID0gdGhpcy5jYW1lcmFQLmZhcjtcclxuXHJcblx0dGhpcy5jYW1lcmFQLmZvdiA9ICB0aGlzLmZvdiAvIHRoaXMuem9vbSA7XHJcblxyXG5cdHRoaXMuY2FtZXJhUC51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XHJcblxyXG5cdHRoaXMucHJvamVjdGlvbk1hdHJpeCA9IHRoaXMuY2FtZXJhUC5wcm9qZWN0aW9uTWF0cml4O1xyXG5cclxuXHR0aGlzLmluUGVyc3BlY3RpdmVNb2RlID0gdHJ1ZTtcclxuXHR0aGlzLmluT3J0aG9ncmFwaGljTW9kZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b09ydGhvZ3JhcGhpYyA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0Ly8gU3dpdGNoZXMgdG8gdGhlIE9ydGhvZ3JhcGhpYyBjYW1lcmEgZXN0aW1hdGluZyB2aWV3cG9ydCBmcm9tIFBlcnNwZWN0aXZlXHJcblxyXG5cdHZhciBmb3YgPSB0aGlzLmZvdjtcclxuXHR2YXIgYXNwZWN0ID0gdGhpcy5jYW1lcmFQLmFzcGVjdDtcclxuXHR2YXIgbmVhciA9IHRoaXMuY2FtZXJhUC5uZWFyO1xyXG5cdHZhciBmYXIgPSB0aGlzLmNhbWVyYVAuZmFyO1xyXG5cclxuXHQvLyBUaGUgc2l6ZSB0aGF0IHdlIHNldCBpcyB0aGUgbWlkIHBsYW5lIG9mIHRoZSB2aWV3aW5nIGZydXN0dW1cclxuXHJcblx0dmFyIGh5cGVyZm9jdXMgPSAoIG5lYXIgKyBmYXIgKSAvIDI7XHJcblxyXG5cdHZhciBoYWxmSGVpZ2h0ID0gTWF0aC50YW4oIGZvdiAvIDIgKSAqIGh5cGVyZm9jdXM7XHJcblx0dmFyIHBsYW5lSGVpZ2h0ID0gMiAqIGhhbGZIZWlnaHQ7XHJcblx0dmFyIHBsYW5lV2lkdGggPSBwbGFuZUhlaWdodCAqIGFzcGVjdDtcclxuXHR2YXIgaGFsZldpZHRoID0gcGxhbmVXaWR0aCAvIDI7XHJcblxyXG5cdGhhbGZIZWlnaHQgLz0gdGhpcy56b29tO1xyXG5cdGhhbGZXaWR0aCAvPSB0aGlzLnpvb207XHJcblxyXG5cdHRoaXMuY2FtZXJhTy5sZWZ0ID0gLWhhbGZXaWR0aDtcclxuXHR0aGlzLmNhbWVyYU8ucmlnaHQgPSBoYWxmV2lkdGg7XHJcblx0dGhpcy5jYW1lcmFPLnRvcCA9IGhhbGZIZWlnaHQ7XHJcblx0dGhpcy5jYW1lcmFPLmJvdHRvbSA9IC1oYWxmSGVpZ2h0O1xyXG5cclxuXHQvLyB0aGlzLmNhbWVyYU8ubGVmdCA9IC1mYXJIYWxmV2lkdGg7XHJcblx0Ly8gdGhpcy5jYW1lcmFPLnJpZ2h0ID0gZmFySGFsZldpZHRoO1xyXG5cdC8vIHRoaXMuY2FtZXJhTy50b3AgPSBmYXJIYWxmSGVpZ2h0O1xyXG5cdC8vIHRoaXMuY2FtZXJhTy5ib3R0b20gPSAtZmFySGFsZkhlaWdodDtcclxuXHJcblx0Ly8gdGhpcy5jYW1lcmFPLmxlZnQgPSB0aGlzLmxlZnQgLyB0aGlzLnpvb207XHJcblx0Ly8gdGhpcy5jYW1lcmFPLnJpZ2h0ID0gdGhpcy5yaWdodCAvIHRoaXMuem9vbTtcclxuXHQvLyB0aGlzLmNhbWVyYU8udG9wID0gdGhpcy50b3AgLyB0aGlzLnpvb207XHJcblx0Ly8gdGhpcy5jYW1lcmFPLmJvdHRvbSA9IHRoaXMuYm90dG9tIC8gdGhpcy56b29tO1xyXG5cclxuXHR0aGlzLmNhbWVyYU8udXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHR0aGlzLm5lYXIgPSB0aGlzLmNhbWVyYU8ubmVhcjtcclxuXHR0aGlzLmZhciA9IHRoaXMuY2FtZXJhTy5mYXI7XHJcblx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gdGhpcy5jYW1lcmFPLnByb2plY3Rpb25NYXRyaXg7XHJcblxyXG5cdHRoaXMuaW5QZXJzcGVjdGl2ZU1vZGUgPSBmYWxzZTtcclxuXHR0aGlzLmluT3J0aG9ncmFwaGljTW9kZSA9IHRydWU7XHJcblxyXG59O1xyXG5cclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS5zZXRTaXplID0gZnVuY3Rpb24oIHdpZHRoLCBoZWlnaHQgKSB7XHJcblxyXG5cdHRoaXMuY2FtZXJhUC5hc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcclxuXHR0aGlzLmxlZnQgPSAtd2lkdGggLyAyO1xyXG5cdHRoaXMucmlnaHQgPSB3aWR0aCAvIDJcclxuXHR0aGlzLnRvcCA9IGhlaWdodCAvIDI7XHJcblx0dGhpcy5ib3R0b20gPSAtaGVpZ2h0IC8gMjtcclxuXHJcbn07XHJcblxyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnNldEZvdiA9IGZ1bmN0aW9uKCBmb3YgKSB7XHJcblxyXG5cdHRoaXMuZm92ID0gZm92O1xyXG5cclxuXHRpZiAoIHRoaXMuaW5QZXJzcGVjdGl2ZU1vZGUgKSB7XHJcblxyXG5cdFx0dGhpcy50b1BlcnNwZWN0aXZlKCk7XHJcblxyXG5cdH0gZWxzZSB7XHJcblxyXG5cdFx0dGhpcy50b09ydGhvZ3JhcGhpYygpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRm9yIG1hbnRhaW5pbmcgc2ltaWxhciBBUEkgd2l0aCBQZXJzcGVjdGl2ZUNhbWVyYVxyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnVwZGF0ZVByb2plY3Rpb25NYXRyaXggPSBmdW5jdGlvbigpIHtcclxuXHJcblx0aWYgKCB0aGlzLmluUGVyc3BlY3RpdmVNb2RlICkge1xyXG5cclxuXHRcdHRoaXMudG9QZXJzcGVjdGl2ZSgpO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdHRoaXMudG9QZXJzcGVjdGl2ZSgpO1xyXG5cdFx0dGhpcy50b09ydGhvZ3JhcGhpYygpO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLypcclxuKiBVc2VzIEZvY2FsIExlbmd0aCAoaW4gbW0pIHRvIGVzdGltYXRlIGFuZCBzZXQgRk9WXHJcbiogMzVtbSAoZnVsbGZyYW1lKSBjYW1lcmEgaXMgdXNlZCBpZiBmcmFtZSBzaXplIGlzIG5vdCBzcGVjaWZpZWQ7XHJcbiogRm9ybXVsYSBiYXNlZCBvbiBodHRwOi8vd3d3LmJvYmF0a2lucy5jb20vcGhvdG9ncmFwaHkvdGVjaG5pY2FsL2ZpZWxkX29mX3ZpZXcuaHRtbFxyXG4qL1xyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUuc2V0TGVucyA9IGZ1bmN0aW9uICggZm9jYWxMZW5ndGgsIGZyYW1lSGVpZ2h0ICkge1xyXG5cclxuXHRpZiAoIGZyYW1lSGVpZ2h0ID09PSB1bmRlZmluZWQgKSBmcmFtZUhlaWdodCA9IDI0O1xyXG5cclxuXHR2YXIgZm92ID0gMiAqIFRIUkVFLk1hdGgucmFkVG9EZWcoIE1hdGguYXRhbiggZnJhbWVIZWlnaHQgLyAoIGZvY2FsTGVuZ3RoICogMiApICkgKTtcclxuXHJcblx0dGhpcy5zZXRGb3YoIGZvdiApO1xyXG5cclxuXHRyZXR1cm4gZm92O1xyXG59O1xyXG5cclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS5zZXRab29tID0gZnVuY3Rpb24oIHpvb20gKSB7XHJcblxyXG5cdHRoaXMuem9vbSA9IHpvb207XHJcblxyXG5cdGlmICggdGhpcy5pblBlcnNwZWN0aXZlTW9kZSApIHtcclxuXHJcblx0XHR0aGlzLnRvUGVyc3BlY3RpdmUoKTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLnRvT3J0aG9ncmFwaGljKCk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9Gcm9udFZpZXcgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5yb3RhdGlvbi54ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnkgPSAwO1xyXG5cdHRoaXMucm90YXRpb24ueiA9IDA7XHJcblxyXG5cdC8vIHNob3VsZCB3ZSBiZSBtb2RpZmluZyB0aGUgbWF0cml4IGluc3RlYWQ/XHJcblxyXG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvQmFja1ZpZXcgPSBmdW5jdGlvbigpIHtcclxuXHJcblx0dGhpcy5yb3RhdGlvbi54ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnkgPSBNYXRoLlBJO1xyXG5cdHRoaXMucm90YXRpb24ueiA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9MZWZ0VmlldyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR0aGlzLnJvdGF0aW9uLnggPSAwO1xyXG5cdHRoaXMucm90YXRpb24ueSA9IC0gTWF0aC5QSSAvIDI7XHJcblx0dGhpcy5yb3RhdGlvbi56ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uQXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbWJpbmVkQ2FtZXJhLnByb3RvdHlwZS50b1JpZ2h0VmlldyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR0aGlzLnJvdGF0aW9uLnggPSAwO1xyXG5cdHRoaXMucm90YXRpb24ueSA9IE1hdGguUEkgLyAyO1xyXG5cdHRoaXMucm90YXRpb24ueiA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Db21iaW5lZENhbWVyYS5wcm90b3R5cGUudG9Ub3BWaWV3ID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdHRoaXMucm90YXRpb24ueCA9IC0gTWF0aC5QSSAvIDI7XHJcblx0dGhpcy5yb3RhdGlvbi55ID0gMDtcclxuXHR0aGlzLnJvdGF0aW9uLnogPSAwO1xyXG5cdHRoaXMucm90YXRpb25BdXRvVXBkYXRlID0gZmFsc2U7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ29tYmluZWRDYW1lcmEucHJvdG90eXBlLnRvQm90dG9tVmlldyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHR0aGlzLnJvdGF0aW9uLnggPSBNYXRoLlBJIC8gMjtcclxuXHR0aGlzLnJvdGF0aW9uLnkgPSAwO1xyXG5cdHRoaXMucm90YXRpb24ueiA9IDA7XHJcblx0dGhpcy5yb3RhdGlvbkF1dG9VcGRhdGUgPSBmYWxzZTtcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICpcdC0gM2QgYXN0ZXJpc2sgc2hhcGUgKGZvciBsaW5lIHBpZWNlcyBUSFJFRS5MaW5lKVxyXG4gKi9cclxuXHJcblRIUkVFLkFzdGVyaXNrR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR2YXIgc2QgPSBpbm5lclJhZGl1cztcclxuXHR2YXIgZWQgPSBvdXRlclJhZGl1cztcclxuXHJcblx0dmFyIHNkMiA9IDAuNzA3ICogc2Q7XHJcblx0dmFyIGVkMiA9IDAuNzA3ICogZWQ7XHJcblxyXG5cdHZhciByYXlzID0gWyBbIHNkLCAwLCAwIF0sIFsgZWQsIDAsIDAgXSwgWyAtc2QsIDAsIDAgXSwgWyAtZWQsIDAsIDAgXSxcclxuXHRcdFx0XHQgWyAwLCBzZCwgMCBdLCBbIDAsIGVkLCAwIF0sIFsgMCwgLXNkLCAwIF0sIFsgMCwgLWVkLCAwIF0sXHJcblx0XHRcdFx0IFsgMCwgMCwgc2QgXSwgWyAwLCAwLCBlZCBdLCBbIDAsIDAsIC1zZCBdLCBbIDAsIDAsIC1lZCBdLFxyXG5cdFx0XHRcdCBbIHNkMiwgc2QyLCAwIF0sIFsgZWQyLCBlZDIsIDAgXSwgWyAtc2QyLCAtc2QyLCAwIF0sIFsgLWVkMiwgLWVkMiwgMCBdLFxyXG5cdFx0XHRcdCBbIHNkMiwgLXNkMiwgMCBdLCBbIGVkMiwgLWVkMiwgMCBdLCBbIC1zZDIsIHNkMiwgMCBdLCBbIC1lZDIsIGVkMiwgMCBdLFxyXG5cdFx0XHRcdCBbIHNkMiwgMCwgc2QyIF0sIFsgZWQyLCAwLCBlZDIgXSwgWyAtc2QyLCAwLCAtc2QyIF0sIFsgLWVkMiwgMCwgLWVkMiBdLFxyXG5cdFx0XHRcdCBbIHNkMiwgMCwgLXNkMiBdLCBbIGVkMiwgMCwgLWVkMiBdLCBbIC1zZDIsIDAsIHNkMiBdLCBbIC1lZDIsIDAsIGVkMiBdLFxyXG5cdFx0XHRcdCBbIDAsIHNkMiwgc2QyIF0sIFsgMCwgZWQyLCBlZDIgXSwgWyAwLCAtc2QyLCAtc2QyIF0sIFsgMCwgLWVkMiwgLWVkMiBdLFxyXG5cdFx0XHRcdCBbIDAsIHNkMiwgLXNkMiBdLCBbIDAsIGVkMiwgLWVkMiBdLCBbIDAsIC1zZDIsIHNkMiBdLCBbIDAsIC1lZDIsIGVkMiBdXHJcblx0XTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHJheXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHggPSByYXlzWyBpIF1bIDAgXTtcclxuXHRcdHZhciB5ID0gcmF5c1sgaSBdWyAxIF07XHJcblx0XHR2YXIgeiA9IHJheXNbIGkgXVsgMiBdO1xyXG5cclxuXHRcdHRoaXMudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIHgsIHksIHogKSApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXN0ZXJpc2tHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTsvKipcclxuICogQGF1dGhvciBodWdoZXNcclxuICovXHJcblxyXG5USFJFRS5DaXJjbGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBzZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG4gICAgVEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCA1MDtcclxuXHJcbiAgICB0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XHJcbiAgICB0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG4gICAgc2VnbWVudHMgPSBzZWdtZW50cyAhPT0gdW5kZWZpbmVkID8gTWF0aC5tYXgoIDMsIHNlZ21lbnRzICkgOiA4O1xyXG5cclxuICAgIHZhciBpLCB1dnMgPSBbXSxcclxuICAgIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIGNlbnRlclVWID0gbmV3IFRIUkVFLlZlY3RvcjIoIDAuNSwgMC41ICk7XHJcblxyXG4gICAgdGhpcy52ZXJ0aWNlcy5wdXNoKGNlbnRlcik7XHJcbiAgICB1dnMucHVzaCggY2VudGVyVVYgKTtcclxuXHJcbiAgICBmb3IgKCBpID0gMDsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG4gICAgICAgIHZlcnRleC54ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyBpIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aCApO1xyXG4gICAgICAgIHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyBpIC8gc2VnbWVudHMgKiB0aGV0YUxlbmd0aCApO1xyXG5cclxuICAgICAgICB0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG4gICAgICAgIHV2cy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMiggKCB2ZXJ0ZXgueCAvIHJhZGl1cyArIDEgKSAvIDIsIC0gKCB2ZXJ0ZXgueSAvIHJhZGl1cyArIDEgKSAvIDIgKyAxICkgKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMCwgLTEgKTtcclxuXHJcbiAgICBmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcclxuXHJcbiAgICAgICAgdmFyIHYxID0gaTtcclxuICAgICAgICB2YXIgdjIgPSBpICsgMSA7XHJcbiAgICAgICAgdmFyIHYzID0gMDtcclxuXHJcbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbiwgbiwgbiBdICkgKTtcclxuICAgICAgICB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2c1sgaSBdLCB1dnNbIGkgKyAxIF0sIGNlbnRlclVWIF0gKTtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcbiAgICB0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DaXJjbGVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9wYXBlcnZpc2lvbjNkLmdvb2dsZWNvZGUuY29tL3N2bi90cnVuay9hczMvdHJ1bmsvc3JjL29yZy9wYXBlcnZpc2lvbjNkL29iamVjdHMvcHJpbWl0aXZlcy9DdWJlLmFzXHJcbiAqL1xyXG5cclxuVEhSRUUuQ3ViZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCBkZXB0aCwgd2lkdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIGRlcHRoU2VnbWVudHMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dGhpcy53aWR0aCA9IHdpZHRoO1xyXG5cdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG5cdHRoaXMuZGVwdGggPSBkZXB0aDtcclxuXHJcblx0dGhpcy53aWR0aFNlZ21lbnRzID0gd2lkdGhTZWdtZW50cyB8fCAxO1xyXG5cdHRoaXMuaGVpZ2h0U2VnbWVudHMgPSBoZWlnaHRTZWdtZW50cyB8fCAxO1xyXG5cdHRoaXMuZGVwdGhTZWdtZW50cyA9IGRlcHRoU2VnbWVudHMgfHwgMTtcclxuXHJcblx0dmFyIHdpZHRoX2hhbGYgPSB0aGlzLndpZHRoIC8gMjtcclxuXHR2YXIgaGVpZ2h0X2hhbGYgPSB0aGlzLmhlaWdodCAvIDI7XHJcblx0dmFyIGRlcHRoX2hhbGYgPSB0aGlzLmRlcHRoIC8gMjtcclxuXHJcblx0YnVpbGRQbGFuZSggJ3onLCAneScsIC0gMSwgLSAxLCB0aGlzLmRlcHRoLCB0aGlzLmhlaWdodCwgd2lkdGhfaGFsZiwgMCApOyAvLyBweFxyXG5cdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAgIDEsIC0gMSwgdGhpcy5kZXB0aCwgdGhpcy5oZWlnaHQsIC0gd2lkdGhfaGFsZiwgMSApOyAvLyBueFxyXG5cdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAgIDEsICAgMSwgdGhpcy53aWR0aCwgdGhpcy5kZXB0aCwgaGVpZ2h0X2hhbGYsIDIgKTsgLy8gcHlcclxuXHRidWlsZFBsYW5lKCAneCcsICd6JywgICAxLCAtIDEsIHRoaXMud2lkdGgsIHRoaXMuZGVwdGgsIC0gaGVpZ2h0X2hhbGYsIDMgKTsgLy8gbnlcclxuXHRidWlsZFBsYW5lKCAneCcsICd5JywgICAxLCAtIDEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBkZXB0aF9oYWxmLCA0ICk7IC8vIHB6XHJcblx0YnVpbGRQbGFuZSggJ3gnLCAneScsIC0gMSwgLSAxLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgLSBkZXB0aF9oYWxmLCA1ICk7IC8vIG56XHJcblxyXG5cdGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBtYXRlcmlhbEluZGV4ICkge1xyXG5cclxuXHRcdHZhciB3LCBpeCwgaXksXHJcblx0XHRncmlkWCA9IHNjb3BlLndpZHRoU2VnbWVudHMsXHJcblx0XHRncmlkWSA9IHNjb3BlLmhlaWdodFNlZ21lbnRzLFxyXG5cdFx0d2lkdGhfaGFsZiA9IHdpZHRoIC8gMixcclxuXHRcdGhlaWdodF9oYWxmID0gaGVpZ2h0IC8gMixcclxuXHRcdG9mZnNldCA9IHNjb3BlLnZlcnRpY2VzLmxlbmd0aDtcclxuXHJcblx0XHRpZiAoICggdSA9PT0gJ3gnICYmIHYgPT09ICd5JyApIHx8ICggdSA9PT0gJ3knICYmIHYgPT09ICd4JyApICkge1xyXG5cclxuXHRcdFx0dyA9ICd6JztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCAoIHUgPT09ICd4JyAmJiB2ID09PSAneicgKSB8fCAoIHUgPT09ICd6JyAmJiB2ID09PSAneCcgKSApIHtcclxuXHJcblx0XHRcdHcgPSAneSc7XHJcblx0XHRcdGdyaWRZID0gc2NvcGUuZGVwdGhTZWdtZW50cztcclxuXHJcblx0XHR9IGVsc2UgaWYgKCAoIHUgPT09ICd6JyAmJiB2ID09PSAneScgKSB8fCAoIHUgPT09ICd5JyAmJiB2ID09PSAneicgKSApIHtcclxuXHJcblx0XHRcdHcgPSAneCc7XHJcblx0XHRcdGdyaWRYID0gc2NvcGUuZGVwdGhTZWdtZW50cztcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMSxcclxuXHRcdGdyaWRZMSA9IGdyaWRZICsgMSxcclxuXHRcdHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYLFxyXG5cdFx0c2VnbWVudF9oZWlnaHQgPSBoZWlnaHQgLyBncmlkWSxcclxuXHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0bm9ybWFsWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLSAxO1xyXG5cclxuXHRcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xyXG5cclxuXHRcdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciB2ZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRcdHZlY3RvclsgdSBdID0gKCBpeCAqIHNlZ21lbnRfd2lkdGggLSB3aWR0aF9oYWxmICkgKiB1ZGlyO1xyXG5cdFx0XHRcdHZlY3RvclsgdiBdID0gKCBpeSAqIHNlZ21lbnRfaGVpZ2h0IC0gaGVpZ2h0X2hhbGYgKSAqIHZkaXI7XHJcblx0XHRcdFx0dmVjdG9yWyB3IF0gPSBkZXB0aDtcclxuXHJcblx0XHRcdFx0c2NvcGUudmVydGljZXMucHVzaCggdmVjdG9yICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTsgaXkrKyApIHtcclxuXHJcblx0XHRcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXgrKyApIHtcclxuXHJcblx0XHRcdFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xyXG5cdFx0XHRcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xyXG5cdFx0XHRcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XHJcblx0XHRcdFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XHJcblxyXG5cdFx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2U0KCBhICsgb2Zmc2V0LCBiICsgb2Zmc2V0LCBjICsgb2Zmc2V0LCBkICsgb2Zmc2V0ICk7XHJcblx0XHRcdFx0ZmFjZS5ub3JtYWwuY29weSggbm9ybWFsICk7XHJcblx0XHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XHJcblx0XHRcdFx0ZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcclxuXHJcblx0XHRcdFx0c2NvcGUuZmFjZXMucHVzaCggZmFjZSApO1xyXG5cdFx0XHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSBpeSAvIGdyaWRZICksXHJcblx0XHRcdFx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGl4IC8gZ3JpZFgsIDEgLSAoIGl5ICsgMSApIC8gZ3JpZFkgKSxcclxuXHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxLSAoIGl5ICsgMSApIC8gZ3JpZFkgKSxcclxuXHRcdFx0XHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggKCBpeCArIDEgKSAvIGdyaWRYLCAxIC0gaXkgLyBncmlkWSApXHJcblx0XHRcdFx0XHRcdF0gKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQ3ViZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpdXNTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRyYWRpdXNUb3AgPSByYWRpdXNUb3AgIT09IHVuZGVmaW5lZCA/IHJhZGl1c1RvcCA6IDIwO1xyXG5cdHJhZGl1c0JvdHRvbSA9IHJhZGl1c0JvdHRvbSAhPT0gdW5kZWZpbmVkID8gcmFkaXVzQm90dG9tIDogMjA7XHJcblx0aGVpZ2h0ID0gaGVpZ2h0ICE9PSB1bmRlZmluZWQgPyBoZWlnaHQgOiAxMDA7XHJcblxyXG5cdHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcclxuXHR2YXIgc2VnbWVudHNYID0gcmFkaXVzU2VnbWVudHMgfHwgODtcclxuXHR2YXIgc2VnbWVudHNZID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuXHJcblx0dmFyIHgsIHksIHZlcnRpY2VzID0gW10sIHV2cyA9IFtdO1xyXG5cclxuXHRmb3IgKCB5ID0gMDsgeSA8PSBzZWdtZW50c1k7IHkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzUm93ID0gW107XHJcblx0XHR2YXIgdXZzUm93ID0gW107XHJcblxyXG5cdFx0dmFyIHYgPSB5IC8gc2VnbWVudHNZO1xyXG5cdFx0dmFyIHJhZGl1cyA9IHYgKiAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApICsgcmFkaXVzVG9wO1xyXG5cclxuXHRcdGZvciAoIHggPSAwOyB4IDw9IHNlZ21lbnRzWDsgeCArKyApIHtcclxuXHJcblx0XHRcdHZhciB1ID0geCAvIHNlZ21lbnRzWDtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguc2luKCB1ICogTWF0aC5QSSAqIDIgKTtcclxuXHRcdFx0dmVydGV4LnkgPSAtIHYgKiBoZWlnaHQgKyBoZWlnaHRIYWxmO1xyXG5cdFx0XHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguY29zKCB1ICogTWF0aC5QSSAqIDIgKTtcclxuXHJcblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcclxuXHRcdFx0dXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XHJcblx0XHR1dnMucHVzaCggdXZzUm93ICk7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIHRhblRoZXRhID0gKCByYWRpdXNCb3R0b20gLSByYWRpdXNUb3AgKSAvIGhlaWdodDtcclxuXHR2YXIgbmEsIG5iO1xyXG5cclxuXHRmb3IgKCB4ID0gMDsgeCA8IHNlZ21lbnRzWDsgeCArKyApIHtcclxuXHJcblx0XHRpZiAoIHJhZGl1c1RvcCAhPT0gMCApIHtcclxuXHJcblx0XHRcdG5hID0gdGhpcy52ZXJ0aWNlc1sgdmVydGljZXNbIDAgXVsgeCBdIF0uY2xvbmUoKTtcclxuXHRcdFx0bmIgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMCBdWyB4ICsgMSBdIF0uY2xvbmUoKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0bmEgPSB0aGlzLnZlcnRpY2VzWyB2ZXJ0aWNlc1sgMSBdWyB4IF0gXS5jbG9uZSgpO1xyXG5cdFx0XHRuYiA9IHRoaXMudmVydGljZXNbIHZlcnRpY2VzWyAxIF1bIHggKyAxIF0gXS5jbG9uZSgpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRuYS5zZXRZKCBNYXRoLnNxcnQoIG5hLnggKiBuYS54ICsgbmEueiAqIG5hLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XHJcblx0XHRuYi5zZXRZKCBNYXRoLnNxcnQoIG5iLnggKiBuYi54ICsgbmIueiAqIG5iLnogKSAqIHRhblRoZXRhICkubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0Zm9yICggeSA9IDA7IHkgPCBzZWdtZW50c1k7IHkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdjEgPSB2ZXJ0aWNlc1sgeSBdWyB4IF07XHJcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4IF07XHJcblx0XHRcdHZhciB2MyA9IHZlcnRpY2VzWyB5ICsgMSBdWyB4ICsgMSBdO1xyXG5cdFx0XHR2YXIgdjQgPSB2ZXJ0aWNlc1sgeSBdWyB4ICsgMSBdO1xyXG5cclxuXHRcdFx0dmFyIG4xID0gbmEuY2xvbmUoKTtcclxuXHRcdFx0dmFyIG4yID0gbmEuY2xvbmUoKTtcclxuXHRcdFx0dmFyIG4zID0gbmIuY2xvbmUoKTtcclxuXHRcdFx0dmFyIG40ID0gbmIuY2xvbmUoKTtcclxuXHJcblx0XHRcdHZhciB1djEgPSB1dnNbIHkgXVsgeCBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djIgPSB1dnNbIHkgKyAxIF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYzID0gdXZzWyB5ICsgMSBdWyB4ICsgMSBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djQgPSB1dnNbIHkgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTQoIHYxLCB2MiwgdjMsIHY0LCBbIG4xLCBuMiwgbjMsIG40IF0gKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2MSwgdXYyLCB1djMsIHV2NCBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIHRvcCBjYXBcclxuXHJcblx0aWYgKCAhb3BlbkVuZGVkICYmIHJhZGl1c1RvcCA+IDAgKSB7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgaGVpZ2h0SGFsZiwgMCApICk7XHJcblxyXG5cdFx0Zm9yICggeCA9IDA7IHggPCBzZWdtZW50c1g7IHggKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgdjEgPSB2ZXJ0aWNlc1sgMCBdWyB4IF07XHJcblx0XHRcdHZhciB2MiA9IHZlcnRpY2VzWyAwIF1bIHggKyAxIF07XHJcblx0XHRcdHZhciB2MyA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMTtcclxuXHJcblx0XHRcdHZhciBuMSA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblx0XHRcdHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblx0XHRcdHZhciBuMyA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAxLCAwICk7XHJcblxyXG5cdFx0XHR2YXIgdXYxID0gdXZzWyAwIF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYyID0gdXZzWyAwIF1bIHggKyAxIF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2MyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB1djIudSwgMCApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIHYxLCB2MiwgdjMsIFsgbjEsIG4yLCBuMyBdICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXYzIF0gKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gYm90dG9tIGNhcFxyXG5cclxuXHRpZiAoICFvcGVuRW5kZWQgJiYgcmFkaXVzQm90dG9tID4gMCApIHtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIGhlaWdodEhhbGYsIDAgKSApO1xyXG5cclxuXHRcdGZvciAoIHggPSAwOyB4IDwgc2VnbWVudHNYOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcclxuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIHkgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjMgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHR2YXIgbjEgPSBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLSAxLCAwICk7XHJcblx0XHRcdHZhciBuMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAtIDEsIDAgKTtcclxuXHRcdFx0dmFyIG4zID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIC0gMSwgMCApO1xyXG5cclxuXHRcdFx0dmFyIHV2MSA9IHV2c1sgeSBdWyB4ICsgMSBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djIgPSB1dnNbIHkgXVsgeCBdLmNsb25lKCk7XHJcblx0XHRcdHZhciB1djMgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYyLnUsIDEgKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCB2MSwgdjIsIHYzLCBbIG4xLCBuMiwgbjMgXSApICk7XHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG59XHJcblxyXG5USFJFRS5DeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xyXG4gKlxyXG4gKiBDcmVhdGVzIGV4dHJ1ZGVkIGdlb21ldHJ5IGZyb20gYSBwYXRoIHNoYXBlLlxyXG4gKlxyXG4gKiBwYXJhbWV0ZXJzID0ge1xyXG4gKlxyXG4gKiAgc2l6ZTogPGZsb2F0PiwgLy8gc2l6ZSBvZiB0aGUgdGV4dFxyXG4gKiAgaGVpZ2h0OiA8ZmxvYXQ+LCAvLyB0aGlja25lc3MgdG8gZXh0cnVkZSB0ZXh0XHJcbiAqICBjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzXHJcbiAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnZW1lbnRzIG9mIGV4dHJ1ZGUgc3BsaW5lIHRvb1xyXG4gKiAgYW1vdW50OiA8aW50PiwgLy8gQW1vdW50XHJcbiAqXHJcbiAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxyXG4gKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGV4dCBiZXZlbCBnb2VzXHJcbiAqICBiZXZlbFNpemU6IDxmbG9hdD4sIC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgaXMgYmV2ZWxcclxuICogIGJldmVsU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgYmV2ZWwgbGF5ZXJzXHJcbiAqXHJcbiAqICBleHRydWRlUGF0aDogPFRIUkVFLkN1cnZlUGF0aD4gLy8gM2Qgc3BsaW5lIHBhdGggdG8gZXh0cnVkZSBzaGFwZSBhbG9uZy4gKGNyZWF0ZXMgRnJhbWVzIGlmIC5mcmFtZXMgYXJlbid0IGRlZmluZWQpXHJcbiAqICBmcmFtZXM6IDxUSFJFRS5UdWJlR2VvbWV0cnkuRnJlbmV0RnJhbWVzPiAvLyBjb250YWluaW5nIGFycmF5cyBvZiB0YW5nZW50cywgbm9ybWFscywgYmlub3JtYWxzXHJcbiAqXHJcbiAqICBtYXRlcmlhbDogPGludD4gLy8gbWF0ZXJpYWwgaW5kZXggZm9yIGZyb250IGFuZCBiYWNrIGZhY2VzXHJcbiAqICBleHRydWRlTWF0ZXJpYWw6IDxpbnQ+IC8vIG1hdGVyaWFsIGluZGV4IGZvciBleHRydXNpb24gYW5kIGJldmVsZWQgZmFjZXNcclxuICogIHV2R2VuZXJhdG9yOiA8T2JqZWN0PiAvLyBvYmplY3QgdGhhdCBwcm92aWRlcyBVViBnZW5lcmF0b3IgZnVuY3Rpb25zXHJcbiAqXHJcbiAqIH1cclxuICoqL1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdGlmICggdHlwZW9mKCBzaGFwZXMgKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcclxuXHRcdHNoYXBlcyA9IFtdO1xyXG5cdFx0cmV0dXJuO1xyXG5cdH1cclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRzaGFwZXMgPSBzaGFwZXMgaW5zdGFuY2VvZiBBcnJheSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XHJcblxyXG5cdHRoaXMuc2hhcGViYiA9IHNoYXBlc1sgc2hhcGVzLmxlbmd0aCAtIDEgXS5nZXRCb3VuZGluZ0JveCgpO1xyXG5cclxuXHR0aGlzLmFkZFNoYXBlTGlzdCggc2hhcGVzLCBvcHRpb25zICk7XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblxyXG5cdC8vIGNhbid0IHJlYWxseSB1c2UgYXV0b21hdGljIHZlcnRleCBub3JtYWxzXHJcblx0Ly8gYXMgdGhlbiBmcm9udCBhbmQgYmFjayBzaWRlcyBnZXQgc21vb3RoZWQgdG9vXHJcblx0Ly8gc2hvdWxkIGRvIHNlcGFyYXRlIHNtb290aGluZyBqdXN0IGZvciBzaWRlc1xyXG5cclxuXHQvL3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcblx0Ly9jb25zb2xlLmxvZyggXCJ0b29rXCIsICggRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSApICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5hZGRTaGFwZUxpc3QgPSBmdW5jdGlvbiAoIHNoYXBlcywgb3B0aW9ucyApIHtcclxuXHR2YXIgc2wgPSBzaGFwZXMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCB2YXIgcyA9IDA7IHMgPCBzbDsgcyArKyApIHtcclxuXHRcdHZhciBzaGFwZSA9IHNoYXBlc1sgcyBdO1xyXG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcclxuXHR9XHJcbn07XHJcblxyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcclxuXHJcblx0dmFyIGFtb3VudCA9IG9wdGlvbnMuYW1vdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmFtb3VudCA6IDEwMDtcclxuXHJcblx0dmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXHJcblx0dmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjsgLy8gOFxyXG5cdHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xyXG5cclxuXHR2YXIgYmV2ZWxFbmFibGVkID0gb3B0aW9ucy5iZXZlbEVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuYmV2ZWxFbmFibGVkIDogdHJ1ZTsgLy8gZmFsc2VcclxuXHJcblx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xyXG5cclxuXHR2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcclxuXHJcblx0dmFyIGV4dHJ1ZGVQYXRoID0gb3B0aW9ucy5leHRydWRlUGF0aDtcclxuXHR2YXIgZXh0cnVkZVB0cywgZXh0cnVkZUJ5UGF0aCA9IGZhbHNlO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xyXG5cdHZhciBleHRydWRlTWF0ZXJpYWwgPSBvcHRpb25zLmV4dHJ1ZGVNYXRlcmlhbDtcclxuXHJcblx0Ly8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXHJcblx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yO1xyXG5cclxuXHR2YXIgc2hhcGViYiA9IHRoaXMuc2hhcGViYjtcclxuXHQvL3NoYXBlYmIgPSBzaGFwZS5nZXRCb3VuZGluZ0JveCgpO1xyXG5cclxuXHJcblxyXG5cdHZhciBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XHJcblx0aWYgKCBleHRydWRlUGF0aCApIHtcclxuXHJcblx0XHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xyXG5cclxuXHRcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xyXG5cdFx0YmV2ZWxFbmFibGVkID0gZmFsc2U7IC8vIGJldmVscyBub3Qgc3VwcG9ydGVkIGZvciBwYXRoIGV4dHJ1c2lvblxyXG5cclxuXHRcdC8vIFNFVFVQIFROQiB2YXJpYWJsZXNcclxuXHJcblx0XHQvLyBSZXVzZSBUTkIgZnJvbSBUdWJlR2VvbXRyeSBmb3Igbm93LlxyXG5cdFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cclxuXHJcblx0XHRzcGxpbmVUdWJlID0gb3B0aW9ucy5mcmFtZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZnJhbWVzIDogbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoZXh0cnVkZVBhdGgsIHN0ZXBzLCBmYWxzZSk7XHJcblxyXG5cdFx0Ly8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XHJcblxyXG5cdFx0Ymlub3JtYWwgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0bm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHBvc2l0aW9uMiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXHJcblxyXG5cdGlmICggISBiZXZlbEVuYWJsZWQgKSB7XHJcblxyXG5cdFx0YmV2ZWxTZWdtZW50cyA9IDA7XHJcblx0XHRiZXZlbFRoaWNrbmVzcyA9IDA7XHJcblx0XHRiZXZlbFNpemUgPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFZhcmlhYmxlcyBpbml0YWxpemF0aW9uXHJcblxyXG5cdHZhciBhaG9sZSwgaCwgaGw7IC8vIGxvb3Bpbmcgb2YgaG9sZXNcclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cdHZhciBiZXZlbFBvaW50cyA9IFtdO1xyXG5cclxuXHR2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblxyXG5cdHZhciBzaGFwZVBvaW50cyA9IHNoYXBlLmV4dHJhY3RQb2ludHMoIGN1cnZlU2VnbWVudHMgKTtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gc2hhcGVQb2ludHMuc2hhcGU7XHJcblx0dmFyIGhvbGVzID0gc2hhcGVQb2ludHMuaG9sZXM7XHJcblxyXG5cdHZhciByZXZlcnNlID0gIVRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApIDtcclxuXHJcblx0aWYgKCByZXZlcnNlICkge1xyXG5cclxuXHRcdHZlcnRpY2VzID0gdmVydGljZXMucmV2ZXJzZSgpO1xyXG5cclxuXHRcdC8vIE1heWJlIHdlIHNob3VsZCBhbHNvIGNoZWNrIGlmIGhvbGVzIGFyZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uLCBqdXN0IHRvIGJlIHNhZmUgLi4uXHJcblxyXG5cdFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0XHRpZiAoIFRIUkVFLlNoYXBlLlV0aWxzLmlzQ2xvY2tXaXNlKCBhaG9sZSApICkge1xyXG5cclxuXHRcdFx0XHRob2xlc1sgaCBdID0gYWhvbGUucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXZlcnNlID0gZmFsc2U7IC8vIElmIHZlcnRpY2VzIGFyZSBpbiBvcmRlciBub3csIHdlIHNob3VsZG4ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoZW0gYWdhaW4gKGhvcGVmdWxseSkhXHJcblxyXG5cdH1cclxuXHJcblxyXG5cdHZhciBmYWNlcyA9IFRIUkVFLlNoYXBlLlV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUgKCB2ZXJ0aWNlcywgaG9sZXMgKTtcclxuXHJcblx0LyogVmVydGljZXMgKi9cclxuXHJcblx0dmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcclxuXHJcblx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyAgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLmNvbmNhdCggYWhvbGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0ZnVuY3Rpb24gc2NhbGVQdDIgKCBwdCwgdmVjLCBzaXplICkge1xyXG5cclxuXHRcdGlmICggIXZlYyApIGNvbnNvbGUubG9nKCBcImRpZVwiICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBiLCBicywgdCwgeixcclxuXHRcdHZlcnQsIHZsZW4gPSB2ZXJ0aWNlcy5sZW5ndGgsXHJcblx0XHRmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoLFxyXG5cdFx0Y29udCwgY2xlbiA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cclxuXHJcblx0Ly8gRmluZCBkaXJlY3Rpb25zIGZvciBwb2ludCBtb3ZlbWVudFxyXG5cclxuXHR2YXIgUkFEX1RPX0RFR1JFRVMgPSAxODAgLyBNYXRoLlBJO1xyXG5cclxuXHJcblx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMoIHB0X2ksIHB0X2osIHB0X2sgKSB7XHJcblxyXG5cdFx0Ly8gQWxnb3JpdGhtIDJcclxuXHJcblx0XHRyZXR1cm4gZ2V0QmV2ZWxWZWMyKCBwdF9pLCBwdF9qLCBwdF9rICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMxKCBwdF9pLCBwdF9qLCBwdF9rICkge1xyXG5cclxuXHRcdHZhciBhbmdsZWEgPSBNYXRoLmF0YW4yKCBwdF9qLnkgLSBwdF9pLnksIHB0X2oueCAtIHB0X2kueCApO1xyXG5cdFx0dmFyIGFuZ2xlYiA9IE1hdGguYXRhbjIoIHB0X2sueSAtIHB0X2kueSwgcHRfay54IC0gcHRfaS54ICk7XHJcblxyXG5cdFx0aWYgKCBhbmdsZWEgPiBhbmdsZWIgKSB7XHJcblxyXG5cdFx0XHRhbmdsZWIgKz0gTWF0aC5QSSAqIDI7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhbmdsZWMgPSAoIGFuZ2xlYSArIGFuZ2xlYiApIC8gMjtcclxuXHJcblxyXG5cdFx0Ly9jb25zb2xlLmxvZygnYW5nbGUxJywgYW5nbGVhICogUkFEX1RPX0RFR1JFRVMsJ2FuZ2xlMicsIGFuZ2xlYiAqIFJBRF9UT19ERUdSRUVTLCAnYW5nbGVjJywgYW5nbGVjICpSQURfVE9fREVHUkVFUyk7XHJcblxyXG5cdFx0dmFyIHggPSAtIE1hdGguY29zKCBhbmdsZWMgKTtcclxuXHRcdHZhciB5ID0gLSBNYXRoLnNpbiggYW5nbGVjICk7XHJcblxyXG5cdFx0dmFyIHZlYyA9IG5ldyBUSFJFRS5WZWN0b3IyKCB4LCB5ICk7IC8vLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHRcdHJldHVybiB2ZWM7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0QmV2ZWxWZWMyKCBwdF9pLCBwdF9qLCBwdF9rICkge1xyXG5cclxuXHRcdHZhciBhID0gVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjEsXHJcblx0XHRcdGIgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnkuX192MixcclxuXHRcdFx0dl9oYXQgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnkuX192MyxcclxuXHRcdFx0d19oYXQgPSBUSFJFRS5FeHRydWRlR2VvbWV0cnkuX192NCxcclxuXHRcdFx0cCA9IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3Y1LFxyXG5cdFx0XHRxID0gVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjYsXHJcblx0XHRcdHYsIHcsXHJcblx0XHRcdHZfZG90X3dfaGF0LCBxX3N1Yl9wX2RvdF93X2hhdCxcclxuXHRcdFx0cywgaW50ZXJzZWN0aW9uO1xyXG5cclxuXHRcdC8vIGdvb2QgcmVhZGluZyBmb3IgbGluZS1saW5lIGludGVyc2VjdGlvblxyXG5cdFx0Ly8gaHR0cDovL3NwdXRzb2Z0LmNvbS9ibG9nLzIwMTAvMDMvbGluZS1saW5lLWludGVyc2VjdGlvbi5odG1sXHJcblxyXG5cdFx0Ly8gZGVmaW5lIGEgYXMgdmVjdG9yIGotPmlcclxuXHRcdC8vIGRlZmluZSBiIGFzIHZlY3RvdCBrLT5pXHJcblxyXG5cdFx0YS5zZXQoIHB0X2kueCAtIHB0X2oueCwgcHRfaS55IC0gcHRfai55ICk7XHJcblx0XHRiLnNldCggcHRfaS54IC0gcHRfay54LCBwdF9pLnkgLSBwdF9rLnkgKTtcclxuXHJcblx0XHQvLyBnZXQgdW5pdCB2ZWN0b3JzXHJcblxyXG5cdFx0diA9IGEubm9ybWFsaXplKCk7XHJcblx0XHR3ID0gYi5ub3JtYWxpemUoKTtcclxuXHJcblx0XHQvLyBub3JtYWxzIGZyb20gcHQgaVxyXG5cclxuXHRcdHZfaGF0LnNldCggLXYueSwgdi54ICk7XHJcblx0XHR3X2hhdC5zZXQoIHcueSwgLXcueCApO1xyXG5cclxuXHRcdC8vIHB0cyBmcm9tIGlcclxuXHJcblx0XHRwLmNvcHkoIHB0X2kgKS5hZGQoIHZfaGF0ICk7XHJcblx0XHRxLmNvcHkoIHB0X2kgKS5hZGQoIHdfaGF0ICk7XHJcblxyXG5cdFx0aWYgKCBwLmVxdWFscyggcSApICkge1xyXG5cclxuXHRcdFx0Ly9jb25zb2xlLmxvZyhcIldhcm5pbmc6IGxpbmVzIGFyZSBzdHJhaWdodFwiKTtcclxuXHRcdFx0cmV0dXJuIHdfaGF0LmNsb25lKCk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFBvaW50cyBmcm9tIGosIGsuIGhlbHBzIHByZXZlbnRzIHBvaW50cyBjcm9zcyBvdmVyb3ZlciBtb3N0IG9mIHRoZSB0aW1lXHJcblxyXG5cdFx0cC5jb3B5KCBwdF9qICkuYWRkKCB2X2hhdCApO1xyXG5cdFx0cS5jb3B5KCBwdF9rICkuYWRkKCB3X2hhdCApO1xyXG5cclxuXHRcdHZfZG90X3dfaGF0ID0gdi5kb3QoIHdfaGF0ICk7XHJcblx0XHRxX3N1Yl9wX2RvdF93X2hhdCA9IHEuc3ViKCBwICkuZG90KCB3X2hhdCApO1xyXG5cclxuXHRcdC8vIFdlIHNob3VsZCBub3QgcmVhY2ggdGhlc2UgY29uZGl0aW9uc1xyXG5cclxuXHRcdGlmICggdl9kb3Rfd19oYXQgPT09IDAgKSB7XHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyggXCJFaXRoZXIgaW5maW5pdGUgb3Igbm8gc29sdXRpb25zIVwiICk7XHJcblxyXG5cdFx0XHRpZiAoIHFfc3ViX3BfZG90X3dfaGF0ID09PSAwICkge1xyXG5cclxuXHRcdFx0XHRjb25zb2xlLmxvZyggXCJJdHMgZmluaXRlIHNvbHV0aW9ucy5cIiApO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0Y29uc29sZS5sb2coIFwiVG9vIGJhZCwgbm8gc29sdXRpb25zLlwiICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHMgPSBxX3N1Yl9wX2RvdF93X2hhdCAvIHZfZG90X3dfaGF0O1xyXG5cclxuXHRcdGlmICggcyA8IDAgKSB7XHJcblxyXG5cdFx0XHQvLyBpbiBjYXNlIG9mIGVtZXJnZWN5LCByZXZlcnQgdG8gYWxnb3JpdGhtIDEuXHJcblxyXG5cdFx0XHRyZXR1cm4gZ2V0QmV2ZWxWZWMxKCBwdF9pLCBwdF9qLCBwdF9rICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdGludGVyc2VjdGlvbiA9IHYubXVsdGlwbHlTY2FsYXIoIHMgKS5hZGQoIHAgKTtcclxuXHJcblx0XHRyZXR1cm4gaW50ZXJzZWN0aW9uLnN1YiggcHRfaSApLmNsb25lKCk7IC8vIERvbid0IG5vcm1hbGl6ZSEsIG90aGVyd2lzZSBzaGFycCBjb3JuZXJzIGJlY29tZSB1Z2x5XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGNvbnRvdXJNb3ZlbWVudHMgPSBbXTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcclxuXHJcblx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XHJcblx0XHRpZiAoIGsgPT09IGlsICkgayA9IDA7XHJcblxyXG5cdFx0Ly8gIChqKS0tLShpKS0tLShrKVxyXG5cdFx0Ly8gY29uc29sZS5sb2coJ2ksaixrJywgaSwgaiAsIGspXHJcblxyXG5cdFx0dmFyIHB0X2kgPSBjb250b3VyWyBpIF07XHJcblx0XHR2YXIgcHRfaiA9IGNvbnRvdXJbIGogXTtcclxuXHRcdHZhciBwdF9rID0gY29udG91clsgayBdO1xyXG5cclxuXHRcdGNvbnRvdXJNb3ZlbWVudHNbIGkgXT0gZ2V0QmV2ZWxWZWMoIGNvbnRvdXJbIGkgXSwgY29udG91clsgaiBdLCBjb250b3VyWyBrIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHR2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXSwgb25lSG9sZU1vdmVtZW50cywgdmVydGljZXNNb3ZlbWVudHMgPSBjb250b3VyTW92ZW1lbnRzLmNvbmNhdCgpO1xyXG5cclxuXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblxyXG5cdFx0b25lSG9sZU1vdmVtZW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aCwgaiA9IGlsIC0gMSwgayA9IGkgKyAxOyBpIDwgaWw7IGkgKyssIGogKyssIGsgKysgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGogPT09IGlsICkgaiA9IDA7XHJcblx0XHRcdGlmICggayA9PT0gaWwgKSBrID0gMDtcclxuXHJcblx0XHRcdC8vICAoaiktLS0oaSktLS0oaylcclxuXHRcdFx0b25lSG9sZU1vdmVtZW50c1sgaSBdPSBnZXRCZXZlbFZlYyggYWhvbGVbIGkgXSwgYWhvbGVbIGogXSwgYWhvbGVbIGsgXSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRob2xlc01vdmVtZW50cy5wdXNoKCBvbmVIb2xlTW92ZW1lbnRzICk7XHJcblx0XHR2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdCggb25lSG9sZU1vdmVtZW50cyApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcclxuXHJcblx0Zm9yICggYiA9IDA7IGIgPCBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xyXG5cdC8vZm9yICggYiA9IGJldmVsU2VnbWVudHM7IGIgPiAwOyBiIC0tICkge1xyXG5cclxuXHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcclxuXHRcdHogPSBiZXZlbFRoaWNrbmVzcyAqICggMSAtIHQgKTtcclxuXHJcblx0XHQvL3ogPSBiZXZlbFRoaWNrbmVzcyAqIHQ7XHJcblx0XHRicyA9IGJldmVsU2l6ZSAqICggTWF0aC5zaW4gKCB0ICogTWF0aC5QSS8yICkgKSA7IC8vIGN1cnZlZFxyXG5cdFx0Ly9icyA9IGJldmVsU2l6ZSAqIHQgOyAvLyBsaW5lYXJcclxuXHJcblx0XHQvLyBjb250cmFjdCBzaGFwZVxyXG5cclxuXHRcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xyXG5cdFx0XHQvL3ZlcnQgPSBzY2FsZVB0KCBjb250b3VyWyBpIF0sIGNvbnRvdXJDZW50cm9pZCwgYnMsIGZhbHNlICk7XHJcblx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAgLSB6ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGV4cGFuZCBob2xlc1xyXG5cclxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoKysgKSB7XHJcblxyXG5cdFx0XHRhaG9sZSA9IGhvbGVzWyBoIF07XHJcblx0XHRcdG9uZUhvbGVNb3ZlbWVudHMgPSBob2xlc01vdmVtZW50c1sgaCBdO1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDAsIGlsID0gYWhvbGUubGVuZ3RoOyBpIDwgaWw7IGkrKyApIHtcclxuXHJcblx0XHRcdFx0dmVydCA9IHNjYWxlUHQyKCBhaG9sZVsgaSBdLCBvbmVIb2xlTW92ZW1lbnRzWyBpIF0sIGJzICk7XHJcblx0XHRcdFx0Ly92ZXJ0ID0gc2NhbGVQdCggYWhvbGVbIGkgXSwgaG9sZXNDZW50cm9pZHNbIGggXSwgYnMsIHRydWUgKTtcclxuXHJcblx0XHRcdFx0diggdmVydC54LCB2ZXJ0LnksICAteiApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRicyA9IGJldmVsU2l6ZTtcclxuXHJcblx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xyXG5cclxuXHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0aWYgKCAhZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdHYoIHZlcnQueCwgdmVydC55LCAwICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIHYoIHZlcnQueCwgdmVydC55ICsgZXh0cnVkZVB0c1sgMCBdLnksIGV4dHJ1ZGVQdHNbIDAgXS54ICk7XHJcblxyXG5cdFx0XHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWzBdICkubXVsdGlwbHlTY2FsYXIodmVydC54KTtcclxuXHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbMF0gKS5tdWx0aXBseVNjYWxhcih2ZXJ0LnkpO1xyXG5cclxuXHRcdFx0cG9zaXRpb24yLmNvcHkoIGV4dHJ1ZGVQdHNbMF0gKS5hZGQobm9ybWFsKS5hZGQoYmlub3JtYWwpO1xyXG5cclxuXHRcdFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBBZGQgc3RlcHBlZCB2ZXJ0aWNlcy4uLlxyXG5cdC8vIEluY2x1ZGluZyBmcm9udCBmYWNpbmcgdmVydGljZXNcclxuXHJcblx0dmFyIHM7XHJcblxyXG5cdGZvciAoIHMgPSAxOyBzIDw9IHN0ZXBzOyBzICsrICkge1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgdmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoICFleHRydWRlQnlQYXRoICkge1xyXG5cclxuXHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50IC8gc3RlcHMgKiBzICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHQvLyB2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueSwgZXh0cnVkZVB0c1sgcyAtIDEgXS54ICk7XHJcblxyXG5cdFx0XHRcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbc10gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XHJcblx0XHRcdFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbc10gKS5tdWx0aXBseVNjYWxhciggdmVydC55ICk7XHJcblxyXG5cdFx0XHRcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzW3NdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XHJcblxyXG5cdFx0XHRcdHYoIHBvc2l0aW9uMi54LCBwb3NpdGlvbjIueSwgcG9zaXRpb24yLnogKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIEFkZCBiZXZlbCBzZWdtZW50cyBwbGFuZXNcclxuXHJcblx0Ly9mb3IgKCBiID0gMTsgYiA8PSBiZXZlbFNlZ21lbnRzOyBiICsrICkge1xyXG5cdGZvciAoIGIgPSBiZXZlbFNlZ21lbnRzIC0gMTsgYiA+PSAwOyBiIC0tICkge1xyXG5cclxuXHRcdHQgPSBiIC8gYmV2ZWxTZWdtZW50cztcclxuXHRcdHogPSBiZXZlbFRoaWNrbmVzcyAqICggMSAtIHQgKTtcclxuXHRcdC8vYnMgPSBiZXZlbFNpemUgKiAoIDEtTWF0aC5zaW4gKCAoIDEgLSB0ICkgKiBNYXRoLlBJLzIgKSApO1xyXG5cdFx0YnMgPSBiZXZlbFNpemUgKiBNYXRoLnNpbiAoIHQgKiBNYXRoLlBJLzIgKSA7XHJcblxyXG5cdFx0Ly8gY29udHJhY3Qgc2hhcGVcclxuXHJcblx0XHRmb3IgKCBpID0gMCwgaWwgPSBjb250b3VyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHRcdFx0diggdmVydC54LCB2ZXJ0LnksICBhbW91bnQgKyB6ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGV4cGFuZCBob2xlc1xyXG5cclxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xyXG5cclxuXHRcdFx0YWhvbGUgPSBob2xlc1sgaCBdO1xyXG5cdFx0XHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwLCBpbCA9IGFob2xlLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcclxuXHJcblx0XHRcdFx0aWYgKCAhZXh0cnVkZUJ5UGF0aCApIHtcclxuXHJcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSwgIGFtb3VudCArIHogKTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHR2KCB2ZXJ0LngsIHZlcnQueSArIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHN0ZXBzIC0gMSBdLnggKyB6ICk7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0LyogRmFjZXMgKi9cclxuXHJcblx0Ly8gVG9wIGFuZCBib3R0b20gZmFjZXNcclxuXHJcblx0YnVpbGRMaWRGYWNlcygpO1xyXG5cclxuXHQvLyBTaWRlcyBmYWNlc1xyXG5cclxuXHRidWlsZFNpZGVGYWNlcygpO1xyXG5cclxuXHJcblx0Ly8vLy8gIEludGVybmFsIGZ1bmN0aW9uc1xyXG5cclxuXHRmdW5jdGlvbiBidWlsZExpZEZhY2VzKCkge1xyXG5cclxuXHRcdGlmICggYmV2ZWxFbmFibGVkICkge1xyXG5cclxuXHRcdFx0dmFyIGxheWVyID0gMCA7IC8vIHN0ZXBzICsgMVxyXG5cdFx0XHR2YXIgb2Zmc2V0ID0gdmxlbiAqIGxheWVyO1xyXG5cclxuXHRcdFx0Ly8gQm90dG9tIGZhY2VzXHJcblxyXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdGYzKCBmYWNlWyAyIF0rIG9mZnNldCwgZmFjZVsgMSBdKyBvZmZzZXQsIGZhY2VbIDAgXSArIG9mZnNldCwgdHJ1ZSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xyXG5cdFx0XHRvZmZzZXQgPSB2bGVuICogbGF5ZXI7XHJcblxyXG5cdFx0XHQvLyBUb3AgZmFjZXNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQsIGZhbHNlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdC8vIEJvdHRvbSBmYWNlc1xyXG5cclxuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpKysgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2UgPSBmYWNlc1sgaSBdO1xyXG5cdFx0XHRcdGYzKCBmYWNlWyAyIF0sIGZhY2VbIDEgXSwgZmFjZVsgMCBdLCB0cnVlICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBUb3AgZmFjZXNcclxuXHJcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZmxlbjsgaSArKyApIHtcclxuXHJcblx0XHRcdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblx0XHRcdFx0ZjMoIGZhY2VbIDAgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMSBdICsgdmxlbiAqIHN0ZXBzLCBmYWNlWyAyIF0gKyB2bGVuICogc3RlcHMsIGZhbHNlICk7XHJcblxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQ3JlYXRlIGZhY2VzIGZvciB0aGUgei1zaWRlcyBvZiB0aGUgc2hhcGVcclxuXHJcblx0ZnVuY3Rpb24gYnVpbGRTaWRlRmFjZXMoKSB7XHJcblxyXG5cdFx0dmFyIGxheWVyb2Zmc2V0ID0gMDtcclxuXHRcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcclxuXHRcdGxheWVyb2Zmc2V0ICs9IGNvbnRvdXIubGVuZ3RoO1xyXG5cclxuXHRcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgIGggPCBobDsgaCArKyApIHtcclxuXHJcblx0XHRcdGFob2xlID0gaG9sZXNbIGggXTtcclxuXHRcdFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcclxuXHJcblx0XHRcdC8vLCB0cnVlXHJcblx0XHRcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2lkZXdhbGxzKCBjb250b3VyLCBsYXllcm9mZnNldCApIHtcclxuXHJcblx0XHR2YXIgaiwgaztcclxuXHRcdGkgPSBjb250b3VyLmxlbmd0aDtcclxuXHJcblx0XHR3aGlsZSAoIC0taSA+PSAwICkge1xyXG5cclxuXHRcdFx0aiA9IGk7XHJcblx0XHRcdGsgPSBpIC0gMTtcclxuXHRcdFx0aWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdiJywgaSxqLCBpLTEsIGssdmVydGljZXMubGVuZ3RoKTtcclxuXHJcblx0XHRcdHZhciBzID0gMCwgc2wgPSBzdGVwcyAgKyBiZXZlbFNlZ21lbnRzICogMjtcclxuXHJcblx0XHRcdGZvciAoIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzbGVuMSA9IHZsZW4gKiBzO1xyXG5cdFx0XHRcdHZhciBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XHJcblxyXG5cdFx0XHRcdHZhciBhID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjEsXHJcblx0XHRcdFx0XHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXHJcblx0XHRcdFx0XHRjID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjIsXHJcblx0XHRcdFx0XHRkID0gbGF5ZXJvZmZzZXQgKyBqICsgc2xlbjI7XHJcblxyXG5cdFx0XHRcdGY0KCBhLCBiLCBjLCBkLCBjb250b3VyLCBzLCBzbCwgaiwgayApO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiB2KCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBmMyggYSwgYiwgYywgaXNCb3R0b20gKSB7XHJcblxyXG5cdFx0YSArPSBzaGFwZXNPZmZzZXQ7XHJcblx0XHRiICs9IHNoYXBlc09mZnNldDtcclxuXHRcdGMgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cclxuXHRcdC8vIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsXHJcblx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIGEsIGIsIGMsIG51bGwsIG51bGwsIG1hdGVyaWFsICkgKTtcclxuXHJcblx0XHR2YXIgdXZzID0gaXNCb3R0b20gPyB1dmdlbi5nZW5lcmF0ZUJvdHRvbVVWKCBzY29wZSwgc2hhcGUsIG9wdGlvbnMsIGEsIGIsIGMgKSA6IHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHNjb3BlLCBzaGFwZSwgb3B0aW9ucywgYSwgYiwgYyApO1xyXG5cclxuIFx0XHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggdXZzICk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZjQoIGEsIGIsIGMsIGQsIHdhbGxDb250b3VyLCBzdGVwSW5kZXgsIHN0ZXBzTGVuZ3RoLCBjb250b3VySW5kZXgxLCBjb250b3VySW5kZXgyICkge1xyXG5cclxuXHRcdGEgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cdFx0YiArPSBzaGFwZXNPZmZzZXQ7XHJcblx0XHRjICs9IHNoYXBlc09mZnNldDtcclxuXHRcdGQgKz0gc2hhcGVzT2Zmc2V0O1xyXG5cclxuIFx0XHRzY29wZS5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTQoIGEsIGIsIGMsIGQsIG51bGwsIG51bGwsIGV4dHJ1ZGVNYXRlcmlhbCApICk7XHJcblxyXG4gXHRcdHZhciB1dnMgPSB1dmdlbi5nZW5lcmF0ZVNpZGVXYWxsVVYoIHNjb3BlLCBzaGFwZSwgd2FsbENvbnRvdXIsIG9wdGlvbnMsIGEsIGIsIGMsIGQsXHJcbiBcdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcEluZGV4LCBzdGVwc0xlbmd0aCwgY29udG91ckluZGV4MSwgY29udG91ckluZGV4MiApO1xyXG4gXHRcdHNjb3BlLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dnMgKTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yID0ge1xyXG5cclxuXHRnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiggZ2VvbWV0cnksIGV4dHJ1ZGVkU2hhcGUsIGV4dHJ1ZGVPcHRpb25zLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xyXG5cdFx0dmFyIGF4ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QSBdLngsXHJcblx0XHRcdGF5ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QSBdLnksXHJcblxyXG5cdFx0XHRieCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEIgXS54LFxyXG5cdFx0XHRieSA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEIgXS55LFxyXG5cclxuXHRcdFx0Y3ggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhDIF0ueCxcclxuXHRcdFx0Y3kgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhDIF0ueTtcclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYXgsIGF5ICksXHJcblx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBieCwgYnkgKSxcclxuXHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGN4LCBjeSApXHJcblx0XHRdO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZUJvdHRvbVVWOiBmdW5jdGlvbiggZ2VvbWV0cnksIGV4dHJ1ZGVkU2hhcGUsIGV4dHJ1ZGVPcHRpb25zLCBpbmRleEEsIGluZGV4QiwgaW5kZXhDICkge1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlVG9wVVYoIGdlb21ldHJ5LCBleHRydWRlZFNoYXBlLCBleHRydWRlT3B0aW9ucywgaW5kZXhBLCBpbmRleEIsIGluZGV4QyApO1xyXG5cclxuXHR9LFxyXG5cclxuXHRnZW5lcmF0ZVNpZGVXYWxsVVY6IGZ1bmN0aW9uKCBnZW9tZXRyeSwgZXh0cnVkZWRTaGFwZSwgd2FsbENvbnRvdXIsIGV4dHJ1ZGVPcHRpb25zLFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCwgc3RlcEluZGV4LCBzdGVwc0xlbmd0aCxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250b3VySW5kZXgxLCBjb250b3VySW5kZXgyICkge1xyXG5cclxuXHRcdHZhciBheCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEEgXS54LFxyXG5cdFx0XHRheSA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEEgXS55LFxyXG5cdFx0XHRheiA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEEgXS56LFxyXG5cclxuXHRcdFx0YnggPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhCIF0ueCxcclxuXHRcdFx0YnkgPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhCIF0ueSxcclxuXHRcdFx0YnogPSBnZW9tZXRyeS52ZXJ0aWNlc1sgaW5kZXhCIF0ueixcclxuXHJcblx0XHRcdGN4ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QyBdLngsXHJcblx0XHRcdGN5ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QyBdLnksXHJcblx0XHRcdGN6ID0gZ2VvbWV0cnkudmVydGljZXNbIGluZGV4QyBdLnosXHJcblxyXG5cdFx0XHRkeCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEQgXS54LFxyXG5cdFx0XHRkeSA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEQgXS55LFxyXG5cdFx0XHRkeiA9IGdlb21ldHJ5LnZlcnRpY2VzWyBpbmRleEQgXS56O1xyXG5cclxuXHRcdGlmICggTWF0aC5hYnMoIGF5IC0gYnkgKSA8IDAuMDEgKSB7XHJcblx0XHRcdHJldHVybiBbXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGF4LCAxIC0gYXogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYngsIDEgLSBieiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBjeCwgMSAtIGN6ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGR4LCAxIC0gZHogKVxyXG5cdFx0XHRdO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFtcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggYXksIDEgLSBheiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBieSwgMSAtIGJ6ICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIGN5LCAxIC0gY3ogKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggZHksIDEgLSBkeiApXHJcblx0XHRcdF07XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjEgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192MiA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3YzID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuVEhSRUUuRXh0cnVkZUdlb21ldHJ5Ll9fdjQgPSBuZXcgVEhSRUUuVmVjdG9yMigpO1xyXG5USFJFRS5FeHRydWRlR2VvbWV0cnkuX192NSA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XHJcblRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5fX3Y2ID0gbmV3IFRIUkVFLlZlY3RvcjIoKTtcclxuLyoqXHJcbiAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHA6Ly9qb25vYnIxLmNvbVxyXG4gKlxyXG4gKiBDcmVhdGVzIGEgb25lLXNpZGVkIHBvbHlnb25hbCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS4gU2ltaWxhciB0b1xyXG4gKiBFeHRydWRlR2VvbWV0cnkuXHJcbiAqXHJcbiAqIHBhcmFtZXRlcnMgPSB7XHJcbiAqXHJcbiAqXHRjdXJ2ZVNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIHBvaW50cyBvbiB0aGUgY3VydmVzLiBOT1QgVVNFRCBBVCBUSEUgTU9NRU5ULlxyXG4gKlxyXG4gKlx0bWF0ZXJpYWw6IDxpbnQ+IC8vIG1hdGVyaWFsIGluZGV4IGZvciBmcm9udCBhbmQgYmFjayBmYWNlc1xyXG4gKlx0dXZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcclxuICpcclxuICogfVxyXG4gKiovXHJcblxyXG5USFJFRS5TaGFwZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0aWYgKCBzaGFwZXMgaW5zdGFuY2VvZiBBcnJheSA9PT0gZmFsc2UgKSBzaGFwZXMgPSBbIHNoYXBlcyBdO1xyXG5cclxuXHR0aGlzLnNoYXBlYmIgPSBzaGFwZXNbIHNoYXBlcy5sZW5ndGggLSAxIF0uZ2V0Qm91bmRpbmdCb3goKTtcclxuXHJcblx0dGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcblxyXG4vKipcclxuICogQWRkIGFuIGFycmF5IG9mIHNoYXBlcyB0byBUSFJFRS5TaGFwZUdlb21ldHJ5LlxyXG4gKi9cclxuVEhSRUUuU2hhcGVHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XHJcblxyXG5cdFx0dGhpcy5hZGRTaGFwZSggc2hhcGVzWyBpIF0sIG9wdGlvbnMgKTtcclxuXHJcblx0fVxyXG5cclxuXHRyZXR1cm4gdGhpcztcclxuXHJcbn07XHJcblxyXG4vKipcclxuICogQWRkcyBhIHNoYXBlIHRvIFRIUkVFLlNoYXBlR2VvbWV0cnksIGJhc2VkIG9uIFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5cclxuICovXHJcblRIUkVFLlNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKCBzaGFwZSwgb3B0aW9ucyApIHtcclxuXHJcblx0aWYgKCBvcHRpb25zID09PSB1bmRlZmluZWQgKSBvcHRpb25zID0ge307XHJcblx0dmFyIGN1cnZlU2VnbWVudHMgPSBvcHRpb25zLmN1cnZlU2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3VydmVTZWdtZW50cyA6IDEyO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBvcHRpb25zLm1hdGVyaWFsO1xyXG5cdHZhciB1dmdlbiA9IG9wdGlvbnMuVVZHZW5lcmF0b3IgPT09IHVuZGVmaW5lZCA/IFRIUkVFLkV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yIDogb3B0aW9ucy5VVkdlbmVyYXRvcjtcclxuXHJcblx0dmFyIHNoYXBlYmIgPSB0aGlzLnNoYXBlYmI7XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciBpLCBsLCBob2xlLCBzO1xyXG5cclxuXHR2YXIgc2hhcGVzT2Zmc2V0ID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGg7XHJcblx0dmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xyXG5cclxuXHR2YXIgdmVydGljZXMgPSBzaGFwZVBvaW50cy5zaGFwZTtcclxuXHR2YXIgaG9sZXMgPSBzaGFwZVBvaW50cy5ob2xlcztcclxuXHJcblx0dmFyIHJldmVyc2UgPSAhVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIHZlcnRpY2VzICk7XHJcblxyXG5cdGlmICggcmV2ZXJzZSApIHtcclxuXHJcblx0XHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcclxuXHJcblx0XHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlLi4uXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGwgPSBob2xlcy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XHJcblxyXG5cdFx0XHRob2xlID0gaG9sZXNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggVEhSRUUuU2hhcGUuVXRpbHMuaXNDbG9ja1dpc2UoIGhvbGUgKSApIHtcclxuXHJcblx0XHRcdFx0aG9sZXNbIGkgXSA9IGhvbGUucmV2ZXJzZSgpO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHRyZXZlcnNlID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcblx0dmFyIGZhY2VzID0gVEhSRUUuU2hhcGUuVXRpbHMudHJpYW5ndWxhdGVTaGFwZSggdmVydGljZXMsIGhvbGVzICk7XHJcblxyXG5cdC8vIFZlcnRpY2VzXHJcblxyXG5cdHZhciBjb250b3VyID0gdmVydGljZXM7XHJcblxyXG5cdGZvciAoIGkgPSAwLCBsID0gaG9sZXMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xyXG5cclxuXHRcdGhvbGUgPSBob2xlc1sgaSBdO1xyXG5cdFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGhvbGUgKTtcclxuXHJcblx0fVxyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgdmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aDtcclxuXHR2YXIgZmFjZSwgZmxlbiA9IGZhY2VzLmxlbmd0aDtcclxuXHR2YXIgY29udCwgY2xlbiA9IGNvbnRvdXIubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkrKyApIHtcclxuXHJcblx0XHR2ZXJ0ID0gdmVydGljZXNbIGkgXTtcclxuXHJcblx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB2ZXJ0LngsIHZlcnQueSwgMCApICk7XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpKysgKSB7XHJcblxyXG5cdFx0ZmFjZSA9IGZhY2VzWyBpIF07XHJcblxyXG5cdFx0dmFyIGEgPSBmYWNlWyAwIF0gKyBzaGFwZXNPZmZzZXQ7XHJcblx0XHR2YXIgYiA9IGZhY2VbIDEgXSArIHNoYXBlc09mZnNldDtcclxuXHRcdHZhciBjID0gZmFjZVsgMiBdICsgc2hhcGVzT2Zmc2V0O1xyXG5cclxuXHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBhLCBiLCBjLCBudWxsLCBudWxsLCBtYXRlcmlhbCApICk7XHJcblx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCB1dmdlbi5nZW5lcmF0ZUJvdHRvbVVWKCB0aGlzLCBzaGFwZSwgb3B0aW9ucywgYSwgYiwgYyApICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFzdHJvZHVkIC8gaHR0cDovL2FzdHJvZHVkLmlzZ3JlYXQub3JnL1xyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2V4b2NvcnRleC5jb21cclxuICovXHJcblxyXG4vLyBwb2ludHMgLSB0byBjcmVhdGUgYSBjbG9zZWQgdG9ydXMsIG9uZSBtdXN0IHVzZSBhIHNldCBvZiBwb2ludHMgXHJcbi8vICAgIGxpa2Ugc286IFsgYSwgYiwgYywgZCwgYSBdLCBzZWUgZmlyc3QgaXMgdGhlIHNhbWUgYXMgbGFzdC5cclxuLy8gc2VnbWVudHMgLSB0aGUgbnVtYmVyIG9mIGNpcmN1bWZlcmVuY2Ugc2VnbWVudHMgdG8gY3JlYXRlXHJcbi8vIHBoaVN0YXJ0IC0gdGhlIHN0YXJ0aW5nIHJhZGlhblxyXG4vLyBwaGlMZW5ndGggLSB0aGUgcmFkaWFuICgwIHRvIDIqUEkpIHJhbmdlIG9mIHRoZSBsYXRoZWQgc2VjdGlvblxyXG4vLyAgICAyKnBpIGlzIGEgY2xvc2VkIGxhdGhlLCBsZXNzIHRoYW4gMlBJIGlzIGEgcG9ydGlvbi5cclxuVEhSRUUuTGF0aGVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHRzZWdtZW50cyA9IHNlZ21lbnRzIHx8IDEyO1xyXG5cdHBoaVN0YXJ0ID0gcGhpU3RhcnQgfHwgMDtcclxuXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggfHwgMiAqIE1hdGguUEk7XHJcblxyXG5cdHZhciBpbnZlcnNlUG9pbnRMZW5ndGggPSAxLjAgLyAoIHBvaW50cy5sZW5ndGggLSAxICk7XHJcblx0dmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPD0gaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHBoaSA9IHBoaVN0YXJ0ICsgaSAqIGludmVyc2VTZWdtZW50cyAqIHBoaUxlbmd0aDtcclxuXHJcblx0XHR2YXIgYyA9IE1hdGguY29zKCBwaGkgKSxcclxuXHRcdFx0cyA9IE1hdGguc2luKCBwaGkgKTtcclxuXHJcblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHB0ID0gcG9pbnRzWyBqIF07XHJcblxyXG5cdFx0XHR2YXIgdmVydGV4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRcdHZlcnRleC54ID0gYyAqIHB0LnggLSBzICogcHQueTtcclxuXHRcdFx0dmVydGV4LnkgPSBzICogcHQueCArIGMgKiBwdC55O1xyXG5cdFx0XHR2ZXJ0ZXgueiA9IHB0Lno7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR2YXIgbnAgPSBwb2ludHMubGVuZ3RoO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc2VnbWVudHM7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gcG9pbnRzLmxlbmd0aCAtIDE7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdHZhciBiYXNlID0gaiArIG5wICogaTtcclxuXHRcdFx0dmFyIGEgPSBiYXNlO1xyXG5cdFx0XHR2YXIgYiA9IGJhc2UgKyBucDtcclxuXHRcdFx0dmFyIGMgPSBiYXNlICsgMSArIG5wO1xyXG5cdFx0XHR2YXIgZCA9IGJhc2UgKyAxO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTQoIGEsIGIsIGMsIGQgKSApO1xyXG5cclxuXHRcdFx0dmFyIHUwID0gaSAqIGludmVyc2VTZWdtZW50cztcclxuXHRcdFx0dmFyIHYwID0gaiAqIGludmVyc2VQb2ludExlbmd0aDtcclxuXHRcdFx0dmFyIHUxID0gdTAgKyBpbnZlcnNlU2VnbWVudHM7XHJcblx0XHRcdHZhciB2MSA9IHYwICsgaW52ZXJzZVBvaW50TGVuZ3RoO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTAsIHYwICksIFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCB1MSwgdjAgKSxcclxuXHRcdFx0XHRuZXcgVEhSRUUuVmVjdG9yMiggdTEsIHYxICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoIHUwLCB2MSApXHJcblxyXG5cdFx0XHRdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkxhdGhlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vcGFwZXJ2aXNpb24zZC5nb29nbGVjb2RlLmNvbS9zdm4vdHJ1bmsvYXMzL3RydW5rL3NyYy9vcmcvcGFwZXJ2aXNpb24zZC9vYmplY3RzL3ByaW1pdGl2ZXMvUGxhbmUuYXNcclxuICovXHJcblxyXG5USFJFRS5QbGFuZUdlb21ldHJ5ID0gZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLndpZHRoID0gd2lkdGg7XHJcblx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG5cdHRoaXMud2lkdGhTZWdtZW50cyA9IHdpZHRoU2VnbWVudHMgfHwgMTtcclxuXHR0aGlzLmhlaWdodFNlZ21lbnRzID0gaGVpZ2h0U2VnbWVudHMgfHwgMTtcclxuXHJcblx0dmFyIGl4LCBpejtcclxuXHR2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcclxuXHR2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xyXG5cclxuXHR2YXIgZ3JpZFggPSB0aGlzLndpZHRoU2VnbWVudHM7XHJcblx0dmFyIGdyaWRaID0gdGhpcy5oZWlnaHRTZWdtZW50cztcclxuXHJcblx0dmFyIGdyaWRYMSA9IGdyaWRYICsgMTtcclxuXHR2YXIgZ3JpZFoxID0gZ3JpZFogKyAxO1xyXG5cclxuXHR2YXIgc2VnbWVudF93aWR0aCA9IHRoaXMud2lkdGggLyBncmlkWDtcclxuXHR2YXIgc2VnbWVudF9oZWlnaHQgPSB0aGlzLmhlaWdodCAvIGdyaWRaO1xyXG5cclxuXHR2YXIgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIDEgKTtcclxuXHJcblx0Zm9yICggaXogPSAwOyBpeiA8IGdyaWRaMTsgaXogKysgKSB7XHJcblxyXG5cdFx0Zm9yICggaXggPSAwOyBpeCA8IGdyaWRYMTsgaXggKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgeCA9IGl4ICogc2VnbWVudF93aWR0aCAtIHdpZHRoX2hhbGY7XHJcblx0XHRcdHZhciB5ID0gaXogKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xyXG5cclxuXHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgLSB5LCAwICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggaXogPSAwOyBpeiA8IGdyaWRaOyBpeiArKyApIHtcclxuXHJcblx0XHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl6O1xyXG5cdFx0XHR2YXIgYiA9IGl4ICsgZ3JpZFgxICogKCBpeiArIDEgKTtcclxuXHRcdFx0dmFyIGMgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogKCBpeiArIDEgKTtcclxuXHRcdFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXo7XHJcblxyXG5cdFx0XHR2YXIgZmFjZSA9IG5ldyBUSFJFRS5GYWNlNCggYSwgYiwgYywgZCApO1xyXG5cdFx0XHRmYWNlLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcclxuXHRcdFx0ZmFjZS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbC5jbG9uZSgpLCBub3JtYWwuY2xvbmUoKSwgbm9ybWFsLmNsb25lKCksIG5vcm1hbC5jbG9uZSgpICk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggW1xyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gaXogLyBncmlkWiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCBpeCAvIGdyaWRYLCAxIC0gKCBpeiArIDEgKSAvIGdyaWRaICksXHJcblx0XHRcdFx0bmV3IFRIUkVFLlZlY3RvcjIoICggaXggKyAxICkgLyBncmlkWCwgMSAtICggaXogKyAxICkgLyBncmlkWiApLFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IyKCAoIGl4ICsgMSApIC8gZ3JpZFgsIDEgLSBpeiAvIGdyaWRaIClcclxuXHRcdFx0XSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QbGFuZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcGhlcmVHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgNTA7XHJcblxyXG5cdHRoaXMud2lkdGhTZWdtZW50cyA9IE1hdGgubWF4KCAzLCBNYXRoLmZsb29yKCB3aWR0aFNlZ21lbnRzICkgfHwgOCApO1xyXG5cdHRoaXMuaGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCA2ICk7XHJcblxyXG5cdHBoaVN0YXJ0ID0gcGhpU3RhcnQgIT09IHVuZGVmaW5lZCA/IHBoaVN0YXJ0IDogMDtcclxuXHRwaGlMZW5ndGggPSBwaGlMZW5ndGggIT09IHVuZGVmaW5lZCA/IHBoaUxlbmd0aCA6IE1hdGguUEkgKiAyO1xyXG5cclxuXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XHJcblx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJO1xyXG5cclxuXHR2YXIgeCwgeSwgdmVydGljZXMgPSBbXSwgdXZzID0gW107XHJcblxyXG5cdGZvciAoIHkgPSAwOyB5IDw9IHRoaXMuaGVpZ2h0U2VnbWVudHM7IHkgKysgKSB7XHJcblxyXG5cdFx0dmFyIHZlcnRpY2VzUm93ID0gW107XHJcblx0XHR2YXIgdXZzUm93ID0gW107XHJcblxyXG5cdFx0Zm9yICggeCA9IDA7IHggPD0gdGhpcy53aWR0aFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHUgPSB4IC8gdGhpcy53aWR0aFNlZ21lbnRzO1xyXG5cdFx0XHR2YXIgdiA9IHkgLyB0aGlzLmhlaWdodFNlZ21lbnRzO1xyXG5cclxuXHRcdFx0dmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0XHRcdHZlcnRleC54ID0gLSB0aGlzLnJhZGl1cyAqIE1hdGguY29zKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XHJcblx0XHRcdHZlcnRleC55ID0gdGhpcy5yYWRpdXMgKiBNYXRoLmNvcyggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xyXG5cdFx0XHR2ZXJ0ZXgueiA9IHRoaXMucmFkaXVzICogTWF0aC5zaW4oIHBoaVN0YXJ0ICsgdSAqIHBoaUxlbmd0aCApICogTWF0aC5zaW4oIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcclxuXHJcblx0XHRcdHRoaXMudmVydGljZXMucHVzaCggdmVydGV4ICk7XHJcblxyXG5cdFx0XHR2ZXJ0aWNlc1Jvdy5wdXNoKCB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIDEgKTtcclxuXHRcdFx0dXZzUm93LnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCB1LCAxIC0gdiApICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZlcnRpY2VzLnB1c2goIHZlcnRpY2VzUm93ICk7XHJcblx0XHR1dnMucHVzaCggdXZzUm93ICk7XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggeSA9IDA7IHkgPCB0aGlzLmhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xyXG5cclxuXHRcdGZvciAoIHggPSAwOyB4IDwgdGhpcy53aWR0aFNlZ21lbnRzOyB4ICsrICkge1xyXG5cclxuXHRcdFx0dmFyIHYxID0gdmVydGljZXNbIHkgXVsgeCArIDEgXTtcclxuXHRcdFx0dmFyIHYyID0gdmVydGljZXNbIHkgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjMgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCBdO1xyXG5cdFx0XHR2YXIgdjQgPSB2ZXJ0aWNlc1sgeSArIDEgXVsgeCArIDEgXTtcclxuXHJcblx0XHRcdHZhciBuMSA9IHRoaXMudmVydGljZXNbIHYxIF0uY2xvbmUoKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0dmFyIG4yID0gdGhpcy52ZXJ0aWNlc1sgdjIgXS5jbG9uZSgpLm5vcm1hbGl6ZSgpO1xyXG5cdFx0XHR2YXIgbjMgPSB0aGlzLnZlcnRpY2VzWyB2MyBdLmNsb25lKCkubm9ybWFsaXplKCk7XHJcblx0XHRcdHZhciBuNCA9IHRoaXMudmVydGljZXNbIHY0IF0uY2xvbmUoKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdHZhciB1djEgPSB1dnNbIHkgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYyID0gdXZzWyB5IF1bIHggXS5jbG9uZSgpO1xyXG5cdFx0XHR2YXIgdXYzID0gdXZzWyB5ICsgMSBdWyB4IF0uY2xvbmUoKTtcclxuXHRcdFx0dmFyIHV2NCA9IHV2c1sgeSArIDEgXVsgeCArIDEgXS5jbG9uZSgpO1xyXG5cclxuXHRcdFx0aWYgKCBNYXRoLmFicyggdGhpcy52ZXJ0aWNlc1sgdjEgXS55ICkgPT09IHRoaXMucmFkaXVzICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYzLCB2NCwgWyBuMSwgbjMsIG40IF0gKSApO1xyXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djMsIHV2NCBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBNYXRoLmFicyggdGhpcy52ZXJ0aWNlc1sgdjMgXS55ICkgPT09IHRoaXMucmFkaXVzICkge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggdjEsIHYyLCB2MywgWyBuMSwgbjIsIG4zIF0gKSApO1xyXG5cdFx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXYxLCB1djIsIHV2MyBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHR0aGlzLmZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlNCggdjEsIHYyLCB2MywgdjQsIFsgbjEsIG4yLCBuMywgbjQgXSApICk7XHJcblx0XHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1djEsIHV2MiwgdXYzLCB1djQgXSApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5TcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICogRm9yIGNyZWF0aW5nIDNEIHRleHQgZ2VvbWV0cnkgaW4gdGhyZWUuanNcclxuICpcclxuICogVGV4dCA9IDNEIFRleHRcclxuICpcclxuICogcGFyYW1ldGVycyA9IHtcclxuICogIHNpemU6IFx0XHRcdDxmbG9hdD4sIFx0Ly8gc2l6ZSBvZiB0aGUgdGV4dFxyXG4gKiAgaGVpZ2h0OiBcdFx0PGZsb2F0PiwgXHQvLyB0aGlja25lc3MgdG8gZXh0cnVkZSB0ZXh0XHJcbiAqICBjdXJ2ZVNlZ21lbnRzOiBcdDxpbnQ+LFx0XHQvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcclxuICpcclxuICogIGZvbnQ6IFx0XHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IG5hbWVcclxuICogIHdlaWdodDogXHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IHdlaWdodCAobm9ybWFsLCBib2xkKVxyXG4gKiAgc3R5bGU6IFx0XHRcdDxzdHJpbmc+LFx0XHQvLyBmb250IHN0eWxlICAobm9ybWFsLCBpdGFsaWNzKVxyXG4gKlxyXG4gKiAgYmV2ZWxFbmFibGVkOlx0PGJvb2w+LFx0XHRcdC8vIHR1cm4gb24gYmV2ZWxcclxuICogIGJldmVsVGhpY2tuZXNzOiA8ZmxvYXQ+LCBcdFx0Ly8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcclxuICogIGJldmVsU2l6ZTpcdFx0PGZsb2F0PiwgXHRcdC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgaXMgYmV2ZWxcclxuICogIH1cclxuICpcclxuICovXHJcblxyXG4vKlx0VXNhZ2UgRXhhbXBsZXNcclxuXHJcblx0Ly8gVGV4dEdlb21ldHJ5IHdyYXBwZXJcclxuXHJcblx0dmFyIHRleHQzZCA9IG5ldyBUZXh0R2VvbWV0cnkoIHRleHQsIG9wdGlvbnMgKTtcclxuXHJcblx0Ly8gQ29tcGxldGUgbWFubmVyXHJcblxyXG5cdHZhciB0ZXh0U2hhcGVzID0gVEhSRUUuRm9udFV0aWxzLmdlbmVyYXRlU2hhcGVzKCB0ZXh0LCBvcHRpb25zICk7XHJcblx0dmFyIHRleHQzZCA9IG5ldyBFeHRydWRlR2VvbWV0cnkoIHRleHRTaGFwZXMsIG9wdGlvbnMgKTtcclxuXHJcbiovXHJcblxyXG5cclxuVEhSRUUuVGV4dEdlb21ldHJ5ID0gZnVuY3Rpb24gKCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xyXG5cclxuXHR2YXIgdGV4dFNoYXBlcyA9IFRIUkVFLkZvbnRVdGlscy5nZW5lcmF0ZVNoYXBlcyggdGV4dCwgcGFyYW1ldGVycyApO1xyXG5cclxuXHQvLyB0cmFuc2xhdGUgcGFyYW1ldGVycyB0byBFeHRydWRlR2VvbWV0cnkgQVBJXHJcblxyXG5cdHBhcmFtZXRlcnMuYW1vdW50ID0gcGFyYW1ldGVycy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaGVpZ2h0IDogNTA7XHJcblxyXG5cdC8vIGRlZmF1bHRzXHJcblxyXG5cdGlmICggcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbFRoaWNrbmVzcyA9IDEwO1xyXG5cdGlmICggcGFyYW1ldGVycy5iZXZlbFNpemUgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxTaXplID0gODtcclxuXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxFbmFibGVkID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuXHRUSFJFRS5FeHRydWRlR2VvbWV0cnkuY2FsbCggdGhpcywgdGV4dFNoYXBlcywgcGFyYW1ldGVycyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlRleHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5FeHRydWRlR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG9vc21veGllY29kZVxyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKiBiYXNlZCBvbiBodHRwOi8vY29kZS5nb29nbGUuY29tL3AvYXdheTNkL3NvdXJjZS9icm93c2UvdHJ1bmsvZnAxMC9Bd2F5M0RMaXRlL3NyYy9hd2F5M2RsaXRlL3ByaW1pdGl2ZXMvVG9ydXMuYXM/cj0yODg4XHJcbiAqL1xyXG5cclxuVEhSRUUuVG9ydXNHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBhcmMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dmFyIHNjb3BlID0gdGhpcztcclxuXHJcblx0dGhpcy5yYWRpdXMgPSByYWRpdXMgfHwgMTAwO1xyXG5cdHRoaXMudHViZSA9IHR1YmUgfHwgNDA7XHJcblx0dGhpcy5yYWRpYWxTZWdtZW50cyA9IHJhZGlhbFNlZ21lbnRzIHx8IDg7XHJcblx0dGhpcy50dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgNjtcclxuXHR0aGlzLmFyYyA9IGFyYyB8fCBNYXRoLlBJICogMjtcclxuXHJcblx0dmFyIGNlbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IzKCksIHV2cyA9IFtdLCBub3JtYWxzID0gW107XHJcblxyXG5cdGZvciAoIHZhciBqID0gMDsgaiA8PSB0aGlzLnJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8PSB0aGlzLnR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciB1ID0gaSAvIHRoaXMudHVidWxhclNlZ21lbnRzICogdGhpcy5hcmM7XHJcblx0XHRcdHZhciB2ID0gaiAvIHRoaXMucmFkaWFsU2VnbWVudHMgKiBNYXRoLlBJICogMjtcclxuXHJcblx0XHRcdGNlbnRlci54ID0gdGhpcy5yYWRpdXMgKiBNYXRoLmNvcyggdSApO1xyXG5cdFx0XHRjZW50ZXIueSA9IHRoaXMucmFkaXVzICogTWF0aC5zaW4oIHUgKTtcclxuXHJcblx0XHRcdHZhciB2ZXJ0ZXggPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHR2ZXJ0ZXgueCA9ICggdGhpcy5yYWRpdXMgKyB0aGlzLnR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLmNvcyggdSApO1xyXG5cdFx0XHR2ZXJ0ZXgueSA9ICggdGhpcy5yYWRpdXMgKyB0aGlzLnR1YmUgKiBNYXRoLmNvcyggdiApICkgKiBNYXRoLnNpbiggdSApO1xyXG5cdFx0XHR2ZXJ0ZXgueiA9IHRoaXMudHViZSAqIE1hdGguc2luKCB2ICk7XHJcblxyXG5cdFx0XHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xyXG5cclxuXHRcdFx0dXZzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IyKCBpIC8gdGhpcy50dWJ1bGFyU2VnbWVudHMsIGogLyB0aGlzLnJhZGlhbFNlZ21lbnRzICkgKTtcclxuXHRcdFx0bm9ybWFscy5wdXNoKCB2ZXJ0ZXguY2xvbmUoKS5zdWIoIGNlbnRlciApLm5vcm1hbGl6ZSgpICk7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblxyXG5cdGZvciAoIHZhciBqID0gMTsgaiA8PSB0aGlzLnJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMTsgaSA8PSB0aGlzLnR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcclxuXHJcblx0XHRcdHZhciBhID0gKCB0aGlzLnR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcclxuXHRcdFx0dmFyIGIgPSAoIHRoaXMudHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XHJcblx0XHRcdHZhciBjID0gKCB0aGlzLnR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XHJcblx0XHRcdHZhciBkID0gKCB0aGlzLnR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xyXG5cclxuXHRcdFx0dmFyIGZhY2UgPSBuZXcgVEhSRUUuRmFjZTQoIGEsIGIsIGMsIGQsIFsgbm9ybWFsc1sgYSBdLCBub3JtYWxzWyBiIF0sIG5vcm1hbHNbIGMgXSwgbm9ybWFsc1sgZCBdIF0gKTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwuYWRkKCBub3JtYWxzWyBhIF0gKTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwuYWRkKCBub3JtYWxzWyBiIF0gKTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwuYWRkKCBub3JtYWxzWyBjIF0gKTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwuYWRkKCBub3JtYWxzWyBkIF0gKTtcclxuXHRcdFx0ZmFjZS5ub3JtYWwubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHR0aGlzLmZhY2VzLnB1c2goIGZhY2UgKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFsgdXZzWyBhIF0uY2xvbmUoKSwgdXZzWyBiIF0uY2xvbmUoKSwgdXZzWyBjIF0uY2xvbmUoKSwgdXZzWyBkIF0uY2xvbmUoKSBdICk7XHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5jb21wdXRlQ2VudHJvaWRzKCk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVG9ydXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3Igb29zbW94aWVjb2RlXHJcbiAqIGJhc2VkIG9uIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9hd2F5M2Qvc291cmNlL2Jyb3dzZS90cnVuay9mcDEwL0F3YXkzRC9zcmMvYXdheTNkL3ByaW1pdGl2ZXMvVG9ydXNLbm90LmFzP3NwZWM9c3ZuMjQ3MyZyPTI0NzNcclxuICovXHJcblxyXG5USFJFRS5Ub3J1c0tub3RHZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCB0dWJlLCByYWRpYWxTZWdtZW50cywgdHVidWxhclNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcblx0VEhSRUUuR2VvbWV0cnkuY2FsbCggdGhpcyApO1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzO1xyXG5cclxuXHR0aGlzLnJhZGl1cyA9IHJhZGl1cyB8fCAxMDA7XHJcblx0dGhpcy50dWJlID0gdHViZSB8fCA0MDtcclxuXHR0aGlzLnJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgNjQ7XHJcblx0dGhpcy50dWJ1bGFyU2VnbWVudHMgPSB0dWJ1bGFyU2VnbWVudHMgfHwgODtcclxuXHR0aGlzLnAgPSBwIHx8IDI7XHJcblx0dGhpcy5xID0gcSB8fCAzO1xyXG5cdHRoaXMuaGVpZ2h0U2NhbGUgPSBoZWlnaHRTY2FsZSB8fCAxO1xyXG5cdHRoaXMuZ3JpZCA9IG5ldyBBcnJheSggdGhpcy5yYWRpYWxTZWdtZW50cyApO1xyXG5cclxuXHR2YXIgdGFuZyA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dmFyIG4gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHZhciBiaXRhbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMucmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XHJcblxyXG5cdFx0dGhpcy5ncmlkWyBpIF0gPSBuZXcgQXJyYXkoIHRoaXMudHVidWxhclNlZ21lbnRzICk7XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgdGhpcy50dWJ1bGFyU2VnbWVudHM7ICsrIGogKSB7XHJcblxyXG5cdFx0XHR2YXIgdSA9IGkgLyB0aGlzLnJhZGlhbFNlZ21lbnRzICogMiAqIHRoaXMucCAqIE1hdGguUEk7XHJcblx0XHRcdHZhciB2ID0gaiAvIHRoaXMudHVidWxhclNlZ21lbnRzICogMiAqIE1hdGguUEk7XHJcblx0XHRcdHZhciBwMSA9IGdldFBvcyggdSwgdiwgdGhpcy5xLCB0aGlzLnAsIHRoaXMucmFkaXVzLCB0aGlzLmhlaWdodFNjYWxlICk7XHJcblx0XHRcdHZhciBwMiA9IGdldFBvcyggdSArIDAuMDEsIHYsIHRoaXMucSwgdGhpcy5wLCB0aGlzLnJhZGl1cywgdGhpcy5oZWlnaHRTY2FsZSApO1xyXG5cdFx0XHR2YXIgY3gsIGN5O1xyXG5cclxuXHRcdFx0dGFuZy5zdWJWZWN0b3JzKCBwMiwgcDEgKTtcclxuXHRcdFx0bi5hZGRWZWN0b3JzKCBwMiwgcDEgKTtcclxuXHJcblx0XHRcdGJpdGFuLmNyb3NzVmVjdG9ycyggdGFuZywgbiApO1xyXG5cdFx0XHRuLmNyb3NzVmVjdG9ycyggYml0YW4sIHRhbmcgKTtcclxuXHRcdFx0Yml0YW4ubm9ybWFsaXplKCk7XHJcblx0XHRcdG4ubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0XHRjeCA9IC0gdGhpcy50dWJlICogTWF0aC5jb3MoIHYgKTsgLy8gVE9ETzogSGFjazogTmVnYXRpbmcgaXQgc28gaXQgZmFjZXMgb3V0c2lkZS5cclxuXHRcdFx0Y3kgPSB0aGlzLnR1YmUgKiBNYXRoLnNpbiggdiApO1xyXG5cclxuXHRcdFx0cDEueCArPSBjeCAqIG4ueCArIGN5ICogYml0YW4ueDtcclxuXHRcdFx0cDEueSArPSBjeCAqIG4ueSArIGN5ICogYml0YW4ueTtcclxuXHRcdFx0cDEueiArPSBjeCAqIG4ueiArIGN5ICogYml0YW4uejtcclxuXHJcblx0XHRcdHRoaXMuZ3JpZFsgaSBdWyBqIF0gPSB2ZXJ0KCBwMS54LCBwMS55LCBwMS56ICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMucmFkaWFsU2VnbWVudHM7ICsrIGkgKSB7XHJcblxyXG5cdFx0Zm9yICggdmFyIGogPSAwOyBqIDwgdGhpcy50dWJ1bGFyU2VnbWVudHM7ICsrIGogKSB7XHJcblxyXG5cdFx0XHR2YXIgaXAgPSAoIGkgKyAxICkgJSB0aGlzLnJhZGlhbFNlZ21lbnRzO1xyXG5cdFx0XHR2YXIganAgPSAoIGogKyAxICkgJSB0aGlzLnR1YnVsYXJTZWdtZW50cztcclxuXHJcblx0XHRcdHZhciBhID0gdGhpcy5ncmlkWyBpIF1bIGogXTtcclxuXHRcdFx0dmFyIGIgPSB0aGlzLmdyaWRbIGlwIF1bIGogXTtcclxuXHRcdFx0dmFyIGMgPSB0aGlzLmdyaWRbIGlwIF1bIGpwIF07XHJcblx0XHRcdHZhciBkID0gdGhpcy5ncmlkWyBpIF1bIGpwIF07XHJcblxyXG5cdFx0XHR2YXIgdXZhID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyB0aGlzLnJhZGlhbFNlZ21lbnRzLCBqIC8gdGhpcy50dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdFx0dmFyIHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyB0aGlzLnJhZGlhbFNlZ21lbnRzLCBqIC8gdGhpcy50dWJ1bGFyU2VnbWVudHMgKTtcclxuXHRcdFx0dmFyIHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyB0aGlzLnJhZGlhbFNlZ21lbnRzLCAoIGogKyAxICkgLyB0aGlzLnR1YnVsYXJTZWdtZW50cyApO1xyXG5cdFx0XHR2YXIgdXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoIGkgLyB0aGlzLnJhZGlhbFNlZ21lbnRzLCAoIGogKyAxICkgLyB0aGlzLnR1YnVsYXJTZWdtZW50cyApO1xyXG5cclxuXHRcdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTQoIGEsIGIsIGMsIGQgKSApO1xyXG5cdFx0XHR0aGlzLmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbIHV2YSx1dmIsdXZjLCB1dmQgXSApO1xyXG5cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxuXHRmdW5jdGlvbiB2ZXJ0KCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdHJldHVybiBzY29wZS52ZXJ0aWNlcy5wdXNoKCBuZXcgVEhSRUUuVmVjdG9yMyggeCwgeSwgeiApICkgLSAxO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldFBvcyggdSwgdiwgaW5fcSwgaW5fcCwgcmFkaXVzLCBoZWlnaHRTY2FsZSApIHtcclxuXHJcblx0XHR2YXIgY3UgPSBNYXRoLmNvcyggdSApO1xyXG5cdFx0dmFyIGN2ID0gTWF0aC5jb3MoIHYgKTtcclxuXHRcdHZhciBzdSA9IE1hdGguc2luKCB1ICk7XHJcblx0XHR2YXIgcXVPdmVyUCA9IGluX3EgLyBpbl9wICogdTtcclxuXHRcdHZhciBjcyA9IE1hdGguY29zKCBxdU92ZXJQICk7XHJcblxyXG5cdFx0dmFyIHR4ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIDAuNSAqIGN1O1xyXG5cdFx0dmFyIHR5ID0gcmFkaXVzICogKCAyICsgY3MgKSAqIHN1ICogMC41O1xyXG5cdFx0dmFyIHR6ID0gaGVpZ2h0U2NhbGUgKiByYWRpdXMgKiBNYXRoLnNpbiggcXVPdmVyUCApICogMC41O1xyXG5cclxuXHRcdHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyggdHgsIHR5LCB0eiApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVG9ydXNLbm90R2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIEBhdXRob3IgbWluaW5nb2xkIC8gaHR0cHM6Ly9naXRodWIuY29tL21pbmluZ29sZFxyXG4gKlxyXG4gKiBNb2RpZmllZCBmcm9tIHRoZSBUb3J1c0tub3RHZW9tZXRyeSBieSBAb29zbW94aWVjb2RlXHJcbiAqXHJcbiAqIENyZWF0ZXMgYSB0dWJlIHdoaWNoIGV4dHJ1ZGVzIGFsb25nIGEgM2Qgc3BsaW5lXHJcbiAqXHJcbiAqIFVzZXMgcGFyYWxsZWwgdHJhbnNwb3J0IGZyYW1lcyBhcyBkZXNjcmliZWQgaW5cclxuICogaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXHJcbiAqL1xyXG5cclxuVEhSRUUuVHViZUdlb21ldHJ5ID0gZnVuY3Rpb24oIHBhdGgsIHNlZ21lbnRzLCByYWRpdXMsIHJhZGl1c1NlZ21lbnRzLCBjbG9zZWQsIGRlYnVnICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMucGF0aCA9IHBhdGg7XHJcblx0dGhpcy5zZWdtZW50cyA9IHNlZ21lbnRzIHx8IDY0O1xyXG5cdHRoaXMucmFkaXVzID0gcmFkaXVzIHx8IDE7XHJcblx0dGhpcy5yYWRpdXNTZWdtZW50cyA9IHJhZGl1c1NlZ21lbnRzIHx8IDg7XHJcblx0dGhpcy5jbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XHJcblxyXG5cdGlmICggZGVidWcgKSB0aGlzLmRlYnVnID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XHJcblxyXG5cdHRoaXMuZ3JpZCA9IFtdO1xyXG5cclxuXHR2YXIgc2NvcGUgPSB0aGlzLFxyXG5cclxuXHRcdHRhbmdlbnQsXHJcblx0XHRub3JtYWwsXHJcblx0XHRiaW5vcm1hbCxcclxuXHJcblx0XHRudW1wb2ludHMgPSB0aGlzLnNlZ21lbnRzICsgMSxcclxuXHJcblx0XHR4LCB5LCB6LFxyXG5cdFx0dHgsIHR5LCB0eixcclxuXHRcdHUsIHYsXHJcblxyXG5cdFx0Y3gsIGN5LFxyXG5cdFx0cG9zLCBwb3MyID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdGksIGosXHJcblx0XHRpcCwganAsXHJcblx0XHRhLCBiLCBjLCBkLFxyXG5cdFx0dXZhLCB1dmIsIHV2YywgdXZkO1xyXG5cclxuXHR2YXIgZnJhbWVzID0gbmV3IFRIUkVFLlR1YmVHZW9tZXRyeS5GcmVuZXRGcmFtZXMoIHRoaXMucGF0aCwgdGhpcy5zZWdtZW50cywgdGhpcy5jbG9zZWQgKSxcclxuXHRcdHRhbmdlbnRzID0gZnJhbWVzLnRhbmdlbnRzLFxyXG5cdFx0bm9ybWFscyA9IGZyYW1lcy5ub3JtYWxzLFxyXG5cdFx0Ymlub3JtYWxzID0gZnJhbWVzLmJpbm9ybWFscztcclxuXHJcblx0Ly8gcHJveHkgaW50ZXJuYWxzXHJcblx0dGhpcy50YW5nZW50cyA9IHRhbmdlbnRzO1xyXG5cdHRoaXMubm9ybWFscyA9IG5vcm1hbHM7XHJcblx0dGhpcy5iaW5vcm1hbHMgPSBiaW5vcm1hbHM7XHJcblxyXG5cdGZ1bmN0aW9uIHZlcnQoIHgsIHksIHogKSB7XHJcblxyXG5cdFx0cmV0dXJuIHNjb3BlLnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCB4LCB5LCB6ICkgKSAtIDE7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8vIGNvbnNydWN0IHRoZSBncmlkXHJcblxyXG5cdGZvciAoIGkgPSAwOyBpIDwgbnVtcG9pbnRzOyBpKysgKSB7XHJcblxyXG5cdFx0dGhpcy5ncmlkWyBpIF0gPSBbXTtcclxuXHJcblx0XHR1ID0gaSAvICggbnVtcG9pbnRzIC0gMSApO1xyXG5cclxuXHRcdHBvcyA9IHBhdGguZ2V0UG9pbnRBdCggdSApO1xyXG5cclxuXHRcdHRhbmdlbnQgPSB0YW5nZW50c1sgaSBdO1xyXG5cdFx0bm9ybWFsID0gbm9ybWFsc1sgaSBdO1xyXG5cdFx0Ymlub3JtYWwgPSBiaW5vcm1hbHNbIGkgXTtcclxuXHJcblx0XHRpZiAoIHRoaXMuZGVidWcgKSB7XHJcblxyXG5cdFx0XHR0aGlzLmRlYnVnLmFkZCggbmV3IFRIUkVFLkFycm93SGVscGVyKHRhbmdlbnQsIHBvcywgcmFkaXVzLCAweDAwMDBmZiApICk7XHJcblx0XHRcdHRoaXMuZGVidWcuYWRkKCBuZXcgVEhSRUUuQXJyb3dIZWxwZXIobm9ybWFsLCBwb3MsIHJhZGl1cywgMHhmZjAwMDAgKSApO1xyXG5cdFx0XHR0aGlzLmRlYnVnLmFkZCggbmV3IFRIUkVFLkFycm93SGVscGVyKGJpbm9ybWFsLCBwb3MsIHJhZGl1cywgMHgwMGZmMDAgKSApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBqID0gMDsgaiA8IHRoaXMucmFkaXVzU2VnbWVudHM7IGorKyApIHtcclxuXHJcblx0XHRcdHYgPSBqIC8gdGhpcy5yYWRpdXNTZWdtZW50cyAqIDIgKiBNYXRoLlBJO1xyXG5cclxuXHRcdFx0Y3ggPSAtdGhpcy5yYWRpdXMgKiBNYXRoLmNvcyggdiApOyAvLyBUT0RPOiBIYWNrOiBOZWdhdGluZyBpdCBzbyBpdCBmYWNlcyBvdXRzaWRlLlxyXG5cdFx0XHRjeSA9IHRoaXMucmFkaXVzICogTWF0aC5zaW4oIHYgKTtcclxuXHJcblx0XHRcdHBvczIuY29weSggcG9zICk7XHJcblx0XHRcdHBvczIueCArPSBjeCAqIG5vcm1hbC54ICsgY3kgKiBiaW5vcm1hbC54O1xyXG5cdFx0XHRwb3MyLnkgKz0gY3ggKiBub3JtYWwueSArIGN5ICogYmlub3JtYWwueTtcclxuXHRcdFx0cG9zMi56ICs9IGN4ICogbm9ybWFsLnogKyBjeSAqIGJpbm9ybWFsLno7XHJcblxyXG5cdFx0XHR0aGlzLmdyaWRbIGkgXVsgaiBdID0gdmVydCggcG9zMi54LCBwb3MyLnksIHBvczIueiApO1xyXG5cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHQvLyBjb25zdHJ1Y3QgdGhlIG1lc2hcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCB0aGlzLnNlZ21lbnRzOyBpKysgKSB7XHJcblxyXG5cdFx0Zm9yICggaiA9IDA7IGogPCB0aGlzLnJhZGl1c1NlZ21lbnRzOyBqKysgKSB7XHJcblxyXG5cdFx0XHRpcCA9ICggdGhpcy5jbG9zZWQgKSA/IChpICsgMSkgJSB0aGlzLnNlZ21lbnRzIDogaSArIDE7XHJcblx0XHRcdGpwID0gKGogKyAxKSAlIHRoaXMucmFkaXVzU2VnbWVudHM7XHJcblxyXG5cdFx0XHRhID0gdGhpcy5ncmlkWyBpIF1bIGogXTtcdFx0Ly8gKioqIE5PVCBORUNFU1NBUklMWSBQTEFOQVIgISAqKipcclxuXHRcdFx0YiA9IHRoaXMuZ3JpZFsgaXAgXVsgaiBdO1xyXG5cdFx0XHRjID0gdGhpcy5ncmlkWyBpcCBdWyBqcCBdO1xyXG5cdFx0XHRkID0gdGhpcy5ncmlkWyBpIF1bIGpwIF07XHJcblxyXG5cdFx0XHR1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHRoaXMuc2VnbWVudHMsIGogLyB0aGlzLnJhZGl1c1NlZ21lbnRzICk7XHJcblx0XHRcdHV2YiA9IG5ldyBUSFJFRS5WZWN0b3IyKCAoIGkgKyAxICkgLyB0aGlzLnNlZ21lbnRzLCBqIC8gdGhpcy5yYWRpdXNTZWdtZW50cyApO1xyXG5cdFx0XHR1dmMgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBpICsgMSApIC8gdGhpcy5zZWdtZW50cywgKCBqICsgMSApIC8gdGhpcy5yYWRpdXNTZWdtZW50cyApO1xyXG5cdFx0XHR1dmQgPSBuZXcgVEhSRUUuVmVjdG9yMiggaSAvIHRoaXMuc2VnbWVudHMsICggaiArIDEgKSAvIHRoaXMucmFkaXVzU2VnbWVudHMgKTtcclxuXHJcblx0XHRcdHRoaXMuZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2U0KCBhLCBiLCBjLCBkICkgKTtcclxuXHRcdFx0dGhpcy5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB1dmEsIHV2YiwgdXZjLCB1dmQgXSApO1xyXG5cclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLlR1YmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuXHJcblxyXG4vLyBGb3IgY29tcHV0aW5nIG9mIEZyZW5ldCBmcmFtZXMsIGV4cG9zaW5nIHRoZSB0YW5nZW50cywgbm9ybWFscyBhbmQgYmlub3JtYWxzIHRoZSBzcGxpbmVcclxuVEhSRUUuVHViZUdlb21ldHJ5LkZyZW5ldEZyYW1lcyA9IGZ1bmN0aW9uKHBhdGgsIHNlZ21lbnRzLCBjbG9zZWQpIHtcclxuXHJcblx0dmFyXHR0YW5nZW50ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRcdG5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRiaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblxyXG5cdFx0dGFuZ2VudHMgPSBbXSxcclxuXHRcdG5vcm1hbHMgPSBbXSxcclxuXHRcdGJpbm9ybWFscyA9IFtdLFxyXG5cclxuXHRcdHZlYyA9IG5ldyBUSFJFRS5WZWN0b3IzKCksXHJcblx0XHRtYXQgPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cclxuXHRcdG51bXBvaW50cyA9IHNlZ21lbnRzICsgMSxcclxuXHRcdHRoZXRhLFxyXG5cdFx0ZXBzaWxvbiA9IDAuMDAwMSxcclxuXHRcdHNtYWxsZXN0LFxyXG5cclxuXHRcdHR4LCB0eSwgdHosXHJcblx0XHRpLCB1LCB2O1xyXG5cclxuXHJcblx0Ly8gZXhwb3NlIGludGVybmFsc1xyXG5cdHRoaXMudGFuZ2VudHMgPSB0YW5nZW50cztcclxuXHR0aGlzLm5vcm1hbHMgPSBub3JtYWxzO1xyXG5cdHRoaXMuYmlub3JtYWxzID0gYmlub3JtYWxzO1xyXG5cclxuXHQvLyBjb21wdXRlIHRoZSB0YW5nZW50IHZlY3RvcnMgZm9yIGVhY2ggc2VnbWVudCBvbiB0aGUgcGF0aFxyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8IG51bXBvaW50czsgaSsrICkge1xyXG5cclxuXHRcdHUgPSBpIC8gKCBudW1wb2ludHMgLSAxICk7XHJcblxyXG5cdFx0dGFuZ2VudHNbIGkgXSA9IHBhdGguZ2V0VGFuZ2VudEF0KCB1ICk7XHJcblx0XHR0YW5nZW50c1sgaSBdLm5vcm1hbGl6ZSgpO1xyXG5cclxuXHR9XHJcblxyXG5cdGluaXRpYWxOb3JtYWwzKCk7XHJcblxyXG5cdGZ1bmN0aW9uIGluaXRpYWxOb3JtYWwxKGxhc3RCaW5vcm1hbCkge1xyXG5cdFx0Ly8gZml4ZWQgc3RhcnQgYmlub3JtYWwuIEhhcyBkYW5nZXJzIG9mIDAgdmVjdG9yc1xyXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdGlmIChsYXN0Qmlub3JtYWw9PT11bmRlZmluZWQpIGxhc3RCaW5vcm1hbCA9IG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAxICk7XHJcblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCBsYXN0Qmlub3JtYWwsIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBpbml0aWFsTm9ybWFsMigpIHtcclxuXHJcblx0XHQvLyBUaGlzIHVzZXMgdGhlIEZyZW5ldC1TZXJyZXQgZm9ybXVsYSBmb3IgZGVyaXZpbmcgYmlub3JtYWxcclxuXHRcdHZhciB0MiA9IHBhdGguZ2V0VGFuZ2VudEF0KCBlcHNpbG9uICk7XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKS5zdWJWZWN0b3JzKCB0MiwgdGFuZ2VudHNbIDAgXSApLm5vcm1hbGl6ZSgpO1xyXG5cdFx0Ymlub3JtYWxzWyAwIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggYmlub3JtYWxzWyAwIF0sIHRhbmdlbnRzWyAwIF0gKS5ub3JtYWxpemUoKTsgLy8gbGFzdCBiaW5vcm1hbCB4IHRhbmdlbnRcclxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICkubm9ybWFsaXplKCk7XHJcblxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaW5pdGlhbE5vcm1hbDMoKSB7XHJcblx0XHQvLyBzZWxlY3QgYW4gaW5pdGlhbCBub3JtYWwgdmVjdG9yIHBlcnBlbmljdWxhciB0byB0aGUgZmlyc3QgdGFuZ2VudCB2ZWN0b3IsXHJcblx0XHQvLyBhbmQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc21hbGxlc3QgdGFuZ2VudCB4eXogY29tcG9uZW50XHJcblxyXG5cdFx0bm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHRcdHNtYWxsZXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuXHRcdHR4ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueCApO1xyXG5cdFx0dHkgPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS55ICk7XHJcblx0XHR0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcclxuXHJcblx0XHRpZiAoIHR4IDw9IHNtYWxsZXN0ICkge1xyXG5cdFx0XHRzbWFsbGVzdCA9IHR4O1xyXG5cdFx0XHRub3JtYWwuc2V0KCAxLCAwLCAwICk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCB0eSA8PSBzbWFsbGVzdCApIHtcclxuXHRcdFx0c21hbGxlc3QgPSB0eTtcclxuXHRcdFx0bm9ybWFsLnNldCggMCwgMSwgMCApO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICggdHogPD0gc21hbGxlc3QgKSB7XHJcblx0XHRcdG5vcm1hbC5zZXQoIDAsIDAsIDEgKTtcclxuXHRcdH1cclxuXHJcblx0XHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcclxuXHRcdGJpbm9ybWFsc1sgMCBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIDAgXSwgbm9ybWFsc1sgMCBdICk7XHJcblx0fVxyXG5cclxuXHJcblx0Ly8gY29tcHV0ZSB0aGUgc2xvd2x5LXZhcnlpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbCB2ZWN0b3JzIGZvciBlYWNoIHNlZ21lbnQgb24gdGhlIHBhdGhcclxuXHJcblx0Zm9yICggaSA9IDE7IGkgPCBudW1wb2ludHM7IGkrKyApIHtcclxuXHJcblx0XHRub3JtYWxzWyBpIF0gPSBub3JtYWxzWyBpLTEgXS5jbG9uZSgpO1xyXG5cclxuXHRcdGJpbm9ybWFsc1sgaSBdID0gYmlub3JtYWxzWyBpLTEgXS5jbG9uZSgpO1xyXG5cclxuXHRcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpLTEgXSwgdGFuZ2VudHNbIGkgXSApO1xyXG5cclxuXHRcdGlmICggdmVjLmxlbmd0aCgpID4gZXBzaWxvbiApIHtcclxuXHJcblx0XHRcdHZlYy5ub3JtYWxpemUoKTtcclxuXHJcblx0XHRcdHRoZXRhID0gTWF0aC5hY29zKCB0YW5nZW50c1sgaS0xIF0uZG90KCB0YW5nZW50c1sgaSBdICkgKTtcclxuXHJcblx0XHRcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxyXG5cclxuXHRpZiAoIGNsb3NlZCApIHtcclxuXHJcblx0XHR0aGV0YSA9IE1hdGguYWNvcyggbm9ybWFsc1sgMCBdLmRvdCggbm9ybWFsc1sgbnVtcG9pbnRzLTEgXSApICk7XHJcblx0XHR0aGV0YSAvPSAoIG51bXBvaW50cyAtIDEgKTtcclxuXHJcblx0XHRpZiAoIHRhbmdlbnRzWyAwIF0uZG90KCB2ZWMuY3Jvc3NWZWN0b3JzKCBub3JtYWxzWyAwIF0sIG5vcm1hbHNbIG51bXBvaW50cy0xIF0gKSApID4gMCApIHtcclxuXHJcblx0XHRcdHRoZXRhID0gLXRoZXRhO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRmb3IgKCBpID0gMTsgaSA8IG51bXBvaW50czsgaSsrICkge1xyXG5cclxuXHRcdFx0Ly8gdHdpc3QgYSBsaXR0bGUuLi5cclxuXHRcdFx0bm9ybWFsc1sgaSBdLmFwcGx5TWF0cml4NCggbWF0Lm1ha2VSb3RhdGlvbkF4aXMoIHRhbmdlbnRzWyBpIF0sIHRoZXRhICogaSApICk7XHJcblx0XHRcdGJpbm9ybWFsc1sgaSBdLmNyb3NzVmVjdG9ycyggdGFuZ2VudHNbIGkgXSwgbm9ybWFsc1sgaSBdICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGNsb2Nrd29ya2dlZWsgLyBodHRwczovL2dpdGh1Yi5jb20vY2xvY2t3b3JrZ2Vla1xyXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuUG9seWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCB2ZXJ0aWNlcywgZmFjZXMsIHJhZGl1cywgZGV0YWlsICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xyXG5cdGRldGFpbCA9IGRldGFpbCB8fCAwO1xyXG5cclxuXHR2YXIgdGhhdCA9IHRoaXM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IHZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0cHJlcGFyZSggbmV3IFRIUkVFLlZlY3RvcjMoIHZlcnRpY2VzWyBpIF1bIDAgXSwgdmVydGljZXNbIGkgXVsgMSBdLCB2ZXJ0aWNlc1sgaSBdWyAyIF0gKSApO1xyXG5cclxuXHR9XHJcblxyXG5cdHZhciBtaWRwb2ludHMgPSBbXSwgcCA9IHRoaXMudmVydGljZXM7XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0bWFrZSggcFsgZmFjZXNbIGkgXVsgMCBdIF0sIHBbIGZhY2VzWyBpIF1bIDEgXSBdLCBwWyBmYWNlc1sgaSBdWyAyIF0gXSwgZGV0YWlsICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XHJcblxyXG5cdC8vIEFwcGx5IHJhZGl1c1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XHJcblxyXG5cdFx0dGhpcy52ZXJ0aWNlc1sgaSBdLm11bHRpcGx5U2NhbGFyKCByYWRpdXMgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gUHJvamVjdCB2ZWN0b3Igb250byBzcGhlcmUncyBzdXJmYWNlXHJcblxyXG5cdGZ1bmN0aW9uIHByZXBhcmUoIHZlY3RvciApIHtcclxuXHJcblx0XHR2YXIgdmVydGV4ID0gdmVjdG9yLm5vcm1hbGl6ZSgpLmNsb25lKCk7XHJcblx0XHR2ZXJ0ZXguaW5kZXggPSB0aGF0LnZlcnRpY2VzLnB1c2goIHZlcnRleCApIC0gMTtcclxuXHJcblx0XHQvLyBUZXh0dXJlIGNvb3JkcyBhcmUgZXF1aXZhbGVudCB0byBtYXAgY29vcmRzLCBjYWxjdWxhdGUgYW5nbGUgYW5kIGNvbnZlcnQgdG8gZnJhY3Rpb24gb2YgYSBjaXJjbGUuXHJcblxyXG5cdFx0dmFyIHUgPSBhemltdXRoKCB2ZWN0b3IgKSAvIDIgLyBNYXRoLlBJICsgMC41O1xyXG5cdFx0dmFyIHYgPSBpbmNsaW5hdGlvbiggdmVjdG9yICkgLyBNYXRoLlBJICsgMC41O1xyXG5cdFx0dmVydGV4LnV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIHUsIDEgLSB2ICk7XHJcblxyXG5cdFx0cmV0dXJuIHZlcnRleDtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gQXBwcm94aW1hdGUgYSBjdXJ2ZWQgZmFjZSB3aXRoIHJlY3Vyc2l2ZWx5IHN1Yi1kaXZpZGVkIHRyaWFuZ2xlcy5cclxuXHJcblx0ZnVuY3Rpb24gbWFrZSggdjEsIHYyLCB2MywgZGV0YWlsICkge1xyXG5cclxuXHRcdGlmICggZGV0YWlsIDwgMSApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gbmV3IFRIUkVFLkZhY2UzKCB2MS5pbmRleCwgdjIuaW5kZXgsIHYzLmluZGV4LCBbIHYxLmNsb25lKCksIHYyLmNsb25lKCksIHYzLmNsb25lKCkgXSApO1xyXG5cdFx0XHRmYWNlLmNlbnRyb2lkLmFkZCggdjEgKS5hZGQoIHYyICkuYWRkKCB2MyApLmRpdmlkZVNjYWxhciggMyApO1xyXG5cdFx0XHRmYWNlLm5vcm1hbCA9IGZhY2UuY2VudHJvaWQuY2xvbmUoKS5ub3JtYWxpemUoKTtcclxuXHRcdFx0dGhhdC5mYWNlcy5wdXNoKCBmYWNlICk7XHJcblxyXG5cdFx0XHR2YXIgYXppID0gYXppbXV0aCggZmFjZS5jZW50cm9pZCApO1xyXG5cdFx0XHR0aGF0LmZhY2VWZXJ0ZXhVdnNbIDAgXS5wdXNoKCBbXHJcblx0XHRcdFx0Y29ycmVjdFVWKCB2MS51diwgdjEsIGF6aSApLFxyXG5cdFx0XHRcdGNvcnJlY3RVViggdjIudXYsIHYyLCBhemkgKSxcclxuXHRcdFx0XHRjb3JyZWN0VVYoIHYzLnV2LCB2MywgYXppIClcclxuXHRcdFx0XSApO1xyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRkZXRhaWwgLT0gMTtcclxuXHJcblx0XHRcdC8vIHNwbGl0IHRyaWFuZ2xlIGludG8gNCBzbWFsbGVyIHRyaWFuZ2xlc1xyXG5cclxuXHRcdFx0bWFrZSggdjEsIG1pZHBvaW50KCB2MSwgdjIgKSwgbWlkcG9pbnQoIHYxLCB2MyApLCBkZXRhaWwgKTsgLy8gdG9wIHF1YWRyYW50XHJcblx0XHRcdG1ha2UoIG1pZHBvaW50KCB2MSwgdjIgKSwgdjIsIG1pZHBvaW50KCB2MiwgdjMgKSwgZGV0YWlsICk7IC8vIGxlZnQgcXVhZHJhbnRcclxuXHRcdFx0bWFrZSggbWlkcG9pbnQoIHYxLCB2MyApLCBtaWRwb2ludCggdjIsIHYzICksIHYzLCBkZXRhaWwgKTsgLy8gcmlnaHQgcXVhZHJhbnRcclxuXHRcdFx0bWFrZSggbWlkcG9pbnQoIHYxLCB2MiApLCBtaWRwb2ludCggdjIsIHYzICksIG1pZHBvaW50KCB2MSwgdjMgKSwgZGV0YWlsICk7IC8vIGNlbnRlciBxdWFkcmFudFxyXG5cclxuXHRcdH1cclxuXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBtaWRwb2ludCggdjEsIHYyICkge1xyXG5cclxuXHRcdGlmICggIW1pZHBvaW50c1sgdjEuaW5kZXggXSApIG1pZHBvaW50c1sgdjEuaW5kZXggXSA9IFtdO1xyXG5cdFx0aWYgKCAhbWlkcG9pbnRzWyB2Mi5pbmRleCBdICkgbWlkcG9pbnRzWyB2Mi5pbmRleCBdID0gW107XHJcblxyXG5cdFx0dmFyIG1pZCA9IG1pZHBvaW50c1sgdjEuaW5kZXggXVsgdjIuaW5kZXggXTtcclxuXHJcblx0XHRpZiAoIG1pZCA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0Ly8gZ2VuZXJhdGUgbWVhbiBwb2ludCBhbmQgcHJvamVjdCB0byBzdXJmYWNlIHdpdGggcHJlcGFyZSgpXHJcblxyXG5cdFx0XHRtaWRwb2ludHNbIHYxLmluZGV4IF1bIHYyLmluZGV4IF0gPSBtaWRwb2ludHNbIHYyLmluZGV4IF1bIHYxLmluZGV4IF0gPSBtaWQgPSBwcmVwYXJlKFxyXG5cdFx0XHRcdG5ldyBUSFJFRS5WZWN0b3IzKCkuYWRkVmVjdG9ycyggdjEsIHYyICkuZGl2aWRlU2NhbGFyKCAyIClcclxuXHRcdFx0KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbWlkO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXHJcblxyXG5cdGZ1bmN0aW9uIGF6aW11dGgoIHZlY3RvciApIHtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5hdGFuMiggdmVjdG9yLnosIC12ZWN0b3IueCApO1xyXG5cclxuXHR9XHJcblxyXG5cclxuXHQvLyBBbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUuXHJcblxyXG5cdGZ1bmN0aW9uIGluY2xpbmF0aW9uKCB2ZWN0b3IgKSB7XHJcblxyXG5cdFx0cmV0dXJuIE1hdGguYXRhbjIoIC12ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcclxuXHJcblx0fVxyXG5cclxuXHJcblx0Ly8gVGV4dHVyZSBmaXhpbmcgaGVscGVyLiBTcGhlcmVzIGhhdmUgc29tZSBvZGQgYmVoYXZpb3Vycy5cclxuXHJcblx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgdmVjdG9yLCBhemltdXRoICkge1xyXG5cclxuXHRcdGlmICggKCBhemltdXRoIDwgMCApICYmICggdXYueCA9PT0gMSApICkgdXYgPSBuZXcgVEhSRUUuVmVjdG9yMiggdXYueCAtIDEsIHV2LnkgKTtcclxuXHRcdGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHV2ID0gbmV3IFRIUkVFLlZlY3RvcjIoIGF6aW11dGggLyAyIC8gTWF0aC5QSSArIDAuNSwgdXYueSApO1xyXG5cdFx0cmV0dXJuIHV2O1xyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cclxuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgVEhSRUUuU3BoZXJlKCBuZXcgVEhSRUUuVmVjdG9yMygpLCByYWRpdXMgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdHZhciB0ID0gKCAxICsgTWF0aC5zcXJ0KCA1ICkgKSAvIDI7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IFtcclxuXHRcdFsgLTEsICB0LCAgMCBdLCBbICAxLCB0LCAwIF0sIFsgLTEsIC10LCAgMCBdLCBbICAxLCAtdCwgIDAgXSxcclxuXHRcdFsgIDAsIC0xLCAgdCBdLCBbICAwLCAxLCB0IF0sIFsgIDAsIC0xLCAtdCBdLCBbICAwLCAgMSwgLXQgXSxcclxuXHRcdFsgIHQsICAwLCAtMSBdLCBbICB0LCAwLCAxIF0sIFsgLXQsICAwLCAtMSBdLCBbIC10LCAgMCwgIDEgXVxyXG5cdF07XHJcblxyXG5cdHZhciBmYWNlcyA9IFtcclxuXHRcdFsgMCwgMTEsICA1IF0sIFsgMCwgIDUsICAxIF0sIFsgIDAsICAxLCAgNyBdLCBbICAwLCAgNywgMTAgXSwgWyAgMCwgMTAsIDExIF0sXHJcblx0XHRbIDEsICA1LCAgOSBdLCBbIDUsIDExLCAgNCBdLCBbIDExLCAxMCwgIDIgXSwgWyAxMCwgIDcsICA2IF0sIFsgIDcsICAxLCAgOCBdLFxyXG5cdFx0WyAzLCAgOSwgIDQgXSwgWyAzLCAgNCwgIDIgXSwgWyAgMywgIDIsICA2IF0sIFsgIDMsICA2LCAgOCBdLCBbICAzLCAgOCwgIDkgXSxcclxuXHRcdFsgNCwgIDksICA1IF0sIFsgMiwgIDQsIDExIF0sIFsgIDYsICAyLCAxMCBdLCBbICA4LCAgNiwgIDcgXSwgWyAgOSwgIDgsICAxIF1cclxuXHRdO1xyXG5cclxuXHRUSFJFRS5Qb2x5aGVkcm9uR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGZhY2VzLCByYWRpdXMsIGRldGFpbCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuT2N0YWhlZHJvbkdlb21ldHJ5ID0gZnVuY3Rpb24gKCByYWRpdXMsIGRldGFpbCApIHtcclxuXHJcblx0dmFyIHZlcnRpY2VzID0gW1xyXG5cdFx0WyAxLCAwLCAwIF0sIFsgLTEsIDAsIDAgXSwgWyAwLCAxLCAwIF0sIFsgMCwgLTEsIDAgXSwgWyAwLCAwLCAxIF0sIFsgMCwgMCwgLTEgXVxyXG5cdF07XHJcblxyXG5cdHZhciBmYWNlcyA9IFtcclxuXHRcdFsgMCwgMiwgNCBdLCBbIDAsIDQsIDMgXSwgWyAwLCAzLCA1IF0sIFsgMCwgNSwgMiBdLCBbIDEsIDIsIDUgXSwgWyAxLCA1LCAzIF0sIFsgMSwgMywgNCBdLCBbIDEsIDQsIDIgXVxyXG5cdF07XHJcblxyXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgZmFjZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcbn07XHJcblxyXG5USFJFRS5PY3RhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHRpbW90aHlwcmF0bGV5IC8gaHR0cHM6Ly9naXRodWIuY29tL3RpbW90aHlwcmF0bGV5XHJcbiAqL1xyXG5cclxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeSA9IGZ1bmN0aW9uICggcmFkaXVzLCBkZXRhaWwgKSB7XHJcblxyXG5cdHZhciB2ZXJ0aWNlcyA9IFtcclxuXHRcdFsgMSwgIDEsICAxIF0sIFsgLTEsIC0xLCAxIF0sIFsgLTEsIDEsIC0xIF0sIFsgMSwgLTEsIC0xIF1cclxuXHRdO1xyXG5cclxuXHR2YXIgZmFjZXMgPSBbXHJcblx0XHRbIDIsIDEsIDAgXSwgWyAwLCAzLCAyIF0sIFsgMSwgMywgMCBdLCBbIDIsIDMsIDEgXVxyXG5cdF07XHJcblxyXG5cdFRIUkVFLlBvbHloZWRyb25HZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgZmFjZXMsIHJhZGl1cywgZGV0YWlsICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuVGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5HZW9tZXRyeS5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3Igeno4NSAvIGh0dHBzOi8vZ2l0aHViLmNvbS96ejg1XHJcbiAqIFBhcmFtZXRyaWMgU3VyZmFjZXMgR2VvbWV0cnlcclxuICogYmFzZWQgb24gdGhlIGJyaWxsaWFudCBhcnRpY2xlIGJ5IEBwcmlkZW91dCBodHRwOi8vcHJpZGVvdXQubmV0L2Jsb2cvP3A9NDRcclxuICpcclxuICogbmV3IFRIUkVFLlBhcmFtZXRyaWNHZW9tZXRyeSggcGFyYW1ldHJpY0Z1bmN0aW9uLCB1U2VnbWVudHMsIHlTZWdlbWVudHMsIHVzZVRyaXMgKTtcclxuICpcclxuICovXHJcblxyXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkgPSBmdW5jdGlvbiAoIGZ1bmMsIHNsaWNlcywgc3RhY2tzLCB1c2VUcmlzICkge1xyXG5cclxuXHRUSFJFRS5HZW9tZXRyeS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXM7XHJcblx0dmFyIGZhY2VzID0gdGhpcy5mYWNlcztcclxuXHR2YXIgdXZzID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XHJcblxyXG5cdHVzZVRyaXMgPSAodXNlVHJpcyA9PT0gdW5kZWZpbmVkKSA/IGZhbHNlIDogdXNlVHJpcztcclxuXHJcblx0dmFyIGksIGlsLCBqLCBwO1xyXG5cdHZhciB1LCB2O1xyXG5cclxuXHR2YXIgc3RhY2tDb3VudCA9IHN0YWNrcyArIDE7XHJcblx0dmFyIHNsaWNlQ291bnQgPSBzbGljZXMgKyAxO1xyXG5cclxuXHRmb3IgKCBpID0gMDsgaSA8PSBzdGFja3M7IGkgKysgKSB7XHJcblxyXG5cdFx0diA9IGkgLyBzdGFja3M7XHJcblxyXG5cdFx0Zm9yICggaiA9IDA7IGogPD0gc2xpY2VzOyBqICsrICkge1xyXG5cclxuXHRcdFx0dSA9IGogLyBzbGljZXM7XHJcblxyXG5cdFx0XHRwID0gZnVuYyggdSwgdiApO1xyXG5cdFx0XHR2ZXJ0cy5wdXNoKCBwICk7XHJcblxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dmFyIGEsIGIsIGMsIGQ7XHJcblx0dmFyIHV2YSwgdXZiLCB1dmMsIHV2ZDtcclxuXHJcblx0Zm9yICggaSA9IDA7IGkgPCBzdGFja3M7IGkgKysgKSB7XHJcblxyXG5cdFx0Zm9yICggaiA9IDA7IGogPCBzbGljZXM7IGogKysgKSB7XHJcblxyXG5cdFx0XHRhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xyXG5cdFx0XHRiID0gaSAqIHNsaWNlQ291bnQgKyBqICsgMTtcclxuXHRcdFx0YyA9IChpICsgMSkgKiBzbGljZUNvdW50ICsgajtcclxuXHRcdFx0ZCA9IChpICsgMSkgKiBzbGljZUNvdW50ICsgaiArIDE7XHJcblxyXG5cdFx0XHR1dmEgPSBuZXcgVEhSRUUuVmVjdG9yMiggaiAvIHNsaWNlcywgaSAvIHN0YWNrcyApO1xyXG5cdFx0XHR1dmIgPSBuZXcgVEhSRUUuVmVjdG9yMiggKCBqICsgMSApIC8gc2xpY2VzLCBpIC8gc3RhY2tzICk7XHJcblx0XHRcdHV2YyA9IG5ldyBUSFJFRS5WZWN0b3IyKCBqIC8gc2xpY2VzLCAoIGkgKyAxICkgLyBzdGFja3MgKTtcclxuXHRcdFx0dXZkID0gbmV3IFRIUkVFLlZlY3RvcjIoICggaiArIDEgKSAvIHNsaWNlcywgKCBpICsgMSApIC8gc3RhY2tzICk7XHJcblxyXG5cdFx0XHRpZiAoIHVzZVRyaXMgKSB7XHJcblxyXG5cdFx0XHRcdGZhY2VzLnB1c2goIG5ldyBUSFJFRS5GYWNlMyggYSwgYiwgYyApICk7XHJcblx0XHRcdFx0ZmFjZXMucHVzaCggbmV3IFRIUkVFLkZhY2UzKCBiLCBkLCBjICkgKTtcclxuXHJcblx0XHRcdFx0dXZzLnB1c2goIFsgdXZhLCB1dmIsIHV2YyBdICk7XHJcblx0XHRcdFx0dXZzLnB1c2goIFsgdXZiLCB1dmQsIHV2YyBdICk7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRmYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTQoIGEsIGIsIGQsIGMgKSApO1xyXG5cdFx0XHRcdHV2cy5wdXNoKCBbIHV2YSwgdXZiLCB1dmQsIHV2YyBdICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdC8vIGNvbnNvbGUubG9nKHRoaXMpO1xyXG5cclxuXHQvLyBtYWdpYyBidWxsZXRcclxuXHQvLyB2YXIgZGlmZiA9IHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xyXG5cdC8vIGNvbnNvbGUubG9nKCdyZW1vdmVkICcsIGRpZmYsICcgdmVydGljZXMgYnkgbWVyZ2luZycpO1xyXG5cclxuXHR0aGlzLmNvbXB1dGVDZW50cm9pZHMoKTtcclxuXHR0aGlzLmNvbXB1dGVGYWNlTm9ybWFscygpO1xyXG5cdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5QYXJhbWV0cmljR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuR2VvbWV0cnkucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIHFpYW8gLyBodHRwczovL2dpdGh1Yi5jb20vcWlhb1xyXG4gKiBAZmlsZW92ZXJ2aWV3IFRoaXMgaXMgYSBjb252ZXggaHVsbCBnZW5lcmF0b3IgdXNpbmcgdGhlIGluY3JlbWVudGFsIG1ldGhvZC4gXHJcbiAqIFRoZSBjb21wbGV4aXR5IGlzIE8obl4yKSB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgdmVydGljZXMuXHJcbiAqIE8obmxvZ24pIGFsZ29yaXRobXMgZG8gZXhpc3QsIGJ1dCB0aGV5IGFyZSBtdWNoIG1vcmUgY29tcGxpY2F0ZWQuXHJcbiAqXHJcbiAqIEJlbmNobWFyazogXHJcbiAqXHJcbiAqICBQbGF0Zm9ybTogQ1BVOiBQNzM1MCBAMi4wMEdIeiBFbmdpbmU6IFY4XHJcbiAqXHJcbiAqICBOdW0gVmVydGljZXNcdFRpbWUobXMpXHJcbiAqXHJcbiAqICAgICAxMCAgICAgICAgICAgMVxyXG4gKiAgICAgMjAgICAgICAgICAgIDNcclxuICogICAgIDMwICAgICAgICAgICAxOVxyXG4gKiAgICAgNDAgICAgICAgICAgIDQ4XHJcbiAqICAgICA1MCAgICAgICAgICAgMTA3XHJcbiAqL1xyXG5cclxuVEhSRUUuQ29udmV4R2VvbWV0cnkgPSBmdW5jdGlvbiggdmVydGljZXMgKSB7XHJcblxyXG5cdFRIUkVFLkdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dmFyIGZhY2VzID0gWyBbIDAsIDEsIDIgXSwgWyAwLCAyLCAxIF0gXTsgXHJcblxyXG5cdGZvciAoIHZhciBpID0gMzsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSsrICkge1xyXG5cclxuXHRcdGFkZFBvaW50KCBpICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdGZ1bmN0aW9uIGFkZFBvaW50KCB2ZXJ0ZXhJZCApIHtcclxuXHJcblx0XHR2YXIgdmVydGV4ID0gdmVydGljZXNbIHZlcnRleElkIF0uY2xvbmUoKTtcclxuXHJcblx0XHR2YXIgbWFnID0gdmVydGV4Lmxlbmd0aCgpO1xyXG5cdFx0dmVydGV4LnggKz0gbWFnICogcmFuZG9tT2Zmc2V0KCk7XHJcblx0XHR2ZXJ0ZXgueSArPSBtYWcgKiByYW5kb21PZmZzZXQoKTtcclxuXHRcdHZlcnRleC56ICs9IG1hZyAqIHJhbmRvbU9mZnNldCgpO1xyXG5cclxuXHRcdHZhciBob2xlID0gW107XHJcblxyXG5cdFx0Zm9yICggdmFyIGYgPSAwOyBmIDwgZmFjZXMubGVuZ3RoOyApIHtcclxuXHJcblx0XHRcdHZhciBmYWNlID0gZmFjZXNbIGYgXTtcclxuXHJcblx0XHRcdC8vIGZvciBlYWNoIGZhY2UsIGlmIHRoZSB2ZXJ0ZXggY2FuIHNlZSBpdCxcclxuXHRcdFx0Ly8gdGhlbiB3ZSB0cnkgdG8gYWRkIHRoZSBmYWNlJ3MgZWRnZXMgaW50byB0aGUgaG9sZS5cclxuXHRcdFx0aWYgKCB2aXNpYmxlKCBmYWNlLCB2ZXJ0ZXggKSApIHtcclxuXHJcblx0XHRcdFx0Zm9yICggdmFyIGUgPSAwOyBlIDwgMzsgZSsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciBlZGdlID0gWyBmYWNlWyBlIF0sIGZhY2VbICggZSArIDEgKSAlIDMgXSBdO1xyXG5cdFx0XHRcdFx0dmFyIGJvdW5kYXJ5ID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0XHQvLyByZW1vdmUgZHVwbGljYXRlZCBlZGdlcy5cclxuXHRcdFx0XHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGhvbGUubGVuZ3RoOyBoKysgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRpZiAoIGVxdWFsRWRnZSggaG9sZVsgaCBdLCBlZGdlICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdGhvbGVbIGggXSA9IGhvbGVbIGhvbGUubGVuZ3RoIC0gMSBdO1xyXG5cdFx0XHRcdFx0XHRcdGhvbGUucG9wKCk7XHJcblx0XHRcdFx0XHRcdFx0Ym91bmRhcnkgPSBmYWxzZTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHJcblx0XHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBib3VuZGFyeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdGhvbGUucHVzaCggZWRnZSApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvLyByZW1vdmUgZmFjZXNbIGYgXVxyXG5cdFx0XHRcdGZhY2VzWyBmIF0gPSBmYWNlc1sgZmFjZXMubGVuZ3RoIC0gMSBdO1xyXG5cdFx0XHRcdGZhY2VzLnBvcCgpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHsgLy8gbm90IHZpc2libGVcclxuXHJcblx0XHRcdFx0ZisrO1xyXG5cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNvbnN0cnVjdCB0aGUgbmV3IGZhY2VzIGZvcm1lZCBieSB0aGUgZWRnZXMgb2YgdGhlIGhvbGUgYW5kIHRoZSB2ZXJ0ZXhcclxuXHRcdGZvciAoIHZhciBoID0gMDsgaCA8IGhvbGUubGVuZ3RoOyBoKysgKSB7XHJcblxyXG5cdFx0XHRmYWNlcy5wdXNoKCBbIFxyXG5cdFx0XHRcdGhvbGVbIGggXVsgMCBdLFxyXG5cdFx0XHRcdGhvbGVbIGggXVsgMSBdLFxyXG5cdFx0XHRcdHZlcnRleElkXHJcblx0XHRcdF0gKTtcclxuXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBXaGV0aGVyIHRoZSBmYWNlIGlzIHZpc2libGUgZnJvbSB0aGUgdmVydGV4XHJcblx0ICovXHJcblx0ZnVuY3Rpb24gdmlzaWJsZSggZmFjZSwgdmVydGV4ICkge1xyXG5cclxuXHRcdHZhciB2YSA9IHZlcnRpY2VzWyBmYWNlWyAwIF0gXTtcclxuXHRcdHZhciB2YiA9IHZlcnRpY2VzWyBmYWNlWyAxIF0gXTtcclxuXHRcdHZhciB2YyA9IHZlcnRpY2VzWyBmYWNlWyAyIF0gXTtcclxuXHJcblx0XHR2YXIgbiA9IG5vcm1hbCggdmEsIHZiLCB2YyApO1xyXG5cclxuXHRcdC8vIGRpc3RhbmNlIGZyb20gZmFjZSB0byBvcmlnaW5cclxuXHRcdHZhciBkaXN0ID0gbi5kb3QoIHZhICk7XHJcblxyXG5cdFx0cmV0dXJuIG4uZG90KCB2ZXJ0ZXggKSA+PSBkaXN0OyBcclxuXHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBGYWNlIG5vcm1hbFxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIG5vcm1hbCggdmEsIHZiLCB2YyApIHtcclxuXHJcblx0XHR2YXIgY2IgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0dmFyIGFiID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0XHRjYi5zdWJWZWN0b3JzKCB2YywgdmIgKTtcclxuXHRcdGFiLnN1YlZlY3RvcnMoIHZhLCB2YiApO1xyXG5cdFx0Y2IuY3Jvc3MoIGFiICk7XHJcblxyXG5cdFx0Y2Iubm9ybWFsaXplKCk7XHJcblxyXG5cdFx0cmV0dXJuIGNiO1xyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERldGVjdCB3aGV0aGVyIHR3byBlZGdlcyBhcmUgZXF1YWwuXHJcblx0ICogTm90ZSB0aGF0IHdoZW4gY29uc3RydWN0aW5nIHRoZSBjb252ZXggaHVsbCwgdHdvIHNhbWUgZWRnZXMgY2FuIG9ubHlcclxuXHQgKiBiZSBvZiB0aGUgbmVnYXRpdmUgZGlyZWN0aW9uLlxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGVxdWFsRWRnZSggZWEsIGViICkge1xyXG5cclxuXHRcdHJldHVybiBlYVsgMCBdID09PSBlYlsgMSBdICYmIGVhWyAxIF0gPT09IGViWyAwIF07IFxyXG5cclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIENyZWF0ZSBhIHJhbmRvbSBvZmZzZXQgYmV0d2VlbiAtMWUtNiBhbmQgMWUtNi5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiByYW5kb21PZmZzZXQoKSB7XHJcblxyXG5cdFx0cmV0dXJuICggTWF0aC5yYW5kb20oKSAtIDAuNSApICogMiAqIDFlLTY7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFhYWDogTm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgY29ycmVjdCBhcHByb2FjaC4gTmVlZCBzb21lb25lIHRvIHJldmlldy5cclxuXHQgKi9cclxuXHRmdW5jdGlvbiB2ZXJ0ZXhVdiggdmVydGV4ICkge1xyXG5cclxuXHRcdHZhciBtYWcgPSB2ZXJ0ZXgubGVuZ3RoKCk7XHJcblx0XHRyZXR1cm4gbmV3IFRIUkVFLlZlY3RvcjIoIHZlcnRleC54IC8gbWFnLCB2ZXJ0ZXgueSAvIG1hZyApO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIFB1c2ggdmVydGljZXMgaW50byBgdGhpcy52ZXJ0aWNlc2AsIHNraXBwaW5nIHRob3NlIGluc2lkZSB0aGUgaHVsbFxyXG5cdHZhciBpZCA9IDA7XHJcblx0dmFyIG5ld0lkID0gbmV3IEFycmF5KCB2ZXJ0aWNlcy5sZW5ndGggKTsgLy8gbWFwIGZyb20gb2xkIHZlcnRleCBpZCB0byBuZXcgaWRcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdFx0IHZhciBmYWNlID0gZmFjZXNbIGkgXTtcclxuXHJcblx0XHQgZm9yICggdmFyIGogPSAwOyBqIDwgMzsgaisrICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIG5ld0lkWyBmYWNlWyBqIF0gXSA9PT0gdW5kZWZpbmVkICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bmV3SWRbIGZhY2VbIGogXSBdID0gaWQrKztcclxuXHRcdFx0XHRcdFx0dGhpcy52ZXJ0aWNlcy5wdXNoKCB2ZXJ0aWNlc1sgZmFjZVsgaiBdIF0gKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRmYWNlWyBqIF0gPSBuZXdJZFsgZmFjZVsgaiBdIF07XHJcblxyXG5cdFx0IH1cclxuXHJcblx0fVxyXG5cclxuXHQvLyBDb252ZXJ0IGZhY2VzIGludG8gaW5zdGFuY2VzIG9mIFRIUkVFLkZhY2UzXHJcblx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpKysgKSB7XHJcblxyXG5cdFx0dGhpcy5mYWNlcy5wdXNoKCBuZXcgVEhSRUUuRmFjZTMoIFxyXG5cdFx0XHRcdGZhY2VzWyBpIF1bIDAgXSxcclxuXHRcdFx0XHRmYWNlc1sgaSBdWyAxIF0sXHJcblx0XHRcdFx0ZmFjZXNbIGkgXVsgMiBdXHJcblx0XHQpICk7XHJcblxyXG5cdH1cclxuXHJcblx0Ly8gQ29tcHV0ZSBVVnNcclxuXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLmZhY2VzLmxlbmd0aDsgaSsrICkge1xyXG5cclxuXHRcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xyXG5cclxuXHRcdHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdLnB1c2goIFtcclxuXHRcdFx0dmVydGV4VXYoIHRoaXMudmVydGljZXNbIGZhY2UuYSBdICksXHJcblx0XHRcdHZlcnRleFV2KCB0aGlzLnZlcnRpY2VzWyBmYWNlLmIgXSApLFxyXG5cdFx0XHR2ZXJ0ZXhVdiggdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF0pXHJcblx0XHRdICk7XHJcblxyXG5cdH1cclxuXHJcblxyXG5cdHRoaXMuY29tcHV0ZUNlbnRyb2lkcygpO1xyXG5cdHRoaXMuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XHJcblx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNvbnZleEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLkdlb21ldHJ5LnByb3RvdHlwZSApO1xyXG4vKipcclxuICogQGF1dGhvciBzcm91Y2hlcmF5IC8gaHR0cDovL3Nyb3VjaGVyYXkub3JnL1xyXG4gKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkF4aXNIZWxwZXIgPSBmdW5jdGlvbiAoIHNpemUgKSB7XHJcblxyXG5cdHZhciBnZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cclxuXHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoIHNpemUgfHwgMSwgMCwgMCApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIHNpemUgfHwgMSwgMCApLFxyXG5cdFx0bmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDAsIHNpemUgfHwgMSApXHJcblx0KTtcclxuXHJcblx0Z2VvbWV0cnkuY29sb3JzLnB1c2goXHJcblx0XHRuZXcgVEhSRUUuQ29sb3IoIDB4ZmYwMDAwICksIG5ldyBUSFJFRS5Db2xvciggMHhmZmFhMDAgKSxcclxuXHRcdG5ldyBUSFJFRS5Db2xvciggMHgwMGZmMDAgKSwgbmV3IFRIUkVFLkNvbG9yKCAweGFhZmYwMCApLFxyXG5cdFx0bmV3IFRIUkVFLkNvbG9yKCAweDAwMDBmZiApLCBuZXcgVEhSRUUuQ29sb3IoIDB4MDBhYWZmIClcclxuXHQpO1xyXG5cclxuXHR2YXIgbWF0ZXJpYWwgPSBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBUSFJFRS5WZXJ0ZXhDb2xvcnMgfSApO1xyXG5cclxuXHRUSFJFRS5MaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCwgVEhSRUUuTGluZVBpZWNlcyApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkF4aXNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuTGluZS5wcm90b3R5cGUgKTtcclxuLyoqXHJcbiAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxyXG4gKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxyXG4gKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cHM6Ly9leG9jb3J0ZXguY29tXHJcbiAqXHJcbiAqIENyZWF0ZXMgYW4gYXJyb3cgZm9yIHZpc3VhbGl6aW5nIGRpcmVjdGlvbnNcclxuICpcclxuICogUGFyYW1ldGVyczpcclxuICogIGRpciAtIFZlY3RvcjNcclxuICogIG9yaWdpbiAtIFZlY3RvcjNcclxuICogIGxlbmd0aCAtIE51bWJlclxyXG4gKiAgaGV4IC0gY29sb3IgaW4gaGV4IHZhbHVlXHJcbiAqL1xyXG5cclxuVEhSRUUuQXJyb3dIZWxwZXIgPSBmdW5jdGlvbiAoIGRpciwgb3JpZ2luLCBsZW5ndGgsIGhleCApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gMjA7XHJcblx0aWYgKCBoZXggPT09IHVuZGVmaW5lZCApIGhleCA9IDB4ZmZmZjAwO1xyXG5cclxuXHR2YXIgbGluZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XHJcblx0bGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCAwLCAwLCAwICkgKTtcclxuXHRsaW5lR2VvbWV0cnkudmVydGljZXMucHVzaCggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSApO1xyXG5cclxuXHR0aGlzLmxpbmUgPSBuZXcgVEhSRUUuTGluZSggbGluZUdlb21ldHJ5LCBuZXcgVEhSRUUuTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleCB9ICkgKTtcclxuXHR0aGlzLmFkZCggdGhpcy5saW5lICk7XHJcblxyXG5cdHZhciBjb25lR2VvbWV0cnkgPSBuZXcgVEhSRUUuQ3lsaW5kZXJHZW9tZXRyeSggMCwgMC4wNSwgMC4yNSwgNSwgMSApO1xyXG5cclxuXHR0aGlzLmNvbmUgPSBuZXcgVEhSRUUuTWVzaCggY29uZUdlb21ldHJ5LCBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleCB9ICkgKTtcclxuXHR0aGlzLmNvbmUucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XHJcblx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xyXG5cclxuXHRpZiAoIG9yaWdpbiBpbnN0YW5jZW9mIFRIUkVFLlZlY3RvcjMgKSB0aGlzLnBvc2l0aW9uID0gb3JpZ2luO1xyXG5cclxuXHR0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XHJcblx0dGhpcy5zZXRMZW5ndGgoIGxlbmd0aCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldERpcmVjdGlvbiA9IGZ1bmN0aW9uICggZGlyICkge1xyXG5cclxuICAgIHZhciBkID0gVEhSRUUuQXJyb3dIZWxwZXIuX192MS5jb3B5KCBkaXIgKS5ub3JtYWxpemUoKTtcclxuXHJcbiAgICBpZiAoIGQueSA+IDAuOTk5ICkge1xyXG5cclxuICAgICAgICB0aGlzLnJvdGF0aW9uLnNldCggMCwgMCwgMCApO1xyXG4gXHJcbiAgICB9IGVsc2UgaWYgKCBkLnkgPCAtIDAuOTk5ICkge1xyXG5cclxuICAgICAgICB0aGlzLnJvdGF0aW9uLnNldCggTWF0aC5QSSwgMCwgMCApO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcblxyXG5cdCAgICB2YXIgYXhpcyA9IFRIUkVFLkFycm93SGVscGVyLl9fdjIuc2V0KCBkLnosIDAsIC0gZC54ICkubm9ybWFsaXplKCk7XHJcblx0ICAgIHZhciByYWRpYW5zID0gTWF0aC5hY29zKCBkLnkgKTtcclxuXHQgICAgdmFyIHF1YXRlcm5pb24gPSBUSFJFRS5BcnJvd0hlbHBlci5fX3ExLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIHJhZGlhbnMgKTtcclxuXHJcblx0ICAgIHRoaXMucm90YXRpb24uc2V0RXVsZXJGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdGhpcy5ldWxlck9yZGVyICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5BcnJvd0hlbHBlci5wcm90b3R5cGUuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKCBsZW5ndGggKSB7XHJcblxyXG5cdHRoaXMuc2NhbGUuc2V0KCBsZW5ndGgsIGxlbmd0aCwgbGVuZ3RoICk7XHJcblxyXG59O1xyXG5cclxuVEhSRUUuQXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKCBoZXggKSB7XHJcblxyXG5cdHRoaXMubGluZS5tYXRlcmlhbC5jb2xvci5zZXRIZXgoIGhleCApO1xyXG5cdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5zZXRIZXgoIGhleCApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkFycm93SGVscGVyLl9fdjEgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5USFJFRS5BcnJvd0hlbHBlci5fX3YyID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuVEhSRUUuQXJyb3dIZWxwZXIuX19xMSA9IG5ldyBUSFJFRS5RdWF0ZXJuaW9uKCk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKlx0LSBzaG93cyBmcnVzdHVtLCBsaW5lIG9mIHNpZ2h0IGFuZCB1cCBvZiB0aGUgY2FtZXJhXHJcbiAqXHQtIHN1aXRhYmxlIGZvciBmYXN0IHVwZGF0ZXNcclxuICogXHQtIGJhc2VkIG9uIGZydXN0dW0gdmlzdWFsaXphdGlvbiBpbiBsaWdodGdsLmpzIHNoYWRvd21hcCBleGFtcGxlXHJcbiAqXHRcdGh0dHA6Ly9ldmFudy5naXRodWIuY29tL2xpZ2h0Z2wuanMvdGVzdHMvc2hhZG93bWFwLmh0bWxcclxuICovXHJcblxyXG5USFJFRS5DYW1lcmFIZWxwZXIgPSBmdW5jdGlvbiAoIGNhbWVyYSApIHtcclxuXHJcblx0VEhSRUUuTGluZS5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkgPSBuZXcgVEhSRUUuR2VvbWV0cnkoKTtcclxuXHR0aGlzLm1hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiAweGZmZmZmZiwgdmVydGV4Q29sb3JzOiBUSFJFRS5GYWNlQ29sb3JzIH0gKTtcclxuXHR0aGlzLnR5cGUgPSBUSFJFRS5MaW5lUGllY2VzO1xyXG5cclxuXHR0aGlzLm1hdHJpeFdvcmxkID0gY2FtZXJhLm1hdHJpeFdvcmxkO1xyXG5cdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xyXG5cclxuXHR0aGlzLnBvaW50TWFwID0ge307XHJcblxyXG5cdC8vIGNvbG9yc1xyXG5cclxuXHR2YXIgaGV4RnJ1c3R1bSA9IDB4ZmZhYTAwO1xyXG5cdHZhciBoZXhDb25lID0gMHhmZjAwMDA7XHJcblx0dmFyIGhleFVwID0gMHgwMGFhZmY7XHJcblx0dmFyIGhleFRhcmdldCA9IDB4ZmZmZmZmO1xyXG5cdHZhciBoZXhDcm9zcyA9IDB4MzMzMzMzO1xyXG5cclxuXHQvLyBuZWFyXHJcblxyXG5cdGFkZExpbmUoIFwibjFcIiwgXCJuMlwiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuMlwiLCBcIm40XCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm40XCIsIFwibjNcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjNcIiwgXCJuMVwiLCBoZXhGcnVzdHVtICk7XHJcblxyXG5cdC8vIGZhclxyXG5cclxuXHRhZGRMaW5lKCBcImYxXCIsIFwiZjJcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwiZjJcIiwgXCJmNFwiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJmNFwiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcImYzXCIsIFwiZjFcIiwgaGV4RnJ1c3R1bSApO1xyXG5cclxuXHQvLyBzaWRlc1xyXG5cclxuXHRhZGRMaW5lKCBcIm4xXCIsIFwiZjFcIiwgaGV4RnJ1c3R1bSApO1xyXG5cdGFkZExpbmUoIFwibjJcIiwgXCJmMlwiLCBoZXhGcnVzdHVtICk7XHJcblx0YWRkTGluZSggXCJuM1wiLCBcImYzXCIsIGhleEZydXN0dW0gKTtcclxuXHRhZGRMaW5lKCBcIm40XCIsIFwiZjRcIiwgaGV4RnJ1c3R1bSApO1xyXG5cclxuXHQvLyBjb25lXHJcblxyXG5cdGFkZExpbmUoIFwicFwiLCBcIm4xXCIsIGhleENvbmUgKTtcclxuXHRhZGRMaW5lKCBcInBcIiwgXCJuMlwiLCBoZXhDb25lICk7XHJcblx0YWRkTGluZSggXCJwXCIsIFwibjNcIiwgaGV4Q29uZSApO1xyXG5cdGFkZExpbmUoIFwicFwiLCBcIm40XCIsIGhleENvbmUgKTtcclxuXHJcblx0Ly8gdXBcclxuXHJcblx0YWRkTGluZSggXCJ1MVwiLCBcInUyXCIsIGhleFVwICk7XHJcblx0YWRkTGluZSggXCJ1MlwiLCBcInUzXCIsIGhleFVwICk7XHJcblx0YWRkTGluZSggXCJ1M1wiLCBcInUxXCIsIGhleFVwICk7XHJcblxyXG5cdC8vIHRhcmdldFxyXG5cclxuXHRhZGRMaW5lKCBcImNcIiwgXCJ0XCIsIGhleFRhcmdldCApO1xyXG5cdGFkZExpbmUoIFwicFwiLCBcImNcIiwgaGV4Q3Jvc3MgKTtcclxuXHJcblx0Ly8gY3Jvc3NcclxuXHJcblx0YWRkTGluZSggXCJjbjFcIiwgXCJjbjJcIiwgaGV4Q3Jvc3MgKTtcclxuXHRhZGRMaW5lKCBcImNuM1wiLCBcImNuNFwiLCBoZXhDcm9zcyApO1xyXG5cclxuXHRhZGRMaW5lKCBcImNmMVwiLCBcImNmMlwiLCBoZXhDcm9zcyApO1xyXG5cdGFkZExpbmUoIFwiY2YzXCIsIFwiY2Y0XCIsIGhleENyb3NzICk7XHJcblxyXG5cdHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG5cclxuXHRmdW5jdGlvbiBhZGRMaW5lKCBhLCBiLCBoZXggKSB7XHJcblxyXG5cdFx0YWRkUG9pbnQoIGEsIGhleCApO1xyXG5cdFx0YWRkUG9pbnQoIGIsIGhleCApO1xyXG5cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGFkZFBvaW50KCBpZCwgaGV4ICkge1xyXG5cclxuXHRcdHNjb3BlLmdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIG5ldyBUSFJFRS5WZWN0b3IzKCkgKTtcclxuXHRcdHNjb3BlLmdlb21ldHJ5LmNvbG9ycy5wdXNoKCBuZXcgVEhSRUUuQ29sb3IoIGhleCApICk7XHJcblxyXG5cdFx0aWYgKCBzY29wZS5wb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkgc2NvcGUucG9pbnRNYXBbIGlkIF0gPSBbXTtcclxuXHJcblx0XHRzY29wZS5wb2ludE1hcFsgaWQgXS5wdXNoKCBzY29wZS5nZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggLSAxICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy51cGRhdGUoIGNhbWVyYSApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLkNhbWVyYUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5MaW5lLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuQ2FtZXJhSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBzY29wZSA9IHRoaXM7XHJcblxyXG5cdHZhciB3ID0gMSwgaCA9IDE7XHJcblxyXG5cdC8vIHdlIG5lZWQganVzdCBjYW1lcmEgcHJvamVjdGlvbiBtYXRyaXhcclxuXHQvLyB3b3JsZCBtYXRyaXggbXVzdCBiZSBpZGVudGl0eVxyXG5cclxuXHRUSFJFRS5DYW1lcmFIZWxwZXIuX19jLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xyXG5cclxuXHQvLyBjZW50ZXIgLyB0YXJnZXRcclxuXHJcblx0c2V0UG9pbnQoIFwiY1wiLCAwLCAwLCAtMSApO1xyXG5cdHNldFBvaW50KCBcInRcIiwgMCwgMCwgIDEgKTtcclxuXHJcblx0Ly8gbmVhclxyXG5cclxuXHRzZXRQb2ludCggXCJuMVwiLCAtdywgLWgsIC0xICk7XHJcblx0c2V0UG9pbnQoIFwibjJcIiwgIHcsIC1oLCAtMSApO1xyXG5cdHNldFBvaW50KCBcIm4zXCIsIC13LCAgaCwgLTEgKTtcclxuXHRzZXRQb2ludCggXCJuNFwiLCAgdywgIGgsIC0xICk7XHJcblxyXG5cdC8vIGZhclxyXG5cclxuXHRzZXRQb2ludCggXCJmMVwiLCAtdywgLWgsIDEgKTtcclxuXHRzZXRQb2ludCggXCJmMlwiLCAgdywgLWgsIDEgKTtcclxuXHRzZXRQb2ludCggXCJmM1wiLCAtdywgIGgsIDEgKTtcclxuXHRzZXRQb2ludCggXCJmNFwiLCAgdywgIGgsIDEgKTtcclxuXHJcblx0Ly8gdXBcclxuXHJcblx0c2V0UG9pbnQoIFwidTFcIiwgIHcgKiAwLjcsIGggKiAxLjEsIC0xICk7XHJcblx0c2V0UG9pbnQoIFwidTJcIiwgLXcgKiAwLjcsIGggKiAxLjEsIC0xICk7XHJcblx0c2V0UG9pbnQoIFwidTNcIiwgICAgICAgIDAsIGggKiAyLCAgIC0xICk7XHJcblxyXG5cdC8vIGNyb3NzXHJcblxyXG5cdHNldFBvaW50KCBcImNmMVwiLCAtdywgIDAsIDEgKTtcclxuXHRzZXRQb2ludCggXCJjZjJcIiwgIHcsICAwLCAxICk7XHJcblx0c2V0UG9pbnQoIFwiY2YzXCIsICAwLCAtaCwgMSApO1xyXG5cdHNldFBvaW50KCBcImNmNFwiLCAgMCwgIGgsIDEgKTtcclxuXHJcblx0c2V0UG9pbnQoIFwiY24xXCIsIC13LCAgMCwgLTEgKTtcclxuXHRzZXRQb2ludCggXCJjbjJcIiwgIHcsICAwLCAtMSApO1xyXG5cdHNldFBvaW50KCBcImNuM1wiLCAgMCwgLWgsIC0xICk7XHJcblx0c2V0UG9pbnQoIFwiY240XCIsICAwLCAgaCwgLTEgKTtcclxuXHJcblx0ZnVuY3Rpb24gc2V0UG9pbnQoIHBvaW50LCB4LCB5LCB6ICkge1xyXG5cclxuXHRcdFRIUkVFLkNhbWVyYUhlbHBlci5fX3Yuc2V0KCB4LCB5LCB6ICk7XHJcblx0XHRUSFJFRS5DYW1lcmFIZWxwZXIuX19wcm9qZWN0b3IudW5wcm9qZWN0VmVjdG9yKCBUSFJFRS5DYW1lcmFIZWxwZXIuX192LCBUSFJFRS5DYW1lcmFIZWxwZXIuX19jICk7XHJcblxyXG5cdFx0dmFyIHBvaW50cyA9IHNjb3BlLnBvaW50TWFwWyBwb2ludCBdO1xyXG5cclxuXHRcdGlmICggcG9pbnRzICE9PSB1bmRlZmluZWQgKSB7XHJcblxyXG5cdFx0XHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0XHRzY29wZS5nZW9tZXRyeS52ZXJ0aWNlc1sgcG9pbnRzWyBpIF0gXS5jb3B5KCBUSFJFRS5DYW1lcmFIZWxwZXIuX192ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9XHJcblxyXG5cdHRoaXMuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5DYW1lcmFIZWxwZXIuX19wcm9qZWN0b3IgPSBuZXcgVEhSRUUuUHJvamVjdG9yKCk7XHJcblRIUkVFLkNhbWVyYUhlbHBlci5fX3YgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5USFJFRS5DYW1lcmFIZWxwZXIuX19jID0gbmV3IFRIUkVFLkNhbWVyYSgpO1xyXG5cclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqXHJcbiAqXHQtIHNob3dzIGRpcmVjdGlvbmFsIGxpZ2h0IGNvbG9yLCBpbnRlbnNpdHksIHBvc2l0aW9uLCBvcmllbnRhdGlvbiBhbmQgdGFyZ2V0XHJcbiAqL1xyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5saWdodCA9IGxpZ2h0O1xyXG5cclxuXHQvLyBwb3NpdGlvblxyXG5cclxuXHR0aGlzLnBvc2l0aW9uID0gbGlnaHQucG9zaXRpb247XHJcblxyXG5cdC8vIGRpcmVjdGlvblxyXG5cclxuXHR0aGlzLmRpcmVjdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5kaXJlY3Rpb24uc3ViVmVjdG9ycyggbGlnaHQudGFyZ2V0LnBvc2l0aW9uLCBsaWdodC5wb3NpdGlvbiApO1xyXG5cclxuXHQvLyBjb2xvclxyXG5cclxuXHR2YXIgaW50ZW5zaXR5ID0gVEhSRUUuTWF0aC5jbGFtcCggbGlnaHQuaW50ZW5zaXR5LCAwLCAxICk7XHJcblxyXG5cdHRoaXMuY29sb3IgPSBsaWdodC5jb2xvci5jbG9uZSgpO1xyXG5cdHRoaXMuY29sb3IubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xyXG5cclxuXHR2YXIgaGV4Q29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xyXG5cclxuXHQvLyBsaWdodCBoZWxwZXJcclxuXHJcblx0dmFyIGJ1bGJHZW9tZXRyeSA9IG5ldyBUSFJFRS5TcGhlcmVHZW9tZXRyeSggc3BoZXJlU2l6ZSwgMTYsIDggKTtcclxuXHR2YXIgcmF5c0dlb21ldHJ5ID0gbmV3IFRIUkVFLkFzdGVyaXNrR2VvbWV0cnkoIHNwaGVyZVNpemUgKiAxLjI1LCBzcGhlcmVTaXplICogMi4yNSApO1xyXG5cclxuXHR2YXIgYnVsYk1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSB9ICk7XHJcblx0dmFyIHJheXNNYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UgfSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIGJ1bGJHZW9tZXRyeSwgYnVsYk1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMubGlnaHRSYXlzID0gbmV3IFRIUkVFLkxpbmUoIHJheXNHZW9tZXRyeSwgcmF5c01hdGVyaWFsLCBUSFJFRS5MaW5lUGllY2VzICk7XHJcblxyXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0U3BoZXJlICk7XHJcblx0dGhpcy5hZGQoIHRoaXMubGlnaHRSYXlzICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUucHJvcGVydGllcy5pc0dpem1vID0gdHJ1ZTtcclxuXHR0aGlzLmxpZ2h0U3BoZXJlLnByb3BlcnRpZXMuZ2l6bW9TdWJqZWN0ID0gbGlnaHQ7XHJcblx0dGhpcy5saWdodFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vUm9vdCA9IHRoaXM7XHJcblxyXG5cdC8vIGxpZ2h0IHRhcmdldCBoZWxwZXJcclxuXHJcblx0dGhpcy50YXJnZXRTcGhlcmUgPSBudWxsO1xyXG5cclxuXHRpZiAoIGxpZ2h0LnRhcmdldC5wcm9wZXJ0aWVzLnRhcmdldEludmVyc2UgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR2YXIgdGFyZ2V0R2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA4LCA0ICk7XHJcblx0XHR2YXIgdGFyZ2V0TWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIHRhcmdldEdlbywgdGFyZ2V0TWF0ZXJpYWwgKTtcclxuXHRcdHRoaXMudGFyZ2V0U3BoZXJlLnBvc2l0aW9uID0gbGlnaHQudGFyZ2V0LnBvc2l0aW9uO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0U3BoZXJlLnByb3BlcnRpZXMuaXNHaXptbyA9IHRydWU7XHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vU3ViamVjdCA9IGxpZ2h0LnRhcmdldDtcclxuXHRcdHRoaXMudGFyZ2V0U3BoZXJlLnByb3BlcnRpZXMuZ2l6bW9Sb290ID0gdGhpcy50YXJnZXRTcGhlcmU7XHJcblxyXG5cdFx0dmFyIGxpbmVNYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBkYXNoU2l6ZTogNCwgZ2FwU2l6ZTogNCwgb3BhY2l0eTogMC43NSwgdHJhbnNwYXJlbnQ6IHRydWUsIGZvZzogZmFsc2UgfSApO1xyXG5cdFx0dmFyIGxpbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdFx0bGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHRoaXMucG9zaXRpb24uY2xvbmUoKSApO1xyXG5cdFx0bGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHRoaXMudGFyZ2V0U3BoZXJlLnBvc2l0aW9uLmNsb25lKCkgKTtcclxuXHRcdGxpbmVHZW9tZXRyeS5jb21wdXRlTGluZURpc3RhbmNlcygpO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBUSFJFRS5MaW5lKCBsaW5lR2VvbWV0cnksIGxpbmVNYXRlcmlhbCApO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLnByb3BlcnRpZXMuaXNHaXptbyA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5wcm9wZXJ0aWVzLmlzR2l6bW8gPSB0cnVlO1xyXG5cclxufVxyXG5cclxuVEhSRUUuRGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5PYmplY3QzRC5wcm90b3R5cGUgKTtcclxuXHJcblRIUkVFLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0Ly8gdXBkYXRlIGFycm93IG9yaWVudGF0aW9uXHJcblx0Ly8gcG9pbnRpbmcgZnJvbSBsaWdodCB0byB0YXJnZXRcclxuXHJcblx0dGhpcy5kaXJlY3Rpb24uc3ViVmVjdG9ycyggdGhpcy5saWdodC50YXJnZXQucG9zaXRpb24sIHRoaXMubGlnaHQucG9zaXRpb24gKTtcclxuXHJcblx0Ly8gdXBkYXRlIGFycm93LCBzcGhlcmVzLCByYXlzIGFuZCBsaW5lIGNvbG9ycyB0byBsaWdodCBjb2xvciAqIGxpZ2h0IGludGVuc2l0eVxyXG5cclxuXHR2YXIgaW50ZW5zaXR5ID0gVEhSRUUuTWF0aC5jbGFtcCggdGhpcy5saWdodC5pbnRlbnNpdHksIDAsIDEgKTtcclxuXHJcblx0dGhpcy5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XHJcblx0dGhpcy5jb2xvci5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdHRoaXMubGlnaHRSYXlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0Ly8gT25seSB1cGRhdGUgdGFyZ2V0U3BoZXJlIGFuZCB0YXJnZXRMaW5lIGlmIGF2YWlsYWJsZVxyXG5cdGlmICggdGhpcy50YXJnZXRTcGhlcmUgIT09IG51bGwgKSB7XHJcblxyXG5cdFx0dGhpcy50YXJnZXRTcGhlcmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHJcblx0XHQvLyB1cGRhdGUgdGFyZ2V0IGxpbmUgdmVydGljZXNcclxuXHJcblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbIDAgXS5jb3B5KCB0aGlzLmxpZ2h0LnBvc2l0aW9uICk7XHJcblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNbIDEgXS5jb3B5KCB0aGlzLmxpZ2h0LnRhcmdldC5wb3NpdGlvbiApO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5jb21wdXRlTGluZURpc3RhbmNlcygpO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKlx0LSBzaG93cyBoZW1pc3BoZXJlIGxpZ2h0IGludGVuc2l0eSwgc2t5IGFuZCBncm91bmQgY29sb3JzIGFuZCBkaXJlY3Rpb25zXHJcbiAqL1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSwgYXJyb3dMZW5ndGgsIGRvbWVTaXplICkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMubGlnaHQgPSBsaWdodDtcclxuXHJcblx0Ly8gcG9zaXRpb25cclxuXHJcblx0dGhpcy5wb3NpdGlvbiA9IGxpZ2h0LnBvc2l0aW9uO1xyXG5cclxuXHQvL1xyXG5cclxuXHR2YXIgaW50ZW5zaXR5ID0gVEhSRUUuTWF0aC5jbGFtcCggbGlnaHQuaW50ZW5zaXR5LCAwLCAxICk7XHJcblxyXG5cdC8vIHNreSBjb2xvclxyXG5cclxuXHR0aGlzLmNvbG9yID0gbGlnaHQuY29sb3IuY2xvbmUoKTtcclxuXHR0aGlzLmNvbG9yLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcclxuXHJcblx0dmFyIGhleENvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcclxuXHJcblx0Ly8gZ3JvdW5kIGNvbG9yXHJcblxyXG5cdHRoaXMuZ3JvdW5kQ29sb3IgPSBsaWdodC5ncm91bmRDb2xvci5jbG9uZSgpO1xyXG5cdHRoaXMuZ3JvdW5kQ29sb3IubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xyXG5cclxuXHR2YXIgaGV4Q29sb3JHcm91bmQgPSB0aGlzLmdyb3VuZENvbG9yLmdldEhleCgpO1xyXG5cclxuXHQvLyBkb3VibGUgY29sb3JlZCBsaWdodCBidWxiXHJcblxyXG5cdHZhciBidWxiR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDE2LCA4LCAwLCBNYXRoLlBJICogMiwgMCwgTWF0aC5QSSAqIDAuNSApO1xyXG5cdHZhciBidWxiR3JvdW5kR2VvbWV0cnkgPSBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoIHNwaGVyZVNpemUsIDE2LCA4LCAwLCBNYXRoLlBJICogMiwgTWF0aC5QSSAqIDAuNSwgTWF0aC5QSSApO1xyXG5cclxuXHR2YXIgYnVsYlNreU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSB9ICk7XHJcblx0dmFyIGJ1bGJHcm91bmRNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3JHcm91bmQsIGZvZzogZmFsc2UgfSApO1xyXG5cclxuXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYnVsYkdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdGJ1bGJHZW9tZXRyeS5mYWNlc1sgaSBdLm1hdGVyaWFsSW5kZXggPSAwO1xyXG5cclxuXHR9XHJcblxyXG5cdGZvciAoIHZhciBpID0gMCwgaWwgPSBidWxiR3JvdW5kR2VvbWV0cnkuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0YnVsYkdyb3VuZEdlb21ldHJ5LmZhY2VzWyBpIF0ubWF0ZXJpYWxJbmRleCA9IDE7XHJcblxyXG5cdH1cclxuXHJcblx0VEhSRUUuR2VvbWV0cnlVdGlscy5tZXJnZSggYnVsYkdlb21ldHJ5LCBidWxiR3JvdW5kR2VvbWV0cnkgKTtcclxuXHJcblx0dGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBidWxiR2VvbWV0cnksIG5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKCBbIGJ1bGJTa3lNYXRlcmlhbCwgYnVsYkdyb3VuZE1hdGVyaWFsIF0gKSApO1xyXG5cclxuXHQvLyBhcnJvd3MgZm9yIHNreSBhbmQgZ3JvdW5kIGxpZ2h0IGRpcmVjdGlvbnNcclxuXHJcblx0dGhpcy5saWdodEFycm93ID0gbmV3IFRIUkVFLkFycm93SGVscGVyKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgKCBzcGhlcmVTaXplICsgYXJyb3dMZW5ndGggKSAqIDEuMSwgMCApLCBhcnJvd0xlbmd0aCwgaGV4Q29sb3IgKTtcclxuXHR0aGlzLmxpZ2h0QXJyb3cucm90YXRpb24ueCA9IE1hdGguUEk7XHJcblxyXG5cdHRoaXMubGlnaHRBcnJvd0dyb3VuZCA9IG5ldyBUSFJFRS5BcnJvd0hlbHBlciggbmV3IFRIUkVFLlZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFRIUkVFLlZlY3RvcjMoIDAsICggc3BoZXJlU2l6ZSArIGFycm93TGVuZ3RoICkgKiAtMS4xLCAwICksIGFycm93TGVuZ3RoLCBoZXhDb2xvckdyb3VuZCApO1xyXG5cclxuXHR2YXIgam9pbnQgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcclxuXHRqb2ludC5yb3RhdGlvbi54ID0gLU1hdGguUEkgKiAwLjU7XHJcblxyXG5cdGpvaW50LmFkZCggdGhpcy5saWdodFNwaGVyZSApO1xyXG5cdGpvaW50LmFkZCggdGhpcy5saWdodEFycm93ICk7XHJcblx0am9pbnQuYWRkKCB0aGlzLmxpZ2h0QXJyb3dHcm91bmQgKTtcclxuXHJcblx0dGhpcy5hZGQoIGpvaW50ICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUucHJvcGVydGllcy5pc0dpem1vID0gdHJ1ZTtcclxuXHR0aGlzLmxpZ2h0U3BoZXJlLnByb3BlcnRpZXMuZ2l6bW9TdWJqZWN0ID0gbGlnaHQ7XHJcblx0dGhpcy5saWdodFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vUm9vdCA9IHRoaXM7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMucHJvcGVydGllcy5pc0dpem1vID0gdHJ1ZTtcclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy50YXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdHRoaXMubG9va0F0KCB0aGlzLnRhcmdldCApO1xyXG5cclxufVxyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuSGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIHVwZGF0ZSBzcGhlcmUgc2t5IGFuZCBncm91bmQgY29sb3JzIHRvIGxpZ2h0IGNvbG9yICogbGlnaHQgaW50ZW5zaXR5XHJcblxyXG5cdHZhciBpbnRlbnNpdHkgPSBUSFJFRS5NYXRoLmNsYW1wKCB0aGlzLmxpZ2h0LmludGVuc2l0eSwgMCwgMSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcclxuXHR0aGlzLmNvbG9yLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcclxuXHJcblx0dGhpcy5ncm91bmRDb2xvci5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICk7XHJcblx0dGhpcy5ncm91bmRDb2xvci5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwubWF0ZXJpYWxzWyAwIF0uY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdHRoaXMubGlnaHRTcGhlcmUubWF0ZXJpYWwubWF0ZXJpYWxzWyAxIF0uY29sb3IuY29weSggdGhpcy5ncm91bmRDb2xvciApO1xyXG5cclxuXHR0aGlzLmxpZ2h0QXJyb3cuc2V0Q29sb3IoIHRoaXMuY29sb3IuZ2V0SGV4KCkgKTtcclxuXHR0aGlzLmxpZ2h0QXJyb3dHcm91bmQuc2V0Q29sb3IoIHRoaXMuZ3JvdW5kQ29sb3IuZ2V0SGV4KCkgKTtcclxuXHJcblx0dGhpcy5sb29rQXQoIHRoaXMudGFyZ2V0ICk7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICpcdC0gc2hvd3MgcG9pbnQgbGlnaHQgY29sb3IsIGludGVuc2l0eSwgcG9zaXRpb24gYW5kIGRpc3RhbmNlXHJcbiAqL1xyXG5cclxuVEhSRUUuUG9pbnRMaWdodEhlbHBlciA9IGZ1bmN0aW9uICggbGlnaHQsIHNwaGVyZVNpemUgKSB7XHJcblxyXG5cdFRIUkVFLk9iamVjdDNELmNhbGwoIHRoaXMgKTtcclxuXHJcblx0dGhpcy5saWdodCA9IGxpZ2h0O1xyXG5cclxuXHQvLyBwb3NpdGlvblxyXG5cclxuXHR0aGlzLnBvc2l0aW9uID0gbGlnaHQucG9zaXRpb247XHJcblxyXG5cdC8vIGNvbG9yXHJcblxyXG5cdHZhciBpbnRlbnNpdHkgPSBUSFJFRS5NYXRoLmNsYW1wKCBsaWdodC5pbnRlbnNpdHksIDAsIDEgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IGxpZ2h0LmNvbG9yLmNsb25lKCk7XHJcblx0dGhpcy5jb2xvci5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblxyXG5cdHZhciBoZXhDb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XHJcblxyXG5cdC8vIGxpZ2h0IGhlbHBlclxyXG5cclxuXHR2YXIgYnVsYkdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCAxNiwgOCApO1xyXG5cdHZhciByYXlzR2VvbWV0cnkgPSBuZXcgVEhSRUUuQXN0ZXJpc2tHZW9tZXRyeSggc3BoZXJlU2l6ZSAqIDEuMjUsIHNwaGVyZVNpemUgKiAyLjI1ICk7XHJcblx0dmFyIGRpc3RhbmNlR2VvbWV0cnkgPSBuZXcgVEhSRUUuSWNvc2FoZWRyb25HZW9tZXRyeSggMSwgMiApO1xyXG5cclxuXHR2YXIgYnVsYk1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSB9ICk7XHJcblx0dmFyIHJheXNNYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UgfSApO1xyXG5cdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSwgd2lyZWZyYW1lOiB0cnVlLCBvcGFjaXR5OiAwLjEsIHRyYW5zcGFyZW50OiB0cnVlIH0gKTtcclxuXHJcblx0dGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBidWxiR2VvbWV0cnksIGJ1bGJNYXRlcmlhbCApO1xyXG5cdHRoaXMubGlnaHRSYXlzID0gbmV3IFRIUkVFLkxpbmUoIHJheXNHZW9tZXRyeSwgcmF5c01hdGVyaWFsLCBUSFJFRS5MaW5lUGllY2VzICk7XHJcblx0dGhpcy5saWdodERpc3RhbmNlID0gbmV3IFRIUkVFLk1lc2goIGRpc3RhbmNlR2VvbWV0cnksIGRpc3RhbmNlTWF0ZXJpYWwgKTtcclxuXHJcblx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcclxuXHJcblx0aWYgKCBkID09PSAwLjAgKSB7XHJcblxyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XHJcblxyXG5cdH1cclxuXHJcblx0dGhpcy5hZGQoIHRoaXMubGlnaHRTcGhlcmUgKTtcclxuXHR0aGlzLmFkZCggdGhpcy5saWdodFJheXMgKTtcclxuXHR0aGlzLmFkZCggdGhpcy5saWdodERpc3RhbmNlICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUucHJvcGVydGllcy5pc0dpem1vID0gdHJ1ZTtcclxuXHR0aGlzLmxpZ2h0U3BoZXJlLnByb3BlcnRpZXMuZ2l6bW9TdWJqZWN0ID0gbGlnaHQ7XHJcblx0dGhpcy5saWdodFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vUm9vdCA9IHRoaXM7XHJcblxyXG5cdC8vXHJcblxyXG5cdHRoaXMucHJvcGVydGllcy5pc0dpem1vID0gdHJ1ZTtcclxuXHJcbn1cclxuXHJcblRIUkVFLlBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcblxyXG5USFJFRS5Qb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIHVwZGF0ZSBzcGhlcmUgYW5kIHJheXMgY29sb3JzIHRvIGxpZ2h0IGNvbG9yICogbGlnaHQgaW50ZW5zaXR5XHJcblxyXG5cdHZhciBpbnRlbnNpdHkgPSBUSFJFRS5NYXRoLmNsYW1wKCB0aGlzLmxpZ2h0LmludGVuc2l0eSwgMCwgMSApO1xyXG5cclxuXHR0aGlzLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcclxuXHR0aGlzLmNvbG9yLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcclxuXHJcblx0dGhpcy5saWdodFNwaGVyZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblx0dGhpcy5saWdodFJheXMubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cdHRoaXMubGlnaHREaXN0YW5jZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblxyXG5cdC8vXHJcblxyXG5cdHZhciBkID0gdGhpcy5saWdodC5kaXN0YW5jZTtcclxuXHJcblx0aWYgKCBkID09PSAwLjAgKSB7XHJcblxyXG5cdFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcclxuXHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IHRydWU7XHJcblx0XHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XHJcblxyXG5cdH1cclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKlxyXG4gKlx0LSBzaG93cyBzcG90IGxpZ2h0IGNvbG9yLCBpbnRlbnNpdHksIHBvc2l0aW9uLCBvcmllbnRhdGlvbiwgbGlnaHQgY29uZSBhbmQgdGFyZ2V0XHJcbiAqL1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyID0gZnVuY3Rpb24gKCBsaWdodCwgc3BoZXJlU2l6ZSApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XHJcblxyXG5cdC8vIHBvc2l0aW9uXHJcblxyXG5cdHRoaXMucG9zaXRpb24gPSBsaWdodC5wb3NpdGlvbjtcclxuXHJcblx0Ly8gZGlyZWN0aW9uXHJcblxyXG5cdHRoaXMuZGlyZWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHR0aGlzLmRpcmVjdGlvbi5zdWJWZWN0b3JzKCBsaWdodC50YXJnZXQucG9zaXRpb24sIGxpZ2h0LnBvc2l0aW9uICk7XHJcblxyXG5cdC8vIGNvbG9yXHJcblxyXG5cdHZhciBpbnRlbnNpdHkgPSBUSFJFRS5NYXRoLmNsYW1wKCBsaWdodC5pbnRlbnNpdHksIDAsIDEgKTtcclxuXHJcblx0dGhpcy5jb2xvciA9IGxpZ2h0LmNvbG9yLmNsb25lKCk7XHJcblx0dGhpcy5jb2xvci5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XHJcblxyXG5cdHZhciBoZXhDb2xvciA9IHRoaXMuY29sb3IuZ2V0SGV4KCk7XHJcblxyXG5cdC8vIGxpZ2h0IGhlbHBlclxyXG5cclxuXHR2YXIgYnVsYkdlb21ldHJ5ID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCAxNiwgOCApO1xyXG5cdHZhciByYXlzR2VvbWV0cnkgPSBuZXcgVEhSRUUuQXN0ZXJpc2tHZW9tZXRyeSggc3BoZXJlU2l6ZSAqIDEuMjUsIHNwaGVyZVNpemUgKiAyLjI1ICk7XHJcblx0dmFyIGNvbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5DeWxpbmRlckdlb21ldHJ5KCAwLjAwMDEsIDEsIDEsIDgsIDEsIHRydWUgKTtcclxuXHJcblx0dmFyIGNvbmVNYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpO1xyXG5cdGNvbmVNYXRyaXgucm90YXRlWCggLU1hdGguUEkvMiApO1xyXG5cdGNvbmVNYXRyaXgudHJhbnNsYXRlKCBuZXcgVEhSRUUuVmVjdG9yMyggMCwgLTAuNSwgMCApICk7XHJcblx0Y29uZUdlb21ldHJ5LmFwcGx5TWF0cml4KCBjb25lTWF0cml4ICk7XHJcblxyXG5cdHZhciBidWxiTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBmb2c6IGZhbHNlIH0gKTtcclxuXHR2YXIgcmF5c01hdGVyaWFsID0gbmV3IFRIUkVFLkxpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXhDb2xvciwgZm9nOiBmYWxzZSB9ICk7XHJcblx0dmFyIGNvbmVNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4zLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUgPSBuZXcgVEhSRUUuTWVzaCggYnVsYkdlb21ldHJ5LCBidWxiTWF0ZXJpYWwgKTtcclxuXHR0aGlzLmxpZ2h0Q29uZSA9IG5ldyBUSFJFRS5NZXNoKCBjb25lR2VvbWV0cnksIGNvbmVNYXRlcmlhbCApO1xyXG5cclxuXHR2YXIgY29uZUxlbmd0aCA9IGxpZ2h0LmRpc3RhbmNlID8gbGlnaHQuZGlzdGFuY2UgOiAxMDAwMDtcclxuXHR2YXIgY29uZVdpZHRoID0gY29uZUxlbmd0aCAqIE1hdGgudGFuKCBsaWdodC5hbmdsZSAqIDAuNSApICogMjtcclxuXHR0aGlzLmxpZ2h0Q29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XHJcblxyXG5cdHRoaXMubGlnaHRSYXlzID0gbmV3IFRIUkVFLkxpbmUoIHJheXNHZW9tZXRyeSwgcmF5c01hdGVyaWFsLCBUSFJFRS5MaW5lUGllY2VzICk7XHJcblxyXG5cdHRoaXMuZ3lyb3Njb3BlID0gbmV3IFRIUkVFLkd5cm9zY29wZSgpO1xyXG5cclxuXHR0aGlzLmd5cm9zY29wZS5hZGQoIHRoaXMubGlnaHRTcGhlcmUgKTtcclxuXHR0aGlzLmd5cm9zY29wZS5hZGQoIHRoaXMubGlnaHRSYXlzICk7XHJcblxyXG5cdHRoaXMuYWRkKCB0aGlzLmd5cm9zY29wZSApO1xyXG5cdHRoaXMuYWRkKCB0aGlzLmxpZ2h0Q29uZSApO1xyXG5cclxuXHR0aGlzLmxvb2tBdCggbGlnaHQudGFyZ2V0LnBvc2l0aW9uICk7XHJcblxyXG5cdHRoaXMubGlnaHRTcGhlcmUucHJvcGVydGllcy5pc0dpem1vID0gdHJ1ZTtcclxuXHR0aGlzLmxpZ2h0U3BoZXJlLnByb3BlcnRpZXMuZ2l6bW9TdWJqZWN0ID0gbGlnaHQ7XHJcblx0dGhpcy5saWdodFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vUm9vdCA9IHRoaXM7XHJcblxyXG5cdC8vIGxpZ2h0IHRhcmdldCBoZWxwZXJcclxuXHJcblx0dGhpcy50YXJnZXRTcGhlcmUgPSBudWxsO1xyXG5cclxuXHRpZiAoIGxpZ2h0LnRhcmdldC5wcm9wZXJ0aWVzLnRhcmdldEludmVyc2UgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR2YXIgdGFyZ2V0R2VvID0gbmV3IFRIUkVFLlNwaGVyZUdlb21ldHJ5KCBzcGhlcmVTaXplLCA4LCA0ICk7XHJcblx0XHR2YXIgdGFyZ2V0TWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0U3BoZXJlID0gbmV3IFRIUkVFLk1lc2goIHRhcmdldEdlbywgdGFyZ2V0TWF0ZXJpYWwgKTtcclxuXHRcdHRoaXMudGFyZ2V0U3BoZXJlLnBvc2l0aW9uID0gbGlnaHQudGFyZ2V0LnBvc2l0aW9uO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0U3BoZXJlLnByb3BlcnRpZXMuaXNHaXptbyA9IHRydWU7XHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZS5wcm9wZXJ0aWVzLmdpem1vU3ViamVjdCA9IGxpZ2h0LnRhcmdldDtcclxuXHRcdHRoaXMudGFyZ2V0U3BoZXJlLnByb3BlcnRpZXMuZ2l6bW9Sb290ID0gdGhpcy50YXJnZXRTcGhlcmU7XHJcblxyXG5cdFx0dmFyIGxpbmVNYXRlcmlhbCA9IG5ldyBUSFJFRS5MaW5lRGFzaGVkTWF0ZXJpYWwoIHsgY29sb3I6IGhleENvbG9yLCBkYXNoU2l6ZTogNCwgZ2FwU2l6ZTogNCwgb3BhY2l0eTogMC43NSwgdHJhbnNwYXJlbnQ6IHRydWUsIGZvZzogZmFsc2UgfSApO1xyXG5cdFx0dmFyIGxpbmVHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xyXG5cdFx0bGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHRoaXMucG9zaXRpb24uY2xvbmUoKSApO1xyXG5cdFx0bGluZUdlb21ldHJ5LnZlcnRpY2VzLnB1c2goIHRoaXMudGFyZ2V0U3BoZXJlLnBvc2l0aW9uLmNsb25lKCkgKTtcclxuXHRcdGxpbmVHZW9tZXRyeS5jb21wdXRlTGluZURpc3RhbmNlcygpO1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0TGluZSA9IG5ldyBUSFJFRS5MaW5lKCBsaW5lR2VvbWV0cnksIGxpbmVNYXRlcmlhbCApO1xyXG5cdFx0dGhpcy50YXJnZXRMaW5lLnByb3BlcnRpZXMuaXNHaXptbyA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcblx0Ly9cclxuXHJcblx0dGhpcy5wcm9wZXJ0aWVzLmlzR2l6bW8gPSB0cnVlO1xyXG5cclxufVxyXG5cclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuU3BvdExpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdC8vIHVwZGF0ZSBhcnJvdyBvcmllbnRhdGlvblxyXG5cdC8vIHBvaW50aW5nIGZyb20gbGlnaHQgdG8gdGFyZ2V0XHJcblxyXG5cdHRoaXMuZGlyZWN0aW9uLnN1YlZlY3RvcnMoIHRoaXMubGlnaHQudGFyZ2V0LnBvc2l0aW9uLCB0aGlzLmxpZ2h0LnBvc2l0aW9uICk7XHJcblxyXG5cdC8vIHVwZGF0ZSBsaWdodCBjb25lIG9yaWVudGF0aW9uIGFuZCBzaXplXHJcblxyXG5cdHRoaXMubG9va0F0KCB0aGlzLmxpZ2h0LnRhcmdldC5wb3NpdGlvbiApO1xyXG5cclxuXHR2YXIgY29uZUxlbmd0aCA9IHRoaXMubGlnaHQuZGlzdGFuY2UgPyB0aGlzLmxpZ2h0LmRpc3RhbmNlIDogMTAwMDA7XHJcblx0dmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSAqIDAuNSApICogMjtcclxuXHR0aGlzLmxpZ2h0Q29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XHJcblxyXG5cdC8vIHVwZGF0ZSBhcnJvdywgc3BoZXJlcywgcmF5cyBhbmQgbGluZSBjb2xvcnMgdG8gbGlnaHQgY29sb3IgKiBsaWdodCBpbnRlbnNpdHlcclxuXHJcblx0dmFyIGludGVuc2l0eSA9IFRIUkVFLk1hdGguY2xhbXAoIHRoaXMubGlnaHQuaW50ZW5zaXR5LCAwLCAxICk7XHJcblxyXG5cdHRoaXMuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xyXG5cdHRoaXMuY29sb3IubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSApO1xyXG5cclxuXHR0aGlzLmxpZ2h0U3BoZXJlLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMuY29sb3IgKTtcclxuXHR0aGlzLmxpZ2h0UmF5cy5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblx0dGhpcy5saWdodENvbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cclxuXHQvLyBPbmx5IHVwZGF0ZSB0YXJnZXRTcGhlcmUgYW5kIHRhcmdldExpbmUgaWYgYXZhaWxhYmxlXHJcblx0aWYgKCB0aGlzLnRhcmdldFNwaGVyZSAhPT0gbnVsbCApIHtcclxuXHJcblx0XHR0aGlzLnRhcmdldFNwaGVyZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmNvbG9yICk7XHJcblx0XHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5jb2xvciApO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSB0YXJnZXQgbGluZSB2ZXJ0aWNlc1xyXG5cclxuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc1sgMCBdLmNvcHkoIHRoaXMubGlnaHQucG9zaXRpb24gKTtcclxuXHRcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS52ZXJ0aWNlc1sgMSBdLmNvcHkoIHRoaXMubGlnaHQudGFyZ2V0LnBvc2l0aW9uICk7XHJcblxyXG5cdFx0dGhpcy50YXJnZXRMaW5lLmdlb21ldHJ5LmNvbXB1dGVMaW5lRGlzdGFuY2VzKCk7XHJcblx0XHR0aGlzLnRhcmdldExpbmUuZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHRUSFJFRS5PYmplY3QzRC5jYWxsKCB0aGlzICk7XHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCByZW5kZXJDYWxsYmFjayApIHsgfTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5JbW1lZGlhdGVSZW5kZXJPYmplY3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVEhSRUUuT2JqZWN0M0QucHJvdG90eXBlICk7XHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkxlbnNGbGFyZSA9IGZ1bmN0aW9uICggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApIHtcclxuXHJcblx0VEhSRUUuT2JqZWN0M0QuY2FsbCggdGhpcyApO1xyXG5cclxuXHR0aGlzLmxlbnNGbGFyZXMgPSBbXTtcclxuXHJcblx0dGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblx0dGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHVuZGVmaW5lZDtcclxuXHJcblx0aWYoIHRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcclxuXHJcblx0XHR0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRIUkVFLk9iamVjdDNELnByb3RvdHlwZSApO1xyXG5cclxuXHJcbi8qXHJcbiAqIEFkZDogYWRkcyBhbm90aGVyIGZsYXJlXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoIHRleHR1cmUsIHNpemUsIGRpc3RhbmNlLCBibGVuZGluZywgY29sb3IsIG9wYWNpdHkgKSB7XHJcblxyXG5cdGlmKCBzaXplID09PSB1bmRlZmluZWQgKSBzaXplID0gLTE7XHJcblx0aWYoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XHJcblx0aWYoIG9wYWNpdHkgPT09IHVuZGVmaW5lZCApIG9wYWNpdHkgPSAxO1xyXG5cdGlmKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoIDB4ZmZmZmZmICk7XHJcblx0aWYoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IFRIUkVFLk5vcm1hbEJsZW5kaW5nO1xyXG5cclxuXHRkaXN0YW5jZSA9IE1hdGgubWluKCBkaXN0YW5jZSwgTWF0aC5tYXgoIDAsIGRpc3RhbmNlICkgKTtcclxuXHJcblx0dGhpcy5sZW5zRmxhcmVzLnB1c2goIHsgdGV4dHVyZTogdGV4dHVyZSwgXHRcdFx0Ly8gVEhSRUUuVGV4dHVyZVxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICBzaXplOiBzaXplLCBcdFx0XHRcdC8vIHNpemUgaW4gcGl4ZWxzICgtMSA9IHVzZSB0ZXh0dXJlLndpZHRoKVxyXG5cdFx0ICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogZGlzdGFuY2UsIFx0XHQvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXHJcblx0XHQgICAgICAgICAgICAgICAgICAgIHg6IDAsIHk6IDAsIHo6IDAsXHRcdFx0Ly8gc2NyZWVuIHBvc2l0aW9uICgtMSA9PiAxKSB6ID0gMCBpcyBvbnRvcCB6ID0gMSBpcyBiYWNrXHJcblx0XHQgICAgICAgICAgICAgICAgICAgIHNjYWxlOiAxLCBcdFx0XHRcdFx0Ly8gc2NhbGVcclxuXHRcdCAgICAgICAgICAgICAgICAgICAgcm90YXRpb246IDEsIFx0XHRcdFx0Ly8gcm90YXRpb25cclxuXHRcdCAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcdFx0XHQvLyBvcGFjaXR5XHJcblx0XHRcdFx0XHRcdFx0Y29sb3I6IGNvbG9yLFx0XHRcdFx0Ly8gY29sb3JcclxuXHRcdCAgICAgICAgICAgICAgICAgICAgYmxlbmRpbmc6IGJsZW5kaW5nIH0gKTtcdFx0Ly8gYmxlbmRpbmdcclxuXHJcbn07XHJcblxyXG5cclxuLypcclxuICogVXBkYXRlIGxlbnMgZmxhcmVzIHVwZGF0ZSBwb3NpdGlvbnMgb24gYWxsIGZsYXJlcyBiYXNlZCBvbiB0aGUgc2NyZWVuIHBvc2l0aW9uXHJcbiAqIFNldCBteUxlbnNGbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayB0byBhbHRlciB0aGUgZmxhcmVzIGluIHlvdXIgcHJvamVjdCBzcGVjaWZpYyB3YXkuXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlLnByb3RvdHlwZS51cGRhdGVMZW5zRmxhcmVzID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgZiwgZmwgPSB0aGlzLmxlbnNGbGFyZXMubGVuZ3RoO1xyXG5cdHZhciBmbGFyZTtcclxuXHR2YXIgdmVjWCA9IC10aGlzLnBvc2l0aW9uU2NyZWVuLnggKiAyO1xyXG5cdHZhciB2ZWNZID0gLXRoaXMucG9zaXRpb25TY3JlZW4ueSAqIDI7XHJcblxyXG5cdGZvciggZiA9IDA7IGYgPCBmbDsgZiArKyApIHtcclxuXHJcblx0XHRmbGFyZSA9IHRoaXMubGVuc0ZsYXJlc1sgZiBdO1xyXG5cclxuXHRcdGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XHJcblx0XHRmbGFyZS55ID0gdGhpcy5wb3NpdGlvblNjcmVlbi55ICsgdmVjWSAqIGZsYXJlLmRpc3RhbmNlO1xyXG5cclxuXHRcdGZsYXJlLndhbnRlZFJvdGF0aW9uID0gZmxhcmUueCAqIE1hdGguUEkgKiAwLjI1O1xyXG5cdFx0ZmxhcmUucm90YXRpb24gKz0gKCBmbGFyZS53YW50ZWRSb3RhdGlvbiAtIGZsYXJlLnJvdGF0aW9uICkgKiAwLjI1O1xyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaCA9IGZ1bmN0aW9uKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XHJcblxyXG5cdFRIUkVFLk1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XHJcblxyXG5cdHRoaXMuYW5pbWF0aW9uc01hcCA9IHt9O1xyXG5cdHRoaXMuYW5pbWF0aW9uc0xpc3QgPSBbXTtcclxuXHJcblx0Ly8gcHJlcGFyZSBkZWZhdWx0IGFuaW1hdGlvblxyXG5cdC8vIChhbGwgZnJhbWVzIHBsYXllZCB0b2dldGhlciBpbiAxIHNlY29uZClcclxuXHJcblx0dmFyIG51bUZyYW1lcyA9IHRoaXMuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aDtcclxuXHJcblx0dmFyIG5hbWUgPSBcIl9fZGVmYXVsdFwiO1xyXG5cclxuXHR2YXIgc3RhcnRGcmFtZSA9IDA7XHJcblx0dmFyIGVuZEZyYW1lID0gbnVtRnJhbWVzIC0gMTtcclxuXHJcblx0dmFyIGZwcyA9IG51bUZyYW1lcyAvIDE7XHJcblxyXG5cdHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCBzdGFydEZyYW1lLCBlbmRGcmFtZSwgZnBzICk7XHJcblx0dGhpcy5zZXRBbmltYXRpb25XZWlnaHQoIG5hbWUsIDEgKTtcclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUSFJFRS5NZXNoLnByb3RvdHlwZSApO1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLmNyZWF0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSwgc3RhcnQsIGVuZCwgZnBzICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0ge1xyXG5cclxuXHRcdHN0YXJ0RnJhbWU6IHN0YXJ0LFxyXG5cdFx0ZW5kRnJhbWU6IGVuZCxcclxuXHJcblx0XHRsZW5ndGg6IGVuZCAtIHN0YXJ0ICsgMSxcclxuXHJcblx0XHRmcHM6IGZwcyxcclxuXHRcdGR1cmF0aW9uOiAoIGVuZCAtIHN0YXJ0ICkgLyBmcHMsXHJcblxyXG5cdFx0bGFzdEZyYW1lOiAwLFxyXG5cdFx0Y3VycmVudEZyYW1lOiAwLFxyXG5cclxuXHRcdGFjdGl2ZTogZmFsc2UsXHJcblxyXG5cdFx0dGltZTogMCxcclxuXHRcdGRpcmVjdGlvbjogMSxcclxuXHRcdHdlaWdodDogMSxcclxuXHJcblx0XHRkaXJlY3Rpb25CYWNrd2FyZHM6IGZhbHNlLFxyXG5cdFx0bWlycm9yZWRMb29wOiBmYWxzZVxyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXSA9IGFuaW1hdGlvbjtcclxuXHR0aGlzLmFuaW1hdGlvbnNMaXN0LnB1c2goIGFuaW1hdGlvbiApO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5hdXRvQ3JlYXRlQW5pbWF0aW9ucyA9IGZ1bmN0aW9uICggZnBzICkge1xyXG5cclxuXHR2YXIgcGF0dGVybiA9IC8oW2Etel0rKShcXGQrKS87XHJcblxyXG5cdHZhciBmaXJzdEFuaW1hdGlvbiwgZnJhbWVSYW5nZXMgPSB7fTtcclxuXHJcblx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcclxuXHJcblx0XHR2YXIgbW9ycGggPSBnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXTtcclxuXHRcdHZhciBjaHVua3MgPSBtb3JwaC5uYW1lLm1hdGNoKCBwYXR0ZXJuICk7XHJcblxyXG5cdFx0aWYgKCBjaHVua3MgJiYgY2h1bmtzLmxlbmd0aCA+IDEgKSB7XHJcblxyXG5cdFx0XHR2YXIgbmFtZSA9IGNodW5rc1sgMSBdO1xyXG5cdFx0XHR2YXIgbnVtID0gY2h1bmtzWyAyIF07XHJcblxyXG5cdFx0XHRpZiAoICEgZnJhbWVSYW5nZXNbIG5hbWUgXSApIGZyYW1lUmFuZ2VzWyBuYW1lIF0gPSB7IHN0YXJ0OiBJbmZpbml0eSwgZW5kOiAtSW5maW5pdHkgfTtcclxuXHJcblx0XHRcdHZhciByYW5nZSA9IGZyYW1lUmFuZ2VzWyBuYW1lIF07XHJcblxyXG5cdFx0XHRpZiAoIGkgPCByYW5nZS5zdGFydCApIHJhbmdlLnN0YXJ0ID0gaTtcclxuXHRcdFx0aWYgKCBpID4gcmFuZ2UuZW5kICkgcmFuZ2UuZW5kID0gaTtcclxuXHJcblx0XHRcdGlmICggISBmaXJzdEFuaW1hdGlvbiApIGZpcnN0QW5pbWF0aW9uID0gbmFtZTtcclxuXHJcblx0XHR9XHJcblxyXG5cdH1cclxuXHJcblx0Zm9yICggdmFyIG5hbWUgaW4gZnJhbWVSYW5nZXMgKSB7XHJcblxyXG5cdFx0dmFyIHJhbmdlID0gZnJhbWVSYW5nZXNbIG5hbWUgXTtcclxuXHRcdHRoaXMuY3JlYXRlQW5pbWF0aW9uKCBuYW1lLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBmcHMgKTtcclxuXHJcblx0fVxyXG5cclxuXHR0aGlzLmZpcnN0QW5pbWF0aW9uID0gZmlyc3RBbmltYXRpb247XHJcblxyXG59O1xyXG5cclxuVEhSRUUuTW9ycGhCbGVuZE1lc2gucHJvdG90eXBlLnNldEFuaW1hdGlvbkRpcmVjdGlvbkZvcndhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IDE7XHJcblx0XHRhbmltYXRpb24uZGlyZWN0aW9uQmFja3dhcmRzID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRGlyZWN0aW9uQmFja3dhcmQgPSBmdW5jdGlvbiAoIG5hbWUgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiA9IC0xO1xyXG5cdFx0YW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyA9IHRydWU7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uRlBTID0gZnVuY3Rpb24gKCBuYW1lLCBmcHMgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmZwcyA9IGZwcztcclxuXHRcdGFuaW1hdGlvbi5kdXJhdGlvbiA9ICggYW5pbWF0aW9uLmVuZCAtIGFuaW1hdGlvbi5zdGFydCApIC8gYW5pbWF0aW9uLmZwcztcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uICggbmFtZSwgZHVyYXRpb24gKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLmR1cmF0aW9uID0gZHVyYXRpb247XHJcblx0XHRhbmltYXRpb24uZnBzID0gKCBhbmltYXRpb24uZW5kIC0gYW5pbWF0aW9uLnN0YXJ0ICkgLyBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc2V0QW5pbWF0aW9uV2VpZ2h0ID0gZnVuY3Rpb24gKCBuYW1lLCB3ZWlnaHQgKSB7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0YW5pbWF0aW9uLndlaWdodCA9IHdlaWdodDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5zZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lLCB0aW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi50aW1lID0gdGltZTtcclxuXHJcblx0fVxyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25UaW1lID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgdGltZSA9IDA7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0dGltZSA9IGFuaW1hdGlvbi50aW1lO1xyXG5cclxuXHR9XHJcblxyXG5cdHJldHVybiB0aW1lO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5nZXRBbmltYXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIGR1cmF0aW9uID0gLTE7XHJcblxyXG5cdHZhciBhbmltYXRpb24gPSB0aGlzLmFuaW1hdGlvbnNNYXBbIG5hbWUgXTtcclxuXHJcblx0aWYgKCBhbmltYXRpb24gKSB7XHJcblxyXG5cdFx0ZHVyYXRpb24gPSBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGR1cmF0aW9uO1xyXG5cclxufTtcclxuXHJcblRIUkVFLk1vcnBoQmxlbmRNZXNoLnByb3RvdHlwZS5wbGF5QW5pbWF0aW9uID0gZnVuY3Rpb24gKCBuYW1lICkge1xyXG5cclxuXHR2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb25zTWFwWyBuYW1lIF07XHJcblxyXG5cdGlmICggYW5pbWF0aW9uICkge1xyXG5cclxuXHRcdGFuaW1hdGlvbi50aW1lID0gMDtcclxuXHRcdGFuaW1hdGlvbi5hY3RpdmUgPSB0cnVlO1xyXG5cclxuXHR9IGVsc2Uge1xyXG5cclxuXHRcdGNvbnNvbGUud2FybiggXCJhbmltYXRpb25bXCIgKyBuYW1lICsgXCJdIHVuZGVmaW5lZFwiICk7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUuc3RvcEFuaW1hdGlvbiA9IGZ1bmN0aW9uICggbmFtZSApIHtcclxuXHJcblx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc01hcFsgbmFtZSBdO1xyXG5cclxuXHRpZiAoIGFuaW1hdGlvbiApIHtcclxuXHJcblx0XHRhbmltYXRpb24uYWN0aXZlID0gZmFsc2U7XHJcblxyXG5cdH1cclxuXHJcbn07XHJcblxyXG5USFJFRS5Nb3JwaEJsZW5kTWVzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCBkZWx0YSApIHtcclxuXHJcblx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHRoaXMuYW5pbWF0aW9uc0xpc3QubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0dmFyIGFuaW1hdGlvbiA9IHRoaXMuYW5pbWF0aW9uc0xpc3RbIGkgXTtcclxuXHJcblx0XHRpZiAoICEgYW5pbWF0aW9uLmFjdGl2ZSApIGNvbnRpbnVlO1xyXG5cclxuXHRcdHZhciBmcmFtZVRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24gLyBhbmltYXRpb24ubGVuZ3RoO1xyXG5cclxuXHRcdGFuaW1hdGlvbi50aW1lICs9IGFuaW1hdGlvbi5kaXJlY3Rpb24gKiBkZWx0YTtcclxuXHJcblx0XHRpZiAoIGFuaW1hdGlvbi5taXJyb3JlZExvb3AgKSB7XHJcblxyXG5cdFx0XHRpZiAoIGFuaW1hdGlvbi50aW1lID4gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IGFuaW1hdGlvbi50aW1lIDwgMCApIHtcclxuXHJcblx0XHRcdFx0YW5pbWF0aW9uLmRpcmVjdGlvbiAqPSAtMTtcclxuXHJcblx0XHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA+IGFuaW1hdGlvbi5kdXJhdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi5kdXJhdGlvbjtcclxuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICggYW5pbWF0aW9uLnRpbWUgPCAwICkge1xyXG5cclxuXHRcdFx0XHRcdGFuaW1hdGlvbi50aW1lID0gMDtcclxuXHRcdFx0XHRcdGFuaW1hdGlvbi5kaXJlY3Rpb25CYWNrd2FyZHMgPSBmYWxzZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRhbmltYXRpb24udGltZSA9IGFuaW1hdGlvbi50aW1lICUgYW5pbWF0aW9uLmR1cmF0aW9uO1xyXG5cclxuXHRcdFx0aWYgKCBhbmltYXRpb24udGltZSA8IDAgKSBhbmltYXRpb24udGltZSArPSBhbmltYXRpb24uZHVyYXRpb247XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBrZXlmcmFtZSA9IGFuaW1hdGlvbi5zdGFydEZyYW1lICsgVEhSRUUuTWF0aC5jbGFtcCggTWF0aC5mbG9vciggYW5pbWF0aW9uLnRpbWUgLyBmcmFtZVRpbWUgKSwgMCwgYW5pbWF0aW9uLmxlbmd0aCAtIDEgKTtcclxuXHRcdHZhciB3ZWlnaHQgPSBhbmltYXRpb24ud2VpZ2h0O1xyXG5cclxuXHRcdGlmICgga2V5ZnJhbWUgIT09IGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgKSB7XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgYW5pbWF0aW9uLmxhc3RGcmFtZSBdID0gMDtcclxuXHRcdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IDEgKiB3ZWlnaHQ7XHJcblxyXG5cdFx0XHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sga2V5ZnJhbWUgXSA9IDA7XHJcblxyXG5cdFx0XHRhbmltYXRpb24ubGFzdEZyYW1lID0gYW5pbWF0aW9uLmN1cnJlbnRGcmFtZTtcclxuXHRcdFx0YW5pbWF0aW9uLmN1cnJlbnRGcmFtZSA9IGtleWZyYW1lO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbWl4ID0gKCBhbmltYXRpb24udGltZSAlIGZyYW1lVGltZSApIC8gZnJhbWVUaW1lO1xyXG5cclxuXHRcdGlmICggYW5pbWF0aW9uLmRpcmVjdGlvbkJhY2t3YXJkcyApIG1peCA9IDEgLSBtaXg7XHJcblxyXG5cdFx0dGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXNbIGFuaW1hdGlvbi5jdXJyZW50RnJhbWUgXSA9IG1peCAqIHdlaWdodDtcclxuXHRcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzWyBhbmltYXRpb24ubGFzdEZyYW1lIF0gPSAoIDEgLSBtaXggKSAqIHdlaWdodDtcclxuXHJcblx0fVxyXG5cclxufTtcclxuLyoqXHJcbiAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXHJcbiAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXHJcbiAqL1xyXG5cclxuVEhSRUUuTGVuc0ZsYXJlUGx1Z2luID0gZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgX2dsLCBfcmVuZGVyZXIsIF9wcmVjaXNpb24sIF9sZW5zRmxhcmUgPSB7fTtcclxuXHJcblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCByZW5kZXJlciApIHtcclxuXHJcblx0XHRfZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cdFx0X3JlbmRlcmVyID0gcmVuZGVyZXI7XHJcblxyXG5cdFx0X3ByZWNpc2lvbiA9IHJlbmRlcmVyLmdldFByZWNpc2lvbigpO1xyXG5cclxuXHRcdF9sZW5zRmxhcmUudmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICsgOCApO1xyXG5cdFx0X2xlbnNGbGFyZS5mYWNlcyA9IG5ldyBVaW50MTZBcnJheSggNiApO1xyXG5cclxuXHRcdHZhciBpID0gMDtcclxuXHRcdF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gLTE7IF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gLTE7XHQvLyB2ZXJ0ZXhcclxuXHRcdF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMDsgIF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMDtcdC8vIHV2Li4uIGV0Yy5cclxuXHJcblx0XHRfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDE7ICBfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IC0xO1xyXG5cdFx0X2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAxOyAgX2xlbnNGbGFyZS52ZXJ0aWNlc1sgaSsrIF0gPSAwO1xyXG5cclxuXHRcdF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMTsgIF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMTtcclxuXHRcdF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMTsgIF9sZW5zRmxhcmUudmVydGljZXNbIGkrKyBdID0gMTtcclxuXHJcblx0XHRfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IC0xOyBfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDE7XHJcblx0XHRfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDA7ICBfbGVuc0ZsYXJlLnZlcnRpY2VzWyBpKysgXSA9IDE7XHJcblxyXG5cdFx0aSA9IDA7XHJcblx0XHRfbGVuc0ZsYXJlLmZhY2VzWyBpKysgXSA9IDA7IF9sZW5zRmxhcmUuZmFjZXNbIGkrKyBdID0gMTsgX2xlbnNGbGFyZS5mYWNlc1sgaSsrIF0gPSAyO1xyXG5cdFx0X2xlbnNGbGFyZS5mYWNlc1sgaSsrIF0gPSAwOyBfbGVuc0ZsYXJlLmZhY2VzWyBpKysgXSA9IDI7IF9sZW5zRmxhcmUuZmFjZXNbIGkrKyBdID0gMztcclxuXHJcblx0XHQvLyBidWZmZXJzXHJcblxyXG5cdFx0X2xlbnNGbGFyZS52ZXJ0ZXhCdWZmZXIgICAgID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cdFx0X2xlbnNGbGFyZS5lbGVtZW50QnVmZmVyICAgID0gX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG5cclxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBfbGVuc0ZsYXJlLnZlcnRleEJ1ZmZlciApO1xyXG5cdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIF9sZW5zRmxhcmUudmVydGljZXMsIF9nbC5TVEFUSUNfRFJBVyApO1xyXG5cclxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIF9sZW5zRmxhcmUuZWxlbWVudEJ1ZmZlciApO1xyXG5cdFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgX2xlbnNGbGFyZS5mYWNlcywgX2dsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0Ly8gdGV4dHVyZXNcclxuXHJcblx0XHRfbGVuc0ZsYXJlLnRlbXBUZXh0dXJlICAgICAgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG5cdFx0X2xlbnNGbGFyZS5vY2NsdXNpb25UZXh0dXJlID0gX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuXHJcblx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBfbGVuc0ZsYXJlLnRlbXBUZXh0dXJlICk7XHJcblx0XHRfZ2wudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIF9nbC5SR0IsIDE2LCAxNiwgMCwgX2dsLlJHQiwgX2dsLlVOU0lHTkVEX0JZVEUsIG51bGwgKTtcclxuXHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCBfZ2wuVEVYVFVSRV8yRCwgX2dsLlRFWFRVUkVfV1JBUF9TLCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xyXG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIF9nbC5URVhUVVJFXzJELCBfZ2wuVEVYVFVSRV9XUkFQX1QsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggX2dsLlRFWFRVUkVfMkQsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIF9nbC5ORUFSRVNUICk7XHJcblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggX2dsLlRFWFRVUkVfMkQsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIF9nbC5ORUFSRVNUICk7XHJcblxyXG5cdFx0X2dsLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgX2xlbnNGbGFyZS5vY2NsdXNpb25UZXh0dXJlICk7XHJcblx0XHRfZ2wudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIF9nbC5SR0JBLCAxNiwgMTYsIDAsIF9nbC5SR0JBLCBfZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xyXG5cdFx0X2dsLnRleFBhcmFtZXRlcmkoIF9nbC5URVhUVVJFXzJELCBfZ2wuVEVYVFVSRV9XUkFQX1MsIF9nbC5DTEFNUF9UT19FREdFICk7XHJcblx0XHRfZ2wudGV4UGFyYW1ldGVyaSggX2dsLlRFWFRVUkVfMkQsIF9nbC5URVhUVVJFX1dSQVBfVCwgX2dsLkNMQU1QX1RPX0VER0UgKTtcclxuXHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCBfZ2wuVEVYVFVSRV8yRCwgX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgX2dsLk5FQVJFU1QgKTtcclxuXHRcdF9nbC50ZXhQYXJhbWV0ZXJpKCBfZ2wuVEVYVFVSRV8yRCwgX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgX2dsLk5FQVJFU1QgKTtcclxuXHJcblx0XHRpZiAoIF9nbC5nZXRQYXJhbWV0ZXIoIF9nbC5NQVhfVkVSVEVYX1RFWFRVUkVfSU1BR0VfVU5JVFMgKSA8PSAwICkge1xyXG5cclxuXHRcdFx0X2xlbnNGbGFyZS5oYXNWZXJ0ZXhUZXh0dXJlID0gZmFsc2U7XHJcblx0XHRcdF9sZW5zRmxhcmUucHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oIFRIUkVFLlNoYWRlckZsYXJlc1sgXCJsZW5zRmxhcmVcIiBdLCBfcHJlY2lzaW9uICk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdF9sZW5zRmxhcmUuaGFzVmVydGV4VGV4dHVyZSA9IHRydWU7XHJcblx0XHRcdF9sZW5zRmxhcmUucHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oIFRIUkVFLlNoYWRlckZsYXJlc1sgXCJsZW5zRmxhcmVWZXJ0ZXhUZXh0dXJlXCIgXSwgX3ByZWNpc2lvbiApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfbGVuc0ZsYXJlLmF0dHJpYnV0ZXMgPSB7fTtcclxuXHRcdF9sZW5zRmxhcmUudW5pZm9ybXMgPSB7fTtcclxuXHJcblx0XHRfbGVuc0ZsYXJlLmF0dHJpYnV0ZXMudmVydGV4ICAgICAgID0gX2dsLmdldEF0dHJpYkxvY2F0aW9uICggX2xlbnNGbGFyZS5wcm9ncmFtLCBcInBvc2l0aW9uXCIgKTtcclxuXHRcdF9sZW5zRmxhcmUuYXR0cmlidXRlcy51diAgICAgICAgICAgPSBfZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBfbGVuc0ZsYXJlLnByb2dyYW0sIFwidXZcIiApO1xyXG5cclxuXHRcdF9sZW5zRmxhcmUudW5pZm9ybXMucmVuZGVyVHlwZSAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbGVuc0ZsYXJlLnByb2dyYW0sIFwicmVuZGVyVHlwZVwiICk7XHJcblx0XHRfbGVuc0ZsYXJlLnVuaWZvcm1zLm1hcCAgICAgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX2xlbnNGbGFyZS5wcm9ncmFtLCBcIm1hcFwiICk7XHJcblx0XHRfbGVuc0ZsYXJlLnVuaWZvcm1zLm9jY2x1c2lvbk1hcCAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX2xlbnNGbGFyZS5wcm9ncmFtLCBcIm9jY2x1c2lvbk1hcFwiICk7XHJcblx0XHRfbGVuc0ZsYXJlLnVuaWZvcm1zLm9wYWNpdHkgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX2xlbnNGbGFyZS5wcm9ncmFtLCBcIm9wYWNpdHlcIiApO1xyXG5cdFx0X2xlbnNGbGFyZS51bmlmb3Jtcy5jb2xvciAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9sZW5zRmxhcmUucHJvZ3JhbSwgXCJjb2xvclwiICk7XHJcblx0XHRfbGVuc0ZsYXJlLnVuaWZvcm1zLnNjYWxlICAgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX2xlbnNGbGFyZS5wcm9ncmFtLCBcInNjYWxlXCIgKTtcclxuXHRcdF9sZW5zRmxhcmUudW5pZm9ybXMucm90YXRpb24gICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfbGVuc0ZsYXJlLnByb2dyYW0sIFwicm90YXRpb25cIiApO1xyXG5cdFx0X2xlbnNGbGFyZS51bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9sZW5zRmxhcmUucHJvZ3JhbSwgXCJzY3JlZW5Qb3NpdGlvblwiICk7XHJcblxyXG5cdH07XHJcblxyXG5cclxuXHQvKlxyXG5cdCAqIFJlbmRlciBsZW5zIGZsYXJlc1xyXG5cdCAqIE1ldGhvZDogcmVuZGVycyAxNngxNiAweGZmMDBmZi1jb2xvcmVkIHBvaW50cyBzY2F0dGVyZWQgb3ZlciB0aGUgbGlnaHQgc291cmNlIGFyZWEsXHJcblx0ICogICAgICAgICByZWFkcyB0aGVzZSBiYWNrIGFuZCBjYWxjdWxhdGVzIG9jY2x1c2lvbi5cclxuXHQgKiAgICAgICAgIFRoZW4gX2xlbnNGbGFyZS51cGRhdGVfbGVuc0ZsYXJlcygpIGlzIGNhbGxlZCB0byByZS1wb3NpdGlvbiBhbmRcclxuXHQgKiAgICAgICAgIHVwZGF0ZSB0cmFuc3BhcmVuY3kgb2YgZmxhcmVzLiBUaGVuIHRoZXkgYXJlIHJlbmRlcmVkLlxyXG5cdCAqXHJcblx0ICovXHJcblxyXG5cdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhLCB2aWV3cG9ydFdpZHRoLCB2aWV3cG9ydEhlaWdodCApIHtcclxuXHJcblx0XHR2YXIgZmxhcmVzID0gc2NlbmUuX193ZWJnbEZsYXJlcyxcclxuXHRcdFx0bkZsYXJlcyA9IGZsYXJlcy5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKCAhIG5GbGFyZXMgKSByZXR1cm47XHJcblxyXG5cdFx0dmFyIHRlbXBQb3NpdGlvbiA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XHJcblxyXG5cdFx0dmFyIGludkFzcGVjdCA9IHZpZXdwb3J0SGVpZ2h0IC8gdmlld3BvcnRXaWR0aCxcclxuXHRcdFx0aGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoICogMC41LFxyXG5cdFx0XHRoYWxmVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEhlaWdodCAqIDAuNTtcclxuXHJcblx0XHR2YXIgc2l6ZSA9IDE2IC8gdmlld3BvcnRIZWlnaHQsXHJcblx0XHRcdHNjYWxlID0gbmV3IFRIUkVFLlZlY3RvcjIoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcclxuXHJcblx0XHR2YXIgc2NyZWVuUG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMyggMSwgMSwgMCApLFxyXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscyA9IG5ldyBUSFJFRS5WZWN0b3IyKCAxLCAxICk7XHJcblxyXG5cdFx0dmFyIHVuaWZvcm1zID0gX2xlbnNGbGFyZS51bmlmb3JtcyxcclxuXHRcdFx0YXR0cmlidXRlcyA9IF9sZW5zRmxhcmUuYXR0cmlidXRlcztcclxuXHJcblx0XHQvLyBzZXQgX2xlbnNGbGFyZSBwcm9ncmFtIGFuZCByZXNldCBibGVuZGluZ1xyXG5cclxuXHRcdF9nbC51c2VQcm9ncmFtKCBfbGVuc0ZsYXJlLnByb2dyYW0gKTtcclxuXHJcblx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIF9sZW5zRmxhcmUuYXR0cmlidXRlcy52ZXJ0ZXggKTtcclxuXHRcdF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggX2xlbnNGbGFyZS5hdHRyaWJ1dGVzLnV2ICk7XHJcblxyXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIGFsbCBsZW5zIGZsYXJlcyB0byB1cGRhdGUgdGhlaXIgb2NjbHVzaW9uIGFuZCBwb3NpdGlvbnNcclxuXHRcdC8vIHNldHVwIGdsIGFuZCBjb21tb24gdXNlZCBhdHRyaWJzL3VuZm9ybXNcclxuXHJcblx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5vY2NsdXNpb25NYXAsIDAgKTtcclxuXHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMSApO1xyXG5cclxuXHRcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBfbGVuc0ZsYXJlLnZlcnRleEJ1ZmZlciApO1xyXG5cdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudmVydGV4LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xyXG5cdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XHJcblxyXG5cdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgX2xlbnNGbGFyZS5lbGVtZW50QnVmZmVyICk7XHJcblxyXG5cdFx0X2dsLmRpc2FibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHRcdF9nbC5kZXB0aE1hc2soIGZhbHNlICk7XHJcblxyXG5cdFx0dmFyIGksIGosIGpsLCBmbGFyZSwgc3ByaXRlO1xyXG5cclxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbkZsYXJlczsgaSArKyApIHtcclxuXHJcblx0XHRcdHNpemUgPSAxNiAvIHZpZXdwb3J0SGVpZ2h0O1xyXG5cdFx0XHRzY2FsZS5zZXQoIHNpemUgKiBpbnZBc3BlY3QsIHNpemUgKTtcclxuXHJcblx0XHRcdC8vIGNhbGMgb2JqZWN0IHNjcmVlbiBwb3NpdGlvblxyXG5cclxuXHRcdFx0ZmxhcmUgPSBmbGFyZXNbIGkgXTtcclxuXHJcblx0XHRcdHRlbXBQb3NpdGlvbi5zZXQoIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWzEyXSwgZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbMTNdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sxNF0gKTtcclxuXHJcblx0XHRcdHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdFx0dGVtcFBvc2l0aW9uLmFwcGx5UHJvamVjdGlvbiggY2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHJcblx0XHRcdC8vIHNldHVwIGFycmF5cyBmb3IgZ2wgcHJvZ3JhbXNcclxuXHJcblx0XHRcdHNjcmVlblBvc2l0aW9uLmNvcHkoIHRlbXBQb3NpdGlvbiApXHJcblxyXG5cdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICsgaGFsZlZpZXdwb3J0V2lkdGg7XHJcblx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnkgPSBzY3JlZW5Qb3NpdGlvbi55ICogaGFsZlZpZXdwb3J0SGVpZ2h0ICsgaGFsZlZpZXdwb3J0SGVpZ2h0O1xyXG5cclxuXHRcdFx0Ly8gc2NyZWVuIGN1bGxcclxuXHJcblx0XHRcdGlmICggX2xlbnNGbGFyZS5oYXNWZXJ0ZXhUZXh0dXJlIHx8IChcclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy54ID4gMCAmJlxyXG5cdFx0XHRcdHNjcmVlblBvc2l0aW9uUGl4ZWxzLnggPCB2aWV3cG9ydFdpZHRoICYmXHJcblx0XHRcdFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA+IDAgJiZcclxuXHRcdFx0XHRzY3JlZW5Qb3NpdGlvblBpeGVscy55IDwgdmlld3BvcnRIZWlnaHQgKSApIHtcclxuXHJcblx0XHRcdFx0Ly8gc2F2ZSBjdXJyZW50IFJHQiB0byB0ZW1wIHRleHR1cmVcclxuXHJcblx0XHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMSApO1xyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIF9sZW5zRmxhcmUudGVtcFRleHR1cmUgKTtcclxuXHRcdFx0XHRfZ2wuY29weVRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBfZ2wuUkdCLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54IC0gOCwgc2NyZWVuUG9zaXRpb25QaXhlbHMueSAtIDgsIDE2LCAxNiwgMCApO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gcmVuZGVyIHBpbmsgcXVhZFxyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAwICk7XHJcblx0XHRcdFx0X2dsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcclxuXHRcdFx0XHRfZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xyXG5cclxuXHRcdFx0XHRfZ2wuZGlzYWJsZSggX2dsLkJMRU5EICk7XHJcblx0XHRcdFx0X2dsLmVuYWJsZSggX2dsLkRFUFRIX1RFU1QgKTtcclxuXHJcblx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggX2dsLlRSSUFOR0xFUywgNiwgX2dsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cclxuXHRcdFx0XHQvLyBjb3B5IHJlc3VsdCB0byBvY2NsdXNpb25NYXBcclxuXHJcblx0XHRcdFx0X2dsLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCApO1xyXG5cdFx0XHRcdF9nbC5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIF9sZW5zRmxhcmUub2NjbHVzaW9uVGV4dHVyZSApO1xyXG5cdFx0XHRcdF9nbC5jb3B5VGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIDAsIF9nbC5SR0JBLCBzY3JlZW5Qb3NpdGlvblBpeGVscy54IC0gOCwgc2NyZWVuUG9zaXRpb25QaXhlbHMueSAtIDgsIDE2LCAxNiwgMCApO1xyXG5cclxuXHJcblx0XHRcdFx0Ly8gcmVzdG9yZSBncmFwaGljc1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5yZW5kZXJUeXBlLCAxICk7XHJcblx0XHRcdFx0X2dsLmRpc2FibGUoIF9nbC5ERVBUSF9URVNUICk7XHJcblxyXG5cdFx0XHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTEgKTtcclxuXHRcdFx0XHRfZ2wuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCBfbGVuc0ZsYXJlLnRlbXBUZXh0dXJlICk7XHJcblx0XHRcdFx0X2dsLmRyYXdFbGVtZW50cyggX2dsLlRSSUFOR0xFUywgNiwgX2dsLlVOU0lHTkVEX1NIT1JULCAwICk7XHJcblxyXG5cclxuXHRcdFx0XHQvLyB1cGRhdGUgb2JqZWN0IHBvc2l0aW9uc1xyXG5cclxuXHRcdFx0XHRmbGFyZS5wb3NpdGlvblNjcmVlbi5jb3B5KCBzY3JlZW5Qb3NpdGlvbiApXHJcblxyXG5cdFx0XHRcdGlmICggZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgKSB7XHJcblxyXG5cdFx0XHRcdFx0ZmxhcmUuY3VzdG9tVXBkYXRlQ2FsbGJhY2soIGZsYXJlICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0ZmxhcmUudXBkYXRlTGVuc0ZsYXJlcygpO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdC8vIHJlbmRlciBmbGFyZXNcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMiApO1xyXG5cdFx0XHRcdF9nbC5lbmFibGUoIF9nbC5CTEVORCApO1xyXG5cclxuXHRcdFx0XHRmb3IgKCBqID0gMCwgamwgPSBmbGFyZS5sZW5zRmxhcmVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHNwcml0ZSA9IGZsYXJlLmxlbnNGbGFyZXNbIGogXTtcclxuXHJcblx0XHRcdFx0XHRpZiAoIHNwcml0ZS5vcGFjaXR5ID4gMC4wMDEgJiYgc3ByaXRlLnNjYWxlID4gMC4wMDEgKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRzY3JlZW5Qb3NpdGlvbi54ID0gc3ByaXRlLng7XHJcblx0XHRcdFx0XHRcdHNjcmVlblBvc2l0aW9uLnkgPSBzcHJpdGUueTtcclxuXHRcdFx0XHRcdFx0c2NyZWVuUG9zaXRpb24ueiA9IHNwcml0ZS56O1xyXG5cclxuXHRcdFx0XHRcdFx0c2l6ZSA9IHNwcml0ZS5zaXplICogc3ByaXRlLnNjYWxlIC8gdmlld3BvcnRIZWlnaHQ7XHJcblxyXG5cdFx0XHRcdFx0XHRzY2FsZS54ID0gc2l6ZSAqIGludkFzcGVjdDtcclxuXHRcdFx0XHRcdFx0c2NhbGUueSA9IHNpemU7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5zY3JlZW5Qb3NpdGlvbiwgc2NyZWVuUG9zaXRpb24ueCwgc2NyZWVuUG9zaXRpb24ueSwgc2NyZWVuUG9zaXRpb24ueiApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy5zY2FsZSwgc2NhbGUueCwgc2NhbGUueSApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgc3ByaXRlLnJvdGF0aW9uICk7XHJcblxyXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBzcHJpdGUub3BhY2l0eSApO1xyXG5cdFx0XHRcdFx0XHRfZ2wudW5pZm9ybTNmKCB1bmlmb3Jtcy5jb2xvciwgc3ByaXRlLmNvbG9yLnIsIHNwcml0ZS5jb2xvci5nLCBzcHJpdGUuY29sb3IuYiApO1xyXG5cclxuXHRcdFx0XHRcdFx0X3JlbmRlcmVyLnNldEJsZW5kaW5nKCBzcHJpdGUuYmxlbmRpbmcsIHNwcml0ZS5ibGVuZEVxdWF0aW9uLCBzcHJpdGUuYmxlbmRTcmMsIHNwcml0ZS5ibGVuZERzdCApO1xyXG5cdFx0XHRcdFx0XHRfcmVuZGVyZXIuc2V0VGV4dHVyZSggc3ByaXRlLnRleHR1cmUsIDEgKTtcclxuXHJcblx0XHRcdFx0XHRcdF9nbC5kcmF3RWxlbWVudHMoIF9nbC5UUklBTkdMRVMsIDYsIF9nbC5VTlNJR05FRF9TSE9SVCwgMCApO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZXN0b3JlIGdsXHJcblxyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkRFUFRIX1RFU1QgKTtcclxuXHRcdF9nbC5kZXB0aE1hc2soIHRydWUgKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSAoIHNoYWRlciwgcHJlY2lzaW9uICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gX2dsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcblx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBfZ2wuY3JlYXRlU2hhZGVyKCBfZ2wuRlJBR01FTlRfU0hBREVSICk7XHJcblx0XHR2YXIgdmVydGV4U2hhZGVyID0gX2dsLmNyZWF0ZVNoYWRlciggX2dsLlZFUlRFWF9TSEFERVIgKTtcclxuXHJcblx0XHR2YXIgcHJlZml4ID0gXCJwcmVjaXNpb24gXCIgKyBwcmVjaXNpb24gKyBcIiBmbG9hdDtcXG5cIjtcclxuXHJcblx0XHRfZ2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyICk7XHJcblx0XHRfZ2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIHByZWZpeCArIHNoYWRlci52ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHRfZ2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdF9nbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHRfZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0X2dsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0X2dsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TaGFkb3dNYXBQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBfZ2wsXHJcblx0X3JlbmRlcmVyLFxyXG5cdF9kZXB0aE1hdGVyaWFsLCBfZGVwdGhNYXRlcmlhbE1vcnBoLCBfZGVwdGhNYXRlcmlhbFNraW4sIF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luLFxyXG5cclxuXHRfZnJ1c3R1bSA9IG5ldyBUSFJFRS5GcnVzdHVtKCksXHJcblx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgVEhSRUUuTWF0cml4NCgpLFxyXG5cclxuXHRfbWluID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHRfbWF4ID0gbmV3IFRIUkVFLlZlY3RvcjMoKSxcclxuXHJcblx0X21hdHJpeFBvc2l0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoKTtcclxuXHJcblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCByZW5kZXJlciApIHtcclxuXHJcblx0XHRfZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cdFx0X3JlbmRlcmVyID0gcmVuZGVyZXI7XHJcblxyXG5cdFx0dmFyIGRlcHRoU2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcImRlcHRoUkdCQVwiIF07XHJcblx0XHR2YXIgZGVwdGhVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRlcHRoU2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG5cdFx0X2RlcHRoTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlciwgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMgfSApO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxNb3JwaCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggeyBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogZGVwdGhVbmlmb3JtcywgbW9ycGhUYXJnZXRzOiB0cnVlIH0gKTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsU2tpbiA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggeyBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogZGVwdGhVbmlmb3Jtcywgc2tpbm5pbmc6IHRydWUgfSApO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlciwgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsIG1vcnBoVGFyZ2V0czogdHJ1ZSwgc2tpbm5pbmc6IHRydWUgfSApO1xyXG5cclxuXHRcdF9kZXB0aE1hdGVyaWFsLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGguX3NoYWRvd1Bhc3MgPSB0cnVlO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCAhICggX3JlbmRlcmVyLnNoYWRvd01hcEVuYWJsZWQgJiYgX3JlbmRlcmVyLnNoYWRvd01hcEF1dG9VcGRhdGUgKSApIHJldHVybjtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSggc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHR2YXIgaSwgaWwsIGosIGpsLCBuLFxyXG5cclxuXHRcdHNoYWRvd01hcCwgc2hhZG93TWF0cml4LCBzaGFkb3dDYW1lcmEsXHJcblx0XHRwcm9ncmFtLCBidWZmZXIsIG1hdGVyaWFsLFxyXG5cdFx0d2ViZ2xPYmplY3QsIG9iamVjdCwgbGlnaHQsXHJcblx0XHRyZW5kZXJMaXN0LFxyXG5cclxuXHRcdGxpZ2h0cyA9IFtdLFxyXG5cdFx0ayA9IDAsXHJcblxyXG5cdFx0Zm9nID0gbnVsbDtcclxuXHJcblx0XHQvLyBzZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcFxyXG5cclxuXHRcdF9nbC5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XHJcblx0XHRfZ2wuZGlzYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkNVTExfRkFDRSApO1xyXG5cdFx0X2dsLmZyb250RmFjZSggX2dsLkNDVyApO1xyXG5cclxuXHRcdGlmICggX3JlbmRlcmVyLnNoYWRvd01hcEN1bGxGYWNlID09PSBUSFJFRS5DdWxsRmFjZUZyb250ICkge1xyXG5cclxuXHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuRlJPTlQgKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLmN1bGxGYWNlKCBfZ2wuQkFDSyApO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHRfcmVuZGVyZXIuc2V0RGVwdGhUZXN0KCB0cnVlICk7XHJcblxyXG5cdFx0Ly8gcHJlcHJvY2VzcyBsaWdodHNcclxuXHRcdC8vIFx0LSBza2lwIGxpZ2h0cyB0aGF0IGFyZSBub3QgY2FzdGluZyBzaGFkb3dzXHJcblx0XHQvL1x0LSBjcmVhdGUgdmlydHVhbCBsaWdodHMgZm9yIGNhc2NhZGVkIHNoYWRvdyBtYXBzXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gc2NlbmUuX19saWdodHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XHJcblxyXG5cdFx0XHRsaWdodCA9IHNjZW5lLl9fbGlnaHRzWyBpIF07XHJcblxyXG5cdFx0XHRpZiAoICEgbGlnaHQuY2FzdFNoYWRvdyApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0aWYgKCAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApICYmIGxpZ2h0LnNoYWRvd0Nhc2NhZGUgKSB7XHJcblxyXG5cdFx0XHRcdGZvciAoIG4gPSAwOyBuIDwgbGlnaHQuc2hhZG93Q2FzY2FkZUNvdW50OyBuICsrICkge1xyXG5cclxuXHRcdFx0XHRcdHZhciB2aXJ0dWFsTGlnaHQ7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhIGxpZ2h0LnNoYWRvd0Nhc2NhZGVBcnJheVsgbiBdICkge1xyXG5cclxuXHRcdFx0XHRcdFx0dmlydHVhbExpZ2h0ID0gY3JlYXRlVmlydHVhbExpZ2h0KCBsaWdodCwgbiApO1xyXG5cdFx0XHRcdFx0XHR2aXJ0dWFsTGlnaHQub3JpZ2luYWxDYW1lcmEgPSBjYW1lcmE7XHJcblxyXG5cdFx0XHRcdFx0XHR2YXIgZ3lybyA9IG5ldyBUSFJFRS5HeXJvc2NvcGUoKTtcclxuXHRcdFx0XHRcdFx0Z3lyby5wb3NpdGlvbiA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVPZmZzZXQ7XHJcblxyXG5cdFx0XHRcdFx0XHRneXJvLmFkZCggdmlydHVhbExpZ2h0ICk7XHJcblx0XHRcdFx0XHRcdGd5cm8uYWRkKCB2aXJ0dWFsTGlnaHQudGFyZ2V0ICk7XHJcblxyXG5cdFx0XHRcdFx0XHRjYW1lcmEuYWRkKCBneXJvICk7XHJcblxyXG5cdFx0XHRcdFx0XHRsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIG4gXSA9IHZpcnR1YWxMaWdodDtcclxuXHJcblx0XHRcdFx0XHRcdGNvbnNvbGUubG9nKCBcIkNyZWF0ZWQgdmlydHVhbExpZ2h0XCIsIHZpcnR1YWxMaWdodCApO1xyXG5cclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0XHR2aXJ0dWFsTGlnaHQgPSBsaWdodC5zaGFkb3dDYXNjYWRlQXJyYXlbIG4gXTtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0dXBkYXRlVmlydHVhbExpZ2h0KCBsaWdodCwgbiApO1xyXG5cclxuXHRcdFx0XHRcdGxpZ2h0c1sgayBdID0gdmlydHVhbExpZ2h0O1xyXG5cdFx0XHRcdFx0ayArKztcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0bGlnaHRzWyBrIF0gPSBsaWdodDtcclxuXHRcdFx0XHRrICsrO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZW5kZXIgZGVwdGggbWFwXHJcblxyXG5cdFx0Zm9yICggaSA9IDAsIGlsID0gbGlnaHRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xyXG5cclxuXHRcdFx0bGlnaHQgPSBsaWdodHNbIGkgXTtcclxuXHJcblx0XHRcdGlmICggISBsaWdodC5zaGFkb3dNYXAgKSB7XHJcblxyXG5cdFx0XHRcdHZhciBzaGFkb3dGaWx0ZXIgPSBUSFJFRS5MaW5lYXJGaWx0ZXI7XHJcblxyXG5cdFx0XHRcdGlmICggX3JlbmRlcmVyLnNoYWRvd01hcFR5cGUgPT09IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXAgKSB7XHJcblxyXG5cdFx0XHRcdFx0c2hhZG93RmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgcGFycyA9IHsgbWluRmlsdGVyOiBzaGFkb3dGaWx0ZXIsIG1hZ0ZpbHRlcjogc2hhZG93RmlsdGVyLCBmb3JtYXQ6IFRIUkVFLlJHQkFGb3JtYXQgfTtcclxuXHJcblx0XHRcdFx0bGlnaHQuc2hhZG93TWFwID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyVGFyZ2V0KCBsaWdodC5zaGFkb3dNYXBXaWR0aCwgbGlnaHQuc2hhZG93TWFwSGVpZ2h0LCBwYXJzICk7XHJcblx0XHRcdFx0bGlnaHQuc2hhZG93TWFwU2l6ZSA9IG5ldyBUSFJFRS5WZWN0b3IyKCBsaWdodC5zaGFkb3dNYXBXaWR0aCwgbGlnaHQuc2hhZG93TWFwSGVpZ2h0ICk7XHJcblxyXG5cdFx0XHRcdGxpZ2h0LnNoYWRvd01hdHJpeCA9IG5ldyBUSFJFRS5NYXRyaXg0KCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoICEgbGlnaHQuc2hhZG93Q2FtZXJhICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuU3BvdExpZ2h0ICkge1xyXG5cclxuXHRcdFx0XHRcdGxpZ2h0LnNoYWRvd0NhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSggbGlnaHQuc2hhZG93Q2FtZXJhRm92LCBsaWdodC5zaGFkb3dNYXBXaWR0aCAvIGxpZ2h0LnNoYWRvd01hcEhlaWdodCwgbGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgbGlnaHQuc2hhZG93Q2FtZXJhRmFyICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxpZ2h0IGluc3RhbmNlb2YgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCApIHtcclxuXHJcblx0XHRcdFx0XHRsaWdodC5zaGFkb3dDYW1lcmEgPSBuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKCBsaWdodC5zaGFkb3dDYW1lcmFMZWZ0LCBsaWdodC5zaGFkb3dDYW1lcmFSaWdodCwgbGlnaHQuc2hhZG93Q2FtZXJhVG9wLCBsaWdodC5zaGFkb3dDYW1lcmFCb3R0b20sIGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIGxpZ2h0LnNoYWRvd0NhbWVyYUZhciApO1xyXG5cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdGNvbnNvbGUuZXJyb3IoIFwiVW5zdXBwb3J0ZWQgbGlnaHQgdHlwZSBmb3Igc2hhZG93XCIgKTtcclxuXHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHNjZW5lLmFkZCggbGlnaHQuc2hhZG93Q2FtZXJhICk7XHJcblxyXG5cdFx0XHRcdGlmICggX3JlbmRlcmVyLmF1dG9VcGRhdGVTY2VuZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgJiYgISBsaWdodC5jYW1lcmFIZWxwZXIgKSB7XHJcblxyXG5cdFx0XHRcdGxpZ2h0LmNhbWVyYUhlbHBlciA9IG5ldyBUSFJFRS5DYW1lcmFIZWxwZXIoIGxpZ2h0LnNoYWRvd0NhbWVyYSApO1xyXG5cdFx0XHRcdGxpZ2h0LnNoYWRvd0NhbWVyYS5hZGQoIGxpZ2h0LmNhbWVyYUhlbHBlciApO1xyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKCBsaWdodC5pc1ZpcnR1YWwgJiYgdmlydHVhbExpZ2h0Lm9yaWdpbmFsQ2FtZXJhID09IGNhbWVyYSApIHtcclxuXHJcblx0XHRcdFx0dXBkYXRlU2hhZG93Q2FtZXJhKCBjYW1lcmEsIGxpZ2h0ICk7XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRzaGFkb3dNYXAgPSBsaWdodC5zaGFkb3dNYXA7XHJcblx0XHRcdHNoYWRvd01hdHJpeCA9IGxpZ2h0LnNoYWRvd01hdHJpeDtcclxuXHRcdFx0c2hhZG93Q2FtZXJhID0gbGlnaHQuc2hhZG93Q2FtZXJhO1xyXG5cclxuXHRcdFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggbGlnaHQubWF0cml4V29ybGQgKTtcclxuXHRcdFx0X21hdHJpeFBvc2l0aW9uLmdldFBvc2l0aW9uRnJvbU1hdHJpeCggbGlnaHQudGFyZ2V0Lm1hdHJpeFdvcmxkICk7XHJcblx0XHRcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9tYXRyaXhQb3NpdGlvbiApO1xyXG5cdFx0XHRzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcclxuXHJcblx0XHRcdHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRpZiAoIGxpZ2h0LmNhbWVyYUhlbHBlciApIGxpZ2h0LmNhbWVyYUhlbHBlci52aXNpYmxlID0gbGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZTtcclxuXHRcdFx0aWYgKCBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlICkgbGlnaHQuY2FtZXJhSGVscGVyLnVwZGF0ZSgpO1xyXG5cclxuXHRcdFx0Ly8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XHJcblxyXG5cdFx0XHRzaGFkb3dNYXRyaXguc2V0KCAwLjUsIDAuMCwgMC4wLCAwLjUsXHJcblx0XHRcdFx0XHRcdFx0ICAwLjAsIDAuNSwgMC4wLCAwLjUsXHJcblx0XHRcdFx0XHRcdFx0ICAwLjAsIDAuMCwgMC41LCAwLjUsXHJcblx0XHRcdFx0XHRcdFx0ICAwLjAsIDAuMCwgMC4wLCAxLjAgKTtcclxuXHJcblx0XHRcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcclxuXHRcdFx0c2hhZG93TWF0cml4Lm11bHRpcGx5KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0XHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXHJcblxyXG5cdFx0XHRfcHJvalNjcmVlbk1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBzaGFkb3dDYW1lcmEucHJvamVjdGlvbk1hdHJpeCwgc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xyXG5cdFx0XHRfZnJ1c3R1bS5zZXRGcm9tTWF0cml4KCBfcHJvalNjcmVlbk1hdHJpeCApO1xyXG5cclxuXHRcdFx0Ly8gcmVuZGVyIHNoYWRvdyBtYXBcclxuXHJcblx0XHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHNoYWRvd01hcCApO1xyXG5cdFx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcclxuXHJcblx0XHRcdC8vIHNldCBvYmplY3QgbWF0cmljZXMgJiBmcnVzdHVtIGN1bGxpbmdcclxuXHJcblx0XHRcdHJlbmRlckxpc3QgPSBzY2VuZS5fX3dlYmdsT2JqZWN0cztcclxuXHJcblx0XHRcdGZvciAoIGogPSAwLCBqbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaiBdO1xyXG5cdFx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcclxuXHJcblx0XHRcdFx0d2ViZ2xPYmplY3QucmVuZGVyID0gZmFsc2U7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgJiYgb2JqZWN0LmNhc3RTaGFkb3cgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCAhICggb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuTWVzaCB8fCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5QYXJ0aWNsZVN5c3RlbSApIHx8ICEgKCBvYmplY3QuZnJ1c3R1bUN1bGxlZCApIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApICkge1xyXG5cclxuXHRcdFx0XHRcdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggc2hhZG93Q2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0XHR3ZWJnbE9iamVjdC5yZW5kZXIgPSB0cnVlO1xyXG5cclxuXHRcdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gcmVuZGVyIHJlZ3VsYXIgb2JqZWN0c1xyXG5cclxuXHRcdFx0dmFyIG9iamVjdE1hdGVyaWFsLCB1c2VNb3JwaGluZywgdXNlU2tpbm5pbmc7XHJcblxyXG5cdFx0XHRmb3IgKCBqID0gMCwgamwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0XHR3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGogXTtcclxuXHJcblx0XHRcdFx0aWYgKCB3ZWJnbE9iamVjdC5yZW5kZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cdFx0XHRcdFx0YnVmZmVyID0gd2ViZ2xPYmplY3QuYnVmZmVyO1xyXG5cclxuXHRcdFx0XHRcdC8vIGN1bGxpbmcgaXMgb3ZlcnJpZGVuIGdsb2JhbGx5IGZvciBhbGwgb2JqZWN0c1xyXG5cdFx0XHRcdFx0Ly8gd2hpbGUgcmVuZGVyaW5nIGRlcHRoIG1hcFxyXG5cclxuXHRcdFx0XHRcdC8vIG5lZWQgdG8gZGVhbCB3aXRoIE1lc2hGYWNlTWF0ZXJpYWwgc29tZWhvd1xyXG5cdFx0XHRcdFx0Ly8gaW4gdGhhdCBjYXNlIGp1c3QgdXNlIHRoZSBmaXJzdCBvZiBtYXRlcmlhbC5tYXRlcmlhbHMgZm9yIG5vd1xyXG5cdFx0XHRcdFx0Ly8gKHByb3BlciBzb2x1dGlvbiB3b3VsZCByZXF1aXJlIHRvIGJyZWFrIG9iamVjdHMgYnkgbWF0ZXJpYWxzXHJcblx0XHRcdFx0XHQvLyAgc2ltaWxhcmx5IHRvIHJlZ3VsYXIgcmVuZGVyaW5nIGFuZCB0aGVuIHNldCBjb3JyZXNwb25kaW5nXHJcblx0XHRcdFx0XHQvLyAgZGVwdGggbWF0ZXJpYWxzIHBlciBlYWNoIGNodW5rIGluc3RlYWQgb2YganVzdCBvbmNlIHBlciBvYmplY3QpXHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0TWF0ZXJpYWwgPSBnZXRPYmplY3RNYXRlcmlhbCggb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0dXNlTW9ycGhpbmcgPSBvYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgJiYgb2JqZWN0TWF0ZXJpYWwubW9ycGhUYXJnZXRzO1xyXG5cdFx0XHRcdFx0dXNlU2tpbm5pbmcgPSBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5Ta2lubmVkTWVzaCAmJiBvYmplY3RNYXRlcmlhbC5za2lubmluZztcclxuXHJcblx0XHRcdFx0XHRpZiAoIG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsICkge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VTa2lubmluZyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsID0gdXNlTW9ycGhpbmcgPyBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbiA6IF9kZXB0aE1hdGVyaWFsU2tpbjtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VNb3JwaGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRcdG1hdGVyaWFsID0gX2RlcHRoTWF0ZXJpYWxNb3JwaDtcclxuXHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0XHRcdFx0bWF0ZXJpYWwgPSBfZGVwdGhNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBidWZmZXIgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSApIHtcclxuXHJcblx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgc2NlbmUuX19saWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXIoIHNoYWRvd0NhbWVyYSwgc2NlbmUuX19saWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBzZXQgbWF0cmljZXMgYW5kIHJlbmRlciBpbW1lZGlhdGUgb2JqZWN0c1xyXG5cclxuXHRcdFx0cmVuZGVyTGlzdCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzSW1tZWRpYXRlO1xyXG5cclxuXHRcdFx0Zm9yICggaiA9IDAsIGpsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBqIF07XHJcblx0XHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICYmIG9iamVjdC5jYXN0U2hhZG93ICkge1xyXG5cclxuXHRcdFx0XHRcdG9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJJbW1lZGlhdGVPYmplY3QoIHNoYWRvd0NhbWVyYSwgc2NlbmUuX19saWdodHMsIGZvZywgX2RlcHRoTWF0ZXJpYWwsIG9iamVjdCApO1xyXG5cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHR9XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJlc3RvcmUgR0wgc3RhdGVcclxuXHJcblx0XHR2YXIgY2xlYXJDb2xvciA9IF9yZW5kZXJlci5nZXRDbGVhckNvbG9yKCksXHJcblx0XHRjbGVhckFscGhhID0gX3JlbmRlcmVyLmdldENsZWFyQWxwaGEoKTtcclxuXHJcblx0XHRfZ2wuY2xlYXJDb2xvciggY2xlYXJDb2xvci5yLCBjbGVhckNvbG9yLmcsIGNsZWFyQ29sb3IuYiwgY2xlYXJBbHBoYSApO1xyXG5cdFx0X2dsLmVuYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdFx0aWYgKCBfcmVuZGVyZXIuc2hhZG93TWFwQ3VsbEZhY2UgPT09IFRIUkVFLkN1bGxGYWNlRnJvbnQgKSB7XHJcblxyXG5cdFx0XHRfZ2wuY3VsbEZhY2UoIF9nbC5CQUNLICk7XHJcblxyXG5cdFx0fVxyXG5cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBjcmVhdGVWaXJ0dWFsTGlnaHQoIGxpZ2h0LCBjYXNjYWRlICkge1xyXG5cclxuXHRcdHZhciB2aXJ0dWFsTGlnaHQgPSBuZXcgVEhSRUUuRGlyZWN0aW9uYWxMaWdodCgpO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5pc1ZpcnR1YWwgPSB0cnVlO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5vbmx5U2hhZG93ID0gdHJ1ZTtcclxuXHRcdHZpcnR1YWxMaWdodC5jYXN0U2hhZG93ID0gdHJ1ZTtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhTmVhciA9IGxpZ2h0LnNoYWRvd0NhbWVyYU5lYXI7XHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhRmFyID0gbGlnaHQuc2hhZG93Q2FtZXJhRmFyO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFMZWZ0ID0gbGlnaHQuc2hhZG93Q2FtZXJhTGVmdDtcclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFSaWdodCA9IGxpZ2h0LnNoYWRvd0NhbWVyYVJpZ2h0O1xyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYUJvdHRvbSA9IGxpZ2h0LnNoYWRvd0NhbWVyYUJvdHRvbTtcclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dDYW1lcmFUb3AgPSBsaWdodC5zaGFkb3dDYW1lcmFUb3A7XHJcblxyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGUgPSBsaWdodC5zaGFkb3dDYW1lcmFWaXNpYmxlO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dEYXJrbmVzcyA9IGxpZ2h0LnNoYWRvd0RhcmtuZXNzO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dCaWFzID0gbGlnaHQuc2hhZG93Q2FzY2FkZUJpYXNbIGNhc2NhZGUgXTtcclxuXHRcdHZpcnR1YWxMaWdodC5zaGFkb3dNYXBXaWR0aCA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVXaWR0aFsgY2FzY2FkZSBdO1xyXG5cdFx0dmlydHVhbExpZ2h0LnNoYWRvd01hcEhlaWdodCA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVIZWlnaHRbIGNhc2NhZGUgXTtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQucG9pbnRzV29ybGQgPSBbXTtcclxuXHRcdHZpcnR1YWxMaWdodC5wb2ludHNGcnVzdHVtID0gW107XHJcblxyXG5cdFx0dmFyIHBvaW50c1dvcmxkID0gdmlydHVhbExpZ2h0LnBvaW50c1dvcmxkLFxyXG5cdFx0XHRwb2ludHNGcnVzdHVtID0gdmlydHVhbExpZ2h0LnBvaW50c0ZydXN0dW07XHJcblxyXG5cdFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgODsgaSArKyApIHtcclxuXHJcblx0XHRcdHBvaW50c1dvcmxkWyBpIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cdFx0XHRwb2ludHNGcnVzdHVtWyBpIF0gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xyXG5cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbmVhclogPSBsaWdodC5zaGFkb3dDYXNjYWRlTmVhclpbIGNhc2NhZGUgXTtcclxuXHRcdHZhciBmYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZUZhclpbIGNhc2NhZGUgXTtcclxuXHJcblx0XHRwb2ludHNGcnVzdHVtWyAwIF0uc2V0KCAtMSwgLTEsIG5lYXJaICk7XHJcblx0XHRwb2ludHNGcnVzdHVtWyAxIF0uc2V0KCAgMSwgLTEsIG5lYXJaICk7XHJcblx0XHRwb2ludHNGcnVzdHVtWyAyIF0uc2V0KCAtMSwgIDEsIG5lYXJaICk7XHJcblx0XHRwb2ludHNGcnVzdHVtWyAzIF0uc2V0KCAgMSwgIDEsIG5lYXJaICk7XHJcblxyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgNCBdLnNldCggLTEsIC0xLCBmYXJaICk7XHJcblx0XHRwb2ludHNGcnVzdHVtWyA1IF0uc2V0KCAgMSwgLTEsIGZhclogKTtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDYgXS5zZXQoIC0xLCAgMSwgZmFyWiApO1xyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgNyBdLnNldCggIDEsICAxLCBmYXJaICk7XHJcblxyXG5cdFx0cmV0dXJuIHZpcnR1YWxMaWdodDtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBTeW5jaHJvbml6ZSB2aXJ0dWFsIGxpZ2h0IHdpdGggdGhlIG9yaWdpbmFsIGxpZ2h0XHJcblxyXG5cdGZ1bmN0aW9uIHVwZGF0ZVZpcnR1YWxMaWdodCggbGlnaHQsIGNhc2NhZGUgKSB7XHJcblxyXG5cdFx0dmFyIHZpcnR1YWxMaWdodCA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVBcnJheVsgY2FzY2FkZSBdO1xyXG5cclxuXHRcdHZpcnR1YWxMaWdodC5wb3NpdGlvbi5jb3B5KCBsaWdodC5wb3NpdGlvbiApO1xyXG5cdFx0dmlydHVhbExpZ2h0LnRhcmdldC5wb3NpdGlvbi5jb3B5KCBsaWdodC50YXJnZXQucG9zaXRpb24gKTtcclxuXHRcdHZpcnR1YWxMaWdodC5sb29rQXQoIHZpcnR1YWxMaWdodC50YXJnZXQgKTtcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93Q2FtZXJhVmlzaWJsZSA9IGxpZ2h0LnNoYWRvd0NhbWVyYVZpc2libGU7XHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93RGFya25lc3MgPSBsaWdodC5zaGFkb3dEYXJrbmVzcztcclxuXHJcblx0XHR2aXJ0dWFsTGlnaHQuc2hhZG93QmlhcyA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVCaWFzWyBjYXNjYWRlIF07XHJcblxyXG5cdFx0dmFyIG5lYXJaID0gbGlnaHQuc2hhZG93Q2FzY2FkZU5lYXJaWyBjYXNjYWRlIF07XHJcblx0XHR2YXIgZmFyWiA9IGxpZ2h0LnNoYWRvd0Nhc2NhZGVGYXJaWyBjYXNjYWRlIF07XHJcblxyXG5cdFx0dmFyIHBvaW50c0ZydXN0dW0gPSB2aXJ0dWFsTGlnaHQucG9pbnRzRnJ1c3R1bTtcclxuXHJcblx0XHRwb2ludHNGcnVzdHVtWyAwIF0ueiA9IG5lYXJaO1xyXG5cdFx0cG9pbnRzRnJ1c3R1bVsgMSBdLnogPSBuZWFyWjtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDIgXS56ID0gbmVhclo7XHJcblx0XHRwb2ludHNGcnVzdHVtWyAzIF0ueiA9IG5lYXJaO1xyXG5cclxuXHRcdHBvaW50c0ZydXN0dW1bIDQgXS56ID0gZmFyWjtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDUgXS56ID0gZmFyWjtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDYgXS56ID0gZmFyWjtcclxuXHRcdHBvaW50c0ZydXN0dW1bIDcgXS56ID0gZmFyWjtcclxuXHJcblx0fVxyXG5cclxuXHQvLyBGaXQgc2hhZG93IGNhbWVyYSdzIG9ydGhvIGZydXN0dW0gdG8gY2FtZXJhIGZydXN0dW1cclxuXHJcblx0ZnVuY3Rpb24gdXBkYXRlU2hhZG93Q2FtZXJhKCBjYW1lcmEsIGxpZ2h0ICkge1xyXG5cclxuXHRcdHZhciBzaGFkb3dDYW1lcmEgPSBsaWdodC5zaGFkb3dDYW1lcmEsXHJcblx0XHRcdHBvaW50c0ZydXN0dW0gPSBsaWdodC5wb2ludHNGcnVzdHVtLFxyXG5cdFx0XHRwb2ludHNXb3JsZCA9IGxpZ2h0LnBvaW50c1dvcmxkO1xyXG5cclxuXHRcdF9taW4uc2V0KCBJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5ICk7XHJcblx0XHRfbWF4LnNldCggLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eSApO1xyXG5cclxuXHRcdGZvciAoIHZhciBpID0gMDsgaSA8IDg7IGkgKysgKSB7XHJcblxyXG5cdFx0XHR2YXIgcCA9IHBvaW50c1dvcmxkWyBpIF07XHJcblxyXG5cdFx0XHRwLmNvcHkoIHBvaW50c0ZydXN0dW1bIGkgXSApO1xyXG5cdFx0XHRUSFJFRS5TaGFkb3dNYXBQbHVnaW4uX19wcm9qZWN0b3IudW5wcm9qZWN0VmVjdG9yKCBwLCBjYW1lcmEgKTtcclxuXHJcblx0XHRcdHAuYXBwbHlNYXRyaXg0KCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XHJcblxyXG5cdFx0XHRpZiAoIHAueCA8IF9taW4ueCApIF9taW4ueCA9IHAueDtcclxuXHRcdFx0aWYgKCBwLnggPiBfbWF4LnggKSBfbWF4LnggPSBwLng7XHJcblxyXG5cdFx0XHRpZiAoIHAueSA8IF9taW4ueSApIF9taW4ueSA9IHAueTtcclxuXHRcdFx0aWYgKCBwLnkgPiBfbWF4LnkgKSBfbWF4LnkgPSBwLnk7XHJcblxyXG5cdFx0XHRpZiAoIHAueiA8IF9taW4ueiApIF9taW4ueiA9IHAuejtcclxuXHRcdFx0aWYgKCBwLnogPiBfbWF4LnogKSBfbWF4LnogPSBwLno7XHJcblxyXG5cdFx0fVxyXG5cclxuXHRcdHNoYWRvd0NhbWVyYS5sZWZ0ID0gX21pbi54O1xyXG5cdFx0c2hhZG93Q2FtZXJhLnJpZ2h0ID0gX21heC54O1xyXG5cdFx0c2hhZG93Q2FtZXJhLnRvcCA9IF9tYXgueTtcclxuXHRcdHNoYWRvd0NhbWVyYS5ib3R0b20gPSBfbWluLnk7XHJcblxyXG5cdFx0Ly8gY2FuJ3QgcmVhbGx5IGZpdCBuZWFyL2ZhclxyXG5cdFx0Ly9zaGFkb3dDYW1lcmEubmVhciA9IF9taW4uejtcclxuXHRcdC8vc2hhZG93Q2FtZXJhLmZhciA9IF9tYXguejtcclxuXHJcblx0XHRzaGFkb3dDYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xyXG5cclxuXHR9XHJcblxyXG5cdC8vIEZvciB0aGUgbW9tZW50IGp1c3QgaWdub3JlIG9iamVjdHMgdGhhdCBoYXZlIG11bHRpcGxlIG1hdGVyaWFscyB3aXRoIGRpZmZlcmVudCBhbmltYXRpb24gbWV0aG9kc1xyXG5cdC8vIE9ubHkgdGhlIGZpcnN0IG1hdGVyaWFsIHdpbGwgYmUgdGFrZW4gaW50byBhY2NvdW50IGZvciBkZWNpZGluZyB3aGljaCBkZXB0aCBtYXRlcmlhbCB0byB1c2UgZm9yIHNoYWRvdyBtYXBzXHJcblxyXG5cdGZ1bmN0aW9uIGdldE9iamVjdE1hdGVyaWFsKCBvYmplY3QgKSB7XHJcblxyXG5cdFx0cmV0dXJuIG9iamVjdC5tYXRlcmlhbCBpbnN0YW5jZW9mIFRIUkVFLk1lc2hGYWNlTWF0ZXJpYWxcclxuXHRcdFx0PyBvYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzWyAwIF1cclxuXHRcdFx0OiBvYmplY3QubWF0ZXJpYWw7XHJcblxyXG5cdH07XHJcblxyXG59O1xyXG5cclxuVEhSRUUuU2hhZG93TWFwUGx1Z2luLl9fcHJvamVjdG9yID0gbmV3IFRIUkVFLlByb2plY3RvcigpO1xyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICovXHJcblxyXG5USFJFRS5TcHJpdGVQbHVnaW4gPSBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdHZhciBfZ2wsIF9yZW5kZXJlciwgX3ByZWNpc2lvbiwgX3Nwcml0ZSA9IHt9O1xyXG5cclxuXHR0aGlzLmluaXQgPSBmdW5jdGlvbiAoIHJlbmRlcmVyICkge1xyXG5cclxuXHRcdF9nbCA9IHJlbmRlcmVyLmNvbnRleHQ7XHJcblx0XHRfcmVuZGVyZXIgPSByZW5kZXJlcjtcclxuXHJcblx0XHRfcHJlY2lzaW9uID0gcmVuZGVyZXIuZ2V0UHJlY2lzaW9uKCk7XHJcblxyXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDggKyA4ICk7XHJcblx0XHRfc3ByaXRlLmZhY2VzICAgID0gbmV3IFVpbnQxNkFycmF5KCA2ICk7XHJcblxyXG5cdFx0dmFyIGkgPSAwO1xyXG5cclxuXHRcdF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gLTE7IF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gLTE7XHQvLyB2ZXJ0ZXggMFxyXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAwOyAgX3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAwO1x0Ly8gdXYgMFxyXG5cclxuXHRcdF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMTsgIF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gLTE7XHQvLyB2ZXJ0ZXggMVxyXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAxOyAgX3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAwO1x0Ly8gdXYgMVxyXG5cclxuXHRcdF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMTsgIF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMTtcdC8vIHZlcnRleCAyXHJcblx0XHRfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IDE7ICBfc3ByaXRlLnZlcnRpY2VzWyBpKysgXSA9IDE7XHQvLyB1diAyXHJcblxyXG5cdFx0X3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAtMTsgX3Nwcml0ZS52ZXJ0aWNlc1sgaSsrIF0gPSAxO1x0Ly8gdmVydGV4IDNcclxuXHRcdF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMDsgIF9zcHJpdGUudmVydGljZXNbIGkrKyBdID0gMTtcdC8vIHV2IDNcclxuXHJcblx0XHRpID0gMDtcclxuXHJcblx0XHRfc3ByaXRlLmZhY2VzWyBpKysgXSA9IDA7IF9zcHJpdGUuZmFjZXNbIGkrKyBdID0gMTsgX3Nwcml0ZS5mYWNlc1sgaSsrIF0gPSAyO1xyXG5cdFx0X3Nwcml0ZS5mYWNlc1sgaSsrIF0gPSAwOyBfc3ByaXRlLmZhY2VzWyBpKysgXSA9IDI7IF9zcHJpdGUuZmFjZXNbIGkrKyBdID0gMztcclxuXHJcblx0XHRfc3ByaXRlLnZlcnRleEJ1ZmZlciAgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblx0XHRfc3ByaXRlLmVsZW1lbnRCdWZmZXIgPSBfZ2wuY3JlYXRlQnVmZmVyKCk7XHJcblxyXG5cdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIF9zcHJpdGUudmVydGV4QnVmZmVyICk7XHJcblx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgX3Nwcml0ZS52ZXJ0aWNlcywgX2dsLlNUQVRJQ19EUkFXICk7XHJcblxyXG5cdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgX3Nwcml0ZS5lbGVtZW50QnVmZmVyICk7XHJcblx0XHRfZ2wuYnVmZmVyRGF0YSggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBfc3ByaXRlLmZhY2VzLCBfZ2wuU1RBVElDX0RSQVcgKTtcclxuXHJcblx0XHRfc3ByaXRlLnByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBUSFJFRS5TaGFkZXJTcHJpdGVbIFwic3ByaXRlXCIgXSwgX3ByZWNpc2lvbiApO1xyXG5cclxuXHRcdF9zcHJpdGUuYXR0cmlidXRlcyA9IHt9O1xyXG5cdFx0X3Nwcml0ZS51bmlmb3JtcyA9IHt9O1xyXG5cclxuXHRcdF9zcHJpdGUuYXR0cmlidXRlcy5wb3NpdGlvbiAgICAgICAgICAgPSBfZ2wuZ2V0QXR0cmliTG9jYXRpb24gKCBfc3ByaXRlLnByb2dyYW0sIFwicG9zaXRpb25cIiApO1xyXG5cdFx0X3Nwcml0ZS5hdHRyaWJ1dGVzLnV2ICAgICAgICAgICAgICAgICA9IF9nbC5nZXRBdHRyaWJMb2NhdGlvbiAoIF9zcHJpdGUucHJvZ3JhbSwgXCJ1dlwiICk7XHJcblxyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy51dk9mZnNldCAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJ1dk9mZnNldFwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLnV2U2NhbGUgICAgICAgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcInV2U2NhbGVcIiApO1xyXG5cclxuXHRcdF9zcHJpdGUudW5pZm9ybXMucm90YXRpb24gICAgICAgICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwicm90YXRpb25cIiApO1xyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5zY2FsZSAgICAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJzY2FsZVwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLmFsaWdubWVudCAgICAgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcImFsaWdubWVudFwiICk7XHJcblxyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5jb2xvciAgICAgICAgICAgICAgICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJjb2xvclwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLm1hcCAgICAgICAgICAgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcIm1hcFwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLm9wYWNpdHkgICAgICAgICAgICAgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcIm9wYWNpdHlcIiApO1xyXG5cclxuXHRcdF9zcHJpdGUudW5pZm9ybXMudXNlU2NyZWVuQ29vcmRpbmF0ZXMgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwidXNlU2NyZWVuQ29vcmRpbmF0ZXNcIiApO1xyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5zaXplQXR0ZW51YXRpb24gICBcdCAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwic2l6ZUF0dGVudWF0aW9uXCIgKTtcclxuXHRcdF9zcHJpdGUudW5pZm9ybXMuc2NyZWVuUG9zaXRpb24gICAgXHQgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcInNjcmVlblBvc2l0aW9uXCIgKTtcclxuXHRcdF9zcHJpdGUudW5pZm9ybXMubW9kZWxWaWV3TWF0cml4ICAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwibW9kZWxWaWV3TWF0cml4XCIgKTtcclxuXHRcdF9zcHJpdGUudW5pZm9ybXMucHJvamVjdGlvbk1hdHJpeCAgICAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwicHJvamVjdGlvbk1hdHJpeFwiICk7XHJcblxyXG5cdFx0X3Nwcml0ZS51bmlmb3Jtcy5mb2dUeXBlIFx0XHQgIFx0ICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJmb2dUeXBlXCIgKTtcclxuXHRcdF9zcHJpdGUudW5pZm9ybXMuZm9nRGVuc2l0eSBcdFx0ICA9IF9nbC5nZXRVbmlmb3JtTG9jYXRpb24oIF9zcHJpdGUucHJvZ3JhbSwgXCJmb2dEZW5zaXR5XCIgKTtcclxuXHRcdF9zcHJpdGUudW5pZm9ybXMuZm9nTmVhciBcdFx0ICBcdCAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwiZm9nTmVhclwiICk7XHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLmZvZ0ZhciBcdFx0ICBcdCAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwiZm9nRmFyXCIgKTtcclxuXHRcdF9zcHJpdGUudW5pZm9ybXMuZm9nQ29sb3IgXHRcdCAgXHQgID0gX2dsLmdldFVuaWZvcm1Mb2NhdGlvbiggX3Nwcml0ZS5wcm9ncmFtLCBcImZvZ0NvbG9yXCIgKTtcclxuXHJcblx0XHRfc3ByaXRlLnVuaWZvcm1zLmFscGhhVGVzdCBcdFx0ICBcdCAgPSBfZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBfc3ByaXRlLnByb2dyYW0sIFwiYWxwaGFUZXN0XCIgKTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHZpZXdwb3J0V2lkdGgsIHZpZXdwb3J0SGVpZ2h0ICkge1xyXG5cclxuXHRcdHZhciBzcHJpdGVzID0gc2NlbmUuX193ZWJnbFNwcml0ZXMsXHJcblx0XHRcdG5TcHJpdGVzID0gc3ByaXRlcy5sZW5ndGg7XHJcblxyXG5cdFx0aWYgKCAhIG5TcHJpdGVzICkgcmV0dXJuO1xyXG5cclxuXHRcdHZhciBhdHRyaWJ1dGVzID0gX3Nwcml0ZS5hdHRyaWJ1dGVzLFxyXG5cdFx0XHR1bmlmb3JtcyA9IF9zcHJpdGUudW5pZm9ybXM7XHJcblxyXG5cdFx0dmFyIGludkFzcGVjdCA9IHZpZXdwb3J0SGVpZ2h0IC8gdmlld3BvcnRXaWR0aDtcclxuXHJcblx0XHR2YXIgaGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydFdpZHRoICogMC41LFxyXG5cdFx0XHRoYWxmVmlld3BvcnRIZWlnaHQgPSB2aWV3cG9ydEhlaWdodCAqIDAuNTtcclxuXHJcblx0XHQvLyBzZXR1cCBnbFxyXG5cclxuXHRcdF9nbC51c2VQcm9ncmFtKCBfc3ByaXRlLnByb2dyYW0gKTtcclxuXHJcblx0XHRfZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkoIGF0dHJpYnV0ZXMucG9zaXRpb24gKTtcclxuXHRcdF9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYXR0cmlidXRlcy51diApO1xyXG5cclxuXHRcdF9nbC5kaXNhYmxlKCBfZ2wuQ1VMTF9GQUNFICk7XHJcblx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHJcblx0XHRfZ2wuYmluZEJ1ZmZlciggX2dsLkFSUkFZX0JVRkZFUiwgX3Nwcml0ZS52ZXJ0ZXhCdWZmZXIgKTtcclxuXHRcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhdHRyaWJ1dGVzLnBvc2l0aW9uLCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xyXG5cdFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIF9nbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCA4ICk7XHJcblxyXG5cdFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgX3Nwcml0ZS5lbGVtZW50QnVmZmVyICk7XHJcblxyXG5cdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xyXG5cclxuXHRcdF9nbC5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKTtcclxuXHRcdF9nbC51bmlmb3JtMWkoIHVuaWZvcm1zLm1hcCwgMCApO1xyXG5cclxuXHRcdHZhciBvbGRGb2dUeXBlID0gMDtcclxuXHRcdHZhciBzY2VuZUZvZ1R5cGUgPSAwO1xyXG5cdFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcclxuXHJcblx0XHRpZiAoIGZvZyApIHtcclxuXHJcblx0XHRcdF9nbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XHJcblxyXG5cdFx0XHRpZiAoIGZvZyBpbnN0YW5jZW9mIFRIUkVFLkZvZyApIHtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nTmVhciwgZm9nLm5lYXIgKTtcclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dGYXIsIGZvZy5mYXIgKTtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMSApO1xyXG5cdFx0XHRcdG9sZEZvZ1R5cGUgPSAxO1xyXG5cdFx0XHRcdHNjZW5lRm9nVHlwZSA9IDE7XHJcblxyXG5cdFx0XHR9IGVsc2UgaWYgKCBmb2cgaW5zdGFuY2VvZiBUSFJFRS5Gb2dFeHAyICkge1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dEZW5zaXR5LCBmb2cuZGVuc2l0eSApO1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAyICk7XHJcblx0XHRcdFx0b2xkRm9nVHlwZSA9IDI7XHJcblx0XHRcdFx0c2NlbmVGb2dUeXBlID0gMjtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMCApO1xyXG5cdFx0XHRvbGRGb2dUeXBlID0gMDtcclxuXHRcdFx0c2NlbmVGb2dUeXBlID0gMDtcclxuXHJcblx0XHR9XHJcblxyXG5cclxuXHRcdC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcclxuXHJcblx0XHR2YXIgaSwgc3ByaXRlLCBtYXRlcmlhbCwgc2NyZWVuUG9zaXRpb24sIHNpemUsIGZvZ1R5cGUsIHNjYWxlID0gW107XHJcblxyXG5cdFx0Zm9yKCBpID0gMDsgaSA8IG5TcHJpdGVzOyBpICsrICkge1xyXG5cclxuXHRcdFx0c3ByaXRlID0gc3ByaXRlc1sgaSBdO1xyXG5cdFx0XHRtYXRlcmlhbCA9IHNwcml0ZS5tYXRlcmlhbDtcclxuXHJcblx0XHRcdGlmICggISBzcHJpdGUudmlzaWJsZSB8fCBtYXRlcmlhbC5vcGFjaXR5ID09PSAwICkgY29udGludWU7XHJcblxyXG5cdFx0XHRpZiAoICEgbWF0ZXJpYWwudXNlU2NyZWVuQ29vcmRpbmF0ZXMgKSB7XHJcblxyXG5cdFx0XHRcdHNwcml0ZS5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xyXG5cdFx0XHRcdHNwcml0ZS56ID0gLSBzcHJpdGUuX21vZGVsVmlld01hdHJpeC5lbGVtZW50c1sgMTQgXTtcclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdHNwcml0ZS56ID0gLSBzcHJpdGUucG9zaXRpb24uejtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0c3ByaXRlcy5zb3J0KCBwYWludGVyU29ydFN0YWJsZSApO1xyXG5cclxuXHRcdC8vIHJlbmRlciBhbGwgc3ByaXRlc1xyXG5cclxuXHRcdGZvciggaSA9IDA7IGkgPCBuU3ByaXRlczsgaSArKyApIHtcclxuXHJcblx0XHRcdHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcclxuXHRcdFx0bWF0ZXJpYWwgPSBzcHJpdGUubWF0ZXJpYWw7XHJcblxyXG5cdFx0XHRpZiAoICEgc3ByaXRlLnZpc2libGUgfHwgbWF0ZXJpYWwub3BhY2l0eSA9PT0gMCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0aWYgKCBtYXRlcmlhbC5tYXAgJiYgbWF0ZXJpYWwubWFwLmltYWdlICYmIG1hdGVyaWFsLm1hcC5pbWFnZS53aWR0aCApIHtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggdW5pZm9ybXMuYWxwaGFUZXN0LCBtYXRlcmlhbC5hbHBoYVRlc3QgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBtYXRlcmlhbC51c2VTY3JlZW5Db29yZGluYXRlcyA9PT0gdHJ1ZSApIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy51c2VTY3JlZW5Db29yZGluYXRlcywgMSApO1xyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0zZihcclxuXHRcdFx0XHRcdFx0dW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sXHJcblx0XHRcdFx0XHRcdCggKCBzcHJpdGUucG9zaXRpb24ueCAqIF9yZW5kZXJlci5kZXZpY2VQaXhlbFJhdGlvICkgLSBoYWxmVmlld3BvcnRXaWR0aCAgKSAvIGhhbGZWaWV3cG9ydFdpZHRoLFxyXG5cdFx0XHRcdFx0XHQoIGhhbGZWaWV3cG9ydEhlaWdodCAtICggc3ByaXRlLnBvc2l0aW9uLnkgKiBfcmVuZGVyZXIuZGV2aWNlUGl4ZWxSYXRpbyApICkgLyBoYWxmVmlld3BvcnRIZWlnaHQsXHJcblx0XHRcdFx0XHRcdE1hdGgubWF4KCAwLCBNYXRoLm1pbiggMSwgc3ByaXRlLnBvc2l0aW9uLnogKSApXHJcblx0XHRcdFx0XHQpO1xyXG5cclxuXHRcdFx0XHRcdHNjYWxlWyAwIF0gPSBfcmVuZGVyZXIuZGV2aWNlUGl4ZWxSYXRpbztcclxuXHRcdFx0XHRcdHNjYWxlWyAxIF0gPSBfcmVuZGVyZXIuZGV2aWNlUGl4ZWxSYXRpbztcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRfZ2wudW5pZm9ybTFpKCB1bmlmb3Jtcy51c2VTY3JlZW5Db29yZGluYXRlcywgMCApO1xyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMuc2l6ZUF0dGVudWF0aW9uLCBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPyAxIDogMCApO1xyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLm1vZGVsVmlld01hdHJpeCwgZmFsc2UsIHNwcml0ZS5fbW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzICk7XHJcblxyXG5cdFx0XHRcdFx0c2NhbGVbIDAgXSA9IDE7XHJcblx0XHRcdFx0XHRzY2FsZVsgMSBdID0gMTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIHNjZW5lLmZvZyAmJiBtYXRlcmlhbC5mb2cgKSB7XHJcblxyXG5cdFx0XHRcdFx0Zm9nVHlwZSA9IHNjZW5lRm9nVHlwZTtcclxuXHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRmb2dUeXBlID0gMDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIG9sZEZvZ1R5cGUgIT09IGZvZ1R5cGUgKSB7XHJcblxyXG5cdFx0XHRcdFx0X2dsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgZm9nVHlwZSApO1xyXG5cdFx0XHRcdFx0b2xkRm9nVHlwZSA9IGZvZ1R5cGU7XHJcblxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0c2l6ZSA9IDEgLyAoIG1hdGVyaWFsLnNjYWxlQnlWaWV3cG9ydCA/IHZpZXdwb3J0SGVpZ2h0IDogMSApO1xyXG5cclxuXHRcdFx0XHRzY2FsZVsgMCBdICo9IHNpemUgKiBpbnZBc3BlY3QgKiBzcHJpdGUuc2NhbGUueFxyXG5cdFx0XHRcdHNjYWxlWyAxIF0gKj0gc2l6ZSAqIHNwcml0ZS5zY2FsZS55O1xyXG5cclxuXHRcdFx0XHRfZ2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCBtYXRlcmlhbC51dlNjYWxlLngsIG1hdGVyaWFsLnV2U2NhbGUueSApO1xyXG5cdFx0XHRcdF9nbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCBtYXRlcmlhbC51dk9mZnNldC54LCBtYXRlcmlhbC51dk9mZnNldC55ICk7XHJcblx0XHRcdFx0X2dsLnVuaWZvcm0yZiggdW5pZm9ybXMuYWxpZ25tZW50LCBtYXRlcmlhbC5hbGlnbm1lbnQueCwgbWF0ZXJpYWwuYWxpZ25tZW50LnkgKTtcclxuXHJcblx0XHRcdFx0X2dsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgbWF0ZXJpYWwub3BhY2l0eSApO1xyXG5cdFx0XHRcdF9nbC51bmlmb3JtM2YoIHVuaWZvcm1zLmNvbG9yLCBtYXRlcmlhbC5jb2xvci5yLCBtYXRlcmlhbC5jb2xvci5nLCBtYXRlcmlhbC5jb2xvci5iICk7XHJcblxyXG5cdFx0XHRcdF9nbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBzcHJpdGUucm90YXRpb24gKTtcclxuXHRcdFx0XHRfZ2wudW5pZm9ybTJmdiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlICk7XHJcblxyXG5cdFx0XHRcdF9yZW5kZXJlci5zZXRCbGVuZGluZyggbWF0ZXJpYWwuYmxlbmRpbmcsIG1hdGVyaWFsLmJsZW5kRXF1YXRpb24sIG1hdGVyaWFsLmJsZW5kU3JjLCBtYXRlcmlhbC5ibGVuZERzdCApO1xyXG5cdFx0XHRcdF9yZW5kZXJlci5zZXREZXB0aFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xyXG5cdFx0XHRcdF9yZW5kZXJlci5zZXREZXB0aFdyaXRlKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XHJcblx0XHRcdFx0X3JlbmRlcmVyLnNldFRleHR1cmUoIG1hdGVyaWFsLm1hcCwgMCApO1xyXG5cclxuXHRcdFx0XHRfZ2wuZHJhd0VsZW1lbnRzKCBfZ2wuVFJJQU5HTEVTLCA2LCBfZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzdG9yZSBnbFxyXG5cclxuXHRcdF9nbC5lbmFibGUoIF9nbC5DVUxMX0ZBQ0UgKTtcclxuXHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbSAoIHNoYWRlciwgcHJlY2lzaW9uICkge1xyXG5cclxuXHRcdHZhciBwcm9ncmFtID0gX2dsLmNyZWF0ZVByb2dyYW0oKTtcclxuXHJcblx0XHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBfZ2wuY3JlYXRlU2hhZGVyKCBfZ2wuRlJBR01FTlRfU0hBREVSICk7XHJcblx0XHR2YXIgdmVydGV4U2hhZGVyID0gX2dsLmNyZWF0ZVNoYWRlciggX2dsLlZFUlRFWF9TSEFERVIgKTtcclxuXHJcblx0XHR2YXIgcHJlZml4ID0gXCJwcmVjaXNpb24gXCIgKyBwcmVjaXNpb24gKyBcIiBmbG9hdDtcXG5cIjtcclxuXHJcblx0XHRfZ2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLmZyYWdtZW50U2hhZGVyICk7XHJcblx0XHRfZ2wuc2hhZGVyU291cmNlKCB2ZXJ0ZXhTaGFkZXIsIHByZWZpeCArIHNoYWRlci52ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHRfZ2wuY29tcGlsZVNoYWRlciggZnJhZ21lbnRTaGFkZXIgKTtcclxuXHRcdF9nbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcclxuXHJcblx0XHRfZ2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xyXG5cdFx0X2dsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XHJcblxyXG5cdFx0X2dsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XHJcblxyXG5cdFx0cmV0dXJuIHByb2dyYW07XHJcblxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlICggYSwgYiApIHtcclxuXHJcblx0XHRpZiAoIGEueiAhPT0gYi56ICkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGIueiAtIGEuejtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0cmV0dXJuIGIuaWQgLSBhLmlkO1xyXG5cclxuXHRcdH1cclxuXHJcblx0fTtcclxuXHJcbn07XHJcbi8qKlxyXG4gKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xyXG4gKi9cclxuXHJcblRIUkVFLkRlcHRoUGFzc1BsdWdpbiA9IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0dGhpcy5lbmFibGVkID0gZmFsc2U7XHJcblx0dGhpcy5yZW5kZXJUYXJnZXQgPSBudWxsO1xyXG5cclxuXHR2YXIgX2dsLFxyXG5cdF9yZW5kZXJlcixcclxuXHRfZGVwdGhNYXRlcmlhbCwgX2RlcHRoTWF0ZXJpYWxNb3JwaCwgX2RlcHRoTWF0ZXJpYWxTa2luLCBfZGVwdGhNYXRlcmlhbE1vcnBoU2tpbixcclxuXHJcblx0X2ZydXN0dW0gPSBuZXcgVEhSRUUuRnJ1c3R1bSgpLFxyXG5cdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IFRIUkVFLk1hdHJpeDQoKTtcclxuXHJcblx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCByZW5kZXJlciApIHtcclxuXHJcblx0XHRfZ2wgPSByZW5kZXJlci5jb250ZXh0O1xyXG5cdFx0X3JlbmRlcmVyID0gcmVuZGVyZXI7XHJcblxyXG5cdFx0dmFyIGRlcHRoU2hhZGVyID0gVEhSRUUuU2hhZGVyTGliWyBcImRlcHRoUkdCQVwiIF07XHJcblx0XHR2YXIgZGVwdGhVbmlmb3JtcyA9IFRIUkVFLlVuaWZvcm1zVXRpbHMuY2xvbmUoIGRlcHRoU2hhZGVyLnVuaWZvcm1zICk7XHJcblxyXG5cdFx0X2RlcHRoTWF0ZXJpYWwgPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlciwgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMgfSApO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxNb3JwaCA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggeyBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogZGVwdGhVbmlmb3JtcywgbW9ycGhUYXJnZXRzOiB0cnVlIH0gKTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsU2tpbiA9IG5ldyBUSFJFRS5TaGFkZXJNYXRlcmlhbCggeyBmcmFnbWVudFNoYWRlcjogZGVwdGhTaGFkZXIuZnJhZ21lbnRTaGFkZXIsIHZlcnRleFNoYWRlcjogZGVwdGhTaGFkZXIudmVydGV4U2hhZGVyLCB1bmlmb3JtczogZGVwdGhVbmlmb3Jtcywgc2tpbm5pbmc6IHRydWUgfSApO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxNb3JwaFNraW4gPSBuZXcgVEhSRUUuU2hhZGVyTWF0ZXJpYWwoIHsgZnJhZ21lbnRTaGFkZXI6IGRlcHRoU2hhZGVyLmZyYWdtZW50U2hhZGVyLCB2ZXJ0ZXhTaGFkZXI6IGRlcHRoU2hhZGVyLnZlcnRleFNoYWRlciwgdW5pZm9ybXM6IGRlcHRoVW5pZm9ybXMsIG1vcnBoVGFyZ2V0czogdHJ1ZSwgc2tpbm5pbmc6IHRydWUgfSApO1xyXG5cclxuXHRcdF9kZXB0aE1hdGVyaWFsLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGguX3NoYWRvd1Bhc3MgPSB0cnVlO1xyXG5cdFx0X2RlcHRoTWF0ZXJpYWxTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHRcdF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luLl9zaGFkb3dQYXNzID0gdHJ1ZTtcclxuXHJcblx0fTtcclxuXHJcblx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEgKSB7XHJcblxyXG5cdFx0aWYgKCAhIHRoaXMuZW5hYmxlZCApIHJldHVybjtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSggc2NlbmUsIGNhbWVyYSApO1xyXG5cclxuXHR9O1xyXG5cclxuXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICggc2NlbmUsIGNhbWVyYSApIHtcclxuXHJcblx0XHR2YXIgaSwgaWwsIGosIGpsLCBuLFxyXG5cclxuXHRcdHByb2dyYW0sIGJ1ZmZlciwgbWF0ZXJpYWwsXHJcblx0XHR3ZWJnbE9iamVjdCwgb2JqZWN0LCBsaWdodCxcclxuXHRcdHJlbmRlckxpc3QsXHJcblxyXG5cdFx0Zm9nID0gbnVsbDtcclxuXHJcblx0XHQvLyBzZXQgR0wgc3RhdGUgZm9yIGRlcHRoIG1hcFxyXG5cclxuXHRcdF9nbC5jbGVhckNvbG9yKCAxLCAxLCAxLCAxICk7XHJcblx0XHRfZ2wuZGlzYWJsZSggX2dsLkJMRU5EICk7XHJcblxyXG5cdFx0X3JlbmRlcmVyLnNldERlcHRoVGVzdCggdHJ1ZSApO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBzY2VuZVxyXG5cclxuXHRcdGlmICggX3JlbmRlcmVyLmF1dG9VcGRhdGVTY2VuZSApIHNjZW5lLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XHJcblxyXG5cdFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxyXG5cclxuXHRcdGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0X3Byb2pTY3JlZW5NYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcclxuXHRcdF9mcnVzdHVtLnNldEZyb21NYXRyaXgoIF9wcm9qU2NyZWVuTWF0cml4ICk7XHJcblxyXG5cdFx0Ly8gcmVuZGVyIGRlcHRoIG1hcFxyXG5cclxuXHRcdF9yZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIHRoaXMucmVuZGVyVGFyZ2V0ICk7XHJcblx0XHRfcmVuZGVyZXIuY2xlYXIoKTtcclxuXHJcblx0XHQvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXHJcblxyXG5cdFx0cmVuZGVyTGlzdCA9IHNjZW5lLl9fd2ViZ2xPYmplY3RzO1xyXG5cclxuXHRcdGZvciAoIGogPSAwLCBqbCA9IHJlbmRlckxpc3QubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XHJcblxyXG5cdFx0XHR3ZWJnbE9iamVjdCA9IHJlbmRlckxpc3RbIGogXTtcclxuXHRcdFx0b2JqZWN0ID0gd2ViZ2xPYmplY3Qub2JqZWN0O1xyXG5cclxuXHRcdFx0d2ViZ2xPYmplY3QucmVuZGVyID0gZmFsc2U7XHJcblxyXG5cdFx0XHRpZiAoIG9iamVjdC52aXNpYmxlICkge1xyXG5cclxuXHRcdFx0XHRpZiAoICEgKCBvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5NZXNoIHx8IG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICkgfHwgISAoIG9iamVjdC5mcnVzdHVtQ3VsbGVkICkgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgKSB7XHJcblxyXG5cdFx0XHRcdFx0b2JqZWN0Ll9tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XHJcblxyXG5cdFx0XHRcdFx0d2ViZ2xPYmplY3QucmVuZGVyID0gdHJ1ZTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyByZW5kZXIgcmVndWxhciBvYmplY3RzXHJcblxyXG5cdFx0dmFyIG9iamVjdE1hdGVyaWFsLCB1c2VNb3JwaGluZywgdXNlU2tpbm5pbmc7XHJcblxyXG5cdFx0Zm9yICggaiA9IDAsIGpsID0gcmVuZGVyTGlzdC5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcclxuXHJcblx0XHRcdHdlYmdsT2JqZWN0ID0gcmVuZGVyTGlzdFsgaiBdO1xyXG5cclxuXHRcdFx0aWYgKCB3ZWJnbE9iamVjdC5yZW5kZXIgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcclxuXHRcdFx0XHRidWZmZXIgPSB3ZWJnbE9iamVjdC5idWZmZXI7XHJcblxyXG5cdFx0XHRcdC8vIHRvZG86IGNyZWF0ZSBwcm9wZXIgZGVwdGggbWF0ZXJpYWwgZm9yIHBhcnRpY2xlc1xyXG5cclxuXHRcdFx0XHRpZiAoIG9iamVjdCBpbnN0YW5jZW9mIFRIUkVFLlBhcnRpY2xlU3lzdGVtICYmICFvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbCApIGNvbnRpbnVlO1xyXG5cclxuXHRcdFx0XHRvYmplY3RNYXRlcmlhbCA9IGdldE9iamVjdE1hdGVyaWFsKCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0aWYgKCBvYmplY3RNYXRlcmlhbCApIF9yZW5kZXJlci5zZXRNYXRlcmlhbEZhY2VzKCBvYmplY3QubWF0ZXJpYWwgKTtcclxuXHJcblx0XHRcdFx0dXNlTW9ycGhpbmcgPSBvYmplY3QuZ2VvbWV0cnkubW9ycGhUYXJnZXRzLmxlbmd0aCA+IDAgJiYgb2JqZWN0TWF0ZXJpYWwubW9ycGhUYXJnZXRzO1xyXG5cdFx0XHRcdHVzZVNraW5uaW5nID0gb2JqZWN0IGluc3RhbmNlb2YgVEhSRUUuU2tpbm5lZE1lc2ggJiYgb2JqZWN0TWF0ZXJpYWwuc2tpbm5pbmc7XHJcblxyXG5cdFx0XHRcdGlmICggb2JqZWN0LmN1c3RvbURlcHRoTWF0ZXJpYWwgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGVwdGhNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0fSBlbHNlIGlmICggdXNlU2tpbm5pbmcgKSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSB1c2VNb3JwaGluZyA/IF9kZXB0aE1hdGVyaWFsTW9ycGhTa2luIDogX2RlcHRoTWF0ZXJpYWxTa2luO1xyXG5cclxuXHRcdFx0XHR9IGVsc2UgaWYgKCB1c2VNb3JwaGluZyApIHtcclxuXHJcblx0XHRcdFx0XHRtYXRlcmlhbCA9IF9kZXB0aE1hdGVyaWFsTW9ycGg7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0bWF0ZXJpYWwgPSBfZGVwdGhNYXRlcmlhbDtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIGJ1ZmZlciBpbnN0YW5jZW9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5ICkge1xyXG5cclxuXHRcdFx0XHRcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIGNhbWVyYSwgc2NlbmUuX19saWdodHMsIGZvZywgbWF0ZXJpYWwsIGJ1ZmZlciwgb2JqZWN0ICk7XHJcblxyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblxyXG5cdFx0XHRcdFx0X3JlbmRlcmVyLnJlbmRlckJ1ZmZlciggY2FtZXJhLCBzY2VuZS5fX2xpZ2h0cywgZm9nLCBtYXRlcmlhbCwgYnVmZmVyLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0fVxyXG5cclxuXHRcdH1cclxuXHJcblx0XHQvLyBzZXQgbWF0cmljZXMgYW5kIHJlbmRlciBpbW1lZGlhdGUgb2JqZWN0c1xyXG5cclxuXHRcdHJlbmRlckxpc3QgPSBzY2VuZS5fX3dlYmdsT2JqZWN0c0ltbWVkaWF0ZTtcclxuXHJcblx0XHRmb3IgKCBqID0gMCwgamwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xyXG5cclxuXHRcdFx0d2ViZ2xPYmplY3QgPSByZW5kZXJMaXN0WyBqIF07XHJcblx0XHRcdG9iamVjdCA9IHdlYmdsT2JqZWN0Lm9iamVjdDtcclxuXHJcblx0XHRcdGlmICggb2JqZWN0LnZpc2libGUgKSB7XHJcblxyXG5cdFx0XHRcdG9iamVjdC5fbW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xyXG5cclxuXHRcdFx0XHRfcmVuZGVyZXIucmVuZGVySW1tZWRpYXRlT2JqZWN0KCBjYW1lcmEsIHNjZW5lLl9fbGlnaHRzLCBmb2csIF9kZXB0aE1hdGVyaWFsLCBvYmplY3QgKTtcclxuXHJcblx0XHRcdH1cclxuXHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcmVzdG9yZSBHTCBzdGF0ZVxyXG5cclxuXHRcdHZhciBjbGVhckNvbG9yID0gX3JlbmRlcmVyLmdldENsZWFyQ29sb3IoKSxcclxuXHRcdGNsZWFyQWxwaGEgPSBfcmVuZGVyZXIuZ2V0Q2xlYXJBbHBoYSgpO1xyXG5cclxuXHRcdF9nbC5jbGVhckNvbG9yKCBjbGVhckNvbG9yLnIsIGNsZWFyQ29sb3IuZywgY2xlYXJDb2xvci5iLCBjbGVhckFscGhhICk7XHJcblx0XHRfZ2wuZW5hYmxlKCBfZ2wuQkxFTkQgKTtcclxuXHJcblx0fTtcclxuXHJcblx0Ly8gRm9yIHRoZSBtb21lbnQganVzdCBpZ25vcmUgb2JqZWN0cyB0aGF0IGhhdmUgbXVsdGlwbGUgbWF0ZXJpYWxzIHdpdGggZGlmZmVyZW50IGFuaW1hdGlvbiBtZXRob2RzXHJcblx0Ly8gT25seSB0aGUgZmlyc3QgbWF0ZXJpYWwgd2lsbCBiZSB0YWtlbiBpbnRvIGFjY291bnQgZm9yIGRlY2lkaW5nIHdoaWNoIGRlcHRoIG1hdGVyaWFsIHRvIHVzZVxyXG5cclxuXHRmdW5jdGlvbiBnZXRPYmplY3RNYXRlcmlhbCggb2JqZWN0ICkge1xyXG5cclxuXHRcdHJldHVybiBvYmplY3QubWF0ZXJpYWwgaW5zdGFuY2VvZiBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsXHJcblx0XHRcdD8gb2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFsc1sgMCBdXHJcblx0XHRcdDogb2JqZWN0Lm1hdGVyaWFsO1xyXG5cclxuXHR9O1xyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xyXG4gKlxyXG4gKi9cclxuXHJcblRIUkVFLlNoYWRlckZsYXJlcyA9IHtcclxuXHJcblx0J2xlbnNGbGFyZVZlcnRleFRleHR1cmUnOiB7XHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIHNjcmVlblBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXHJcblxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2VVYgPSB1djtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMyIHBvcyA9IHBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XHRcImlmKCByZW5kZXJUeXBlID09IDIgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ2ZWM0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjEgKSApICtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICBcInRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuMSApICkgK1wiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIFwidGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC4xICkgKSArXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgXCJ0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApICtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICBcInRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuOSApICkgK1wiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIFwidGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC45ICkgKSArXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgXCJ0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjkgKSApICtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICBcInRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjEsIDAuNSApICkgK1wiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgIFwidGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC41ICkgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInZWaXNpYmlsaXR5ID0gKCAgICAgICB2aXNpYmlsaXR5LnIgLyA5LjAgKSAqXCIsXHJcblx0XHRcdFx0XHRcdFx0XHQgIFwiKCAxLjAgLSB2aXNpYmlsaXR5LmcgLyA5LjAgKSAqXCIsXHJcblx0XHRcdFx0XHRcdFx0XHQgIFwiKCAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjAgKSAqXCIsXHJcblx0XHRcdFx0XHRcdFx0XHQgIFwiKCAxLjAgLSB2aXNpYmlsaXR5LmEgLyA5LjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcInBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblx0XHRcdFx0XHRcInBvcy55ID0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueCArIGNvcyggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XHRcImdsX1Bvc2l0aW9uID0gdmVjNCggKCBwb3MgKiBzY2FsZSArIHNjcmVlblBvc2l0aW9uLnh5ICkueHksIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMzIGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG5cdFx0XHRcInZhcnlpbmcgZmxvYXQgdlZpc2liaWxpdHk7XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0Ly8gcGluayBzcXVhcmVcclxuXHJcblx0XHRcdFx0XCJpZiggcmVuZGVyVHlwZSA9PSAwICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggMS4wLCAwLjAsIDEuMCwgMC4wICk7XCIsXHJcblxyXG5cdFx0XHRcdC8vIHJlc3RvcmVcclxuXHJcblx0XHRcdFx0XCJ9IGVsc2UgaWYoIHJlbmRlclR5cGUgPT0gMSApIHtcIixcclxuXHJcblx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gZmxhcmVcclxuXHJcblx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cdFx0XHRcdFx0XCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZWaXNpYmlsaXR5O1wiLFxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlO1wiLFxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IucmdiICo9IGNvbG9yO1wiLFxyXG5cclxuXHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFwifVwiXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9LFxyXG5cclxuXHJcblx0J2xlbnNGbGFyZSc6IHtcclxuXHJcblx0XHR2ZXJ0ZXhTaGFkZXI6IFtcclxuXHJcblx0XHRcdFwidW5pZm9ybSBsb3dwIGludCByZW5kZXJUeXBlO1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXHJcblx0XHRcdFwidW5pZm9ybSB2ZWMyIHNjYWxlO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgcm90YXRpb247XCIsXHJcblxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcImF0dHJpYnV0ZSB2ZWMyIHV2O1wiLFxyXG5cclxuXHRcdFx0XCJ2YXJ5aW5nIHZlYzIgdlVWO1wiLFxyXG5cclxuXHRcdFx0XCJ2b2lkIG1haW4oKSB7XCIsXHJcblxyXG5cdFx0XHRcdFwidlVWID0gdXY7XCIsXHJcblxyXG5cdFx0XHRcdFwidmVjMiBwb3MgPSBwb3NpdGlvbjtcIixcclxuXHJcblx0XHRcdFx0XCJpZiggcmVuZGVyVHlwZSA9PSAyICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwicG9zLnggPSBjb3MoIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuXHRcdFx0XHRcdFwicG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7XCIsXHJcblxyXG5cdFx0XHRcIn1cIlxyXG5cclxuXHRcdF0uam9pbiggXCJcXG5cIiApLFxyXG5cclxuXHRcdGZyYWdtZW50U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1wiLFxyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7XCIsXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gc2FtcGxlcjJEIG1hcDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBvY2NsdXNpb25NYXA7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBvcGFjaXR5O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMyBjb2xvcjtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHQvLyBwaW5rIHNxdWFyZVxyXG5cclxuXHRcdFx0XHRcImlmKCByZW5kZXJUeXBlID09IDAgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJnbF9GcmFnQ29sb3IgPSB2ZWM0KCB0ZXh0dXJlMkQoIG1hcCwgdlVWICkucmdiLCAwLjAgKTtcIixcclxuXHJcblx0XHRcdFx0Ly8gcmVzdG9yZVxyXG5cclxuXHRcdFx0XHRcIn0gZWxzZSBpZiggcmVuZGVyVHlwZSA9PSAxICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cclxuXHRcdFx0XHQvLyBmbGFyZVxyXG5cclxuXHRcdFx0XHRcIn0gZWxzZSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCB2aXNpYmlsaXR5ID0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKS5hICtcIixcclxuXHRcdFx0XHRcdFx0XHRcdFx0ICAgXCJ0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApLmEgK1wiLFxyXG5cdFx0XHRcdFx0XHRcdFx0XHQgICBcInRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICkuYSArXCIsXHJcblx0XHRcdFx0XHRcdFx0XHRcdCAgIFwidGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKS5hO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmlzaWJpbGl0eSA9ICggMS4wIC0gdmlzaWJpbGl0eSAvIDQuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcdFwidmVjNCB0ZXh0dXJlID0gdGV4dHVyZTJEKCBtYXAsIHZVViApO1wiLFxyXG5cdFx0XHRcdFx0XCJ0ZXh0dXJlLmEgKj0gb3BhY2l0eSAqIHZpc2liaWxpdHk7XCIsXHJcblx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IHRleHR1cmU7XCIsXHJcblx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG4vKipcclxuICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cclxuICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cclxuICpcclxuICovXHJcblxyXG5USFJFRS5TaGFkZXJTcHJpdGUgPSB7XHJcblxyXG5cdCdzcHJpdGUnOiB7XHJcblxyXG5cdFx0dmVydGV4U2hhZGVyOiBbXHJcblxyXG5cdFx0XHRcInVuaWZvcm0gaW50IHVzZVNjcmVlbkNvb3JkaW5hdGVzO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gaW50IHNpemVBdHRlbnVhdGlvbjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247XCIsXHJcblx0XHRcdFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IHJvdGF0aW9uO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMiBzY2FsZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgYWxpZ25tZW50O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gdmVjMiB1dk9mZnNldDtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzIgdXZTY2FsZTtcIixcclxuXHJcblx0XHRcdFwiYXR0cmlidXRlIHZlYzIgcG9zaXRpb247XCIsXHJcblx0XHRcdFwiYXR0cmlidXRlIHZlYzIgdXY7XCIsXHJcblxyXG5cdFx0XHRcInZhcnlpbmcgdmVjMiB2VVY7XCIsXHJcblxyXG5cdFx0XHRcInZvaWQgbWFpbigpIHtcIixcclxuXHJcblx0XHRcdFx0XCJ2VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWMyIGFsaWduZWRQb3NpdGlvbiA9IHBvc2l0aW9uICsgYWxpZ25tZW50O1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzIgcm90YXRlZFBvc2l0aW9uO1wiLFxyXG5cdFx0XHRcdFwicm90YXRlZFBvc2l0aW9uLnggPSAoIGNvcyggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi54IC0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnkgKSAqIHNjYWxlLng7XCIsXHJcblx0XHRcdFx0XCJyb3RhdGVkUG9zaXRpb24ueSA9ICggc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueSApICogc2NhbGUueTtcIixcclxuXHJcblx0XHRcdFx0XCJ2ZWM0IGZpbmFsUG9zaXRpb247XCIsXHJcblxyXG5cdFx0XHRcdFwiaWYoIHVzZVNjcmVlbkNvb3JkaW5hdGVzICE9IDAgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmaW5hbFBvc2l0aW9uID0gdmVjNCggc2NyZWVuUG9zaXRpb24ueHkgKyByb3RhdGVkUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLnosIDEuMCApO1wiLFxyXG5cclxuXHRcdFx0XHRcIn0gZWxzZSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmaW5hbFBvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApO1wiLFxyXG5cdFx0XHRcdFx0XCJmaW5hbFBvc2l0aW9uLnh5ICs9IHJvdGF0ZWRQb3NpdGlvbiAqICggc2l6ZUF0dGVudWF0aW9uID09IDEgPyAxLjAgOiBmaW5hbFBvc2l0aW9uLnogKTtcIixcclxuXHJcblx0XHRcdFx0XCJ9XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfUG9zaXRpb24gPSBmaW5hbFBvc2l0aW9uO1wiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKSxcclxuXHJcblx0XHRmcmFnbWVudFNoYWRlcjogW1xyXG5cclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgY29sb3I7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBzYW1wbGVyMkQgbWFwO1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcIixcclxuXHJcblx0XHRcdFwidW5pZm9ybSBpbnQgZm9nVHlwZTtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIHZlYzMgZm9nQ29sb3I7XCIsXHJcblx0XHRcdFwidW5pZm9ybSBmbG9hdCBmb2dEZW5zaXR5O1wiLFxyXG5cdFx0XHRcInVuaWZvcm0gZmxvYXQgZm9nTmVhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGZvZ0ZhcjtcIixcclxuXHRcdFx0XCJ1bmlmb3JtIGZsb2F0IGFscGhhVGVzdDtcIixcclxuXHJcblx0XHRcdFwidmFyeWluZyB2ZWMyIHZVVjtcIixcclxuXHJcblx0XHRcdFwidm9pZCBtYWluKCkge1wiLFxyXG5cclxuXHRcdFx0XHRcInZlYzQgdGV4dHVyZSA9IHRleHR1cmUyRCggbWFwLCB2VVYgKTtcIixcclxuXHJcblx0XHRcdFx0XCJpZiAoIHRleHR1cmUuYSA8IGFscGhhVGVzdCApIGRpc2NhcmQ7XCIsXHJcblxyXG5cdFx0XHRcdFwiZ2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IgKiB0ZXh0dXJlLnh5eiwgdGV4dHVyZS5hICogb3BhY2l0eSApO1wiLFxyXG5cclxuXHRcdFx0XHRcImlmICggZm9nVHlwZSA+IDAgKSB7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJmbG9hdCBkZXB0aCA9IGdsX0ZyYWdDb29yZC56IC8gZ2xfRnJhZ0Nvb3JkLnc7XCIsXHJcblx0XHRcdFx0XHRcImZsb2F0IGZvZ0ZhY3RvciA9IDAuMDtcIixcclxuXHJcblx0XHRcdFx0XHRcImlmICggZm9nVHlwZSA9PSAxICkge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJmb2dGYWN0b3IgPSBzbW9vdGhzdGVwKCBmb2dOZWFyLCBmb2dGYXIsIGRlcHRoICk7XCIsXHJcblxyXG5cdFx0XHRcdFx0XCJ9IGVsc2Uge1wiLFxyXG5cclxuXHRcdFx0XHRcdFx0XCJjb25zdCBmbG9hdCBMT0cyID0gMS40NDI2OTU7XCIsXHJcblx0XHRcdFx0XHRcdFwiZmxvYXQgZm9nRmFjdG9yID0gZXhwMiggLSBmb2dEZW5zaXR5ICogZm9nRGVuc2l0eSAqIGRlcHRoICogZGVwdGggKiBMT0cyICk7XCIsXHJcblx0XHRcdFx0XHRcdFwiZm9nRmFjdG9yID0gMS4wIC0gY2xhbXAoIGZvZ0ZhY3RvciwgMC4wLCAxLjAgKTtcIixcclxuXHJcblx0XHRcdFx0XHRcIn1cIixcclxuXHJcblx0XHRcdFx0XHRcImdsX0ZyYWdDb2xvciA9IG1peCggZ2xfRnJhZ0NvbG9yLCB2ZWM0KCBmb2dDb2xvciwgZ2xfRnJhZ0NvbG9yLncgKSwgZm9nRmFjdG9yICk7XCIsXHJcblxyXG5cdFx0XHRcdFwifVwiLFxyXG5cclxuXHRcdFx0XCJ9XCJcclxuXHJcblx0XHRdLmpvaW4oIFwiXFxuXCIgKVxyXG5cclxuXHR9XHJcblxyXG59O1xyXG5cclxuLy8gRXhwb3J0IHRoZSBUSFJFRSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXHJcbi8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cclxuLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxyXG4vLyBmb3IgQ2xvc3VyZSBDb21waWxlciBcImFkdmFuY2VkXCIgbW9kZS5cclxuaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xyXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gVEhSRUU7XHJcbiAgfVxyXG4gIGV4cG9ydHMuVEhSRUUgPSBUSFJFRTtcclxufSBlbHNlIHtcclxuICB0aGlzWydUSFJFRSddID0gVEhSRUU7XHJcbn1cclxuIiwiLypcbiAqIHRpY1xuICogaHR0cHM6Ly9naXRodWIuY29tL3NoYW1hL3RpY1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMyBLeWxlIFJvYmluc29uIFlvdW5nXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cblxuZnVuY3Rpb24gVGljKCkgeyB0aGlzLl90aGluZ3MgPSBbXTsgfVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBUaWMoKTsgfTtcblxuVGljLnByb3RvdHlwZS5fc3RhY2sgPSBmdW5jdGlvbih0aGluZykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYuX3RoaW5ncy5wdXNoKHRoaW5nKTtcbiAgdmFyIGkgPSBzZWxmLl90aGluZ3MubGVuZ3RoIC0gMTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkgeyBkZWxldGUgc2VsZi5fdGhpbmdzW2ldOyB9XG59O1xuXG5UaWMucHJvdG90eXBlLmludGVydmFsID0gVGljLnByb3RvdHlwZS5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKGZuLCBhdCkge1xuICByZXR1cm4gdGhpcy5fc3RhY2soe1xuICAgIGZuOiBmbiwgYXQ6IGF0LCBhcmdzOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgIGVsYXBzZWQ6IDAsIG9uY2U6IGZhbHNlXG4gIH0pO1xufTtcblxuVGljLnByb3RvdHlwZS50aW1lb3V0ID0gVGljLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oZm4sIGF0KSB7XG4gIHJldHVybiB0aGlzLl9zdGFjayh7XG4gICAgZm46IGZuLCBhdDogYXQsIGFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgZWxhcHNlZDogMCwgb25jZTogdHJ1ZVxuICB9KTtcbn07XG5cblRpYy5wcm90b3R5cGUudGljayA9IGZ1bmN0aW9uKGR0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5fdGhpbmdzLmZvckVhY2goZnVuY3Rpb24odGhpbmcsIGkpIHtcbiAgICB0aGluZy5lbGFwc2VkICs9IGR0O1xuICAgIGlmICh0aGluZy5lbGFwc2VkID4gdGhpbmcuYXQpIHtcbiAgICAgIHRoaW5nLmVsYXBzZWQgLT0gdGhpbmcuYXQ7XG4gICAgICB0aGluZy5mbi5hcHBseSh0aGluZy5mbiwgdGhpbmcuYXJncyB8fCBbXSk7XG4gICAgICBpZiAodGhpbmcub25jZSkge1xuICAgICAgICBkZWxldGUgc2VsZi5fdGhpbmdzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBjb250cm9sXG5cbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5TdHJlYW1cblxuZnVuY3Rpb24gY29udHJvbChjb250cm9sX3N0YXRlLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgQ29udHJvbChjb250cm9sX3N0YXRlLCBvcHRzKVxufVxuXG5mdW5jdGlvbiBDb250cm9sKHN0YXRlLCBvcHRzKSB7XG4gIFN0cmVhbS5jYWxsKHRoaXMpXG5cbiAgb3B0cyA9IG9wdHMgfHwge31cblxuICB0aGlzLnN0YXRlID0gc3RhdGVcbiAgdGhpcy5fcGl0Y2hfdGFyZ2V0ID0gXG4gIHRoaXMuX3lhd190YXJnZXQgPVxuICB0aGlzLl9yb2xsX3RhcmdldCA9XG4gIHRoaXMuX3RhcmdldCA9IG51bGxcbiAgdGhpcy5zcGVlZCA9IG9wdHMuc3BlZWQgfHwgMC4wMDMyXG4gIHRoaXMubWF4X3NwZWVkID0gb3B0cy5tYXhTcGVlZCB8fCAwLjAxMTJcbiAgdGhpcy5qdW1wX21heF9zcGVlZCA9IG9wdHMuanVtcE1heFNwZWVkIHx8IDAuMDE2XG4gIHRoaXMuanVtcF9tYXhfdGltZXIgPSBvcHRzLmp1bXBUaW1lciB8fCAyMDBcbiAgdGhpcy5qdW1wX3NwZWVkID0gb3B0cy5qdW1wU3BlZWQgfHwgMC4wMDRcbiAgdGhpcy5qdW1wX3RpbWVyID0gdGhpcy5qdW1wX3RpbWVyX21heFxuICB0aGlzLmp1bXBpbmcgPSBmYWxzZVxuICB0aGlzLmFjY2VsZXJhdGlvbiA9IG9wdHMuYWNjZWxlcmF0aW9uQ3VydmUgfHwgdGhpcy5hY2NlbGVyYXRpb25cblxuICB0aGlzLmZpcmVfcmF0ZSA9IG9wdHMuZmlyZVJhdGUgfHwgMFxuICB0aGlzLm5lZWRzX2Rpc2NyZXRlX2ZpcmUgPSBvcHRzLmRpc2NyZXRlRmlyZSB8fCBmYWxzZVxuICB0aGlzLm9uZmlyZSA9IG9wdHMub25maXJlIHx8IHRoaXMub25maXJlXG4gIHRoaXMuZmlyaW5nID0gMFxuXG4gIHRoaXMueF9yb3RhdGlvbl9wZXJfbXMgPSBvcHRzLnJvdGF0aW9uWE1heCB8fCBvcHRzLnJvdGF0aW9uTWF4IHx8IDMzXG4gIHRoaXMueV9yb3RhdGlvbl9wZXJfbXMgPSBvcHRzLnJvdGF0aW9uWU1heCB8fCBvcHRzLnJvdGF0aW9uTWF4IHx8IDMzXG4gIHRoaXMuel9yb3RhdGlvbl9wZXJfbXMgPSBvcHRzLnJvdGF0aW9uWk1heCB8fCBvcHRzLnJvdGF0aW9uTWF4IHx8IDMzXG5cbiAgdGhpcy54X3JvdGF0aW9uX2NsYW1wID0gb3B0cy5yb3RhdGlvblhDbGFtcCB8fCBNYXRoLlBJIC8gMlxuICB0aGlzLnlfcm90YXRpb25fY2xhbXAgPSBvcHRzLnJvdGF0aW9uWUNsYW1wIHx8IEluZmluaXR5XG4gIHRoaXMuel9yb3RhdGlvbl9jbGFtcCA9IG9wdHMucm90YXRpb25aQ2xhbXAgfHwgMFxuXG4gIHRoaXMucm90YXRpb25fc2NhbGUgPSBvcHRzLnJvdGF0aW9uU2NhbGUgfHwgMC4wMDJcblxuICB0aGlzLmFpcl9jb250cm9sID0gJ2FpckNvbnRyb2wnIGluIG9wdHMgPyBvcHRzLmFpckNvbnRyb2wgOiB0cnVlXG5cbiAgdGhpcy5zdGF0ZS54X3JvdGF0aW9uX2FjY3VtID1cbiAgdGhpcy5zdGF0ZS55X3JvdGF0aW9uX2FjY3VtID0gXG4gIHRoaXMuc3RhdGUuel9yb3RhdGlvbl9hY2N1bSA9IDAuMFxuXG4gIHRoaXMuYWNjZWxfbWF4X3RpbWVyID0gb3B0cy5hY2NlbFRpbWVyIHx8IDIwMFxuICB0aGlzLnhfYWNjZWxfdGltZXIgPSB0aGlzLmFjY2VsX21heF90aW1lciswXG4gIHRoaXMuel9hY2NlbF90aW1lciA9IHRoaXMuYWNjZWxfbWF4X3RpbWVyKzBcblxuICB0aGlzLnJlYWRhYmxlID1cbiAgdGhpcy53cml0YWJsZSA9IHRydWVcblxuICB0aGlzLmJ1ZmZlciA9IFtdXG4gIHRoaXMucGF1c2VkID0gZmFsc2Vcbn1cblxudmFyIGNvbnMgPSBDb250cm9sXG4gICwgcHJvdG8gPSBjb25zLnByb3RvdHlwZSA9IG5ldyBTdHJlYW1cblxucHJvdG8uY29uc3RydWN0b3IgPSBjb25zXG5cbnZhciBtYXggPSBNYXRoLm1heFxuICAsIG1pbiA9IE1hdGgubWluXG4gICwgc2luID0gTWF0aC5zaW5cbiAgLCBhYnMgPSBNYXRoLmFic1xuICAsIGZsb29yID0gTWF0aC5mbG9vclxuICAsIFBJID0gTWF0aC5QSVxuXG5wcm90by50aWNrID0gZnVuY3Rpb24oZHQpIHtcbiAgaWYoIXRoaXMuX3RhcmdldCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGVcbiAgICAsIHRhcmdldCA9IHRoaXMuX3RhcmdldFxuICAgICwgc3BlZWQgPSB0aGlzLnNwZWVkXG4gICAgLCBqdW1wX3NwZWVkID0gdGhpcy5qdW1wX3NwZWVkXG4gICAgLCBva2F5X3ogPSBhYnModGFyZ2V0LnZlbG9jaXR5LnopIDwgdGhpcy5tYXhfc3BlZWRcbiAgICAsIG9rYXlfeCA9IGFicyh0YXJnZXQudmVsb2NpdHkueCkgPCB0aGlzLm1heF9zcGVlZFxuICAgICwgYXRfcmVzdCA9IHRhcmdldC5hdFJlc3RZKClcblxuICBpZighdGhpcy5fdGFyZ2V0KSByZXR1cm5cblxuICBpZihzdGF0ZS5mb3J3YXJkIHx8IHN0YXRlLmJhY2t3YXJkKSB7XG4gICAgdGhpcy56X2FjY2VsX3RpbWVyID0gbWF4KDAsIHRoaXMuel9hY2NlbF90aW1lciAtIGR0KVxuICB9XG4gIGlmKHN0YXRlLmJhY2t3YXJkKSB7XG4gICAgaWYodGFyZ2V0LnZlbG9jaXR5LnogPCB0aGlzLm1heF9zcGVlZClcbiAgICAgIHRhcmdldC52ZWxvY2l0eS56ID0gbWF4KG1pbih0aGlzLm1heF9zcGVlZCwgc3BlZWQgKiBkdCAqIHRoaXMuYWNjZWxlcmF0aW9uKHRoaXMuel9hY2NlbF90aW1lciwgdGhpcy5hY2NlbF9tYXhfdGltZXIpKSwgdGFyZ2V0LnZlbG9jaXR5LnopXG4gIH0gZWxzZSBpZihzdGF0ZS5mb3J3YXJkKSB7XG4gICAgaWYodGFyZ2V0LnZlbG9jaXR5LnogPiAtdGhpcy5tYXhfc3BlZWQpXG4gICAgICB0YXJnZXQudmVsb2NpdHkueiA9IG1pbihtYXgoLXRoaXMubWF4X3NwZWVkLCAtc3BlZWQgKiBkdCAqIHRoaXMuYWNjZWxlcmF0aW9uKHRoaXMuel9hY2NlbF90aW1lciwgdGhpcy5hY2NlbF9tYXhfdGltZXIpKSwgdGFyZ2V0LnZlbG9jaXR5LnopXG4gIH0gZWxzZSB7XG4gICAgdGhpcy56X2FjY2VsX3RpbWVyID0gdGhpcy5hY2NlbF9tYXhfdGltZXJcblxuICB9XG4gXG5cbiAgaWYoc3RhdGUubGVmdCB8fCBzdGF0ZS5yaWdodCkge1xuICAgIHRoaXMueF9hY2NlbF90aW1lciA9IG1heCgwLCB0aGlzLnhfYWNjZWxfdGltZXIgLSBkdClcbiAgfVxuXG4gIGlmKHN0YXRlLnJpZ2h0KSB7XG4gICAgaWYodGFyZ2V0LnZlbG9jaXR5LnggPCB0aGlzLm1heF9zcGVlZClcbiAgICAgIHRhcmdldC52ZWxvY2l0eS54ID0gbWF4KG1pbih0aGlzLm1heF9zcGVlZCwgc3BlZWQgKiBkdCAqIHRoaXMuYWNjZWxlcmF0aW9uKHRoaXMueF9hY2NlbF90aW1lciwgdGhpcy5hY2NlbF9tYXhfdGltZXIpKSwgdGFyZ2V0LnZlbG9jaXR5LngpXG4gIH0gZWxzZSBpZihzdGF0ZS5sZWZ0KSB7XG4gICAgaWYodGFyZ2V0LnZlbG9jaXR5LnggPiAtdGhpcy5tYXhfc3BlZWQpXG4gICAgICB0YXJnZXQudmVsb2NpdHkueCA9IG1pbihtYXgoLXRoaXMubWF4X3NwZWVkLCAtc3BlZWQgKiBkdCAqIHRoaXMuYWNjZWxlcmF0aW9uKHRoaXMueF9hY2NlbF90aW1lciwgdGhpcy5hY2NlbF9tYXhfdGltZXIpKSwgdGFyZ2V0LnZlbG9jaXR5LngpXG4gIH0gZWxzZSB7XG4gICAgdGhpcy54X2FjY2VsX3RpbWVyID0gdGhpcy5hY2NlbF9tYXhfdGltZXJcbiAgfVxuXG4gIGlmKHN0YXRlLmp1bXApIHtcbiAgICBpZighdGhpcy5qdW1waW5nICYmICFhdF9yZXN0KSB7XG4gICAgICAvLyB3ZSdyZSBmYWxsaW5nLCB3ZSBjYW4ndCBqdW1wXG4gICAgfSBlbHNlIGlmKGF0X3Jlc3QgPiAwKSB7XG4gICAgICAvLyB3ZSBoaXQgb3VyIGhlYWRcbiAgICAgIHRoaXMuanVtcGluZyA9IGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuanVtcGluZyA9IHRydWVcbiAgICAgIGlmKHRoaXMuanVtcF90aW1lciA+IDApIHtcbiAgICAgICAgdGFyZ2V0LnZlbG9jaXR5LnkgPSBtaW4odGFyZ2V0LnZlbG9jaXR5LnkgKyBqdW1wX3NwZWVkICogbWluKGR0LCB0aGlzLmp1bXBfdGltZXIpLCB0aGlzLmp1bXBfbWF4X3NwZWVkKVxuICAgICAgfVxuICAgICAgdGhpcy5qdW1wX3RpbWVyID0gbWF4KHRoaXMuanVtcF90aW1lciAtIGR0LCAwKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLmp1bXBpbmcgPSBmYWxzZVxuICB9XG4gIHRoaXMuanVtcF90aW1lciA9IGF0X3Jlc3QgPCAwID8gdGhpcy5qdW1wX21heF90aW1lciA6IHRoaXMuanVtcF90aW1lclxuXG4gIHZhciBjYW5fZmlyZSA9IHRydWVcblxuICBpZihzdGF0ZS5maXJlIHx8IHN0YXRlLmZpcmVhbHQpIHtcbiAgICBpZih0aGlzLmZpcmluZyAmJiB0aGlzLm5lZWRzX2Rpc2NyZXRlX2ZpcmUpIHtcbiAgICAgIHRoaXMuZmlyaW5nICs9IGR0XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCF0aGlzLmZpcmVfcmF0ZSB8fCBmbG9vcih0aGlzLmZpcmluZyAvIHRoaXMuZmlyZV9yYXRlKSAhPT0gZmxvb3IoKHRoaXMuZmlyaW5nICsgZHQpIC8gdGhpcy5maXJlX3JhdGUpKSB7XG4gICAgICAgIHRoaXMub25maXJlKHN0YXRlKVxuICAgICAgfVxuICAgICAgdGhpcy5maXJpbmcgKz0gZHRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maXJpbmcgPSAwXG4gIH1cblxuICB2YXIgeF9yb3RhdGlvbiA9IHRoaXMuc3RhdGUueF9yb3RhdGlvbl9hY2N1bSAqIHRoaXMucm90YXRpb25fc2NhbGVcbiAgICAsIHlfcm90YXRpb24gPSB0aGlzLnN0YXRlLnlfcm90YXRpb25fYWNjdW0gKiB0aGlzLnJvdGF0aW9uX3NjYWxlXG4gICAgLCB6X3JvdGF0aW9uID0gdGhpcy5zdGF0ZS56X3JvdGF0aW9uX2FjY3VtICogdGhpcy5yb3RhdGlvbl9zY2FsZVxuICAgICwgcGl0Y2hfdGFyZ2V0ID0gdGhpcy5fcGl0Y2hfdGFyZ2V0XG4gICAgLCB5YXdfdGFyZ2V0ID0gdGhpcy5feWF3X3RhcmdldFxuICAgICwgcm9sbF90YXJnZXQgPSB0aGlzLl9yb2xsX3RhcmdldFxuXG4gIHBpdGNoX3RhcmdldC5yb3RhdGlvbi54ID0gY2xhbXAocGl0Y2hfdGFyZ2V0LnJvdGF0aW9uLnggKyBjbGFtcCh4X3JvdGF0aW9uLCB0aGlzLnhfcm90YXRpb25fcGVyX21zKSwgdGhpcy54X3JvdGF0aW9uX2NsYW1wKVxuICB5YXdfdGFyZ2V0LnJvdGF0aW9uLnkgPSBjbGFtcCh5YXdfdGFyZ2V0LnJvdGF0aW9uLnkgKyBjbGFtcCh5X3JvdGF0aW9uLCB0aGlzLnlfcm90YXRpb25fcGVyX21zKSwgdGhpcy55X3JvdGF0aW9uX2NsYW1wKVxuICByb2xsX3RhcmdldC5yb3RhdGlvbi56ID0gY2xhbXAocm9sbF90YXJnZXQucm90YXRpb24ueiArIGNsYW1wKHpfcm90YXRpb24sIHRoaXMuel9yb3RhdGlvbl9wZXJfbXMpLCB0aGlzLnpfcm90YXRpb25fY2xhbXApXG5cbiAgaWYodGhpcy5saXN0ZW5lcnMoJ2RhdGEnKS5sZW5ndGgpIHtcbiAgICB0aGlzLmVtaXRVcGRhdGUoKVxuICB9XG5cbiAgdGhpcy5zdGF0ZS54X3JvdGF0aW9uX2FjY3VtID1cbiAgdGhpcy5zdGF0ZS55X3JvdGF0aW9uX2FjY3VtID1cbiAgdGhpcy5zdGF0ZS56X3JvdGF0aW9uX2FjY3VtID0gMFxufVxuXG5wcm90by53cml0ZSA9IGZ1bmN0aW9uKGNoYW5nZXMpIHtcbiAgZm9yKHZhciBrZXkgaW4gY2hhbmdlcykge1xuICAgIHRoaXMuc3RhdGVba2V5XSA9IGNoYW5nZXNba2V5XVxuICB9XG59XG5cbnByb3RvLmVuZCA9IGZ1bmN0aW9uKGRlbHRhcykge1xuICBpZihkZWx0YXMpIHtcbiAgICB0aGlzLndyaXRlKGRlbHRhcylcbiAgfVxufVxuXG5wcm90by5jcmVhdGVXcml0ZVJvdGF0aW9uU3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGVcbiAgICAsIHN0cmVhbSA9IG5ldyBTdHJlYW1cblxuICBzdGF0ZS54X3JvdGF0aW9uX2FjY3VtID1cbiAgc3RhdGUueV9yb3RhdGlvbl9hY2N1bSA9XG4gIHN0YXRlLnpfcm90YXRpb25fYWNjdW0gPSAwXG5cbiAgc3RyZWFtLndyaXRhYmxlID0gdHJ1ZVxuICBzdHJlYW0ud3JpdGUgPSB3cml0ZVxuICBzdHJlYW0uZW5kID0gZW5kXG5cbiAgcmV0dXJuIHN0cmVhbVxuXG4gIGZ1bmN0aW9uIHdyaXRlKGNoYW5nZXMpIHtcbiAgICBzdGF0ZS54X3JvdGF0aW9uX2FjY3VtIC09IGNoYW5nZXMuZHkgfHwgMFxuICAgIHN0YXRlLnlfcm90YXRpb25fYWNjdW0gLT0gY2hhbmdlcy5keCB8fCAwXG4gICAgc3RhdGUuel9yb3RhdGlvbl9hY2N1bSArPSBjaGFuZ2VzLmR6IHx8IDBcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZChkZWx0YXMpIHtcbiAgICBpZihkZWx0YXMpIHtcbiAgICAgIHN0cmVhbS53cml0ZShkZWx0YXMpXG4gICAgfVxuICB9XG59XG5cbnByb3RvLmVtaXRVcGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMucXVldWUoe1xuICAgICAgeF9yb3RhdGlvbl9hY2N1bTogdGhpcy5zdGF0ZS54X3JvdGF0aW9uX2FjY3VtXG4gICAgLCB5X3JvdGF0aW9uX2FjY3VtOiB0aGlzLnN0YXRlLnlfcm90YXRpb25fYWNjdW1cbiAgICAsIHpfcm90YXRpb25fYWNjdW06IHRoaXMuc3RhdGUuel9yb3RhdGlvbl9hY2N1bVxuICAgICwgZm9yd2FyZDogdGhpcy5zdGF0ZS5mb3J3YXJkXG4gICAgLCBiYWNrd2FyZDogdGhpcy5zdGF0ZS5iYWNrd2FyZFxuICAgICwgbGVmdDogdGhpcy5zdGF0ZS5sZWZ0XG4gICAgLCByaWdodDogdGhpcy5zdGF0ZS5yaWdodFxuICAgICwgZmlyZTogdGhpcy5zdGF0ZS5maXJlXG4gICAgLCBmaXJlYWx0OiB0aGlzLnN0YXRlLmZpcmVhbHRcbiAgICAsIGp1bXA6IHRoaXMuc3RhdGUuanVtcFxuICB9KVxufVxuXG5wcm90by5kcmFpbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYnVmID0gdGhpcy5idWZmZXJcbiAgICAsIGRhdGFcblxuICB3aGlsZShidWYubGVuZ3RoICYmICF0aGlzLnBhdXNlZCkge1xuICAgIGRhdGEgPSBidWYuc2hpZnQoKVxuICAgIGlmKG51bGwgPT09IGRhdGEpIHtcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2VuZCcpXG4gICAgfVxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpXG4gIH1cbn1cblxucHJvdG8ucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucGF1c2VkID0gZmFsc2VcbiAgdGhpcy5kcmFpbigpXG5cbiAgaWYoIXRoaXMucGF1c2VkKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxucHJvdG8ucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgaWYodGhpcy5wYXVzZWQpIHJldHVyblxuXG4gIHRoaXMucGF1c2VkID0gdHJ1ZVxuICB0aGlzLmVtaXQoJ3BhdXNlJylcbiAgcmV0dXJuIHRoaXNcbn1cblxucHJvdG8ucXVldWUgPSBmdW5jdGlvbihkYXRhKSB7XG4gIHRoaXMuYnVmZmVyLnB1c2goZGF0YSlcbiAgdGhpcy5kcmFpbigpXG4gIHJldHVybiB0aGlzXG59XG5cbnByb3RvLmFjY2VsZXJhdGlvbiA9IGZ1bmN0aW9uKGN1cnJlbnQsIG1heCkge1xuICAvLyBtYXggLT4gMFxuICB2YXIgcGN0ID0gKG1heCAtIGN1cnJlbnQpIC8gbWF4XG4gIHJldHVybiBzaW4oUEkvMipwY3QpXG59XG5cbnByb3RvLnRhcmdldCA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICBpZih0YXJnZXQpIHtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXRcbiAgICB0aGlzLl95YXdfdGFyZ2V0ID0gdGFyZ2V0LnlhdyB8fCB0YXJnZXRcbiAgICB0aGlzLl9waXRjaF90YXJnZXQgPSB0YXJnZXQucGl0Y2ggfHwgdGFyZ2V0XG4gICAgdGhpcy5fcm9sbF90YXJnZXQgPSB0YXJnZXQucm9sbCB8fCB0YXJnZXRcbiAgfVxuICByZXR1cm4gdGhpcy5fdGFyZ2V0XG59XG5cbnByb3RvLm9uZmlyZSA9IGZ1bmN0aW9uKF8pIHtcblxufVxuXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgdG8pIHtcbiAgcmV0dXJuIGlzRmluaXRlKHRvKSA/IG1heChtaW4odmFsdWUsIHRvKSwgLXRvKSA6IHZhbHVlXG59XG4iLCJ2YXIgVEhSRUUgPSByZXF1aXJlKCd0aHJlZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgbWVzaGVyLCBzY2FsZUZhY3RvciwgdGhyZWUpIHtcbiAgcmV0dXJuIG5ldyBNZXNoKGRhdGEsIG1lc2hlciwgc2NhbGVGYWN0b3IsIHRocmVlKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5NZXNoID0gTWVzaFxuXG5mdW5jdGlvbiBNZXNoKGRhdGEsIG1lc2hlciwgc2NhbGVGYWN0b3IsIHRocmVlKSB7XG4gIHRoaXMuVEhSRUUgPSB0aHJlZSB8fCBUSFJFRVxuICB0aGlzLmRhdGEgPSBkYXRhXG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkgPSBuZXcgdGhpcy5USFJFRS5HZW9tZXRyeSgpXG4gIHRoaXMuc2NhbGUgPSBzY2FsZUZhY3RvciB8fCBuZXcgdGhpcy5USFJFRS5WZWN0b3IzKDEwLCAxMCwgMTApXG4gIFxuICB2YXIgcmVzdWx0ID0gbWVzaGVyKCBkYXRhLnZveGVscywgZGF0YS5kaW1zIClcbiAgdGhpcy5tZXNoZWQgPSByZXN1bHRcblxuICBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggPSAwXG4gIGdlb21ldHJ5LmZhY2VzLmxlbmd0aCA9IDBcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC52ZXJ0aWNlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBxID0gcmVzdWx0LnZlcnRpY2VzW2ldXG4gICAgZ2VvbWV0cnkudmVydGljZXMucHVzaChuZXcgdGhpcy5USFJFRS5WZWN0b3IzKHFbMF0sIHFbMV0sIHFbMl0pKVxuICB9IFxuICBcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHQuZmFjZXMubGVuZ3RoOyArK2kpIHtcbiAgICBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWzBdLnB1c2godGhpcy5mYWNlVmVydGV4VXYoaSkpXG4gICAgXG4gICAgdmFyIHEgPSByZXN1bHQuZmFjZXNbaV1cbiAgICBpZiAocS5sZW5ndGggPT09IDUpIHtcbiAgICAgIHZhciBmID0gbmV3IHRoaXMuVEhSRUUuRmFjZTQocVswXSwgcVsxXSwgcVsyXSwgcVszXSlcbiAgICAgIGYuY29sb3IgPSBuZXcgdGhpcy5USFJFRS5Db2xvcihxWzRdKVxuICAgICAgZ2VvbWV0cnkuZmFjZXMucHVzaChmKVxuICAgIH0gZWxzZSBpZiAocS5sZW5ndGggPT0gNCkge1xuICAgICAgdmFyIGYgPSBuZXcgdGhpcy5USFJFRS5GYWNlMyhxWzBdLCBxWzFdLCBxWzJdKVxuICAgICAgZi5jb2xvciA9IG5ldyB0aGlzLlRIUkVFLkNvbG9yKHFbM10pXG4gICAgICBnZW9tZXRyeS5mYWNlcy5wdXNoKGYpXG4gICAgfVxuICB9XG4gIFxuICBnZW9tZXRyeS5jb21wdXRlRmFjZU5vcm1hbHMoKVxuXG4gIC8vIGNvbXB1dGUgdmVydGV4IGNvbG9ycyBmb3IgYW1iaWVudCBvY2NsdXNpb25cbiAgdmFyIGxpZ2h0ID0gbmV3IFRIUkVFLkNvbG9yKDB4ZmZmZmZmKVxuICB2YXIgc2hhZG93ID0gbmV3IFRIUkVFLkNvbG9yKDB4NTA1MDUwKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGZhY2UgPSBnZW9tZXRyeS5mYWNlc1tpXVxuICAgIC8vIGZhY2luZyB1cFxuICAgIGlmIChmYWNlLm5vcm1hbC55ID09PSAxKSAgICAgICBmYWNlLnZlcnRleENvbG9ycyA9IFtsaWdodCwgbGlnaHQsIGxpZ2h0LCBsaWdodF1cbiAgICAvLyBmYWNpbmcgZG93blxuICAgIGVsc2UgaWYgKGZhY2Uubm9ybWFsLnkgPT09IC0xKSBmYWNlLnZlcnRleENvbG9ycyA9IFtzaGFkb3csIHNoYWRvdywgc2hhZG93LCBzaGFkb3ddXG4gICAgLy8gZmFjaW5nIHJpZ2h0XG4gICAgZWxzZSBpZiAoZmFjZS5ub3JtYWwueCA9PT0gMSkgIGZhY2UudmVydGV4Q29sb3JzID0gW3NoYWRvdywgbGlnaHQsIGxpZ2h0LCBzaGFkb3ddXG4gICAgLy8gZmFjaW5nIGxlZnRcbiAgICBlbHNlIGlmIChmYWNlLm5vcm1hbC54ID09PSAtMSkgZmFjZS52ZXJ0ZXhDb2xvcnMgPSBbc2hhZG93LCBzaGFkb3csIGxpZ2h0LCBsaWdodF1cbiAgICAvLyBmYWNpbmcgYmFja3dhcmRcbiAgICBlbHNlIGlmIChmYWNlLm5vcm1hbC56ID09PSAxKSAgZmFjZS52ZXJ0ZXhDb2xvcnMgPSBbc2hhZG93LCBzaGFkb3csIGxpZ2h0LCBsaWdodF1cbiAgICAvLyBmYWNpbmcgZm9yd2FyZFxuICAgIGVsc2UgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWNlLnZlcnRleENvbG9ycyA9IFtzaGFkb3csIGxpZ2h0LCBsaWdodCwgc2hhZG93XVxuICB9XG5cbiAgZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID0gdHJ1ZVxuICBnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPSB0cnVlXG4gIGdlb21ldHJ5Lm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZVxuXG4gIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpXG4gIGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpXG5cbn1cblxuTWVzaC5wcm90b3R5cGUuY3JlYXRlV2lyZU1lc2ggPSBmdW5jdGlvbihoZXhDb2xvcikgeyAgICBcbiAgdmFyIHdpcmVNYXRlcmlhbCA9IG5ldyB0aGlzLlRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICBjb2xvciA6IGhleENvbG9yIHx8IDB4ZmZmZmZmLFxuICAgIHdpcmVmcmFtZSA6IHRydWVcbiAgfSlcbiAgd2lyZU1lc2ggPSBuZXcgVEhSRUUuTWVzaCh0aGlzLmdlb21ldHJ5LCB3aXJlTWF0ZXJpYWwpXG4gIHdpcmVNZXNoLnNjYWxlID0gdGhpcy5zY2FsZVxuICB3aXJlTWVzaC5kb3VibGVTaWRlZCA9IHRydWVcbiAgdGhpcy53aXJlTWVzaCA9IHdpcmVNZXNoXG4gIHJldHVybiB3aXJlTWVzaFxufVxuXG5NZXNoLnByb3RvdHlwZS5jcmVhdGVTdXJmYWNlTWVzaCA9IGZ1bmN0aW9uKG1hdGVyaWFsKSB7XG4gIG1hdGVyaWFsID0gbWF0ZXJpYWwgfHwgbmV3IHRoaXMuVEhSRUUuTWVzaE5vcm1hbE1hdGVyaWFsKClcbiAgdmFyIHN1cmZhY2VNZXNoICA9IG5ldyB0aGlzLlRIUkVFLk1lc2goIHRoaXMuZ2VvbWV0cnksIG1hdGVyaWFsIClcbiAgc3VyZmFjZU1lc2guc2NhbGUgPSB0aGlzLnNjYWxlXG4gIHN1cmZhY2VNZXNoLmRvdWJsZVNpZGVkID0gZmFsc2VcbiAgdGhpcy5zdXJmYWNlTWVzaCA9IHN1cmZhY2VNZXNoXG4gIHJldHVybiBzdXJmYWNlTWVzaFxufVxuXG5NZXNoLnByb3RvdHlwZS5hZGRUb1NjZW5lID0gZnVuY3Rpb24oc2NlbmUpIHtcbiAgaWYgKHRoaXMud2lyZU1lc2gpIHNjZW5lLmFkZCggdGhpcy53aXJlTWVzaCApXG4gIGlmICh0aGlzLnN1cmZhY2VNZXNoKSBzY2VuZS5hZGQoIHRoaXMuc3VyZmFjZU1lc2ggKVxufVxuXG5NZXNoLnByb3RvdHlwZS5zZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgaWYgKHRoaXMud2lyZU1lc2gpIHRoaXMud2lyZU1lc2gucG9zaXRpb24gPSBuZXcgdGhpcy5USFJFRS5WZWN0b3IzKHgsIHksIHopXG4gIGlmICh0aGlzLnN1cmZhY2VNZXNoKSB0aGlzLnN1cmZhY2VNZXNoLnBvc2l0aW9uID0gbmV3IHRoaXMuVEhSRUUuVmVjdG9yMyh4LCB5LCB6KVxufVxuXG5NZXNoLnByb3RvdHlwZS5mYWNlVmVydGV4VXYgPSBmdW5jdGlvbihpKSB7XG4gIHZhciB2cyA9IFtcbiAgICB0aGlzLm1lc2hlZC52ZXJ0aWNlc1tpKjQrMF0sXG4gICAgdGhpcy5tZXNoZWQudmVydGljZXNbaSo0KzFdLFxuICAgIHRoaXMubWVzaGVkLnZlcnRpY2VzW2kqNCsyXSxcbiAgICB0aGlzLm1lc2hlZC52ZXJ0aWNlc1tpKjQrM11cbiAgXVxuICB2YXIgc3BhbnMgPSB7XG4gICAgeDA6IHZzWzBdWzBdIC0gdnNbMV1bMF0sXG4gICAgeDE6IHZzWzFdWzBdIC0gdnNbMl1bMF0sXG4gICAgeTA6IHZzWzBdWzFdIC0gdnNbMV1bMV0sXG4gICAgeTE6IHZzWzFdWzFdIC0gdnNbMl1bMV0sXG4gICAgejA6IHZzWzBdWzJdIC0gdnNbMV1bMl0sXG4gICAgejE6IHZzWzFdWzJdIC0gdnNbMl1bMl1cbiAgfVxuICB2YXIgc2l6ZSA9IHtcbiAgICB4OiBNYXRoLm1heChNYXRoLmFicyhzcGFucy54MCksIE1hdGguYWJzKHNwYW5zLngxKSksXG4gICAgeTogTWF0aC5tYXgoTWF0aC5hYnMoc3BhbnMueTApLCBNYXRoLmFicyhzcGFucy55MSkpLFxuICAgIHo6IE1hdGgubWF4KE1hdGguYWJzKHNwYW5zLnowKSwgTWF0aC5hYnMoc3BhbnMuejEpKVxuICB9XG4gIGlmIChzaXplLnggPT09IDApIHtcbiAgICBpZiAoc3BhbnMueTAgPiBzcGFucy55MSkge1xuICAgICAgdmFyIHdpZHRoID0gc2l6ZS55XG4gICAgICB2YXIgaGVpZ2h0ID0gc2l6ZS56XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHdpZHRoID0gc2l6ZS56XG4gICAgICB2YXIgaGVpZ2h0ID0gc2l6ZS55XG4gICAgfVxuICB9XG4gIGlmIChzaXplLnkgPT09IDApIHtcbiAgICBpZiAoc3BhbnMueDAgPiBzcGFucy54MSkge1xuICAgICAgdmFyIHdpZHRoID0gc2l6ZS54XG4gICAgICB2YXIgaGVpZ2h0ID0gc2l6ZS56XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHdpZHRoID0gc2l6ZS56XG4gICAgICB2YXIgaGVpZ2h0ID0gc2l6ZS54XG4gICAgfVxuICB9XG4gIGlmIChzaXplLnogPT09IDApIHtcbiAgICBpZiAoc3BhbnMueDAgPiBzcGFucy54MSkge1xuICAgICAgdmFyIHdpZHRoID0gc2l6ZS54XG4gICAgICB2YXIgaGVpZ2h0ID0gc2l6ZS55XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHdpZHRoID0gc2l6ZS55XG4gICAgICB2YXIgaGVpZ2h0ID0gc2l6ZS54XG4gICAgfVxuICB9XG4gIGlmICgoc2l6ZS56ID09PSAwICYmIHNwYW5zLngwIDwgc3BhbnMueDEpIHx8IChzaXplLnggPT09IDAgJiYgc3BhbnMueTAgPiBzcGFucy55MSkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IHRoaXMuVEhSRUUuVmVjdG9yMihoZWlnaHQsIDApLFxuICAgICAgbmV3IHRoaXMuVEhSRUUuVmVjdG9yMigwLCAwKSxcbiAgICAgIG5ldyB0aGlzLlRIUkVFLlZlY3RvcjIoMCwgd2lkdGgpLFxuICAgICAgbmV3IHRoaXMuVEhSRUUuVmVjdG9yMihoZWlnaHQsIHdpZHRoKVxuICAgIF1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW1xuICAgICAgbmV3IHRoaXMuVEhSRUUuVmVjdG9yMigwLCAwKSxcbiAgICAgIG5ldyB0aGlzLlRIUkVFLlZlY3RvcjIoMCwgaGVpZ2h0KSxcbiAgICAgIG5ldyB0aGlzLlRIUkVFLlZlY3RvcjIod2lkdGgsIGhlaWdodCksXG4gICAgICBuZXcgdGhpcy5USFJFRS5WZWN0b3IyKHdpZHRoLCAwKVxuICAgIF1cbiAgfVxufVxuO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBwaHlzaWNhbFxuXG52YXIgYWFiYiA9IHJlcXVpcmUoJ2FhYmItM2QnKVxuICAsIFRIUkVFID0gcmVxdWlyZSgndGhyZWUnKVxuXG5mdW5jdGlvbiBwaHlzaWNhbChhdmF0YXIsIGNvbGxpZGFibGVzLCBkaW1lbnNpb25zLCB0ZXJtaW5hbCkge1xuICByZXR1cm4gbmV3IFBoeXNpY2FsKGF2YXRhciwgY29sbGlkYWJsZXMsIGRpbWVuc2lvbnMsIHRlcm1pbmFsKVxufVxuXG5mdW5jdGlvbiBQaHlzaWNhbChhdmF0YXIsIGNvbGxpZGFibGVzLCBkaW1lbnNpb25zLCB0ZXJtaW5hbCkge1xuICB0aGlzLmF2YXRhciA9IGF2YXRhclxuICB0aGlzLnRlcm1pbmFsID0gdGVybWluYWwgfHwgbmV3IFRIUkVFLlZlY3RvcjMoMC45LCAwLjEsIDAuOSlcbiAgdGhpcy5kaW1lbnNpb25zID0gZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMgfHwgWzEsIDEsIDFdXG4gIHRoaXMuX2FhYmIgPSBhYWJiKFswLCAwLCAwXSwgZGltZW5zaW9ucylcbiAgdGhpcy5yZXN0aW5nID0ge3g6IGZhbHNlLCB5OiBmYWxzZSwgejogZmFsc2V9XG4gIHRoaXMuY29sbGlkYWJsZXMgPSBjb2xsaWRhYmxlc1xuICB0aGlzLmZyaWN0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMSwgMSwgMSlcblxuICB0aGlzLnJvdGF0aW9uID0gdGhpcy5hdmF0YXIucm90YXRpb25cbiAgdGhpcy5kZWZhdWx0X2ZyaWN0aW9uID0gMVxuXG4gIC8vIGRlZmF1bHQgeWF3L3BpdGNoL3JvbGwgY29udHJvbHMgdG8gdGhlIGF2YXRhclxuICB0aGlzLnlhdyA9XG4gIHRoaXMucGl0Y2ggPVxuICB0aGlzLnJvbGwgPSBhdmF0YXJcblxuICB0aGlzLmZvcmNlcyA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApXG4gIHRoaXMuYXR0cmFjdG9ycyA9IFtdXG4gIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMClcbiAgdGhpcy52ZWxvY2l0eSA9IG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApXG59XG5cbnZhciBjb25zID0gUGh5c2ljYWxcbiAgLCBwcm90byA9IGNvbnMucHJvdG90eXBlXG4gICwgYXhlcyA9IFsneCcsICd5JywgJ3onXVxuICAsIGFicyA9IE1hdGguYWJzXG5cbi8vIG1ha2UgdGhlc2UgKm9uY2UqLCBzbyB3ZSdyZSBub3QgZ2VuZXJhdGluZ1xuLy8gZ2FyYmFnZSBmb3IgZXZlcnkgb2JqZWN0IGluIHRoZSBnYW1lLlxudmFyIFdPUkxEX0RFU0lSRUQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKVxuICAsIERFU0lSRUQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKVxuICAsIFNUQVJUID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMClcbiAgLCBFTkQgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKVxuICAsIERJUkVDVElPTiA9IG5ldyBUSFJFRS5WZWN0b3IzKClcbiAgLCBMT0NBTF9BVFRSQUNUT1IgPSBuZXcgVEhSRUUuVmVjdG9yMygpXG4gICwgVE9UQUxfRk9SQ0VTID0gbmV3IFRIUkVFLlZlY3RvcjMoKVxuXG5wcm90by5hcHBseVdvcmxkQWNjZWxlcmF0aW9uID0gYXBwbHlUbygnYWNjZWxlcmF0aW9uJylcbnByb3RvLmFwcGx5V29ybGRWZWxvY2l0eSA9IGFwcGx5VG8oJ3ZlbG9jaXR5JylcblxuZnVuY3Rpb24gYXBwbHlUbyh3aGljaCkge1xuICByZXR1cm4gZnVuY3Rpb24od29ybGQpIHtcbiAgICB2YXIgbG9jYWwgPSB0aGlzLmF2YXRhci53b3JsZFRvTG9jYWwod29ybGQpXG4gICAgdGhpc1t3aGljaF0ueCArPSBsb2NhbC54XG4gICAgdGhpc1t3aGljaF0ueSArPSBsb2NhbC55XG4gICAgdGhpc1t3aGljaF0ueiArPSBsb2NhbC56XG4gIH1cbn1cblxucHJvdG8udGljayA9IGZ1bmN0aW9uKGR0KSB7XG4gIHZhciBmb3JjZXMgPSB0aGlzLmZvcmNlc1xuICAgICwgYWNjZWxlcmF0aW9uID0gdGhpcy5hY2NlbGVyYXRpb25cbiAgICAsIHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eVxuICAgICwgdGVybWluYWwgPSB0aGlzLnRlcm1pbmFsXG4gICAgLCBmcmljdGlvbiA9IHRoaXMuZnJpY3Rpb25cbiAgICAsIGRlc2lyZWQgPSBERVNJUkVEXG4gICAgLCB3b3JsZF9kZXNpcmVkID0gV09STERfREVTSVJFRFxuICAgICwgYmJveFxuICAgICwgcGNzXG4gIFRPVEFMX0ZPUkNFUy5tdWx0aXBseVNjYWxhcigwKVxuXG4gIGRlc2lyZWQueCA9XG4gIGRlc2lyZWQueSA9XG4gIGRlc2lyZWQueiA9XG4gIHdvcmxkX2Rlc2lyZWQueCA9XG4gIHdvcmxkX2Rlc2lyZWQueSA9XG4gIHdvcmxkX2Rlc2lyZWQueiA9IDBcblxuICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5hdHRyYWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpc3RhbmNlX2ZhY3RvciA9IHRoaXMuYXZhdGFyLnBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKHRoaXMuYXR0cmFjdG9yc1tpXSlcbiAgICBMT0NBTF9BVFRSQUNUT1IuY29weSh0aGlzLmF0dHJhY3RvcnNbaV0pXG4gICAgTE9DQUxfQVRUUkFDVE9SID0gdGhpcy5hdmF0YXIud29ybGRUb0xvY2FsKExPQ0FMX0FUVFJBQ1RPUilcblxuICAgIERJUkVDVElPTi5zdWIoTE9DQUxfQVRUUkFDVE9SLCB0aGlzLmF2YXRhci5wb3NpdGlvbilcblxuICAgIERJUkVDVElPTi5kaXZpZGVTY2FsYXIoRElSRUNUSU9OLmxlbmd0aCgpICogZGlzdGFuY2VfZmFjdG9yKVxuICAgIERJUkVDVElPTi5tdWx0aXBseVNjYWxhcih0aGlzLmF0dHJhY3RvcnNbaV0ubWFzcylcblxuICAgIFRPVEFMX0ZPUkNFUy5hZGRTZWxmKERJUkVDVElPTilcbiAgfVxuICBcbiAgaWYoIXRoaXMucmVzdGluZy54KSB7XG4gICAgYWNjZWxlcmF0aW9uLnggLz0gOCAqIGR0XG4gICAgYWNjZWxlcmF0aW9uLnggKz0gVE9UQUxfRk9SQ0VTLnggKiBkdFxuICAgIGFjY2VsZXJhdGlvbi54ICs9IGZvcmNlcy54ICogZHRcblxuICAgIHZlbG9jaXR5LnggKz0gYWNjZWxlcmF0aW9uLnggKiBkdFxuICAgIHZlbG9jaXR5LnggKj0gZnJpY3Rpb24ueFxuXG4gICAgaWYoYWJzKHZlbG9jaXR5LngpIDwgdGVybWluYWwueCkge1xuICAgICAgZGVzaXJlZC54ID0gKHZlbG9jaXR5LnggKiBkdClcbiAgICB9IGVsc2UgaWYodmVsb2NpdHkueCAhPT0gMCkge1xuICAgICAgZGVzaXJlZC54ID0gKHZlbG9jaXR5LnggLyBhYnModmVsb2NpdHkueCkpICogdGVybWluYWwueFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhY2NlbGVyYXRpb24ueCA9IHZlbG9jaXR5LnggPSAwXG4gIH1cbiAgaWYoIXRoaXMucmVzdGluZy55KSB7XG4gICAgYWNjZWxlcmF0aW9uLnkgLz0gOCAqIGR0XG4gICAgYWNjZWxlcmF0aW9uLnkgKz0gVE9UQUxfRk9SQ0VTLnkgKiBkdFxuICAgIGFjY2VsZXJhdGlvbi55ICs9IGZvcmNlcy55ICogZHRcblxuICAgIHZlbG9jaXR5LnkgKz0gYWNjZWxlcmF0aW9uLnkgKiBkdFxuICAgIHZlbG9jaXR5LnkgKj0gZnJpY3Rpb24ueVxuXG4gICAgaWYoYWJzKHZlbG9jaXR5LnkpIDwgdGVybWluYWwueSkge1xuICAgICAgZGVzaXJlZC55ID0gKHZlbG9jaXR5LnkgKiBkdClcbiAgICB9IGVsc2UgaWYodmVsb2NpdHkueSAhPT0gMCkge1xuICAgICAgZGVzaXJlZC55ID0gKHZlbG9jaXR5LnkgLyBhYnModmVsb2NpdHkueSkpICogdGVybWluYWwueVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhY2NlbGVyYXRpb24ueSA9IHZlbG9jaXR5LnkgPSAwXG4gIH1cbiAgaWYoIXRoaXMucmVzdGluZy56KSB7XG4gICAgYWNjZWxlcmF0aW9uLnogLz0gOCAqIGR0XG4gICAgYWNjZWxlcmF0aW9uLnogKz0gVE9UQUxfRk9SQ0VTLnogKiBkdFxuICAgIGFjY2VsZXJhdGlvbi56ICs9IGZvcmNlcy56ICogZHRcblxuICAgIHZlbG9jaXR5LnogKz0gYWNjZWxlcmF0aW9uLnogKiBkdFxuICAgIHZlbG9jaXR5LnogKj0gZnJpY3Rpb24uelxuXG4gICAgaWYoYWJzKHZlbG9jaXR5LnopIDwgdGVybWluYWwueikge1xuICAgICAgZGVzaXJlZC56ID0gKHZlbG9jaXR5LnogKiBkdClcbiAgICB9IGVsc2UgaWYodmVsb2NpdHkueiAhPT0gMCkge1xuICAgICAgZGVzaXJlZC56ID0gKHZlbG9jaXR5LnogLyBhYnModmVsb2NpdHkueikpICogdGVybWluYWwuelxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhY2NlbGVyYXRpb24ueiA9IHZlbG9jaXR5LnogPSAwXG4gIH1cbiAgXG4gIFNUQVJULmNvcHkodGhpcy5hdmF0YXIucG9zaXRpb24pXG4gIHRoaXMuYXZhdGFyLnRyYW5zbGF0ZVgoZGVzaXJlZC54KVxuICB0aGlzLmF2YXRhci50cmFuc2xhdGVZKGRlc2lyZWQueSlcbiAgdGhpcy5hdmF0YXIudHJhbnNsYXRlWihkZXNpcmVkLnopXG4gIEVORC5jb3B5KHRoaXMuYXZhdGFyLnBvc2l0aW9uKVxuICB0aGlzLmF2YXRhci5wb3NpdGlvbi5jb3B5KFNUQVJUKVxuICB3b3JsZF9kZXNpcmVkLnggPSBFTkQueCAtIFNUQVJULnhcbiAgd29ybGRfZGVzaXJlZC55ID0gRU5ELnkgLSBTVEFSVC55XG4gIHdvcmxkX2Rlc2lyZWQueiA9IEVORC56IC0gU1RBUlQuelxuICB0aGlzLmZyaWN0aW9uLnggPVxuICB0aGlzLmZyaWN0aW9uLnkgPVxuICB0aGlzLmZyaWN0aW9uLnogPSB0aGlzLmRlZmF1bHRfZnJpY3Rpb25cblxuICAvLyBydW4gY29sbGlzaW9uc1xuICB0aGlzLnJlc3RpbmcueCA9XG4gIHRoaXMucmVzdGluZy55ID1cbiAgdGhpcy5yZXN0aW5nLnogPSBmYWxzZVxuXG4gIGJib3ggPSB0aGlzLmFhYmIoKVxuICBwY3MgPSB0aGlzLmNvbGxpZGFibGVzXG5cbiAgZm9yKHZhciBpID0gMCwgbGVuID0gcGNzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYocGNzW2ldICE9PSB0aGlzKSB7XG4gICAgICBwY3NbaV0uY29sbGlkZSh0aGlzLCBiYm94LCB3b3JsZF9kZXNpcmVkLCB0aGlzLnJlc3RpbmcpXG4gICAgfVxuICB9XG5cbiAgLy8gYXBwbHkgdHJhbnNsYXRpb25cbiAgdGhpcy5hdmF0YXIucG9zaXRpb24ueCArPSB3b3JsZF9kZXNpcmVkLnhcbiAgdGhpcy5hdmF0YXIucG9zaXRpb24ueSArPSB3b3JsZF9kZXNpcmVkLnlcbiAgdGhpcy5hdmF0YXIucG9zaXRpb24ueiArPSB3b3JsZF9kZXNpcmVkLnpcbn1cblxucHJvdG8uc3ViamVjdFRvID0gZnVuY3Rpb24oZm9yY2UpIHtcbiAgdGhpcy5mb3JjZXMueCArPSBmb3JjZVswXVxuICB0aGlzLmZvcmNlcy55ICs9IGZvcmNlWzFdXG4gIHRoaXMuZm9yY2VzLnogKz0gZm9yY2VbMl1cbiAgcmV0dXJuIHRoaXNcbn1cblxucHJvdG8ucmVtb3ZlRm9yY2UgPSBmdW5jdGlvbihmb3JjZSkge1xuICB0aGlzLmZvcmNlcy54IC09IGZvcmNlWzBdXG4gIHRoaXMuZm9yY2VzLnkgLT0gZm9yY2VbMV1cbiAgdGhpcy5mb3JjZXMueiAtPSBmb3JjZVsyXVxuICByZXR1cm4gdGhpc1xufVxuXG5wcm90by5hdHRyYWN0VG8gPSBmdW5jdGlvbih2ZWN0b3IsIG1hc3MpIHtcbiAgdmVjdG9yLm1hc3MgPSBtYXNzXG4gIHRoaXMuYXR0cmFjdG9ycy5wdXNoKHZlY3Rvcilcbn1cblxucHJvdG8uYWFiYiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcG9zID0gdGhpcy5hdmF0YXIucG9zaXRpb25cbiAgdmFyIGQgPSB0aGlzLmRpbWVuc2lvbnNcbiAgcmV0dXJuIGFhYmIoXG4gICAgW3Bvcy54IC0gKGRbMF0vMiksIHBvcy55LCBwb3MueiAtIChkWzJdLzIpXSxcbiAgICB0aGlzLmRpbWVuc2lvbnNcbiAgKVxufVxuXG4vLyBubyBvYmplY3QgLT4gb2JqZWN0IGNvbGxpc2lvbnMgZm9yIG5vdywgdGhhbmtzXG5wcm90by5jb2xsaWRlID0gZnVuY3Rpb24ob3RoZXIsIGJib3gsIHdvcmxkX3ZlYywgcmVzdGluZykge1xuICByZXR1cm5cbn1cblxucHJvdG8uYXRSZXN0WCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZXN0aW5nLnhcbn1cblxucHJvdG8uYXRSZXN0WSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZXN0aW5nLnlcbn1cblxucHJvdG8uYXRSZXN0WiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5yZXN0aW5nLnpcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIHRyYWNlUmF5X2ltcGwoXG4gIHZveGVscyxcbiAgcHgsIHB5LCBweixcbiAgZHgsIGR5LCBkeixcbiAgbWF4X2QsXG4gIGhpdF9wb3MsXG4gIGhpdF9ub3JtLFxuICBFUFNJTE9OKSB7XG4gIHZhciB0ID0gMC4wXG4gICAgLCBueD0wLCBueT0wLCBuej0wXG4gICAgLCBpeCwgaXksIGl6XG4gICAgLCBmeCwgZnksIGZ6XG4gICAgLCBveCwgb3ksIG96XG4gICAgLCBleCwgZXksIGV6XG4gICAgLCBiLCBzdGVwLCBtaW5fc3RlcFxuICAgICwgZmxvb3IgPSBNYXRoLmZsb29yXG4gIC8vU3RlcCBibG9jay1ieS1ibG9jayBhbG9uZyByYXlcbiAgd2hpbGUodCA8PSBtYXhfZCkge1xuICAgIG94ID0gcHggKyB0ICogZHhcbiAgICBveSA9IHB5ICsgdCAqIGR5XG4gICAgb3ogPSBweiArIHQgKiBkelxuICAgIGl4ID0gZmxvb3Iob3gpfDBcbiAgICBpeSA9IGZsb29yKG95KXwwXG4gICAgaXogPSBmbG9vcihveil8MFxuICAgIGZ4ID0gb3ggLSBpeFxuICAgIGZ5ID0gb3kgLSBpeVxuICAgIGZ6ID0gb3ogLSBpelxuICAgIGIgPSB2b3hlbHMuZ2V0QmxvY2soaXgsIGl5LCBpeilcbiAgICBpZihiKSB7XG4gICAgICBpZihoaXRfcG9zKSB7XG4gICAgICAgIC8vQ2xhbXAgdG8gZmFjZSBvbiBoaXRcbiAgICAgICAgaGl0X3Bvc1swXSA9IGZ4IDwgRVBTSUxPTiA/ICtpeCA6IChmeCA+IDEuMC1FUFNJTE9OID8gaXgrMS4wLUVQU0lMT04gOiBveClcbiAgICAgICAgaGl0X3Bvc1sxXSA9IGZ5IDwgRVBTSUxPTiA/ICtpeSA6IChmeSA+IDEuMC1FUFNJTE9OID8gaXkrMS4wLUVQU0lMT04gOiBveSlcbiAgICAgICAgaGl0X3Bvc1syXSA9IGZ6IDwgRVBTSUxPTiA/ICtpeiA6IChmeiA+IDEuMC1FUFNJTE9OID8gaXorMS4wLUVQU0lMT04gOiBveilcbiAgICAgIH1cbiAgICAgIGlmKGhpdF9ub3JtKSB7XG4gICAgICAgIGhpdF9ub3JtWzBdID0gbnhcbiAgICAgICAgaGl0X25vcm1bMV0gPSBueVxuICAgICAgICBoaXRfbm9ybVsyXSA9IG56XG4gICAgICB9XG4gICAgICByZXR1cm4gYlxuICAgIH1cbiAgICAvL0NoZWNrIGVkZ2UgY2FzZXNcbiAgICBtaW5fc3RlcCA9ICsoRVBTSUxPTiAqICgxLjAgKyB0KSlcbiAgICBpZih0ID4gbWluX3N0ZXApIHtcbiAgICAgIGV4ID0gbnggPCAwID8gZnggPD0gbWluX3N0ZXAgOiBmeCA+PSAxLjAgLSBtaW5fc3RlcFxuICAgICAgZXkgPSBueSA8IDAgPyBmeSA8PSBtaW5fc3RlcCA6IGZ5ID49IDEuMCAtIG1pbl9zdGVwXG4gICAgICBleiA9IG56IDwgMCA/IGZ6IDw9IG1pbl9zdGVwIDogZnogPj0gMS4wIC0gbWluX3N0ZXBcbiAgICAgIGlmKGV4ICYmIGV5ICYmIGV6KSB7XG4gICAgICAgIGIgPSB2b3hlbHMuZ2V0QmxvY2soaXgrbngsIGl5K255LCBpeikgfHxcbiAgICAgICAgICAgIHZveGVscy5nZXRCbG9jayhpeCwgaXkrbnksIGl6K256KSB8fFxuICAgICAgICAgICAgdm94ZWxzLmdldEJsb2NrKGl4K254LCBpeSwgaXorbnopXG4gICAgICAgIGlmKGIpIHtcbiAgICAgICAgICBpZihoaXRfcG9zKSB7XG4gICAgICAgICAgICBoaXRfcG9zWzBdID0gbnggPCAwID8gaXgtRVBTSUxPTiA6IGl4ICsgMS4wLUVQU0lMT05cbiAgICAgICAgICAgIGhpdF9wb3NbMV0gPSBueSA8IDAgPyBpeS1FUFNJTE9OIDogaXkgKyAxLjAtRVBTSUxPTlxuICAgICAgICAgICAgaGl0X3Bvc1syXSA9IG56IDwgMCA/IGl6LUVQU0lMT04gOiBpeiArIDEuMC1FUFNJTE9OXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhpdF9ub3JtKSB7XG4gICAgICAgICAgICBoaXRfbm9ybVswXSA9IG54XG4gICAgICAgICAgICBoaXRfbm9ybVsxXSA9IG55XG4gICAgICAgICAgICBoaXRfbm9ybVsyXSA9IG56XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGV4ICYmIChleSB8fCBleikpIHtcbiAgICAgICAgYiA9IHZveGVscy5nZXRCbG9jayhpeCtueCwgaXksIGl6KVxuICAgICAgICBpZihiKSB7XG4gICAgICAgICAgaWYoaGl0X3Bvcykge1xuICAgICAgICAgICAgaGl0X3Bvc1swXSA9IG54IDwgMCA/IGl4LUVQU0lMT04gOiBpeCArIDEuMC1FUFNJTE9OXG4gICAgICAgICAgICBoaXRfcG9zWzFdID0gZnkgPCBFUFNJTE9OID8gK2l5IDogb3lcbiAgICAgICAgICAgIGhpdF9wb3NbMl0gPSBmeiA8IEVQU0lMT04gPyAraXogOiBvelxuICAgICAgICAgIH1cbiAgICAgICAgICBpZihoaXRfbm9ybSkge1xuICAgICAgICAgICAgaGl0X25vcm1bMF0gPSBueFxuICAgICAgICAgICAgaGl0X25vcm1bMV0gPSBueVxuICAgICAgICAgICAgaGl0X25vcm1bMl0gPSBuelxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYlxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihleSAmJiAoZXggfHwgZXopKSB7XG4gICAgICAgIGIgPSB2b3hlbHMuZ2V0QmxvY2soaXgsIGl5K255LCBpeilcbiAgICAgICAgaWYoYikge1xuICAgICAgICAgIGlmKGhpdF9wb3MpIHtcbiAgICAgICAgICAgIGhpdF9wb3NbMF0gPSBmeCA8IEVQU0lMT04gPyAraXggOiBveFxuICAgICAgICAgICAgaGl0X3Bvc1sxXSA9IG55IDwgMCA/IGl5LUVQU0lMT04gOiBpeSArIDEuMC1FUFNJTE9OXG4gICAgICAgICAgICBoaXRfcG9zWzJdID0gZnogPCBFUFNJTE9OID8gK2l6IDogb3pcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoaGl0X25vcm0pIHtcbiAgICAgICAgICAgIGhpdF9ub3JtWzBdID0gbnhcbiAgICAgICAgICAgIGhpdF9ub3JtWzFdID0gbnlcbiAgICAgICAgICAgIGhpdF9ub3JtWzJdID0gbnpcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoZXogJiYgKGV4IHx8IGV5KSkge1xuICAgICAgICBiID0gdm94ZWxzLmdldEJsb2NrKGl4LCBpeSwgaXorbnopXG4gICAgICAgIGlmKGIpIHtcbiAgICAgICAgICBpZihoaXRfcG9zKSB7XG4gICAgICAgICAgICBoaXRfcG9zWzBdID0gZnggPCBFUFNJTE9OID8gK2l4IDogb3hcbiAgICAgICAgICAgIGhpdF9wb3NbMV0gPSBmeSA8IEVQU0lMT04gPyAraXkgOiBveVxuICAgICAgICAgICAgaGl0X3Bvc1syXSA9IG56IDwgMCA/IGl6LUVQU0lMT04gOiBpeiArIDEuMC1FUFNJTE9OXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKGhpdF9ub3JtKSB7XG4gICAgICAgICAgICBoaXRfbm9ybVswXSA9IG54XG4gICAgICAgICAgICBoaXRfbm9ybVsxXSA9IG55XG4gICAgICAgICAgICBoaXRfbm9ybVsyXSA9IG56XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy9XYWxrIHRvIG5leHQgZmFjZSBvZiBjdWJlIGFsb25nIHJheVxuICAgIG54ID0gbnkgPSBueiA9IDBcbiAgICBzdGVwID0gMi4wXG4gICAgaWYoZHggPCAtRVBTSUxPTikge1xuICAgICAgdmFyIHMgPSAtZngvZHhcbiAgICAgIG54ID0gMVxuICAgICAgc3RlcCA9IHNcbiAgICB9XG4gICAgaWYoZHggPiBFUFNJTE9OKSB7XG4gICAgICB2YXIgcyA9ICgxLjAtZngpL2R4XG4gICAgICBueCA9IC0xXG4gICAgICBzdGVwID0gc1xuICAgIH1cbiAgICBpZihkeSA8IC1FUFNJTE9OKSB7XG4gICAgICB2YXIgcyA9IC1meS9keVxuICAgICAgaWYocyA8IHN0ZXAtbWluX3N0ZXApIHtcbiAgICAgICAgbnggPSAwXG4gICAgICAgIG55ID0gMVxuICAgICAgICBzdGVwID0gc1xuICAgICAgfSBlbHNlIGlmKHMgPCBzdGVwK21pbl9zdGVwKSB7XG4gICAgICAgIG55ID0gMVxuICAgICAgfVxuICAgIH1cbiAgICBpZihkeSA+IEVQU0lMT04pIHtcbiAgICAgIHZhciBzID0gKDEuMC1meSkvZHlcbiAgICAgIGlmKHMgPCBzdGVwLW1pbl9zdGVwKSB7XG4gICAgICAgIG54ID0gMFxuICAgICAgICBueSA9IC0xXG4gICAgICAgIHN0ZXAgPSBzXG4gICAgICB9IGVsc2UgaWYocyA8IHN0ZXArbWluX3N0ZXApIHtcbiAgICAgICAgbnkgPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICBpZihkeiA8IC1FUFNJTE9OKSB7XG4gICAgICB2YXIgcyA9IC1mei9kelxuICAgICAgaWYocyA8IHN0ZXAtbWluX3N0ZXApIHtcbiAgICAgICAgbnggPSBueSA9IDBcbiAgICAgICAgbnogPSAxXG4gICAgICAgIHN0ZXAgPSBzXG4gICAgICB9IGVsc2UgaWYocyA8IHN0ZXArbWluX3N0ZXApIHtcbiAgICAgICAgbnogPSAxXG4gICAgICB9XG4gICAgfVxuICAgIGlmKGR6ID4gRVBTSUxPTikge1xuICAgICAgdmFyIHMgPSAoMS4wLWZ6KS9kelxuICAgICAgaWYocyA8IHN0ZXAtbWluX3N0ZXApIHtcbiAgICAgICAgbnggPSBueSA9IDBcbiAgICAgICAgbnogPSAtMVxuICAgICAgICBzdGVwID0gc1xuICAgICAgfSBlbHNlIGlmKHMgPCBzdGVwK21pbl9zdGVwKSB7XG4gICAgICAgIG56ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoc3RlcCA+IG1heF9kIC0gdCkge1xuICAgICAgc3RlcCA9IG1heF9kIC0gdCAtIG1pbl9zdGVwXG4gICAgfVxuICAgIGlmKHN0ZXAgPCBtaW5fc3RlcCkge1xuICAgICAgc3RlcCA9IG1pbl9zdGVwXG4gICAgfVxuICAgIHQgKz0gc3RlcFxuICB9XG4gIGlmKGhpdF9wb3MpIHtcbiAgICBoaXRfcG9zWzBdID0gb3g7XG4gICAgaGl0X3Bvc1sxXSA9IG95O1xuICAgIGhpdF9wb3NbMl0gPSBvejtcbiAgfVxuICBpZihoaXRfbm9ybSkge1xuICAgIGhpdF9ub3JtWzBdID0gaGl0X25vcm1bMV0gPSBoaXRfbm9ybVsyXSA9IDA7XG4gIH1cbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gdHJhY2VSYXkodm94ZWxzLCBvcmlnaW4sIGRpcmVjdGlvbiwgbWF4X2QsIGhpdF9wb3MsIGhpdF9ub3JtLCBFUFNJTE9OKSB7XG4gIHZhciBweCA9ICtvcmlnaW5bMF1cbiAgICAsIHB5ID0gK29yaWdpblsxXVxuICAgICwgcHogPSArb3JpZ2luWzJdXG4gICAgLCBkeCA9ICtkaXJlY3Rpb25bMF1cbiAgICAsIGR5ID0gK2RpcmVjdGlvblsxXVxuICAgICwgZHogPSArZGlyZWN0aW9uWzJdXG4gICAgLCBkcyA9IE1hdGguc3FydChkeCpkeCArIGR5KmR5ICsgZHoqZHopXG4gIGlmKHR5cGVvZihFUFNJTE9OKSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIEVQU0lMT04gPSAxZS04XG4gIH1cbiAgaWYoZHMgPCBFUFNJTE9OKSB7XG4gICAgaWYoaGl0X3Bvcykge1xuICAgICAgaGl0X3Bvc1swXSA9IGhpdF9wb3NbMV0gPSBoaXRfcG9zWzJdXG4gICAgfVxuICAgIGlmKGhpdF9ub3JtKSB7XG4gICAgICBoaXRfbm9ybVswXSA9IGhpdF9ub3JtWzFdID0gaGl0X25vcm1bMl1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZHggLz0gZHNcbiAgZHkgLz0gZHNcbiAgZHogLz0gZHNcbiAgaWYodHlwZW9mKG1heF9kKSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1heF9kID0gNjQuMFxuICB9IGVsc2Uge1xuICAgIG1heF9kID0gK21heF9kXG4gIH1cbiAgcmV0dXJuIHRyYWNlUmF5X2ltcGwodm94ZWxzLCBweCwgcHksIHB6LCBkeCwgZHksIGR6LCBtYXhfZCwgaGl0X3BvcywgaGl0X25vcm0sIEVQU0lMT04pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhY2VSYXkiLCJtb2R1bGUuZXhwb3J0cyA9IGNvb3JkaW5hdGVzXG5cbnZhciBhYWJiID0gcmVxdWlyZSgnYWFiYi0zZCcpXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcblxuZnVuY3Rpb24gY29vcmRpbmF0ZXMoc3BhdGlhbCwgYm94LCByZWdpb25XaWR0aCkge1xuICB2YXIgZW1pdHRlciA9IG5ldyBldmVudHMuRXZlbnRFbWl0dGVyKClcbiAgdmFyIGxhc3RSZWdpb24gPSBbTmFOLCBOYU4sIE5hTl1cbiAgdmFyIHRoaXNSZWdpb25cblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHJlZ2lvbldpZHRoID0gYm94XG4gICAgYm94ID0gYWFiYihbLUluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV0sIFtJbmZpbml0eSwgSW5maW5pdHksIEluZmluaXR5XSlcbiAgfVxuXG4gIHNwYXRpYWwub24oJ3Bvc2l0aW9uJywgYm94LCB1cGRhdGVSZWdpb24pXG4gIFxuICBmdW5jdGlvbiB1cGRhdGVSZWdpb24ocG9zKSB7XG4gICAgdGhpc1JlZ2lvbiA9IFtNYXRoLmZsb29yKHBvc1swXSAvIHJlZ2lvbldpZHRoKSwgTWF0aC5mbG9vcihwb3NbMV0gLyByZWdpb25XaWR0aCksIE1hdGguZmxvb3IocG9zWzJdIC8gcmVnaW9uV2lkdGgpXVxuICAgIGlmICh0aGlzUmVnaW9uWzBdICE9PSBsYXN0UmVnaW9uWzBdIHx8IHRoaXNSZWdpb25bMV0gIT09IGxhc3RSZWdpb25bMV0gfHwgdGhpc1JlZ2lvblsyXSAhPT0gbGFzdFJlZ2lvblsyXSkge1xuICAgICAgZW1pdHRlci5lbWl0KCdjaGFuZ2UnLCB0aGlzUmVnaW9uKVxuICAgIH1cbiAgICBsYXN0UmVnaW9uID0gdGhpc1JlZ2lvblxuICB9XG4gXG4gIHJldHVybiBlbWl0dGVyXG59IiwidmFyIHRpYyA9IHJlcXVpcmUoJ3RpYycpKCk7XG52YXIgY3JlYXRlQXRsYXMgPSByZXF1aXJlKCdhdGxhc3BhY2snKTtcblxuZnVuY3Rpb24gVGV4dHVyZShvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUZXh0dXJlKSkgcmV0dXJuIG5ldyBUZXh0dXJlKG9wdHMgfHwge30pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuZ2FtZSA9IG9wdHMuZ2FtZTsgZGVsZXRlIG9wdHMuZ2FtZTtcbiAgdGhpcy5USFJFRSA9IHRoaXMuZ2FtZS5USFJFRTtcbiAgdGhpcy5tYXRlcmlhbHMgPSBbXTtcbiAgdGhpcy50ZXh0dXJlUGF0aCA9IG9wdHMudGV4dHVyZVBhdGggfHwgJy90ZXh0dXJlcy8nO1xuICB0aGlzLmxvYWRpbmcgPSAwO1xuXG4gIHZhciB1c2VGbGF0Q29sb3JzID0gb3B0cy5tYXRlcmlhbEZsYXRDb2xvciA9PT0gdHJ1ZTtcbiAgZGVsZXRlIG9wdHMubWF0ZXJpYWxGbGF0Q29sb3I7XG5cbiAgdGhpcy5vcHRpb25zID0gZGVmYXVsdHMob3B0cyB8fCB7fSwge1xuICAgIGNyb3NzT3JpZ2luOiAnQW5vbnltb3VzJyxcbiAgICBtYXRlcmlhbFBhcmFtczogZGVmYXVsdHMob3B0cy5tYXRlcmlhbFBhcmFtcyB8fCB7fSwge1xuICAgICAgYW1iaWVudDogMHhiYmJiYmJcbiAgICB9KSxcbiAgICBtYXRlcmlhbFR5cGU6IHRoaXMuVEhSRUUuTWVzaExhbWJlcnRNYXRlcmlhbCxcbiAgICBhcHBseVRleHR1cmVQYXJhbXM6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgbWFwLm1hZ0ZpbHRlciA9IHNlbGYuVEhSRUUuTmVhcmVzdEZpbHRlcjtcbiAgICAgIG1hcC5taW5GaWx0ZXIgPSBzZWxmLlRIUkVFLkxpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGNyZWF0ZSBhIGNhbnZhcyBmb3IgdGhlIHRleHR1cmUgYXRsYXNcbiAgdGhpcy5jYW52YXMgPSAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSA6IHt9O1xuICB0aGlzLmNhbnZhcy53aWR0aCA9IG9wdHMuYXRsYXNXaWR0aCB8fCA1MTI7XG4gIHRoaXMuY2FudmFzLmhlaWdodCA9IG9wdHMuYXRsYXNIZWlnaHQgfHwgNTEyO1xuXG4gIC8vIGNyZWF0ZSBjb3JlIGF0bGFzIGFuZCB0ZXh0dXJlXG4gIHRoaXMuYXRsYXMgPSBjcmVhdGVBdGxhcyh0aGlzLmNhbnZhcyk7XG4gIHRoaXMuYXRsYXMudGlsZXBhZCA9IHRydWU7XG4gIHRoaXMuX2F0bGFzdXYgPSBmYWxzZTtcbiAgdGhpcy5fYXRsYXNrZXkgPSBmYWxzZTtcbiAgdGhpcy50ZXh0dXJlID0gbmV3IHRoaXMuVEhSRUUuVGV4dHVyZSh0aGlzLmNhbnZhcyk7XG4gIHRoaXMub3B0aW9ucy5hcHBseVRleHR1cmVQYXJhbXModGhpcy50ZXh0dXJlKTtcblxuICBpZiAodXNlRmxhdENvbG9ycykge1xuICAgIC8vIElmIHdlcmUgdXNpbmcgc2ltcGxlIGNvbG9yc1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgdGhpcy5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgICB2ZXJ0ZXhDb2xvcnM6IHRoaXMuVEhSRUUuVmVydGV4Q29sb3JzXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbG9hZCBhIGZpcnN0IG1hdGVyaWFsIGZvciBlYXN5IGFwcGxpY2F0aW9uIHRvIG1lc2hlc1xuICAgIHRoaXMubWF0ZXJpYWwgPSBuZXcgdGhpcy5vcHRpb25zLm1hdGVyaWFsVHlwZSh0aGlzLm9wdGlvbnMubWF0ZXJpYWxQYXJhbXMpO1xuICAgIHRoaXMubWF0ZXJpYWwubWFwID0gdGhpcy50ZXh0dXJlO1xuICAgIHRoaXMubWF0ZXJpYWwudHJhbnNwYXJlbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gYSBwbGFjZSBmb3IgbWVzaGVzIHRvIHdhaXQgd2hpbGUgdGV4dHVyZXMgYXJlIGxvYWRpbmdcbiAgdGhpcy5fbWVzaFF1ZXVlID0gW107XG59XG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmU7XG5cblRleHR1cmUucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbihuYW1lcywgZG9uZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICghQXJyYXkuaXNBcnJheShuYW1lcykpIG5hbWVzID0gW25hbWVzXTtcbiAgZG9uZSA9IGRvbmUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdGhpcy5sb2FkaW5nKys7XG5cbiAgdmFyIG1hdGVyaWFsU2xpY2UgPSBuYW1lcy5tYXAoc2VsZi5fZXhwYW5kTmFtZSk7XG4gIHNlbGYubWF0ZXJpYWxzID0gc2VsZi5tYXRlcmlhbHMuY29uY2F0KG1hdGVyaWFsU2xpY2UpO1xuXG4gIC8vIGxvYWQgb250byB0aGUgdGV4dHVyZSBhdGxhc1xuICB2YXIgbG9hZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIG1hdGVyaWFsU2xpY2UuZm9yRWFjaChmdW5jdGlvbihtYXRzKSB7XG4gICAgbWF0cy5mb3JFYWNoKGZ1bmN0aW9uKG1hdCkge1xuICAgICAgaWYgKG1hdC5zbGljZSgwLCAxKSA9PT0gJyMnKSByZXR1cm47XG4gICAgICAvLyB0b2RvOiBjaGVjayBpZiB0ZXh0dXJlIGFscmVhZHkgZXhpc3RzXG4gICAgICBsb2FkW21hdF0gPSB0cnVlO1xuICAgIH0pO1xuICB9KTtcbiAgaWYgKE9iamVjdC5rZXlzKGxvYWQpLmxlbmd0aCA+IDApIHtcbiAgICBlYWNoKE9iamVjdC5rZXlzKGxvYWQpLCBzZWxmLnBhY2suYmluZChzZWxmKSwgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLl9hZnRlckxvYWRpbmcoKTtcbiAgICAgIGRvbmUobWF0ZXJpYWxTbGljZSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc2VsZi5fYWZ0ZXJMb2FkaW5nKCk7XG4gIH1cbn07XG5cblRleHR1cmUucHJvdG90eXBlLnBhY2sgPSBmdW5jdGlvbihuYW1lLCBkb25lKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gcGFjayhpbWcpIHtcbiAgICB2YXIgbm9kZSA9IHNlbGYuYXRsYXMucGFjayhpbWcpO1xuICAgIGlmIChub2RlID09PSBmYWxzZSkge1xuICAgICAgc2VsZi5hdGxhcyA9IHNlbGYuYXRsYXMuZXhwYW5kKGltZyk7XG4gICAgICBzZWxmLmF0bGFzLnRpbGVwYWQgPSB0cnVlO1xuICAgIH1cbiAgICBkb25lKCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuaWQgPSBuYW1lO1xuICAgIGltZy5jcm9zc09yaWdpbiA9IHNlbGYub3B0aW9ucy5jcm9zc09yaWdpbjtcbiAgICBpbWcuc3JjID0gc2VsZi50ZXh0dXJlUGF0aCArIGV4dChuYW1lKTtcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBwYWNrKGltZyk7XG4gICAgfTtcbiAgICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS5lcnJvcignQ291bGRuXFwndCBsb2FkIFVSTCBbJyArIGltZy5zcmMgKyAnXScpO1xuICAgICAgZG9uZSgpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcGFjayhuYW1lKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHR5cGUgPSAwO1xuICBzZWxmLm1hdGVyaWFscy5mb3JFYWNoKGZ1bmN0aW9uKG1hdHMsIGkpIHtcbiAgICBtYXRzLmZvckVhY2goZnVuY3Rpb24obWF0KSB7XG4gICAgICBpZiAobWF0ID09PSBuYW1lKSB7XG4gICAgICAgIHR5cGUgPSBpICsgMTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh0eXBlICE9PSAwKSByZXR1cm4gZmFsc2U7XG4gIH0pO1xuICByZXR1cm4gdHlwZTtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLl9leHBhbmROYW1lID0gZnVuY3Rpb24obmFtZSkge1xuICBpZiAobmFtZSA9PT0gbnVsbCkgcmV0dXJuIEFycmF5KDYpO1xuICBpZiAobmFtZS50b3ApIHJldHVybiBbbmFtZS5iYWNrLCBuYW1lLmZyb250LCBuYW1lLnRvcCwgbmFtZS5ib3R0b20sIG5hbWUubGVmdCwgbmFtZS5yaWdodF07XG4gIGlmICghQXJyYXkuaXNBcnJheShuYW1lKSkgbmFtZSA9IFtuYW1lXTtcbiAgLy8gbG9hZCB0aGUgMCB0ZXh0dXJlIHRvIGFsbFxuICBpZiAobmFtZS5sZW5ndGggPT09IDEpIG5hbWUgPSBbbmFtZVswXSxuYW1lWzBdLG5hbWVbMF0sbmFtZVswXSxuYW1lWzBdLG5hbWVbMF1dO1xuICAvLyAwIGlzIHRvcC9ib3R0b20sIDEgaXMgc2lkZXNcbiAgaWYgKG5hbWUubGVuZ3RoID09PSAyKSBuYW1lID0gW25hbWVbMV0sbmFtZVsxXSxuYW1lWzBdLG5hbWVbMF0sbmFtZVsxXSxuYW1lWzFdXTtcbiAgLy8gMCBpcyB0b3AsIDEgaXMgYm90dG9tLCAyIGlzIHNpZGVzXG4gIGlmIChuYW1lLmxlbmd0aCA9PT0gMykgbmFtZSA9IFtuYW1lWzJdLG5hbWVbMl0sbmFtZVswXSxuYW1lWzFdLG5hbWVbMl0sbmFtZVsyXV07XG4gIC8vIDAgaXMgdG9wLCAxIGlzIGJvdHRvbSwgMiBpcyBmcm9udC9iYWNrLCAzIGlzIGxlZnQvcmlnaHRcbiAgaWYgKG5hbWUubGVuZ3RoID09PSA0KSBuYW1lID0gW25hbWVbMl0sbmFtZVsyXSxuYW1lWzBdLG5hbWVbMV0sbmFtZVszXSxuYW1lWzNdXTtcbiAgcmV0dXJuIG5hbWU7XG59O1xuXG5UZXh0dXJlLnByb3RvdHlwZS5fYWZ0ZXJMb2FkaW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZnVuY3Rpb24gYWxsZG9uZSgpIHtcbiAgICBzZWxmLmxvYWRpbmctLTtcbiAgICBzZWxmLl9hdGxhc3V2ID0gc2VsZi5hdGxhcy51dihzZWxmLmNhbnZhcy53aWR0aCwgc2VsZi5jYW52YXMuaGVpZ2h0KTtcbiAgICBzZWxmLl9hdGxhc2tleSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgc2VsZi5hdGxhcy5pbmRleCgpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBzZWxmLl9hdGxhc2tleVtrZXkubmFtZV0gPSBrZXk7XG4gICAgfSk7XG4gICAgc2VsZi50ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICBzZWxmLm1hdGVyaWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAvL3dpbmRvdy5vcGVuKHNlbGYuY2FudmFzLnRvRGF0YVVSTCgpKTtcbiAgICBpZiAoc2VsZi5fbWVzaFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIHNlbGYuX21lc2hRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uKHF1ZXVlLCBpKSB7XG4gICAgICAgIHNlbGYucGFpbnQuYXBwbHkocXVldWUuc2VsZiwgcXVldWUuYXJncyk7XG4gICAgICAgIGRlbGV0ZSBzZWxmLl9tZXNoUXVldWVbaV07XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgc2VsZi5fcG93ZXJvZjIoZnVuY3Rpb24oKSB7XG4gICAgc2V0VGltZW91dChhbGxkb25lLCAxMDApO1xuICB9KTtcbn07XG5cbi8vIEVuc3VyZSB0aGUgdGV4dHVyZSBzdGF5cyBhdCBhIHBvd2VyIG9mIDIgZm9yIG1pcG1hcHNcbi8vIHRoaXMgaXMgY2hlYXRpbmcgOkRcblRleHR1cmUucHJvdG90eXBlLl9wb3dlcm9mMiA9IGZ1bmN0aW9uKGRvbmUpIHtcbiAgdmFyIHcgPSB0aGlzLmNhbnZhcy53aWR0aDtcbiAgdmFyIGggPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gIGZ1bmN0aW9uIHBvdzIoeCkge1xuICAgIHgtLTtcbiAgICB4IHw9IHggPj4gMTtcbiAgICB4IHw9IHggPj4gMjtcbiAgICB4IHw9IHggPj4gNDtcbiAgICB4IHw9IHggPj4gODtcbiAgICB4IHw9IHggPj4gMTY7XG4gICAgeCsrO1xuICAgIHJldHVybiB4O1xuICB9XG4gIGlmIChoID4gdykgdyA9IGg7XG4gIHZhciBvbGQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwb3cyKHcpO1xuICB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnB1dEltYWdlRGF0YShvbGQsIDAsIDApO1xuICBkb25lKCk7XG59O1xuXG5UZXh0dXJlLnByb3RvdHlwZS5wYWludCA9IGZ1bmN0aW9uKG1lc2gsIG1hdGVyaWFscykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gaWYgd2VyZSBsb2FkaW5nIHB1dCBpbnRvIHF1ZXVlXG4gIGlmIChzZWxmLmxvYWRpbmcgPiAwKSB7XG4gICAgc2VsZi5fbWVzaFF1ZXVlLnB1c2goe3NlbGY6IHNlbGYsIGFyZ3M6IGFyZ3VtZW50c30pO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc1ZveGVsTWVzaCA9IChtYXRlcmlhbHMpID8gZmFsc2UgOiB0cnVlO1xuICBpZiAoIWlzVm94ZWxNZXNoKSBtYXRlcmlhbHMgPSBzZWxmLl9leHBhbmROYW1lKG1hdGVyaWFscyk7XG5cbiAgbWVzaC5nZW9tZXRyeS5mYWNlcy5mb3JFYWNoKGZ1bmN0aW9uKGZhY2UsIGkpIHtcbiAgICBpZiAobWVzaC5nZW9tZXRyeS5mYWNlVmVydGV4VXZzWzBdLmxlbmd0aCA8IDEpIHJldHVybjtcblxuICAgIGlmIChpc1ZveGVsTWVzaCkge1xuICAgICAgdmFyIGluZGV4ID0gTWF0aC5mbG9vcihmYWNlLmNvbG9yLmIqMjU1ICsgZmFjZS5jb2xvci5nKjI1NSoyNTUgKyBmYWNlLmNvbG9yLnIqMjU1KjI1NSoyNTUpO1xuICAgICAgbWF0ZXJpYWxzID0gc2VsZi5tYXRlcmlhbHNbaW5kZXggLSAxXTtcbiAgICAgIGlmICghbWF0ZXJpYWxzKSBtYXRlcmlhbHMgPSBzZWxmLm1hdGVyaWFsc1swXTtcbiAgICB9XG5cbiAgICAvLyBCQUNLLCBGUk9OVCwgVE9QLCBCT1RUT00sIExFRlQsIFJJR0hUXG4gICAgdmFyIG5hbWUgPSBtYXRlcmlhbHNbMF0gfHwgJyc7XG4gICAgaWYgICAgICAoZmFjZS5ub3JtYWwueiA9PT0gMSkgIG5hbWUgPSBtYXRlcmlhbHNbMV0gfHwgJyc7XG4gICAgZWxzZSBpZiAoZmFjZS5ub3JtYWwueSA9PT0gMSkgIG5hbWUgPSBtYXRlcmlhbHNbMl0gfHwgJyc7XG4gICAgZWxzZSBpZiAoZmFjZS5ub3JtYWwueSA9PT0gLTEpIG5hbWUgPSBtYXRlcmlhbHNbM10gfHwgJyc7XG4gICAgZWxzZSBpZiAoZmFjZS5ub3JtYWwueCA9PT0gLTEpIG5hbWUgPSBtYXRlcmlhbHNbNF0gfHwgJyc7XG4gICAgZWxzZSBpZiAoZmFjZS5ub3JtYWwueCA9PT0gMSkgIG5hbWUgPSBtYXRlcmlhbHNbNV0gfHwgJyc7XG5cbiAgICAvLyBpZiBqdXN0IGEgc2ltcGxlIGNvbG9yXG4gICAgaWYgKG5hbWUuc2xpY2UoMCwgMSkgPT09ICcjJykge1xuICAgICAgc2VsZi5zZXRDb2xvcihtZXNoLmdlb21ldHJ5LmZhY2VzW2ldLCBuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYXRsYXN1diA9IHNlbGYuX2F0bGFzdXZbbmFtZV07XG4gICAgaWYgKCFhdGxhc3V2KSByZXR1cm47XG5cbiAgICAvLyAwIC0tIDFcbiAgICAvLyB8ICAgIHxcbiAgICAvLyAzIC0tIDJcbiAgICAvLyBmYWNlcyBvbiB0aGVzZSBtZXNoZXMgYXJlIGZsaXBwZWQgdmVydGljYWxseSwgc28gd2UgbWFwIGluIHJldmVyc2VcbiAgICAvLyBUT0RPOiB0b3BzIG5lZWQgcm90YXRlXG4gICAgaWYgKGlzVm94ZWxNZXNoKSB7XG4gICAgICBpZiAoZmFjZS5ub3JtYWwueiA9PT0gLTEgfHwgZmFjZS5ub3JtYWwueCA9PT0gMSkge1xuICAgICAgICBhdGxhc3V2ID0gdXZyb3QoYXRsYXN1diwgOTApO1xuICAgICAgfVxuICAgICAgYXRsYXN1diA9IHV2aW52ZXJ0KGF0bGFzdXYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdGxhc3V2ID0gdXZyb3QoYXRsYXN1diwgLTkwKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgIG1lc2guZ2VvbWV0cnkuZmFjZVZlcnRleFV2c1swXVtpXVtqXS5zZXQoYXRsYXN1dltqXVswXSwgMSAtIGF0bGFzdXZbal1bMV0pO1xuICAgIH1cbiAgfSk7XG5cbiAgbWVzaC5nZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gdHJ1ZTtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLnNwcml0ZSA9IGZ1bmN0aW9uKG5hbWUsIHcsIGgsIGNiKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHR5cGVvZiB3ID09PSAnZnVuY3Rpb24nKSB7IGNiID0gdzsgdyA9IG51bGw7IH1cbiAgaWYgKHR5cGVvZiBoID09PSAnZnVuY3Rpb24nKSB7IGNiID0gaDsgaCA9IG51bGw7IH1cbiAgdyA9IHcgfHwgMTY7IGggPSBoIHx8IHc7XG4gIHNlbGYubG9hZGluZysrO1xuICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gIGltZy5zcmMgPSBzZWxmLnRleHR1cmVQYXRoICsgZXh0KG5hbWUpO1xuICBpbWcub25lcnJvciA9IGNiO1xuICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhbnZhc2VzID0gW107XG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBpbWcud2lkdGg7IHggKz0gdykge1xuICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBpbWcuaGVpZ2h0OyB5ICs9IGgpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICBjYW52YXMud2lkdGggPSB3OyBjYW52YXMuaGVpZ2h0ID0gaDtcbiAgICAgICAgY2FudmFzLm5hbWUgPSBuYW1lICsgJ18nICsgeCArICdfJyArIHk7XG4gICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShpbWcsIHgsIHksIHcsIGgsIDAsIDAsIHcsIGgpO1xuICAgICAgICBjYW52YXNlcy5wdXNoKGNhbnZhcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0ZXh0dXJlcyA9IFtdO1xuICAgIGVhY2goY2FudmFzZXMsIGZ1bmN0aW9uKGNhbnZhcywgbmV4dCkge1xuICAgICAgdmFyIHRleCA9IG5ldyBJbWFnZSgpO1xuICAgICAgdGV4Lm5hbWUgPSBjYW52YXMubmFtZTtcbiAgICAgIHRleC5zcmMgPSBjYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICB0ZXgub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYucGFjayh0ZXgsIG5leHQpO1xuICAgICAgfTtcbiAgICAgIHRleC5vbmVycm9yID0gbmV4dDtcbiAgICAgIHRleHR1cmVzLnB1c2goW1xuICAgICAgICB0ZXgubmFtZSwgdGV4Lm5hbWUsIHRleC5uYW1lLFxuICAgICAgICB0ZXgubmFtZSwgdGV4Lm5hbWUsIHRleC5uYW1lXG4gICAgICBdKTtcbiAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuX2FmdGVyTG9hZGluZygpO1xuICAgICAgZGVsZXRlIGNhbnZhc2VzO1xuICAgICAgc2VsZi5tYXRlcmlhbHMgPSBzZWxmLm1hdGVyaWFscy5jb25jYXQodGV4dHVyZXMpO1xuICAgICAgY2IodGV4dHVyZXMpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gc2VsZjtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbihtZXNoLCBuYW1lcywgZGVsYXkpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWxheSA9IGRlbGF5IHx8IDEwMDA7XG4gIGlmICghQXJyYXkuaXNBcnJheShuYW1lcykgfHwgbmFtZXMubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuICB2YXIgaSA9IDA7XG4gIHZhciBtYXQgPSBuZXcgdGhpcy5vcHRpb25zLm1hdGVyaWFsVHlwZSh0aGlzLm9wdGlvbnMubWF0ZXJpYWxQYXJhbXMpO1xuICBtYXQubWFwID0gdGhpcy50ZXh0dXJlO1xuICBtYXQudHJhbnNwYXJlbnQgPSB0cnVlO1xuICBtYXQubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB0aWMuaW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5wYWludChtZXNoLCBuYW1lc1tpICUgbmFtZXMubGVuZ3RoXSk7XG4gICAgaSsrO1xuICB9LCBkZWxheSk7XG4gIHJldHVybiBtYXQ7XG59O1xuXG5UZXh0dXJlLnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oZHQpIHtcbiAgdGljLnRpY2soZHQpO1xufTtcblxuVGV4dHVyZS5wcm90b3R5cGUuc2V0Q29sb3IgPSBmdW5jdGlvbihmYWNlLCBjb2xvcikge1xuICB2YXIgcmdiID0gaGV4MnJnYihjb2xvcik7XG4gIGZhY2UuY29sb3Iuc2V0UkdCKHJnYlswXSwgcmdiWzFdLCByZ2JbMl0pO1xuICB2YXIgbGQgPSB0aGlzLl9saWdodERhcmsoY29sb3IpO1xuXG4gIC8vIFRPRE86IEFPIHNob3VsZCBiZSBmaWd1cmVkIGJldHRlciB0aGFuIHRoaXNcbiAgaWYgKGZhY2Uubm9ybWFsLnkgPT09IDEpICAgICAgIGZhY2UudmVydGV4Q29sb3JzID0gW2xkWzBdLCBsZFswXSwgbGRbMF0sIGxkWzBdXTtcbiAgZWxzZSBpZiAoZmFjZS5ub3JtYWwueSA9PT0gLTEpIGZhY2UudmVydGV4Q29sb3JzID0gW2xkWzFdLCBsZFsxXSwgbGRbMV0sIGxkWzFdXTtcbiAgZWxzZSBpZiAoZmFjZS5ub3JtYWwueCA9PT0gMSkgIGZhY2UudmVydGV4Q29sb3JzID0gW2xkWzFdLCBsZFswXSwgbGRbMF0sIGxkWzFdXTtcbiAgZWxzZSBpZiAoZmFjZS5ub3JtYWwueCA9PT0gLTEpIGZhY2UudmVydGV4Q29sb3JzID0gW2xkWzFdLCBsZFsxXSwgbGRbMF0sIGxkWzBdXTtcbiAgZWxzZSBpZiAoZmFjZS5ub3JtYWwueiA9PT0gMSkgIGZhY2UudmVydGV4Q29sb3JzID0gW2xkWzFdLCBsZFsxXSwgbGRbMF0sIGxkWzBdXTtcbiAgZWxzZSAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhY2UudmVydGV4Q29sb3JzID0gW2xkWzFdLCBsZFswXSwgbGRbMF0sIGxkWzFdXTtcbn07XG5cblRleHR1cmUucHJvdG90eXBlLl9saWdodERhcmsgPSBtZW1vaXplKGZ1bmN0aW9uKGNvbG9yKSB7XG4gIHZhciBsaWdodCA9IG5ldyB0aGlzLlRIUkVFLkNvbG9yKGNvbG9yKTtcbiAgdmFyIGhzbCA9IGxpZ2h0LmdldEhTTCgpO1xuICB2YXIgZGFyayA9IGxpZ2h0LmNsb25lKCk7XG4gIGRhcmsuc2V0SFNMKGhzbC5oLCBoc2wucywgaHNsLmwgLSAwLjEpO1xuICByZXR1cm4gW2xpZ2h0LCBkYXJrXTtcbn0pO1xuXG5mdW5jdGlvbiB1dnJvdChjb29yZHMsIGRlZykge1xuICBpZiAoZGVnID09PSAwKSByZXR1cm4gY29vcmRzO1xuICB2YXIgYyA9IFtdO1xuICB2YXIgaSA9ICg0IC0gTWF0aC5jZWlsKGRlZyAvIDkwKSkgJSA0O1xuICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgIGMucHVzaChjb29yZHNbaV0pO1xuICAgIGlmIChpID09PSAzKSBpID0gMDsgZWxzZSBpKys7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIHV2aW52ZXJ0KGNvb3Jkcykge1xuICB2YXIgYyA9IGNvb3Jkcy5zbGljZSgwKTtcbiAgcmV0dXJuIFtjWzNdLCBjWzJdLCBjWzFdLCBjWzBdXTtcbn1cblxuZnVuY3Rpb24gZXh0KG5hbWUpIHtcbiAgcmV0dXJuIChTdHJpbmcobmFtZSkuaW5kZXhPZignLicpICE9PSAtMSkgPyBuYW1lIDogbmFtZSArICcucG5nJztcbn1cblxuZnVuY3Rpb24gZGVmYXVsdHMob2JqKSB7XG4gIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKS5mb3JFYWNoKGZ1bmN0aW9uKGZyb20pIHtcbiAgICBpZiAoZnJvbSkgZm9yICh2YXIgayBpbiBmcm9tKSBpZiAob2JqW2tdID09IG51bGwpIG9ialtrXSA9IGZyb21ba107XG4gIH0pO1xuICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiBlYWNoKGFyciwgaXQsIGRvbmUpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgYXJyLmZvckVhY2goZnVuY3Rpb24oYSkge1xuICAgIGl0KGEsIGZ1bmN0aW9uKCkge1xuICAgICAgY291bnQrKztcbiAgICAgIGlmIChjb3VudCA+PSBhcnIubGVuZ3RoKSBkb25lKCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoZXgycmdiKGhleCkge1xuICBpZiAoaGV4WzBdID09PSAnIycpIGhleCA9IGhleC5zdWJzdHIoMSk7XG4gIHJldHVybiBbcGFyc2VJbnQoaGV4LnN1YnN0cigwLDIpLCAxNikvMjU1LCBwYXJzZUludChoZXguc3Vic3RyKDIsMiksIDE2KS8yNTUsIHBhcnNlSW50KGhleC5zdWJzdHIoNCwyKSwgMTYpLzI1NV07XG59XG5cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYykge1xuICBmdW5jdGlvbiBtZW1vaXplZCgpIHtcbiAgICB2YXIgY2FjaGUgPSBtZW1vaXplZC5jYWNoZSwga2V5ID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGNhY2hlLCBrZXkpXG4gICAgICA/IGNhY2hlW2tleV1cbiAgICAgIDogKGNhY2hlW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG4gIG1lbW9pemVkLmNhY2hlID0ge307XG4gIHJldHVybiBtZW1vaXplZDtcbn1cbiIsIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLmF0bGFzcGFjaz1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIChmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qXG4gKiBhdGxhc3BhY2tcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zaGFtYS9hdGxhc3BhY2tcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQgS3lsZSBSb2JpbnNvbiBZb3VuZ1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICpcbiAqIEJhc2VkIG9uIE5pY2sgV2VsY2gncyBiaW5wYWNrOiBodHRwczovL2dpdGh1Yi5jb20vbWFja3N0YW5uL2JpbnBhY2tcbiAqL1xuXG5mdW5jdGlvbiBSZWN0KHgsIHksIHcsIGgpIHtcbiAgdGhpcy54ID0geDsgdGhpcy55ID0geTtcbiAgdGhpcy53ID0gdzsgdGhpcy5oID0gaDtcbn1cblxuUmVjdC5wcm90b3R5cGUuZml0c0luID0gZnVuY3Rpb24ob3V0ZXIpIHtcbiAgcmV0dXJuIG91dGVyLncgPj0gdGhpcy53ICYmIG91dGVyLmggPj0gdGhpcy5oO1xufTtcblxuUmVjdC5wcm90b3R5cGUuc2FtZVNpemVBcyA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLncgPT09IG90aGVyLncgJiYgdGhpcy5oID09PSBvdGhlci5oO1xufTtcblxuZnVuY3Rpb24gQXRsYXMoeCwgeSwgdywgaCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHRoaXMuY2FudmFzID0geDtcbiAgICB4ID0geSA9IDA7XG4gICAgdyA9IHRoaXMuY2FudmFzLndpZHRoO1xuICAgIGggPSB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gIH1cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB3ID0geDsgaCA9IHk7IHggPSB5ID0gMDtcbiAgfVxuICB0aGlzLmxlZnQgPSB0aGlzLnJpZ2h0ID0gbnVsbDtcbiAgdGhpcy5yZWN0ID0gbmV3IFJlY3QoeCwgeSwgdywgaCk7XG4gIHRoaXMuZmlsbGVkID0gZmFsc2U7XG4gIHRoaXMudGlsZXBhZCA9IGZhbHNlO1xuICB0aGlzLl9jYWNoZSA9IFtdO1xuICB0aGlzLl91dmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7IHJldHVybiBuZXcgQXRsYXMoYXJndW1lbnRzWzBdKTsgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgeyByZXR1cm4gbmV3IEF0bGFzKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTsgfVxuICByZXR1cm4gbmV3IEF0bGFzKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXSk7XG59O1xubW9kdWxlLmV4cG9ydHMuQXRsYXMgPSBBdGxhcztcbm1vZHVsZS5leHBvcnRzLlJlY3QgPSBSZWN0O1xuXG4vLyBwYWNrIGltYWdlL3JlY3QgdG8gdGhlIGF0bGFzXG5BdGxhcy5wcm90b3R5cGUucGFjayA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgdGhpcy5fY2FjaGUgPSBbXTtcbiAgdGhpcy5fdXZjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJlY3QgPSB0aGlzLl90b1JlY3QocmVjdCk7XG5cbiAgaWYgKHRoaXMuaW1nICYmIHRoaXMudGlsZXBhZCkge1xuICAgIHJlY3QgPSB0aGlzLl90aWxlcGFkKHJlY3QpO1xuICB9XG5cbiAgaWYgKHRoaXMubGVmdCAhPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLl9vbnRvQ2FudmFzKHRoaXMubGVmdC5wYWNrKHJlY3QpIHx8IHRoaXMucmlnaHQucGFjayhyZWN0KSk7XG4gIH1cbiAgLy8gaWYgYXRsYXMgZmlsbGVkIG9yIHdvbnQgZml0XG4gIGlmICh0aGlzLmZpbGxlZCB8fCAhcmVjdC5maXRzSW4odGhpcy5yZWN0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBpZiB0aGlzIGF0bGFzIGhhcyBiZWVuIGZpbGxlZFxuICBpZiAocmVjdC5zYW1lU2l6ZUFzKHRoaXMucmVjdCkpIHtcbiAgICB0aGlzLmZpbGxlZCA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXMuX29udG9DYW52YXModGhpcyk7XG4gIH1cbiAgaWYgKCh0aGlzLnJlY3QudyAtIHJlY3QudykgPiAodGhpcy5yZWN0LmggLSByZWN0LmgpKSB7XG4gICAgdGhpcy5sZWZ0ID0gbmV3IEF0bGFzKHRoaXMucmVjdC54LCB0aGlzLnJlY3QueSwgcmVjdC53LCB0aGlzLnJlY3QuaCk7XG4gICAgdGhpcy5yaWdodCA9IG5ldyBBdGxhcyh0aGlzLnJlY3QueCArIHJlY3QudywgdGhpcy5yZWN0LnksIHRoaXMucmVjdC53IC0gcmVjdC53LCB0aGlzLnJlY3QuaCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sZWZ0ID0gbmV3IEF0bGFzKHRoaXMucmVjdC54LCB0aGlzLnJlY3QueSwgdGhpcy5yZWN0LncsIHJlY3QuaCk7XG4gICAgdGhpcy5yaWdodCA9IG5ldyBBdGxhcyh0aGlzLnJlY3QueCwgdGhpcy5yZWN0LnkgKyByZWN0LmgsIHRoaXMucmVjdC53LCB0aGlzLnJlY3QuaCAtIHJlY3QuaCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX29udG9DYW52YXModGhpcy5sZWZ0LnBhY2socmVjdCkpO1xufTtcblxuQXRsYXMucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZWN0ID0gdGhpcy5fdG9SZWN0KHJlY3QpO1xuXG4gIGlmICh0aGlzLmltZyAmJiB0aGlzLnRpbGVwYWQpIHtcbiAgICByZWN0ID0gdGhpcy5fdGlsZXBhZChyZWN0KTtcbiAgfVxuXG4gIHZhciBhdGxhcztcbiAgaWYgKHRoaXMucmVjdC53IDwgdGhpcy5yZWN0LmgpIHtcbiAgICBhdGxhcyA9IG5ldyBBdGxhcygwLCAwLCB0aGlzLnJlY3QudyArIHJlY3QudywgdGhpcy5yZWN0LmgpO1xuICAgIGF0bGFzLnJpZ2h0ID0gbmV3IEF0bGFzKHRoaXMucmVjdC53LCAwLCByZWN0LncsIHRoaXMucmVjdC5oKTtcbiAgICBhdGxhcy5sZWZ0ID0gdGhpcztcbiAgfSBlbHNlIHtcbiAgICBhdGxhcyA9IG5ldyBBdGxhcygwLCAwLCB0aGlzLnJlY3QudywgdGhpcy5yZWN0LmggKyByZWN0LmgpO1xuICAgIGF0bGFzLnJpZ2h0ID0gbmV3IEF0bGFzKDAsIHRoaXMucmVjdC5oLCB0aGlzLnJlY3QudywgcmVjdC5oKTtcbiAgICBhdGxhcy5sZWZ0ID0gdGhpcztcbiAgfVxuXG4gIFsnY2FudmFzJywgJ2NvbnRleHQnLCAnaW1nJ10uZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgaWYgKHNlbGZbcF0pIHtcbiAgICAgIGF0bGFzW3BdID0gc2VsZltwXTtcbiAgICAgIHNlbGZbcF0gPSBudWxsO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcmVzaXplIGNhbnZhc1xuICBpZiAoYXRsYXMuY2FudmFzKSB7XG4gICAgaWYgKCFhdGxhcy5jb250ZXh0KSB7XG4gICAgICBhdGxhcy5jb250ZXh0ID0gYXRsYXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgfVxuICAgIHZhciBvbGQgPSBhdGxhcy5jb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBhdGxhcy5jYW52YXMud2lkdGgsIGF0bGFzLmNhbnZhcy5oZWlnaHQpO1xuICAgIGF0bGFzLmNhbnZhcy53aWR0aCA9IGF0bGFzLnJlY3QudztcbiAgICBhdGxhcy5jYW52YXMuaGVpZ2h0ID0gYXRsYXMucmVjdC5oO1xuICAgIGF0bGFzLmNvbnRleHQucHV0SW1hZ2VEYXRhKG9sZCwgMCwgMCk7XG4gIH1cblxuICByZXR1cm4gKGF0bGFzLnBhY2socmVjdCkgPT09IGZhbHNlKSA/IGF0bGFzLmV4cGFuZChyZWN0KSA6IGF0bGFzO1xufTtcblxuQXRsYXMucHJvdG90eXBlLmluZGV4ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHNlbGYuX2NhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gc2VsZi5fY2FjaGU7XG4gIH1cbiAgKGZ1bmN0aW9uIGxvb3AoYXRsYXMpIHtcbiAgICBpZiAoYXRsYXMubGVmdCAhPT0gbnVsbCkge1xuICAgICAgbG9vcChhdGxhcy5sZWZ0KTtcbiAgICAgIGxvb3AoYXRsYXMucmlnaHQpO1xuICAgIH0gZWxzZSBpZiAoYXRsYXMucmVjdC5uYW1lKSB7XG4gICAgICBzZWxmLl9jYWNoZS5wdXNoKGF0bGFzLnJlY3QpO1xuICAgIH1cbiAgfShzZWxmKSk7XG4gIHJldHVybiBzZWxmLl9jYWNoZTtcbn07XG5cbkF0bGFzLnByb3RvdHlwZS51diA9IGZ1bmN0aW9uKHcsIGgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB3ID0gdyB8fCBzZWxmLnJlY3QudztcbiAgaCA9IGggfHwgc2VsZi5yZWN0Lmg7XG4gIHZhciBpc1BhZCA9IHRoaXMudGlsZXBhZDtcbiAgKGZ1bmN0aW9uIGxvb3AoYXRsYXMpIHtcbiAgICBpZiAoYXRsYXMubGVmdCAhPT0gbnVsbCkge1xuICAgICAgbG9vcChhdGxhcy5sZWZ0KTtcbiAgICAgIGxvb3AoYXRsYXMucmlnaHQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGF0bGFzLnJlY3QubmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHZhciBwID0gKGlzUGFkKSA/IGF0bGFzLnJlY3QudyAvIDQgOiAwO1xuICAgICAgc2VsZi5fdXZjYWNoZVthdGxhcy5yZWN0Lm5hbWVdID0gW1xuICAgICAgICBbYXRsYXMucmVjdC54ICsgcCwgYXRsYXMucmVjdC55ICsgcF0sXG4gICAgICAgIFsoYXRsYXMucmVjdC54ICsgcCkgKyAoYXRsYXMucmVjdC53IC0gKHAgKiAyKSksIGF0bGFzLnJlY3QueSArIHBdLFxuICAgICAgICBbKGF0bGFzLnJlY3QueCArIHApICsgKGF0bGFzLnJlY3QudyAtIChwICogMikpLCAoYXRsYXMucmVjdC55ICsgcCkgKyAoYXRsYXMucmVjdC5oIC0gKHAgKiAyKSldLFxuICAgICAgICBbKGF0bGFzLnJlY3QueCArIHApLCAoYXRsYXMucmVjdC55ICsgcCkgKyAoYXRsYXMucmVjdC5oIC0gKHAgKiAyKSldLFxuICAgICAgXS5tYXAoZnVuY3Rpb24odXYpIHtcbiAgICAgICAgaWYgKHV2WzBdICE9PSAwKSB7XG4gICAgICAgICAgdXZbMF0gPSB1dlswXSAvIHc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV2WzFdICE9PSAwKSB7XG4gICAgICAgICAgdXZbMV0gPSB1dlsxXSAvIGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV2O1xuICAgICAgfSk7XG4gICAgfVxuICB9KHNlbGYpKTtcbiAgcmV0dXJuIHNlbGYuX3V2Y2FjaGU7XG59O1xuXG5BdGxhcy5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uKGlucHV0KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIGlucHV0ID0gSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIChmdW5jdGlvbiBsb29wKG9iaikge1xuICAgICAgaWYgKCFvYmogfHwgIW9iai5yZWN0KSByZXR1cm47XG4gICAgICB2YXIgYXRsYXMgPSBuZXcgQXRsYXMob2JqLnJlY3QueCwgb2JqLnJlY3QueSwgb2JqLnJlY3Qudywgb2JqLnJlY3QuaCk7XG4gICAgICBpZiAob2JqLmxlZnQpIGF0bGFzLmxlZnQgPSBsb29wKG9iai5sZWZ0KTtcbiAgICAgIGlmIChvYmoucmlnaHQpIGF0bGFzLnJpZ2h0ID0gbG9vcChvYmoucmlnaHQpO1xuICAgICAgcmV0dXJuIGF0bGFzO1xuICAgIH0oaW5wdXQpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZnVuY3Rpb24gbG9vcChhdGxhcykge1xuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgbGVmdDogbnVsbCwgcmlnaHQ6IG51bGwsXG4gICAgICAgIHJlY3Q6IGF0bGFzLnJlY3QsIGZpbGxlZDogYXRsYXMuZmlsbGVkXG4gICAgICB9O1xuICAgICAgaWYgKGF0bGFzLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgb2JqLmxlZnQgPSBsb29wKGF0bGFzLmxlZnQpO1xuICAgICAgICBvYmoucmlnaHQgPSBsb29wKGF0bGFzLnJpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfShzZWxmKSwgbnVsbCwgMik7XG4gIH1cbn07XG5cbi8vIFBhZHMgdGhlIGltYWdlIGJ5IHRpbGluZyBpdHNlbGYgYXJvdW5kIGl0c2VsZlxuQXRsYXMucHJvdG90eXBlLl90aWxlcGFkID0gZnVuY3Rpb24ocmVjdCkge1xuICB2YXIgaW1nID0gdGhpcy5pbWc7XG4gIGlmICghaW1nKSByZXR1cm4gcmVjdDtcblxuICB2YXIgcCA9IGltZy53aWR0aCAvIDI7XG5cbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjYW52YXMubmFtZSA9IGltZy5uYW1lIHx8IGltZy5zcmM7XG4gIGNhbnZhcy5pZCA9IGltZy5pZCB8fCAnJztcbiAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoICsgaW1nLndpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodCArIGltZy5oZWlnaHQ7XG4gIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICB2YXIgcGF0dGVybiA9IGN0eC5jcmVhdGVQYXR0ZXJuKGltZywgJ3JlcGVhdCcpO1xuICBjdHguZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgY3R4LnRyYW5zbGF0ZShwLCBwKTtcbiAgY3R4LmZpbGxSZWN0KC1wLCAtcCwgY2FudmFzLndpZHRoICsgcCwgY2FudmFzLmhlaWdodCArIHApO1xuICBjdHgudHJhbnNsYXRlKC1wLCAtcCk7XG5cbiAgdGhpcy5pbWcgPSBjYW52YXM7XG5cbiAgcmV0dXJuIG5ldyBSZWN0KHJlY3QueCwgcmVjdC55LCB0aGlzLmltZy53aWR0aCwgdGhpcy5pbWcuaGVpZ2h0KTtcbn07XG5cbi8vIGlmIGhhcyBhbiBpbWFnZSBhbmQgY2FudmFzLCBkcmF3IHRvIHRoZSBjYW52YXMgYXMgd2UgZ29cbkF0bGFzLnByb3RvdHlwZS5fb250b0NhbnZhcyA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYgKG5vZGUgJiYgdGhpcy5pbWcgJiYgdGhpcy5jYW52YXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdChub2RlLnJlY3QueCwgbm9kZS5yZWN0LnksIG5vZGUucmVjdC53LCBub2RlLnJlY3QuaCk7XG4gICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZSh0aGlzLmltZywgbm9kZS5yZWN0LngsIG5vZGUucmVjdC55LCBub2RlLnJlY3Qudywgbm9kZS5yZWN0LmgpO1xuICAgIG5vZGUucmVjdC5uYW1lID0gdGhpcy5pbWcuaWQgfHwgdGhpcy5pbWcubmFtZSB8fCB0aGlzLmltZy5zcmMgfHwgbnVsbDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn07XG5cbi8vIG1ha2Ugc3VyZSB3ZSdyZSBhbHdheXMgd29ya2luZyB3aXRoIHJlY3RzXG5BdGxhcy5wcm90b3R5cGUuX3RvUmVjdCA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgLy8gaWYgcmVjdCBpcyBhbiBpbWFnZVxuICBpZiAocmVjdC5ub2RlTmFtZSAmJiByZWN0Lm5vZGVOYW1lID09PSAnSU1HJykge1xuICAgIHRoaXMuaW1nID0gcmVjdDtcbiAgICByZWN0ID0gbmV3IFJlY3QocmVjdC54LCByZWN0LnksIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcbiAgfVxuICAvLyBpZiByZWN0IGlzIGFuIG9iamVjdFxuICBpZiAoIShyZWN0IGluc3RhbmNlb2YgUmVjdCkpIHtcbiAgICByZWN0ID0gbmV3IFJlY3QocmVjdC54IHx8IDAsIHJlY3QueSB8fCAwLCByZWN0LncgfHwgcmVjdC53aWR0aCwgcmVjdC5oIHx8IHJlY3QuaGVpZ2h0KTtcbiAgfVxuICByZXR1cm4gcmVjdDtcbn07XG5cbkF0bGFzLnByb3RvdHlwZS5fZGVidWcgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLmNhbnZhcykgeyByZXR1cm47IH1cbiAgdmFyIGNvbnRleHQgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICB0aGlzLmluZGV4KCkuZm9yRWFjaChmdW5jdGlvbihyZWN0KSB7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICBjb250ZXh0LnN0cm9rZVJlY3QocmVjdC54LCByZWN0LnksIHJlY3QudywgcmVjdC5oKTtcbiAgfSk7XG59O1xuXG59LHt9XX0se30sWzFdKVxuKDEpXG59KTs7XG4iLCJ2YXIgVEhSRUUsIHRlbXBvcmFyeVBvc2l0aW9uLCB0ZW1wb3JhcnlWZWN0b3JcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aHJlZSwgb3B0cykge1xuICB0ZW1wb3JhcnlQb3NpdGlvbiA9IG5ldyB0aHJlZS5WZWN0b3IzXG4gIHRlbXBvcmFyeVZlY3RvciA9IG5ldyB0aHJlZS5WZWN0b3IzXG4gIFxuICByZXR1cm4gbmV3IFZpZXcodGhyZWUsIG9wdHMpXG59XG5cbmZ1bmN0aW9uIFZpZXcodGhyZWUsIG9wdHMpIHtcbiAgVEhSRUUgPSB0aHJlZSAvLyB0aHJlZS5qcyBkb2Vzbid0IHN1cHBvcnQgbXVsdGlwbGUgaW5zdGFuY2VzIG9uIGEgc2luZ2xlIHBhZ2VcbiAgdGhpcy5mb3YgPSBvcHRzLmZvdiB8fCA2MFxuICB0aGlzLndpZHRoID0gb3B0cy53aWR0aCB8fCA1MTJcbiAgdGhpcy5oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCA1MTJcbiAgdGhpcy5hc3BlY3RSYXRpbyA9IG9wdHMuYXNwZWN0UmF0aW8gfHwgdGhpcy53aWR0aC90aGlzLmhlaWdodFxuICB0aGlzLm5lYXJQbGFuZSA9IG9wdHMubmVhclBsYW5lIHx8IDFcbiAgdGhpcy5mYXJQbGFuZSA9IG9wdHMuZmFyUGxhbmUgfHwgMTAwMDBcbiAgdGhpcy5za3lDb2xvciA9IG9wdHMuc2t5Q29sb3IgfHwgMHhCRkQxRTVcbiAgdGhpcy5vcnRobyA9IG9wdHMub3J0aG9cbiAgdGhpcy5jYW1lcmEgPSB0aGlzLm9ydGhvPyhuZXcgVEhSRUUuT3J0aG9ncmFwaGljQ2FtZXJhKHRoaXMud2lkdGgvLTIsIHRoaXMud2lkdGgvMiwgdGhpcy5oZWlnaHQvMiwgdGhpcy5oZWlnaHQvLTIsIHRoaXMubmVhclBsYW5lLCB0aGlzLmZhclBsYW5lKSk6KG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSh0aGlzLmZvdiwgdGhpcy5hc3BlY3RSYXRpbywgdGhpcy5uZWFyUGxhbmUsIHRoaXMuZmFyUGxhbmUpKVxuICB0aGlzLmNhbWVyYS5sb29rQXQobmV3IFRIUkVFLlZlY3RvcjMoMCwgMCwgMCkpXG5cbiAgaWYgKCFwcm9jZXNzLmJyb3dzZXIpIHJldHVyblxuXG4gIHRoaXMuY3JlYXRlUmVuZGVyZXIoKVxuICB0aGlzLmVsZW1lbnQgPSB0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnRcbn1cblxuVmlldy5wcm90b3R5cGUuY3JlYXRlUmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICBhbnRpYWxpYXM6IHRydWVcbiAgfSlcbiAgdGhpcy5yZW5kZXJlci5zZXRTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICB0aGlzLnJlbmRlcmVyLnNldENsZWFyQ29sb3JIZXgodGhpcy5za3lDb2xvciwgMS4wKVxuICB0aGlzLnJlbmRlcmVyLmNsZWFyKClcbn1cblxuVmlldy5wcm90b3R5cGUuYmluZFRvU2NlbmUgPSBmdW5jdGlvbihzY2VuZSkge1xuICBzY2VuZS5hZGQodGhpcy5jYW1lcmEpXG59XG5cblZpZXcucHJvdG90eXBlLmdldENhbWVyYSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5jYW1lcmFcbn1cblxuVmlldy5wcm90b3R5cGUuY2FtZXJhUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdGVtcG9yYXJ5UG9zaXRpb24ubXVsdGlwbHlTY2FsYXIoMClcbiAgdGVtcG9yYXJ5UG9zaXRpb24uYXBwbHlNYXRyaXg0KHRoaXMuY2FtZXJhLm1hdHJpeFdvcmxkKVxuICByZXR1cm4gW3RlbXBvcmFyeVBvc2l0aW9uLngsIHRlbXBvcmFyeVBvc2l0aW9uLnksIHRlbXBvcmFyeVBvc2l0aW9uLnpdXG59XG5cblZpZXcucHJvdG90eXBlLmNhbWVyYVZlY3RvciA9IGZ1bmN0aW9uKCkge1xuICB0ZW1wb3JhcnlWZWN0b3IubXVsdGlwbHlTY2FsYXIoMClcbiAgdGVtcG9yYXJ5VmVjdG9yLnogPSAtMVxuICB0aGlzLmNhbWVyYS5tYXRyaXhXb3JsZC5yb3RhdGVBeGlzKHRlbXBvcmFyeVZlY3RvcilcbiAgcmV0dXJuIFt0ZW1wb3JhcnlWZWN0b3IueCwgdGVtcG9yYXJ5VmVjdG9yLnksIHRlbXBvcmFyeVZlY3Rvci56XVxufVxuXG5WaWV3LnByb3RvdHlwZS5yZXNpemVXaW5kb3cgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmICh0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgIHdpZHRoID0gd2lkdGggfHwgdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQuY2xpZW50V2lkdGhcbiAgICBoZWlnaHQgPSBoZWlnaHQgfHwgdGhpcy5lbGVtZW50LnBhcmVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gIH1cblxuICB0aGlzLmNhbWVyYS5hc3BlY3QgPSB0aGlzLmFzcGVjdFJhdGlvID0gd2lkdGgvaGVpZ2h0XG4gIHRoaXMud2lkdGggPSB3aWR0aFxuICB0aGlzLmhlaWdodCA9IGhlaWdodFxuXG4gIHRoaXMuY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKVxuXG4gIHRoaXMucmVuZGVyZXIuc2V0U2l6ZSggd2lkdGgsIGhlaWdodCApXG59XG5cblZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHRoaXMucmVuZGVyZXIucmVuZGVyKHNjZW5lLCB0aGlzLmNhbWVyYSlcbn1cblxuVmlldy5wcm90b3R5cGUuYXBwZW5kVG8gPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ29iamVjdCcpIHtcbiAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudClcbiAgfVxuICBlbHNlIHtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudClcbiAgfVxuXG4gIHRoaXMucmVzaXplV2luZG93KHRoaXMud2lkdGgsdGhpcy5oZWlnaHQpXG59IiwidmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IEhpZ2hsaWdodGVyXG5cbmZ1bmN0aW9uIEhpZ2hsaWdodGVyKGdhbWUsIG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhpZ2hsaWdodGVyKSkgcmV0dXJuIG5ldyBIaWdobGlnaHRlcihnYW1lLCBvcHRzKVxuICB0aGlzLmdhbWUgPSBnYW1lXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnkgPSBvcHRzLmdlb21ldHJ5IHx8IG5ldyBnYW1lLlRIUkVFLkN1YmVHZW9tZXRyeSgxLCAxLCAxKVxuICB2YXIgbWF0ZXJpYWwgPSBvcHRzLm1hdGVyaWFsIHx8IG5ldyBnYW1lLlRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICBjb2xvcjogb3B0cy5jb2xvciB8fCAweDAwMDAwMCxcbiAgICB3aXJlZnJhbWU6IHRydWUsXG4gICAgd2lyZWZyYW1lTGluZXdpZHRoOiBvcHRzLndpcmVmcmFtZUxpbmV3aWR0aCB8fCAzLFxuICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgIG9wYWNpdHk6IG9wdHMud2lyZWZyYW1lT3BhY2l0eSB8fCAwLjVcbiAgfSlcbiAgdGhpcy5tZXNoID0gbmV3IGdhbWUuVEhSRUUuTWVzaChnZW9tZXRyeSwgbWF0ZXJpYWwpXG4gIHRoaXMuZGlzdGFuY2UgPSBvcHRzLmRpc3RhbmNlIHx8IDEwXG4gIHRoaXMuY3VyclZveGVsUG9zIC8vIHVuZGVmaW5lZCB3aGVuIG5vIHZveGVsIHNlbGVjdGVkIGZvciBoaWdobGlnaHRcbiAgdGhpcy5jdXJyVm94ZWxBZGogLy8gdW5kZWZpbmVkIHdoZW4gbm8gYWRqYWNlbnQgdm94ZWwgc2VsZWN0ZWQgZm9yIGhpZ2hsaWdodFxuICB0aGlzLnRhcmdldFBvc2l0aW9uIC8vIGRlc2lyZWQgcG9zaXRpb24gb2YgaGlnaGxpZ2h0IGN1YmUgY2VudGVyXG4gIFxuICAvLyB0aGUgYWRqYWNlbnQgaGlnaGxpZ2h0IHdpbGwgYmUgYWN0aXZlIHdoZW4gdGhlIGZvbGxvd2luZyByZXR1cm5zIHRydWVcbiAgdGhpcy5hZGphY2VudEFjdGl2ZSA9IG9wdHMuYWRqYWNlbnRBY3RpdmUgfHwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2FtZS5jb250cm9scy5zdGF0ZS5hbHQgfVxuICBcbiAgLy8gdGhlIHNlbGVjdGlvbiBoaWdobGlnaHQgd2lsbCBiZSBhY3RpdmUgd2hlbiB0aGUgZm9sbG93aW5nIHJldHVybnMgdHJ1ZVxuICB0aGlzLnNlbGVjdEFjdGl2ZSA9IG9wdHMuc2VsZWN0QWN0aXZlIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdhbWUuY29udHJvbHMuc3RhdGUuc2VsZWN0IH1cbiAgXG4gIC8vIGFuaW1hdGUgaGlnaGxpZ2h0IHRyYW5zaXRpb25zP1xuICB0aGlzLmFuaW1hdGUgPSBvcHRzLmFuaW1hdGVcbiAgdGhpcy5hbmltYXRlRnVuY3Rpb24gPSBvcHRzLmFuaW1hdGVGdW5jdGlvbiB8fCBmdW5jdGlvbiAocG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBkZWx0YVRpbWUpIHtcbiAgICBpZiAoIXBvc2l0aW9uIHx8ICF0YXJnZXRQb3NpdGlvbiB8fCAhZGVsdGFUaW1lKSByZXR1cm47XG4gICAgdmFyIHJhdGUgPSAxMFxuICAgIGlmIChNYXRoLmFicyh0YXJnZXRQb3NpdGlvblswXSAtIHBvc2l0aW9uWzBdKSA8IDAuMDVcbiAgICAgJiYgTWF0aC5hYnModGFyZ2V0UG9zaXRpb25bMV0gLSBwb3NpdGlvblsxXSkgPCAwLjA1XG4gICAgICYmIE1hdGguYWJzKHRhcmdldFBvc2l0aW9uWzJdIC0gcG9zaXRpb25bMl0pIDwgMC4wNSkge1xuICAgICAgcmV0dXJuIHRhcmdldFBvc2l0aW9uIC8vIGNsb3NlIGVub3VnaCB0byBzbmFwIGFuZCBiZSBkb25lXG4gICAgfVxuICAgIGRlbHRhVGltZSA9IGRlbHRhVGltZSAvIDEwMDAgLy8gdXN1YWxseSBhcm91bmQgLjAxNiBzZWNvbmRzICg2MCBGUFMpXG4gICAgcG9zaXRpb25bMF0gKz0gcmF0ZSAqIGRlbHRhVGltZSAqICh0YXJnZXRQb3NpdGlvblswXSAtIHBvc2l0aW9uWzBdKVxuICAgIHBvc2l0aW9uWzFdICs9IHJhdGUgKiBkZWx0YVRpbWUgKiAodGFyZ2V0UG9zaXRpb25bMV0gLSBwb3NpdGlvblsxXSlcbiAgICBwb3NpdGlvblsyXSArPSByYXRlICogZGVsdGFUaW1lICogKHRhcmdldFBvc2l0aW9uWzJdIC0gcG9zaXRpb25bMl0pXG4gICAgcmV0dXJuIHBvc2l0aW9uXG4gIH1cblxuICAvLyBoaWdobGlnaHQgJ2Vhc2luZycgYW5pbWF0aW9uLCBjYWxsZWQgZXZlcnkgdGljayBpZiBlbmFibGVkXG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAodGhpcy5hbmltYXRlKSBnYW1lLm9uKCd0aWNrJywgZnVuY3Rpb24gKGR0KSB7XG4gICAgdmFyIHBvc2l0aW9uID0gW3NlbGYubWVzaC5wb3NpdGlvbi54LCBzZWxmLm1lc2gucG9zaXRpb24ueSwgc2VsZi5tZXNoLnBvc2l0aW9uLnpdXG4gICAgcG9zaXRpb24gPSBzZWxmLmFuaW1hdGVGdW5jdGlvbihwb3NpdGlvbiwgc2VsZi50YXJnZXRQb3NpdGlvbiwgZHQpXG4gICAgaWYgKHBvc2l0aW9uKSBzZWxmLm1lc2gucG9zaXRpb24uc2V0KHBvc2l0aW9uWzBdLCBwb3NpdGlvblsxXSwgcG9zaXRpb25bMl0pXG4gIH0pXG5cbiAgZ2FtZS5vbigndGljaycsIF8udGhyb3R0bGUodGhpcy5oaWdobGlnaHQuYmluZCh0aGlzKSwgb3B0cy5mcmVxdWVuY3kgfHwgMTAwKSlcbiAgXG4gIC8vIGFuY2hvcnMgZm9yIG11bHRpLXZveGVsIHNlbGVjdGlvblxuICB0aGlzLnNlbGVjdFN0YXJ0XG4gIHRoaXMuc2VsZWN0RW5kXG59XG5cbmluaGVyaXRzKEhpZ2hsaWdodGVyLCBldmVudHMuRXZlbnRFbWl0dGVyKVxuXG5IaWdobGlnaHRlci5wcm90b3R5cGUuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuXG4gIHZhciBjcCA9IHRoaXMuZ2FtZS5jYW1lcmFQb3NpdGlvbigpXG4gIHZhciBjdiA9IHRoaXMuZ2FtZS5jYW1lcmFWZWN0b3IoKVxuICB2YXIgaGl0ID0gdGhpcy5nYW1lLnJheWNhc3RWb3hlbHMoY3AsIGN2LCB0aGlzLmRpc3RhbmNlKVxuICB2YXIgdGFyZ2V0UG9zaXRpb25DYW5kaWRhdGVcblxuICB2YXIgcmVtb3ZlQWRqYWNlbnQgPSBmdW5jdGlvbiAoc2VsZikgeyAvLyByZW1vdmUgYWRqYWNlbnQgaGlnaGxpZ2h0IGlmIGFueVxuICAgIGlmICghc2VsZi5jdXJyVm94ZWxBZGopIHJldHVybjtcbiAgICBzZWxmLmVtaXQoJ3JlbW92ZS1hZGphY2VudCcsIHNlbGYuY3VyclZveGVsQWRqKVxuICAgIHNlbGYuY3VyclZveGVsQWRqID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyByZW1vdmUgZXhpc3RpbmcgaGlnaGxpZ2h0IGlmIGFueVxuICBpZiAoIWhpdCkge1xuICAgIGlmICghdGhpcy5jdXJyVm94ZWxQb3MpIHJldHVybjsgLy8gYWxyZWFkeSByZW1vdmVkXG4gICAgdGhpcy5nYW1lLnNjZW5lLnJlbW92ZSh0aGlzLm1lc2gpXG4gICAgdGhpcy5lbWl0KCdyZW1vdmUnLCB0aGlzLmN1cnJWb3hlbFBvcy5zbGljZSgpKVxuICAgIHRoaXMuY3VyclZveGVsUG9zID0gdW5kZWZpbmVkXG4gICAgcmVtb3ZlQWRqYWNlbnQodGhpcylcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmV3Vm94ZWxQb3MgPSBoaXQudm94ZWxcbiAgaWYgKCF0aGlzLmN1cnJWb3hlbFBvc1xuICAgIHx8IG5ld1ZveGVsUG9zWzBdICE9PSB0aGlzLmN1cnJWb3hlbFBvc1swXVxuICAgIHx8IG5ld1ZveGVsUG9zWzFdICE9PSB0aGlzLmN1cnJWb3hlbFBvc1sxXVxuICAgIHx8IG5ld1ZveGVsUG9zWzJdICE9PSB0aGlzLmN1cnJWb3hlbFBvc1syXSkgeyAvLyBubyBjdXJyZW50IGhpZ2hsaWdodCBvciBpdCBtb3ZlZFxuXG4gICAgaWYgKHRoaXMuY3VyclZveGVsUG9zKSB7XG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZScsIHRoaXMuY3VyclZveGVsUG9zLnNsaWNlKCkpIC8vIG1vdmVkIGhpZ2hsaWdodFxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuZ2FtZS5zY2VuZS5hZGQodGhpcy5tZXNoKSAvLyBmcmVzaCBoaWdobGlnaHRcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdoaWdobGlnaHQnLCBuZXdWb3hlbFBvcy5zbGljZSgpKVxuICAgIHRoaXMuY3VyclZveGVsUG9zID0gbmV3Vm94ZWxQb3Muc2xpY2UoKVxuICB9XG4gIC8vIHRyeSB0byBzZXQgdGhlIHBvc2l0aW9uIGV2ZXJ5IHRpbWUsIGl0IG1heSBiZSBvdmVycmlkZGVuIGJlbG93XG4gIHRhcmdldFBvc2l0aW9uQ2FuZGlkYXRlID0gW3RoaXMuY3VyclZveGVsUG9zWzBdICsgMC41LCB0aGlzLmN1cnJWb3hlbFBvc1sxXSArIDAuNSwgdGhpcy5jdXJyVm94ZWxQb3NbMl0gKyAwLjVdXG5cbiAgLy8gaWYgaW4gXCJhZGphY2VudFwiIG1vZGUsIGhpZ2hsaWdodCBhZGphY2VudCB2b3hlbCBpbnN0ZWFkXG4gIGlmICh0aGlzLmFkamFjZW50QWN0aXZlKCkpIHtcbiAgICAvLyBzaW5jZSB3ZSBnb3QgaGVyZSwgd2Uga25vdyB3ZSBoYXZlIGEgc2VsZWN0ZWQgbm9uLWVtcHR5IHZveGVsXG4gICAgLy8gYW5kIHdpdGggYW4gZW1wdHkgYWRqYWNlbnQgdm94ZWwgdGhhdCB3ZSBjYW4gd29yayB3aXRoXG4gICAgdmFyIG5ld1ZveGVsQWRqID0gaGl0LmFkamFjZW50XG4gICAgaWYgKCF0aGlzLmN1cnJWb3hlbEFkalxuICAgICAgfHwgbmV3Vm94ZWxBZGpbMF0gIT09IHRoaXMuY3VyclZveGVsQWRqWzBdXG4gICAgICB8fCBuZXdWb3hlbEFkalsxXSAhPT0gdGhpcy5jdXJyVm94ZWxBZGpbMV1cbiAgICAgIHx8IG5ld1ZveGVsQWRqWzJdICE9PSB0aGlzLmN1cnJWb3hlbEFkalsyXSkgeyAvLyBubyBjdXJyZW50IGFkaiBoaWdobGlnaHQgb3IgaXQgaGFzIG1vdmVkXG4gIFxuICAgICAgaWYgKHRoaXMuY3VyclZveGVsQWRqKSB7XG4gICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlLWFkamFjZW50JywgdGhpcy5jdXJyVm94ZWxBZGouc2xpY2UoKSkgLy8gbW92ZWQgYWRqYWNlbnQgaGlnaGxpZ2h0XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoJ2hpZ2hsaWdodC1hZGphY2VudCcsIG5ld1ZveGVsQWRqLnNsaWNlKCkpXG4gICAgICBcbiAgICAgIHRoaXMuY3VyclZveGVsQWRqID0gbmV3Vm94ZWxBZGouc2xpY2UoKVxuICAgIH1cbiAgICB0YXJnZXRQb3NpdGlvbkNhbmRpZGF0ZSA9IFt0aGlzLmN1cnJWb3hlbEFkalswXSArIDAuNSwgdGhpcy5jdXJyVm94ZWxBZGpbMV0gKyAwLjUsIHRoaXMuY3VyclZveGVsQWRqWzJdICsgMC41XVxuICB9XG4gIGVsc2UgcmVtb3ZlQWRqYWNlbnQodGhpcylcblxuICAvLyBpZiBpbiBcInNlbGVjdFwiIG1vZGUsIHRyYWNrIHN0YXJ0IGFuZCBlbmQgdm94ZWwgYm91bmRzXG4gIGlmICh0aGlzLnNlbGVjdEFjdGl2ZSgpKSB7XG4gICAgaWYgKCF0aGlzLnNlbGVjdFN0YXJ0KSB7IC8vIHN0YXJ0IGEgbmV3IHNlbGVjdGlvblxuICAgICAgdGhpcy5zZWxlY3RTdGFydCA9IHRoaXMuc2VsZWN0RW5kID0gdGhpcy5jdXJyVm94ZWxBZGogfHwgdGhpcy5jdXJyVm94ZWxQb3NcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgZW5kQ2FuZGlkYXRlID0gdGhpcy5jdXJyVm94ZWxBZGogfHwgdGhpcy5jdXJyVm94ZWxQb3NcbiAgICAgIGlmIChlbmRDYW5kaWRhdGVbMF0gIT09IHRoaXMuc2VsZWN0RW5kWzBdXG4gICAgICAgfHwgZW5kQ2FuZGlkYXRlWzFdICE9PSB0aGlzLnNlbGVjdEVuZFsxXVxuICAgICAgIHx8IGVuZENhbmRpZGF0ZVsyXSAhPT0gdGhpcy5zZWxlY3RFbmRbMl0pIHsgXG4gICAgICAgICBcbiAgICAgICAgdGhpcy5zZWxlY3RFbmQgPSBlbmRDYW5kaWRhdGUgLy8gc2VsZWN0aW9uIGVuZCBoYXMgY2hhbmdlZFxuICAgICAgICBcbiAgICAgICAgdGhpcy5lbWl0KCdoaWdobGlnaHQtc2VsZWN0JywgeyBzdGFydDogdGhpcy5zZWxlY3RTdGFydC5zbGljZSgpLCBlbmQ6IHRoaXMuc2VsZWN0RW5kLnNsaWNlKCkgfSlcbiAgICAgICAgXG4gICAgICAgIHZhciBzY2FsZSA9IFtdXG4gICAgICAgIHNjYWxlWzBdID0gTWF0aC5hYnModGhpcy5zZWxlY3RFbmRbMF0gLSB0aGlzLnNlbGVjdFN0YXJ0WzBdKSArIDFcbiAgICAgICAgc2NhbGVbMV0gPSBNYXRoLmFicyh0aGlzLnNlbGVjdEVuZFsxXSAtIHRoaXMuc2VsZWN0U3RhcnRbMV0pICsgMVxuICAgICAgICBzY2FsZVsyXSA9IE1hdGguYWJzKHRoaXMuc2VsZWN0RW5kWzJdIC0gdGhpcy5zZWxlY3RTdGFydFsyXSkgKyAxXG4gICAgICAgIHRoaXMubWVzaC5zY2FsZS5zZXQoc2NhbGVbMF0sIHNjYWxlWzFdLCBzY2FsZVsyXSlcbiAgICAgICAgXG4gICAgICAgIHZhciBwb3MgPSBbXVxuICAgICAgICBwb3NbMF0gPSB0aGlzLnNlbGVjdFN0YXJ0WzBdICsgMC41ICsgKHRoaXMuc2VsZWN0RW5kWzBdIC0gdGhpcy5zZWxlY3RTdGFydFswXSkgLyAyXG4gICAgICAgIHBvc1sxXSA9IHRoaXMuc2VsZWN0U3RhcnRbMV0gKyAwLjUgKyAodGhpcy5zZWxlY3RFbmRbMV0gLSB0aGlzLnNlbGVjdFN0YXJ0WzFdKSAvIDJcbiAgICAgICAgcG9zWzJdID0gdGhpcy5zZWxlY3RTdGFydFsyXSArIDAuNSArICh0aGlzLnNlbGVjdEVuZFsyXSAtIHRoaXMuc2VsZWN0U3RhcnRbMl0pIC8gMlxuICAgICAgICB0aGlzLnRhcmdldFBvc2l0aW9uID0gcG9zXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIGlmICh0aGlzLnNlbGVjdFN0YXJ0KSB7XG4gICAgICB0aGlzLmVtaXQoJ2hpZ2hsaWdodC1kZXNlbGVjdCcsIHsgc3RhcnQ6IHRoaXMuc2VsZWN0U3RhcnQuc2xpY2UoKSwgZW5kOiB0aGlzLnNlbGVjdEVuZC5zbGljZSgpIH0pXG4gICAgICB0aGlzLnNlbGVjdFN0YXJ0ID0gbnVsbFxuICAgICAgdGhpcy5tZXNoLnNjYWxlLnNldCgxLCAxLCAxKVxuICAgIH1cbiAgICB0aGlzLnRhcmdldFBvc2l0aW9uID0gdGFyZ2V0UG9zaXRpb25DYW5kaWRhdGUgLy8gaGlnaGxpZ2h0ZWQgdm94ZWwgb3IgYWRqYWNlbnRcbiAgfVxuICBpZiAoIXRoaXMuYW5pbWF0ZSkgdGhpcy5tZXNoLnBvc2l0aW9uLnNldCh0aGlzLnRhcmdldFBvc2l0aW9uWzBdLCB0aGlzLnRhcmdldFBvc2l0aW9uWzFdLCB0aGlzLnRhcmdldFBvc2l0aW9uWzJdKVxufVxuIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS40LjRcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTMgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIEluYy5cbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGdsb2JhbGAgb24gdGhlIHNlcnZlci5cbiAgdmFyIHJvb3QgPSB0aGlzO1xuXG4gIC8vIFNhdmUgdGhlIHByZXZpb3VzIHZhbHVlIG9mIHRoZSBgX2AgdmFyaWFibGUuXG4gIHZhciBwcmV2aW91c1VuZGVyc2NvcmUgPSByb290Ll87XG5cbiAgLy8gRXN0YWJsaXNoIHRoZSBvYmplY3QgdGhhdCBnZXRzIHJldHVybmVkIHRvIGJyZWFrIG91dCBvZiBhIGxvb3AgaXRlcmF0aW9uLlxuICB2YXIgYnJlYWtlciA9IHt9O1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICAgIGNvbmNhdCAgICAgICAgICAgPSBBcnJheVByb3RvLmNvbmNhdCxcbiAgICAgIHRvU3RyaW5nICAgICAgICAgPSBPYmpQcm90by50b1N0cmluZyxcbiAgICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUZvckVhY2ggICAgICA9IEFycmF5UHJvdG8uZm9yRWFjaCxcbiAgICBuYXRpdmVNYXAgICAgICAgICAgPSBBcnJheVByb3RvLm1hcCxcbiAgICBuYXRpdmVSZWR1Y2UgICAgICAgPSBBcnJheVByb3RvLnJlZHVjZSxcbiAgICBuYXRpdmVSZWR1Y2VSaWdodCAgPSBBcnJheVByb3RvLnJlZHVjZVJpZ2h0LFxuICAgIG5hdGl2ZUZpbHRlciAgICAgICA9IEFycmF5UHJvdG8uZmlsdGVyLFxuICAgIG5hdGl2ZUV2ZXJ5ICAgICAgICA9IEFycmF5UHJvdG8uZXZlcnksXG4gICAgbmF0aXZlU29tZSAgICAgICAgID0gQXJyYXlQcm90by5zb21lLFxuICAgIG5hdGl2ZUluZGV4T2YgICAgICA9IEFycmF5UHJvdG8uaW5kZXhPZixcbiAgICBuYXRpdmVMYXN0SW5kZXhPZiAgPSBBcnJheVByb3RvLmxhc3RJbmRleE9mLFxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQ7XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0IHZpYSBhIHN0cmluZyBpZGVudGlmaWVyLFxuICAvLyBmb3IgQ2xvc3VyZSBDb21waWxlciBcImFkdmFuY2VkXCIgbW9kZS5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS40LjQnO1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgb2JqZWN0cyB3aXRoIHRoZSBidWlsdC1pbiBgZm9yRWFjaGAsIGFycmF5cywgYW5kIHJhdyBvYmplY3RzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgZm9yRWFjaGAgaWYgYXZhaWxhYmxlLlxuICB2YXIgZWFjaCA9IF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgICBpZiAobmF0aXZlRm9yRWFjaCAmJiBvYmouZm9yRWFjaCA9PT0gbmF0aXZlRm9yRWFjaCkge1xuICAgICAgb2JqLmZvckVhY2goaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAob2JqLmxlbmd0aCA9PT0gK29iai5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGJyZWFrZXIpIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoXy5oYXMob2JqLCBrZXkpKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2tleV0sIGtleSwgb2JqKSA9PT0gYnJlYWtlcikgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0b3IgdG8gZWFjaCBlbGVtZW50LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgbWFwYCBpZiBhdmFpbGFibGUuXG4gIF8ubWFwID0gXy5jb2xsZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0cztcbiAgICBpZiAobmF0aXZlTWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkgcmV0dXJuIG9iai5tYXAoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGhdID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIHZhciByZWR1Y2VFcnJvciA9ICdSZWR1Y2Ugb2YgZW1wdHkgYXJyYXkgd2l0aCBubyBpbml0aWFsIHZhbHVlJztcblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGByZWR1Y2VgIGlmIGF2YWlsYWJsZS5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgdmFyIGluaXRpYWwgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICBpZiAob2JqID09IG51bGwpIG9iaiA9IFtdO1xuICAgIGlmIChuYXRpdmVSZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgICBpZiAoY29udGV4dCkgaXRlcmF0b3IgPSBfLmJpbmQoaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgICAgcmV0dXJuIGluaXRpYWwgPyBvYmoucmVkdWNlKGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2UoaXRlcmF0b3IpO1xuICAgIH1cbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIWluaXRpYWwpIHtcbiAgICAgICAgbWVtbyA9IHZhbHVlO1xuICAgICAgICBpbml0aWFsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG1lbW8sIHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBUaGUgcmlnaHQtYXNzb2NpYXRpdmUgdmVyc2lvbiBvZiByZWR1Y2UsIGFsc28ga25vd24gYXMgYGZvbGRyYC5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYHJlZHVjZVJpZ2h0YCBpZiBhdmFpbGFibGUuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgbWVtbywgY29udGV4dCkge1xuICAgIHZhciBpbml0aWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gICAgaWYgKG9iaiA9PSBudWxsKSBvYmogPSBbXTtcbiAgICBpZiAobmF0aXZlUmVkdWNlUmlnaHQgJiYgb2JqLnJlZHVjZVJpZ2h0ID09PSBuYXRpdmVSZWR1Y2VSaWdodCkge1xuICAgICAgaWYgKGNvbnRleHQpIGl0ZXJhdG9yID0gXy5iaW5kKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICAgIHJldHVybiBpbml0aWFsID8gb2JqLnJlZHVjZVJpZ2h0KGl0ZXJhdG9yLCBtZW1vKSA6IG9iai5yZWR1Y2VSaWdodChpdGVyYXRvcik7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSBvYmoubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09ICtsZW5ndGgpIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB9XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaW5kZXggPSBrZXlzID8ga2V5c1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgIGlmICghaW5pdGlhbCkge1xuICAgICAgICBtZW1vID0gb2JqW2luZGV4XTtcbiAgICAgICAgaW5pdGlhbCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZW1vID0gaXRlcmF0b3IuY2FsbChjb250ZXh0LCBtZW1vLCBvYmpbaW5kZXhdLCBpbmRleCwgbGlzdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFpbml0aWFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKHJlZHVjZUVycm9yKTtcbiAgICByZXR1cm4gbWVtbztcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQ7XG4gICAgYW55KG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSB7XG4gICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBmaWx0ZXJgIGlmIGF2YWlsYWJsZS5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdHM7XG4gICAgaWYgKG5hdGl2ZUZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHJldHVybiBvYmouZmlsdGVyKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzW3Jlc3VsdHMubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuICFpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgfSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBldmVyeWAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgfHwgKGl0ZXJhdG9yID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChuYXRpdmVFdmVyeSAmJiBvYmouZXZlcnkgPT09IG5hdGl2ZUV2ZXJ5KSByZXR1cm4gb2JqLmV2ZXJ5KGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAoIShyZXN1bHQgPSByZXN1bHQgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpKSkgcmV0dXJuIGJyZWFrZXI7XG4gICAgfSk7XG4gICAgcmV0dXJuICEhcmVzdWx0O1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgc29tZWAgaWYgYXZhaWxhYmxlLlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICB2YXIgYW55ID0gXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgfHwgKGl0ZXJhdG9yID0gXy5pZGVudGl0eSk7XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAobmF0aXZlU29tZSAmJiBvYmouc29tZSA9PT0gbmF0aXZlU29tZSkgcmV0dXJuIG9iai5zb21lKGl0ZXJhdG9yLCBjb250ZXh0KTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICBpZiAocmVzdWx0IHx8IChyZXN1bHQgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkpKSByZXR1cm4gYnJlYWtlcjtcbiAgICB9KTtcbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiB2YWx1ZSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgdGFyZ2V0KSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG5hdGl2ZUluZGV4T2YgJiYgb2JqLmluZGV4T2YgPT09IG5hdGl2ZUluZGV4T2YpIHJldHVybiBvYmouaW5kZXhPZih0YXJnZXQpICE9IC0xO1xuICAgIHJldHVybiBhbnkob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSB0YXJnZXQ7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gSW52b2tlIGEgbWV0aG9kICh3aXRoIGFyZ3VtZW50cykgb24gZXZlcnkgaXRlbSBpbiBhIGNvbGxlY3Rpb24uXG4gIF8uaW52b2tlID0gZnVuY3Rpb24ob2JqLCBtZXRob2QpIHtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgaXNGdW5jID0gXy5pc0Z1bmN0aW9uKG1ldGhvZCk7XG4gICAgcmV0dXJuIF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiAoaXNGdW5jID8gbWV0aG9kIDogdmFsdWVbbWV0aG9kXSkuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKXsgcmV0dXJuIHZhbHVlW2tleV07IH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMsIGZpcnN0KSB7XG4gICAgaWYgKF8uaXNFbXB0eShhdHRycykpIHJldHVybiBmaXJzdCA/IG51bGwgOiBbXTtcbiAgICByZXR1cm4gX1tmaXJzdCA/ICdmaW5kJyA6ICdmaWx0ZXInXShvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcbiAgICAgICAgaWYgKGF0dHJzW2tleV0gIT09IHZhbHVlW2tleV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8ud2hlcmUob2JqLCBhdHRycywgdHJ1ZSk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtYXhpbXVtIGVsZW1lbnQgb3IgKGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICAvLyBDYW4ndCBvcHRpbWl6ZSBhcnJheXMgb2YgaW50ZWdlcnMgbG9uZ2VyIHRoYW4gNjUsNTM1IGVsZW1lbnRzLlxuICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD04MDc5N1xuICBfLm1heCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNBcnJheShvYmopICYmIG9ialswXSA9PT0gK29ialswXSAmJiBvYmoubGVuZ3RoIDwgNjU1MzUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heC5hcHBseShNYXRoLCBvYmopO1xuICAgIH1cbiAgICBpZiAoIWl0ZXJhdG9yICYmIF8uaXNFbXB0eShvYmopKSByZXR1cm4gLUluZmluaXR5O1xuICAgIHZhciByZXN1bHQgPSB7Y29tcHV0ZWQgOiAtSW5maW5pdHksIHZhbHVlOiAtSW5maW5pdHl9O1xuICAgIGVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGl0ZXJhdG9yID8gaXRlcmF0b3IuY2FsbChjb250ZXh0LCB2YWx1ZSwgaW5kZXgsIGxpc3QpIDogdmFsdWU7XG4gICAgICBjb21wdXRlZCA+PSByZXN1bHQuY29tcHV0ZWQgJiYgKHJlc3VsdCA9IHt2YWx1ZSA6IHZhbHVlLCBjb21wdXRlZCA6IGNvbXB1dGVkfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0FycmF5KG9iaikgJiYgb2JqWzBdID09PSArb2JqWzBdICYmIG9iai5sZW5ndGggPCA2NTUzNSkge1xuICAgICAgcmV0dXJuIE1hdGgubWluLmFwcGx5KE1hdGgsIG9iaik7XG4gICAgfVxuICAgIGlmICghaXRlcmF0b3IgJiYgXy5pc0VtcHR5KG9iaikpIHJldHVybiBJbmZpbml0eTtcbiAgICB2YXIgcmVzdWx0ID0ge2NvbXB1dGVkIDogSW5maW5pdHksIHZhbHVlOiBJbmZpbml0eX07XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgdmFyIGNvbXB1dGVkID0gaXRlcmF0b3IgPyBpdGVyYXRvci5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgbGlzdCkgOiB2YWx1ZTtcbiAgICAgIGNvbXB1dGVkIDwgcmVzdWx0LmNvbXB1dGVkICYmIChyZXN1bHQgPSB7dmFsdWUgOiB2YWx1ZSwgY29tcHV0ZWQgOiBjb21wdXRlZH0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhbiBhcnJheS5cbiAgXy5zaHVmZmxlID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHJhbmQ7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBbXTtcbiAgICBlYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbShpbmRleCsrKTtcbiAgICAgIHNodWZmbGVkW2luZGV4IC0gMV0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGxvb2t1cCBpdGVyYXRvcnMuXG4gIHZhciBsb29rdXBJdGVyYXRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG9iail7IHJldHVybiBvYmpbdmFsdWVdOyB9O1xuICB9O1xuXG4gIC8vIFNvcnQgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiBwcm9kdWNlZCBieSBhbiBpdGVyYXRvci5cbiAgXy5zb3J0QnkgPSBmdW5jdGlvbihvYmosIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IodmFsdWUpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZSA6IHZhbHVlLFxuICAgICAgICBpbmRleCA6IGluZGV4LFxuICAgICAgICBjcml0ZXJpYSA6IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBsaXN0KVxuICAgICAgfTtcbiAgICB9KS5zb3J0KGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgICB2YXIgYSA9IGxlZnQuY3JpdGVyaWE7XG4gICAgICB2YXIgYiA9IHJpZ2h0LmNyaXRlcmlhO1xuICAgICAgaWYgKGEgIT09IGIpIHtcbiAgICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHZvaWQgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhIDwgYiB8fCBiID09PSB2b2lkIDApIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsZWZ0LmluZGV4IDwgcmlnaHQuaW5kZXggPyAtMSA6IDE7XG4gICAgfSksICd2YWx1ZScpO1xuICB9O1xuXG4gIC8vIEFuIGludGVybmFsIGZ1bmN0aW9uIHVzZWQgZm9yIGFnZ3JlZ2F0ZSBcImdyb3VwIGJ5XCIgb3BlcmF0aW9ucy5cbiAgdmFyIGdyb3VwID0gZnVuY3Rpb24ob2JqLCB2YWx1ZSwgY29udGV4dCwgYmVoYXZpb3IpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGl0ZXJhdG9yID0gbG9va3VwSXRlcmF0b3IodmFsdWUgfHwgXy5pZGVudGl0eSk7XG4gICAgZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgdmFyIGtleSA9IGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgYmVoYXZpb3IocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIEdyb3VwcyB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uLiBQYXNzIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGVcbiAgLy8gdG8gZ3JvdXAgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBjcml0ZXJpb24uXG4gIF8uZ3JvdXBCeSA9IGZ1bmN0aW9uKG9iaiwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZ3JvdXAob2JqLCB2YWx1ZSwgY29udGV4dCwgZnVuY3Rpb24ocmVzdWx0LCBrZXksIHZhbHVlKSB7XG4gICAgICAoXy5oYXMocmVzdWx0LCBrZXkpID8gcmVzdWx0W2tleV0gOiAocmVzdWx0W2tleV0gPSBbXSkpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvdW50cyBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IHRoYXQgZ3JvdXAgYnkgYSBjZXJ0YWluIGNyaXRlcmlvbi4gUGFzc1xuICAvLyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlIHRvIGNvdW50IGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgLy8gY3JpdGVyaW9uLlxuICBfLmNvdW50QnkgPSBmdW5jdGlvbihvYmosIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGdyb3VwKG9iaiwgdmFsdWUsIGNvbnRleHQsIGZ1bmN0aW9uKHJlc3VsdCwga2V5KSB7XG4gICAgICBpZiAoIV8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0gPSAwO1xuICAgICAgcmVzdWx0W2tleV0rKztcbiAgICB9KTtcbiAgfTtcblxuICAvLyBVc2UgYSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRvIGZpZ3VyZSBvdXQgdGhlIHNtYWxsZXN0IGluZGV4IGF0IHdoaWNoXG4gIC8vIGFuIG9iamVjdCBzaG91bGQgYmUgaW5zZXJ0ZWQgc28gYXMgdG8gbWFpbnRhaW4gb3JkZXIuIFVzZXMgYmluYXJ5IHNlYXJjaC5cbiAgXy5zb3J0ZWRJbmRleCA9IGZ1bmN0aW9uKGFycmF5LCBvYmosIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0b3IgPSBpdGVyYXRvciA9PSBudWxsID8gXy5pZGVudGl0eSA6IGxvb2t1cEl0ZXJhdG9yKGl0ZXJhdG9yKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgIHZhciBtaWQgPSAobG93ICsgaGlnaCkgPj4+IDE7XG4gICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGFycmF5W21pZF0pIDwgdmFsdWUgPyBsb3cgPSBtaWQgKyAxIDogaGlnaCA9IG1pZDtcbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfTtcblxuICAvLyBTYWZlbHkgY29udmVydCBhbnl0aGluZyBpdGVyYWJsZSBpbnRvIGEgcmVhbCwgbGl2ZSBhcnJheS5cbiAgXy50b0FycmF5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBbXTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikpIHJldHVybiBzbGljZS5jYWxsKG9iaik7XG4gICAgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIChvYmoubGVuZ3RoID09PSArb2JqLmxlbmd0aCkgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIEFycmF5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS1cblxuICAvLyBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gdGhlIGZpcnN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gQWxpYXNlZCBhcyBgaGVhZGAgYW5kIGB0YWtlYC4gVGhlICoqZ3VhcmQqKiBjaGVja1xuICAvLyBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8uZmlyc3QgPSBfLmhlYWQgPSBfLnRha2UgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIHZvaWQgMDtcbiAgICByZXR1cm4gKG4gIT0gbnVsbCkgJiYgIWd1YXJkID8gc2xpY2UuY2FsbChhcnJheSwgMCwgbikgOiBhcnJheVswXTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoXG4gIC8vIGBfLm1hcGAuXG4gIF8uaW5pdGlhbCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAoKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbikpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS4gVGhlICoqZ3VhcmQqKiBjaGVjayBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBfLm1hcGAuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmICgobiAhPSBudWxsKSAmJiAhZ3VhcmQpIHtcbiAgICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBNYXRoLm1heChhcnJheS5sZW5ndGggLSBuLCAwKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuIFRoZSAqKmd1YXJkKipcbiAgLy8gY2hlY2sgYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLnJlc3QgPSBfLnRhaWwgPSBfLmRyb3AgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgKG4gPT0gbnVsbCkgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBvdXRwdXQpIHtcbiAgICBlYWNoKGlucHV0LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgc2hhbGxvdyA/IHB1c2guYXBwbHkob3V0cHV0LCB2YWx1ZSkgOiBmbGF0dGVuKHZhbHVlLCBzaGFsbG93LCBvdXRwdXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29tcGxldGVseSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbiBhcnJheS5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgW10pO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdG9yO1xuICAgICAgaXRlcmF0b3IgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBpbml0aWFsID0gaXRlcmF0b3IgPyBfLm1hcChhcnJheSwgaXRlcmF0b3IsIGNvbnRleHQpIDogYXJyYXk7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGVhY2goaW5pdGlhbCwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICBpZiAoaXNTb3J0ZWQgPyAoIWluZGV4IHx8IHNlZW5bc2Vlbi5sZW5ndGggLSAxXSAhPT0gdmFsdWUpIDogIV8uY29udGFpbnMoc2VlbiwgdmFsdWUpKSB7XG4gICAgICAgIHNlZW4ucHVzaCh2YWx1ZSk7XG4gICAgICAgIHJlc3VsdHMucHVzaChhcnJheVtpbmRleF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIGFyZ3VtZW50cykpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHJldHVybiBfLmZpbHRlcihfLnVuaXEoYXJyYXkpLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gXy5ldmVyeShyZXN0LCBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICByZXR1cm4gXy5pbmRleE9mKG90aGVyLCBpdGVtKSA+PSAwO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVGFrZSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIG9uZSBhcnJheSBhbmQgYSBudW1iZXIgb2Ygb3RoZXIgYXJyYXlzLlxuICAvLyBPbmx5IHRoZSBlbGVtZW50cyBwcmVzZW50IGluIGp1c3QgdGhlIGZpcnN0IGFycmF5IHdpbGwgcmVtYWluLlxuICBfLmRpZmZlcmVuY2UgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN0ID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7IHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7IH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGxlbmd0aCA9IF8ubWF4KF8ucGx1Y2soYXJncywgJ2xlbmd0aCcpKTtcbiAgICB2YXIgcmVzdWx0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdHNbaV0gPSBfLnBsdWNrKGFyZ3MsIFwiXCIgKyBpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIGlmIChsaXN0ID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICByZXN1bHRbbGlzdFtpXV0gPSB2YWx1ZXNbaV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbbGlzdFtpXVswXV0gPSBsaXN0W2ldWzFdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIElmIHRoZSBicm93c2VyIGRvZXNuJ3Qgc3VwcGx5IHVzIHdpdGggaW5kZXhPZiAoSSdtIGxvb2tpbmcgYXQgeW91LCAqKk1TSUUqKiksXG4gIC8vIHdlIG5lZWQgdGhpcyBmdW5jdGlvbi4gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhblxuICAvLyBpdGVtIGluIGFuIGFycmF5LCBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgaW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlzU29ydGVkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiAtMTtcbiAgICB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICBpZiAodHlwZW9mIGlzU29ydGVkID09ICdudW1iZXInKSB7XG4gICAgICAgIGkgPSAoaXNTb3J0ZWQgPCAwID8gTWF0aC5tYXgoMCwgbCArIGlzU29ydGVkKSA6IGlzU29ydGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSBfLnNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2ldID09PSBpdGVtID8gaSA6IC0xO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmF0aXZlSW5kZXhPZiAmJiBhcnJheS5pbmRleE9mID09PSBuYXRpdmVJbmRleE9mKSByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtLCBpc1NvcnRlZCk7XG4gICAgZm9yICg7IGkgPCBsOyBpKyspIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBsYXN0SW5kZXhPZmAgaWYgYXZhaWxhYmxlLlxuICBfLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGZyb20pIHtcbiAgICBpZiAoYXJyYXkgPT0gbnVsbCkgcmV0dXJuIC0xO1xuICAgIHZhciBoYXNJbmRleCA9IGZyb20gIT0gbnVsbDtcbiAgICBpZiAobmF0aXZlTGFzdEluZGV4T2YgJiYgYXJyYXkubGFzdEluZGV4T2YgPT09IG5hdGl2ZUxhc3RJbmRleE9mKSB7XG4gICAgICByZXR1cm4gaGFzSW5kZXggPyBhcnJheS5sYXN0SW5kZXhPZihpdGVtLCBmcm9tKSA6IGFycmF5Lmxhc3RJbmRleE9mKGl0ZW0pO1xuICAgIH1cbiAgICB2YXIgaSA9IChoYXNJbmRleCA/IGZyb20gOiBhcnJheS5sZW5ndGgpO1xuICAgIHdoaWxlIChpLS0pIGlmIChhcnJheVtpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBhcmd1bWVudHNbMl0gfHwgMTtcblxuICAgIHZhciBsZW4gPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIHJhbmdlID0gbmV3IEFycmF5KGxlbik7XG5cbiAgICB3aGlsZShpZHggPCBsZW4pIHtcbiAgICAgIHJhbmdlW2lkeCsrXSA9IHN0YXJ0O1xuICAgICAgc3RhcnQgKz0gc3RlcDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBDcmVhdGUgYSBmdW5jdGlvbiBib3VuZCB0byBhIGdpdmVuIG9iamVjdCAoYXNzaWduaW5nIGB0aGlzYCwgYW5kIGFyZ3VtZW50cyxcbiAgLy8gb3B0aW9uYWxseSkuIERlbGVnYXRlcyB0byAqKkVDTUFTY3JpcHQgNSoqJ3MgbmF0aXZlIGBGdW5jdGlvbi5iaW5kYCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIF8uYmluZCA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQpIHtcbiAgICBpZiAoZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kICYmIG5hdGl2ZUJpbmQpIHJldHVybiBuYXRpdmVCaW5kLmFwcGx5KGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBCaW5kIGFsbCBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXRcbiAgLy8gYWxsIGNhbGxiYWNrcyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBmdW5jcyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoZnVuY3MubGVuZ3RoID09PSAwKSBmdW5jcyA9IF8uZnVuY3Rpb25zKG9iaik7XG4gICAgZWFjaChmdW5jcywgZnVuY3Rpb24oZikgeyBvYmpbZl0gPSBfLmJpbmQob2JqW2ZdLCBvYmopOyB9KTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vID0ge307XG4gICAgaGFzaGVyIHx8IChoYXNoZXIgPSBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5ID0gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gXy5oYXMobWVtbywga2V5KSA/IG1lbW9ba2V5XSA6IChtZW1vW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgcmV0dXJuIGZ1bmMuYXBwbHkobnVsbCwgYXJncyk7IH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gZnVuY3Rpb24oZnVuYykge1xuICAgIHJldHVybiBfLmRlbGF5LmFwcGx5KF8sIFtmdW5jLCAxXS5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCB3aGVuIGludm9rZWQsIHdpbGwgb25seSBiZSB0cmlnZ2VyZWQgYXQgbW9zdCBvbmNlXG4gIC8vIGR1cmluZyBhIGdpdmVuIHdpbmRvdyBvZiB0aW1lLlxuICBfLnRocm90dGxlID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBjb250ZXh0LCBhcmdzLCB0aW1lb3V0LCByZXN1bHQ7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gbmV3IERhdGU7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gbmV3IERhdGU7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDApIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgcHJldmlvdXMgPSBub3c7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0KSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCByZXN1bHQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgIH07XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcbiAgICAgIGlmIChjYWxsTm93KSByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIHJhbiA9IGZhbHNlLCBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyYW4pIHJldHVybiBtZW1vO1xuICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gW2Z1bmNdO1xuICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIHdyYXBwZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZnVuY3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBmb3IgKHZhciBpID0gZnVuY3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJncyA9IFtmdW5jc1tpXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBhZnRlciBiZWluZyBjYWxsZWQgTiB0aW1lcy5cbiAgXy5hZnRlciA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgaWYgKHRpbWVzIDw9IDApIHJldHVybiBmdW5jKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSZXRyaWV2ZSB0aGUgbmFtZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBuYXRpdmVLZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogIT09IE9iamVjdChvYmopKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9iamVjdCcpO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5c1trZXlzLmxlbmd0aF0gPSBrZXk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgdGhlIHZhbHVlcyBvZiBhbiBvYmplY3QncyBwcm9wZXJ0aWVzLlxuICBfLnZhbHVlcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSB2YWx1ZXMucHVzaChvYmpba2V5XSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBwYWlycyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGlmIChfLmhhcyhvYmosIGtleSkpIHBhaXJzLnB1c2goW2tleSwgb2JqW2tleV1dKTtcbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSByZXN1bHRbb2JqW2tleV1dID0ga2V5O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgIG9ialtwcm9wXSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5waWNrID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGNvcHkgPSB7fTtcbiAgICB2YXIga2V5cyA9IGNvbmNhdC5hcHBseShBcnJheVByb3RvLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGVhY2goa2V5cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoa2V5IGluIG9iaikgY29weVtrZXldID0gb2JqW2tleV07XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH07XG5cbiAgIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCB3aXRob3V0IHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLm9taXQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgY29weSA9IHt9O1xuICAgIHZhciBrZXlzID0gY29uY2F0LmFwcGx5KEFycmF5UHJvdG8sIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKCFfLmNvbnRhaW5zKGtleXMsIGtleSkpIGNvcHlba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbiAgfTtcblxuICAvLyBGaWxsIGluIGEgZ2l2ZW4gb2JqZWN0IHdpdGggZGVmYXVsdCBwcm9wZXJ0aWVzLlxuICBfLmRlZmF1bHRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChzbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIGZ1bmN0aW9uKHNvdXJjZSkge1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChvYmpbcHJvcF0gPT0gbnVsbCkgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBDcmVhdGUgYSAoc2hhbGxvdy1jbG9uZWQpIGR1cGxpY2F0ZSBvZiBhbiBvYmplY3QuXG4gIF8uY2xvbmUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gXy5pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IF8uZXh0ZW5kKHt9LCBvYmopO1xuICB9O1xuXG4gIC8vIEludm9rZXMgaW50ZXJjZXB0b3Igd2l0aCB0aGUgb2JqLCBhbmQgdGhlbiByZXR1cm5zIG9iai5cbiAgLy8gVGhlIHByaW1hcnkgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sIGluXG4gIC8vIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICBfLnRhcCA9IGZ1bmN0aW9uKG9iaiwgaW50ZXJjZXB0b3IpIHtcbiAgICBpbnRlcmNlcHRvcihvYmopO1xuICAgIHJldHVybiBvYmo7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBIYXJtb255IGBlZ2FsYCBwcm9wb3NhbDogaHR0cDovL3dpa2kuZWNtYXNjcmlwdC5vcmcvZG9rdS5waHA/aWQ9aGFybW9ueTplZ2FsLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT0gdG9TdHJpbmcuY2FsbChiKSkgcmV0dXJuIGZhbHNlO1xuICAgIHN3aXRjaCAoY2xhc3NOYW1lKSB7XG4gICAgICAvLyBTdHJpbmdzLCBudW1iZXJzLCBkYXRlcywgYW5kIGJvb2xlYW5zIGFyZSBjb21wYXJlZCBieSB2YWx1ZS5cbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuIGEgPT0gU3RyaW5nKGIpO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS4gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvclxuICAgICAgICAvLyBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuIGEgIT0gK2EgPyBiICE9ICtiIDogKGEgPT0gMCA/IDEgLyBhID09IDEgLyBiIDogYSA9PSArYik7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT0gK2I7XG4gICAgICAvLyBSZWdFeHBzIGFyZSBjb21wYXJlZCBieSB0aGVpciBzb3VyY2UgcGF0dGVybnMgYW5kIGZsYWdzLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgICAgcmV0dXJuIGEuc291cmNlID09IGIuc291cmNlICYmXG4gICAgICAgICAgICAgICBhLmdsb2JhbCA9PSBiLmdsb2JhbCAmJlxuICAgICAgICAgICAgICAgYS5tdWx0aWxpbmUgPT0gYi5tdWx0aWxpbmUgJiZcbiAgICAgICAgICAgICAgIGEuaWdub3JlQ2FzZSA9PSBiLmlnbm9yZUNhc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09IGEpIHJldHVybiBiU3RhY2tbbGVuZ3RoXSA9PSBiO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGZpcnN0IG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgYVN0YWNrLnB1c2goYSk7XG4gICAgYlN0YWNrLnB1c2goYik7XG4gICAgdmFyIHNpemUgPSAwLCByZXN1bHQgPSB0cnVlO1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChjbGFzc05hbWUgPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBzaXplID0gYS5sZW5ndGg7XG4gICAgICByZXN1bHQgPSBzaXplID09IGIubGVuZ3RoO1xuICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gZXEoYVtzaXplXSwgYltzaXplXSwgYVN0YWNrLCBiU3RhY2spKSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0cyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVpdmFsZW50LCBidXQgYE9iamVjdGBzXG4gICAgICAvLyBmcm9tIGRpZmZlcmVudCBmcmFtZXMgYXJlLlxuICAgICAgdmFyIGFDdG9yID0gYS5jb25zdHJ1Y3RvciwgYkN0b3IgPSBiLmNvbnN0cnVjdG9yO1xuICAgICAgaWYgKGFDdG9yICE9PSBiQ3RvciAmJiAhKF8uaXNGdW5jdGlvbihhQ3RvcikgJiYgKGFDdG9yIGluc3RhbmNlb2YgYUN0b3IpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiAoYkN0b3IgaW5zdGFuY2VvZiBiQ3RvcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIERlZXAgY29tcGFyZSBvYmplY3RzLlxuICAgICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgICAgaWYgKF8uaGFzKGEsIGtleSkpIHtcbiAgICAgICAgICAvLyBDb3VudCB0aGUgZXhwZWN0ZWQgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIC8vIERlZXAgY29tcGFyZSBlYWNoIG1lbWJlci5cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPSBfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRW5zdXJlIHRoYXQgYm90aCBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXMuXG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIGZvciAoa2V5IGluIGIpIHtcbiAgICAgICAgICBpZiAoXy5oYXMoYiwga2V5KSAmJiAhKHNpemUtLSkpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9ICFzaXplO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYiwgW10sIFtdKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIGFycmF5LCBzdHJpbmcsIG9yIG9iamVjdCBlbXB0eT9cbiAgLy8gQW4gXCJlbXB0eVwiIG9iamVjdCBoYXMgbm8gZW51bWVyYWJsZSBvd24tcHJvcGVydGllcy5cbiAgXy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoXy5pc0FycmF5KG9iaikgfHwgXy5pc1N0cmluZyhvYmopKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhIERPTSBlbGVtZW50P1xuICBfLmlzRWxlbWVudCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiAhIShvYmogJiYgb2JqLm5vZGVUeXBlID09PSAxKTtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGFuIGFycmF5P1xuICAvLyBEZWxlZ2F0ZXMgdG8gRUNNQTUncyBuYXRpdmUgQXJyYXkuaXNBcnJheVxuICBfLmlzQXJyYXkgPSBuYXRpdmVJc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IE9iamVjdChvYmopO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLlxuICBlYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUpLCB3aGVyZVxuICAvLyB0aGVyZSBpc24ndCBhbnkgaW5zcGVjdGFibGUgXCJBcmd1bWVudHNcIiB0eXBlLlxuICBpZiAoIV8uaXNBcmd1bWVudHMoYXJndW1lbnRzKSkge1xuICAgIF8uaXNBcmd1bWVudHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiAhIShvYmogJiYgXy5oYXMob2JqLCAnY2FsbGVlJykpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuXG4gIGlmICh0eXBlb2YgKC8uLykgIT09ICdmdW5jdGlvbicpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgZXF1YWwgdG8gbnVsbD9cbiAgXy5pc051bGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSBudWxsO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgdW5kZWZpbmVkP1xuICBfLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gdm9pZCAwO1xuICB9O1xuXG4gIC8vIFNob3J0Y3V0IGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gcHJvcGVydHkgZGlyZWN0bHlcbiAgLy8gb24gaXRzZWxmIChpbiBvdGhlciB3b3Jkcywgbm90IG9uIGEgcHJvdG90eXBlKS5cbiAgXy5oYXMgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbiAgfTtcblxuICAvLyBVdGlsaXR5IEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJ1biBVbmRlcnNjb3JlLmpzIGluICpub0NvbmZsaWN0KiBtb2RlLCByZXR1cm5pbmcgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHNcbiAgLy8gcHJldmlvdXMgb3duZXIuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcbiAgICByb290Ll8gPSBwcmV2aW91c1VuZGVyc2NvcmU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gS2VlcCB0aGUgaWRlbnRpdHkgZnVuY3Rpb24gYXJvdW5kIGZvciBkZWZhdWx0IGl0ZXJhdG9ycy5cbiAgXy5pZGVudGl0eSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGkpO1xuICAgIHJldHVybiBhY2N1bTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBiZXR3ZWVuIG1pbiBhbmQgbWF4IChpbmNsdXNpdmUpLlxuICBfLnJhbmRvbSA9IGZ1bmN0aW9uKG1pbiwgbWF4KSB7XG4gICAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgICBtYXggPSBtaW47XG4gICAgICBtaW4gPSAwO1xuICAgIH1cbiAgICByZXR1cm4gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcbiAgfTtcblxuICAvLyBMaXN0IG9mIEhUTUwgZW50aXRpZXMgZm9yIGVzY2FwaW5nLlxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgIGVzY2FwZToge1xuICAgICAgJyYnOiAnJmFtcDsnLFxuICAgICAgJzwnOiAnJmx0OycsXG4gICAgICAnPic6ICcmZ3Q7JyxcbiAgICAgICdcIic6ICcmcXVvdDsnLFxuICAgICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICAgJy8nOiAnJiN4MkY7J1xuICAgIH1cbiAgfTtcbiAgZW50aXR5TWFwLnVuZXNjYXBlID0gXy5pbnZlcnQoZW50aXR5TWFwLmVzY2FwZSk7XG5cbiAgLy8gUmVnZXhlcyBjb250YWluaW5nIHRoZSBrZXlzIGFuZCB2YWx1ZXMgbGlzdGVkIGltbWVkaWF0ZWx5IGFib3ZlLlxuICB2YXIgZW50aXR5UmVnZXhlcyA9IHtcbiAgICBlc2NhcGU6ICAgbmV3IFJlZ0V4cCgnWycgKyBfLmtleXMoZW50aXR5TWFwLmVzY2FwZSkuam9pbignJykgKyAnXScsICdnJyksXG4gICAgdW5lc2NhcGU6IG5ldyBSZWdFeHAoJygnICsgXy5rZXlzKGVudGl0eU1hcC51bmVzY2FwZSkuam9pbignfCcpICsgJyknLCAnZycpXG4gIH07XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICBfLmVhY2goWydlc2NhcGUnLCAndW5lc2NhcGUnXSwgZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgX1ttZXRob2RdID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICBpZiAoc3RyaW5nID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIHJldHVybiAoJycgKyBzdHJpbmcpLnJlcGxhY2UoZW50aXR5UmVnZXhlc1ttZXRob2RdLCBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgICByZXR1cm4gZW50aXR5TWFwW21ldGhvZF1bbWF0Y2hdO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBwcm9wZXJ0eSBpcyBhIGZ1bmN0aW9uIHRoZW4gaW52b2tlIGl0O1xuICAvLyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gQWRkIHlvdXIgb3duIGN1c3RvbSBmdW5jdGlvbnMgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLm1peGluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKXtcbiAgICAgIHZhciBmdW5jID0gX1tuYW1lXSA9IG9ialtuYW1lXTtcbiAgICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gW3RoaXMuX3dyYXBwZWRdO1xuICAgICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHQnOiAgICAgJ3QnLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHR8XFx1MjAyOHxcXHUyMDI5L2c7XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gICAgdmFyIHJlbmRlcjtcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgICAgICAucmVwbGFjZShlc2NhcGVyLCBmdW5jdGlvbihtYXRjaCkgeyByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07IH0pO1xuXG4gICAgICBpZiAoZXNjYXBlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIicrXFxuKChfX3Q9KFwiICsgZXNjYXBlICsgXCIpKT09bnVsbD8nJzpfLmVzY2FwZShfX3QpKStcXG4nXCI7XG4gICAgICB9XG4gICAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9XG4gICAgICBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cbiAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgXCJyZXR1cm4gX19wO1xcblwiO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSkgcmV0dXJuIHJlbmRlcihkYXRhLCBfKTtcbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIChzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJykgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbiwgd2hpY2ggd2lsbCBkZWxlZ2F0ZSB0byB0aGUgd3JhcHBlci5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfKG9iaikuY2hhaW4oKTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoYWluID8gXyhvYmopLmNoYWluKCkgOiBvYmo7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydwb3AnLCAncHVzaCcsICdyZXZlcnNlJywgJ3NoaWZ0JywgJ3NvcnQnLCAnc3BsaWNlJywgJ3Vuc2hpZnQnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fd3JhcHBlZDtcbiAgICAgIG1ldGhvZC5hcHBseShvYmosIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoKG5hbWUgPT0gJ3NoaWZ0JyB8fCBuYW1lID09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdC5jYWxsKHRoaXMsIG9iaik7XG4gICAgfTtcbiAgfSk7XG5cbiAgLy8gQWRkIGFsbCBhY2Nlc3NvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIGVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQuY2FsbCh0aGlzLCBtZXRob2QuYXBwbHkodGhpcy5fd3JhcHBlZCwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG5cbiAgXy5leHRlbmQoXy5wcm90b3R5cGUsIHtcblxuICAgIC8vIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgICBjaGFpbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9jaGFpbiA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRXh0cmFjdHMgdGhlIHJlc3VsdCBmcm9tIGEgd3JhcHBlZCBhbmQgY2hhaW5lZCBvYmplY3QuXG4gICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBwZWQ7XG4gICAgfVxuXG4gIH0pO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwidmFyIHNraW4gPSByZXF1aXJlKCdtaW5lY3JhZnQtc2tpbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChnYW1lKSB7XG4gICAgdmFyIG1vdW50UG9pbnQ7XG4gICAgdmFyIHBvc3Nlc3NlZDtcbiAgICBcbiAgICByZXR1cm4gZnVuY3Rpb24gKGltZywgc2tpbk9wdHMpIHtcbiAgICAgICAgaWYgKCFza2luT3B0cykge1xuICAgICAgICAgIHNraW5PcHRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgc2tpbk9wdHMuc2NhbGUgPSBza2luT3B0cy5zY2FsZSB8fCBuZXcgZ2FtZS5USFJFRS5WZWN0b3IzKDAuMDQsIDAuMDQsIDAuMDQpO1xuICAgICAgICB2YXIgcGxheWVyU2tpbiA9IHNraW4oZ2FtZS5USFJFRSwgaW1nLCBza2luT3B0cyk7XG4gICAgICAgIHZhciBwbGF5ZXIgPSBwbGF5ZXJTa2luLm1lc2g7XG4gICAgICAgIHZhciBwaHlzaWNzID0gZ2FtZS5tYWtlUGh5c2ljYWwocGxheWVyKTtcbiAgICAgICAgcGh5c2ljcy5wbGF5ZXJTa2luID0gcGxheWVyU2tpbjtcbiAgICAgICAgXG4gICAgICAgIHBsYXllci5wb3NpdGlvbi5zZXQoMCwgNTYyLCAtMjApO1xuICAgICAgICBnYW1lLnNjZW5lLmFkZChwbGF5ZXIpO1xuICAgICAgICBnYW1lLmFkZEl0ZW0ocGh5c2ljcyk7XG4gICAgICAgIFxuICAgICAgICBwaHlzaWNzLnlhdyA9IHBsYXllcjtcbiAgICAgICAgcGh5c2ljcy5waXRjaCA9IHBsYXllci5oZWFkO1xuICAgICAgICBwaHlzaWNzLnN1YmplY3RUbyhnYW1lLmdyYXZpdHkpO1xuICAgICAgICBwaHlzaWNzLmJsb2Nrc0NyZWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIGdhbWUuY29udHJvbChwaHlzaWNzKTtcbiAgICAgICAgXG4gICAgICAgIHBoeXNpY3MubW92ZSA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgICAgICB2YXIgeHl6ID0gcGFyc2VYWVooeCwgeSwgeik7XG4gICAgICAgICAgICBwaHlzaWNzLnlhdy5wb3NpdGlvbi54ICs9IHh5ei54O1xuICAgICAgICAgICAgcGh5c2ljcy55YXcucG9zaXRpb24ueSArPSB4eXoueTtcbiAgICAgICAgICAgIHBoeXNpY3MueWF3LnBvc2l0aW9uLnogKz0geHl6Lno7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBwaHlzaWNzLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5LCB6KSB7XG4gICAgICAgICAgICB2YXIgeHl6ID0gcGFyc2VYWVooeCwgeSwgeik7XG4gICAgICAgICAgICBwaHlzaWNzLnlhdy5wb3NpdGlvbi54ID0geHl6Lng7XG4gICAgICAgICAgICBwaHlzaWNzLnlhdy5wb3NpdGlvbi55ID0geHl6Lnk7XG4gICAgICAgICAgICBwaHlzaWNzLnlhdy5wb3NpdGlvbi56ID0geHl6Lno7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgcG92ID0gMTtcbiAgICAgICAgcGh5c2ljcy5wb3YgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdmaXJzdCcgfHwgdHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHBvdiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAndGhpcmQnIHx8IHR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBwb3YgPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGh5c2ljcy5wb3NzZXNzKCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBwaHlzaWNzLnRvZ2dsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHBoeXNpY3MucG92KHBvdiA9PT0gMSA/IDMgOiAxKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHBoeXNpY3MucG9zc2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChwb3NzZXNzZWQpIHBvc3Nlc3NlZC5yZW1vdmUoZ2FtZS5jYW1lcmEpO1xuICAgICAgICAgICAgdmFyIGtleSA9IHBvdiA9PT0gMSA/ICdjYW1lcmFJbnNpZGUnIDogJ2NhbWVyYU91dHNpZGUnO1xuICAgICAgICAgICAgcGxheWVyW2tleV0uYWRkKGdhbWUuY2FtZXJhKTtcbiAgICAgICAgICAgIHBvc3Nlc3NlZCA9IHBsYXllcltrZXldO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgcGh5c2ljcy5wb3NpdGlvbiA9IHBoeXNpY3MueWF3LnBvc2l0aW9uO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHBoeXNpY3M7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gcGFyc2VYWVogKHgsIHksIHopIHtcbiAgICBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogeFswXSwgeTogeFsxXSwgejogeFsyXSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgeCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogeC54IHx8IDAsIHk6IHgueSB8fCAwLCB6OiB4LnogfHwgMCB9O1xuICAgIH1cbiAgICByZXR1cm4geyB4OiBOdW1iZXIoeCksIHk6IE51bWJlcih5KSwgejogTnVtYmVyKHopIH07XG59XG4iLCJ2YXIgVEhSRUVcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0aHJlZSwgaW1hZ2UsIHNpemVSYXRpbykge1xuICByZXR1cm4gbmV3IFNraW4odGhyZWUsIGltYWdlLCBzaXplUmF0aW8pXG59XG5cbmZ1bmN0aW9uIFNraW4odGhyZWUsIGltYWdlLCBvcHRzKSB7XG4gIGlmIChvcHRzKSBvcHRzLmltYWdlID0gb3B0cy5pbWFnZSB8fCBpbWFnZVxuICBlbHNlIG9wdHMgPSB7IGltYWdlOiBpbWFnZSB9XG4gIGlmICh0eXBlb2YgaW1hZ2UgPT09ICdvYmplY3QnICYmICEoaW1hZ2UgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIG9wdHMgPSBpbWFnZVxuICBUSFJFRSA9IHRocmVlIC8vIGhhY2sgdW50aWwgdGhyZWUuanMgZml4ZXMgbXVsdGlwbGUgaW5zdGFudGlhdGlvblxuICB0aGlzLnNpemVSYXRpbyA9IG9wdHMuc2l6ZVJhdGlvIHx8IDhcbiAgdGhpcy5zY2FsZSA9IG9wdHMuc2NhbGUgfHwgbmV3IHRocmVlLlZlY3RvcjMoMSwgMSwgMSlcbiAgdGhpcy5mYWxsYmFja0ltYWdlID0gb3B0cy5mYWxsYmFja0ltYWdlIHx8ICdza2luLnBuZydcbiAgdGhpcy5jcmVhdGVDYW52YXNlcygpXG4gIHRoaXMuY2hhck1hdGVyaWFsID0gdGhpcy5nZXRNYXRlcmlhbCh0aGlzLnNraW4sIGZhbHNlKVxuXHR0aGlzLmNoYXJNYXRlcmlhbFRyYW5zID0gdGhpcy5nZXRNYXRlcmlhbCh0aGlzLnNraW4sIHRydWUpXG4gIGlmICh0eXBlb2Ygb3B0cy5pbWFnZSA9PT0gXCJzdHJpbmdcIikgdGhpcy5mZXRjaEltYWdlKG9wdHMuaW1hZ2UpXG4gIGlmIChvcHRzLmltYWdlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHRoaXMuc2V0SW1hZ2Uob3B0cy5pbWFnZSlcbiAgdGhpcy5tZXNoID0gdGhpcy5jcmVhdGVQbGF5ZXJPYmplY3QoKVxufVxuXG5Ta2luLnByb3RvdHlwZS5jcmVhdGVDYW52YXNlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnNraW5CaWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxuICB0aGlzLnNraW5CaWdDb250ZXh0ID0gdGhpcy5za2luQmlnLmdldENvbnRleHQoJzJkJylcbiAgdGhpcy5za2luQmlnLndpZHRoID0gNjQgKiB0aGlzLnNpemVSYXRpb1xuICB0aGlzLnNraW5CaWcuaGVpZ2h0ID0gMzIgKiB0aGlzLnNpemVSYXRpb1xuICBcbiAgdGhpcy5za2luID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgdGhpcy5za2luQ29udGV4dCA9IHRoaXMuc2tpbi5nZXRDb250ZXh0KCcyZCcpXG4gIHRoaXMuc2tpbi53aWR0aCA9IDY0XG4gIHRoaXMuc2tpbi5oZWlnaHQgPSAzMlxufVxuXG5Ta2luLnByb3RvdHlwZS5mZXRjaEltYWdlID0gZnVuY3Rpb24oaW1hZ2VVUkwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMuaW1hZ2UgPSBuZXcgSW1hZ2UoKVxuICB0aGlzLmltYWdlLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cydcbiAgdGhpcy5pbWFnZS5zcmMgPSBpbWFnZVVSTFxuICB0aGlzLmltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuc2V0SW1hZ2Uoc2VsZi5pbWFnZSlcbiAgfVxufVxuXG5Ta2luLnByb3RvdHlwZS5zZXRJbWFnZSA9IGZ1bmN0aW9uIChza2luKSB7XG4gIHRoaXMuaW1hZ2UgPSBza2luXG4gIHRoaXMuc2tpbkNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIDY0LCAzMik7XG4gIFxuICB0aGlzLnNraW5Db250ZXh0LmRyYXdJbWFnZShza2luLCAwLCAwKTtcbiAgXG4gIHZhciBpbWdkYXRhID0gdGhpcy5za2luQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgNjQsIDMyKTtcbiAgdmFyIHBpeGVscyA9IGltZ2RhdGEuZGF0YTtcblxuICB0aGlzLnNraW5CaWdDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLnNraW5CaWcud2lkdGgsIHRoaXMuc2tpbkJpZy5oZWlnaHQpO1xuICB0aGlzLnNraW5CaWdDb250ZXh0LnNhdmUoKTtcbiAgXG4gIHZhciBpc09uZWNvbG9yID0gdHJ1ZTtcbiAgXG4gIHZhciBjb2xvckNoZWNrQWdhaW5zdCA9IFs0MCwgMF07XG4gIHZhciBjb2xvckluZGV4ID0gKGNvbG9yQ2hlY2tBZ2FpbnN0WzBdK2NvbG9yQ2hlY2tBZ2FpbnN0WzFdKjY0KSo0O1xuICBcbiAgdmFyIGlzUGl4ZWxEaWZmZXJlbnQgPSBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmKHBpeGVsc1soeCt5KjY0KSo0KzBdICE9PSBwaXhlbHNbY29sb3JJbmRleCswXSB8fCBwaXhlbHNbKHgreSo2NCkqNCsxXSAhPT0gcGl4ZWxzW2NvbG9ySW5kZXgrMV0gfHwgcGl4ZWxzWyh4K3kqNjQpKjQrMl0gIT09IHBpeGVsc1tjb2xvckluZGV4KzJdIHx8IHBpeGVsc1soeCt5KjY0KSo0KzNdICE9PSBwaXhlbHNbY29sb3JJbmRleCszXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgXG4gIC8vIENoZWNrIGlmIGhlbG1ldC9oYXQgaXMgYSBzb2xpZCBjb2xvclxuICAvLyBCb3R0b20gcm93XG4gIGZvcih2YXIgaT0zMjsgaSA8IDY0OyBpKz0xKSB7XG4gICAgZm9yKHZhciBqPTg7IGogPCAxNjsgais9MSkge1xuICAgICAgaWYoaXNQaXhlbERpZmZlcmVudChpLCBqKSkge1xuICAgICAgICBpc09uZWNvbG9yID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZighaXNPbmVjb2xvcikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmKCFpc09uZWNvbG9yKSB7XG4gICAgLy8gVG9wIHJvd1xuICAgIGZvcih2YXIgaT00MDsgaSA8IDU2OyBpKz0xKSB7XG4gICAgICBmb3IodmFyIGo9MDsgaiA8IDg7IGorPTEpIHtcbiAgICAgICAgaWYoaXNQaXhlbERpZmZlcmVudChpLCBqKSkge1xuICAgICAgICAgIGlzT25lY29sb3IgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoIWlzT25lY29sb3IpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICB9XG4gIH1cbiAgXG4gIGZvcih2YXIgaT0wOyBpIDwgNjQ7IGkrPTEpIHtcbiAgICBmb3IodmFyIGo9MDsgaiA8IDMyOyBqKz0xKSB7XG4gICAgICBpZihpc09uZWNvbG9yICYmICgoaSA+PSAzMiAmJiBpIDwgNjQgJiYgaiA+PSA4ICYmIGogPCAxNikgfHwgKGkgPj0gNDAgJiYgaSA8IDU2ICYmIGogPj0gMCAmJiBqIDwgOCkpKSB7XG4gICAgICAgIHBpeGVsc1soaStqKjY0KSo0KzNdID0gMFxuICAgICAgfVxuICAgICAgdGhpcy5za2luQmlnQ29udGV4dC5maWxsU3R5bGUgPSAncmdiYSgnK3BpeGVsc1soaStqKjY0KSo0KzBdKycsICcrcGl4ZWxzWyhpK2oqNjQpKjQrMV0rJywgJytwaXhlbHNbKGkraio2NCkqNCsyXSsnLCAnK3BpeGVsc1soaStqKjY0KSo0KzNdLzI1NSsnKSc7XG4gICAgICB0aGlzLnNraW5CaWdDb250ZXh0LmZpbGxSZWN0KGkgKiB0aGlzLnNpemVSYXRpbywgaiAqIHRoaXMuc2l6ZVJhdGlvLCB0aGlzLnNpemVSYXRpbywgdGhpcy5zaXplUmF0aW8pO1xuICAgIH1cbiAgfVxuICBcbiAgdGhpcy5za2luQmlnQ29udGV4dC5yZXN0b3JlKCk7XG4gIFxuICB0aGlzLnNraW5Db250ZXh0LnB1dEltYWdlRGF0YShpbWdkYXRhLCAwLCAwKTtcbiAgXG4gIHRoaXMuY2hhck1hdGVyaWFsLm1hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIHRoaXMuY2hhck1hdGVyaWFsVHJhbnMubWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgXG59O1xuXG5Ta2luLnByb3RvdHlwZS5nZXRNYXRlcmlhbCA9IGZ1bmN0aW9uKGltZywgdHJhbnNwYXJlbnQpIHtcbiAgdmFyIHRleHR1cmUgICAgPSBuZXcgVEhSRUUuVGV4dHVyZShpbWcpO1xuICB0ZXh0dXJlLm1hZ0ZpbHRlciAgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICB0ZXh0dXJlLm1pbkZpbHRlciAgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICB0ZXh0dXJlLmZvcm1hdCAgICA9IHRyYW5zcGFyZW50ID8gVEhSRUUuUkdCQUZvcm1hdCA6IFRIUkVFLlJHQkZvcm1hdDtcbiAgdGV4dHVyZS5uZWVkc1VwZGF0ZSAgPSB0cnVlO1xuICB2YXIgbWF0ZXJpYWwgID0gbmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICBtYXAgICAgOiB0ZXh0dXJlLFxuICAgIHRyYW5zcGFyZW50ICA6IHRyYW5zcGFyZW50ID8gdHJ1ZSA6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gbWF0ZXJpYWw7XG59XG5cblNraW4ucHJvdG90eXBlLlVWTWFwID0gZnVuY3Rpb24obWVzaCwgZmFjZSwgeCwgeSwgdywgaCwgcm90YXRlQnkpIHtcbiAgaWYgKCFyb3RhdGVCeSkgcm90YXRlQnkgPSAwO1xuICB2YXIgdXZzID0gbWVzaC5nZW9tZXRyeS5mYWNlVmVydGV4VXZzWzBdW2ZhY2VdO1xuICB2YXIgdGlsZVUgPSB4O1xuICB2YXIgdGlsZVYgPSB5O1xuICB2YXIgdGlsZVV2V2lkdGggPSAxLzY0O1xuICB2YXIgdGlsZVV2SGVpZ2h0ID0gMS8zMjtcbiAgdXZzWyAoMCArIHJvdGF0ZUJ5KSAlIDQgXS54ID0gKHRpbGVVICogdGlsZVV2V2lkdGgpXG4gIHV2c1sgKDAgKyByb3RhdGVCeSkgJSA0IF0ueSA9IDEgLSAodGlsZVYgKiB0aWxlVXZIZWlnaHQpXG4gIHV2c1sgKDEgKyByb3RhdGVCeSkgJSA0IF0ueCA9ICh0aWxlVSAqIHRpbGVVdldpZHRoKVxuICB1dnNbICgxICsgcm90YXRlQnkpICUgNCBdLnkgPSAxIC0gKHRpbGVWICogdGlsZVV2SGVpZ2h0ICsgaCAqIHRpbGVVdkhlaWdodClcbiAgdXZzWyAoMiArIHJvdGF0ZUJ5KSAlIDQgXS54ID0gKHRpbGVVICogdGlsZVV2V2lkdGggKyB3ICogdGlsZVV2V2lkdGgpXG4gIHV2c1sgKDIgKyByb3RhdGVCeSkgJSA0IF0ueSA9IDEgLSAodGlsZVYgKiB0aWxlVXZIZWlnaHQgKyBoICogdGlsZVV2SGVpZ2h0KVxuICB1dnNbICgzICsgcm90YXRlQnkpICUgNCBdLnggPSAodGlsZVUgKiB0aWxlVXZXaWR0aCArIHcgKiB0aWxlVXZXaWR0aClcbiAgdXZzWyAoMyArIHJvdGF0ZUJ5KSAlIDQgXS55ID0gMSAtICh0aWxlViAqIHRpbGVVdkhlaWdodClcbn1cblxuU2tpbi5wcm90b3R5cGUuY3ViZUZyb21QbGFuZXMgPSBmdW5jdGlvbiAoc2l6ZSwgbWF0KSB7XG4gIHZhciBjdWJlID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG4gIHZhciBtZXNoZXMgPSBbXTtcbiAgZm9yKHZhciBpPTA7IGkgPCA2OyBpKyspIHtcbiAgICB2YXIgbWVzaCA9IG5ldyBUSFJFRS5NZXNoKG5ldyBUSFJFRS5QbGFuZUdlb21ldHJ5KHNpemUsIHNpemUpLCBtYXQpO1xuICAgIG1lc2guZG91YmxlU2lkZWQgPSB0cnVlO1xuICAgIGN1YmUuYWRkKG1lc2gpO1xuICAgIG1lc2hlcy5wdXNoKG1lc2gpO1xuICB9XG4gIC8vIEZyb250XG4gIG1lc2hlc1swXS5yb3RhdGlvbi54ID0gTWF0aC5QSS8yO1xuICBtZXNoZXNbMF0ucm90YXRpb24ueiA9IC1NYXRoLlBJLzI7XG4gIG1lc2hlc1swXS5wb3NpdGlvbi54ID0gc2l6ZS8yO1xuICBcbiAgLy8gQmFja1xuICBtZXNoZXNbMV0ucm90YXRpb24ueCA9IE1hdGguUEkvMjtcbiAgbWVzaGVzWzFdLnJvdGF0aW9uLnogPSBNYXRoLlBJLzI7XG4gIG1lc2hlc1sxXS5wb3NpdGlvbi54ID0gLXNpemUvMjtcbiAgXG4gIC8vIFRvcFxuICBtZXNoZXNbMl0ucG9zaXRpb24ueSA9IHNpemUvMjtcbiAgXG4gIC8vIEJvdHRvbVxuICBtZXNoZXNbM10ucm90YXRpb24ueSA9IE1hdGguUEk7XG4gIG1lc2hlc1szXS5yb3RhdGlvbi56ID0gTWF0aC5QSTtcbiAgbWVzaGVzWzNdLnBvc2l0aW9uLnkgPSAtc2l6ZS8yO1xuICBcbiAgLy8gTGVmdFxuICBtZXNoZXNbNF0ucm90YXRpb24ueCA9IE1hdGguUEkvMjtcbiAgbWVzaGVzWzRdLnBvc2l0aW9uLnogPSBzaXplLzI7XG4gIFxuICAvLyBSaWdodFxuICBtZXNoZXNbNV0ucm90YXRpb24ueCA9IC1NYXRoLlBJLzI7XG4gIG1lc2hlc1s1XS5yb3RhdGlvbi55ID0gTWF0aC5QSTtcbiAgbWVzaGVzWzVdLnBvc2l0aW9uLnogPSAtc2l6ZS8yO1xuICBcbiAgcmV0dXJuIGN1YmU7XG59XG5cbi8vZXhwb3J0aW5nIHRoZXNlIG1lc2hlcyBmb3IgbWFuaXB1bGF0aW9uOlxuLy9sZWZ0TGVnXG4vL3JpZ2h0TGVnXG4vL2xlZnRBcm1cbi8vcmlnaHRBcm1cbi8vYm9keVxuLy9oZWFkXG5cblNraW4ucHJvdG90eXBlLmNyZWF0ZVBsYXllck9iamVjdCA9IGZ1bmN0aW9uKHNjZW5lKSB7XG4gIHZhciBoZWFkZ3JvdXAgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgdmFyIHVwcGVyYm9keSA9IHRoaXMudXBwZXJib2R5ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG4gIFxuICAvLyBMZWZ0IGxlZ1xuICB2YXIgbGVmdGxlZ2dlbyA9IG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoNCwgMTIsIDQpO1xuICBmb3IodmFyIGk9MDsgaSA8IDg7IGkrPTEpIHtcbiAgICBsZWZ0bGVnZ2VvLnZlcnRpY2VzW2ldLnkgLT0gNjtcbiAgfVxuICB2YXIgbGVmdGxlZyA9IHRoaXMubGVmdExlZyA9IG5ldyBUSFJFRS5NZXNoKGxlZnRsZWdnZW8sIHRoaXMuY2hhck1hdGVyaWFsKTtcbiAgbGVmdGxlZy5wb3NpdGlvbi56ID0gLTI7XG4gIGxlZnRsZWcucG9zaXRpb24ueSA9IC02O1xuICB0aGlzLlVWTWFwKGxlZnRsZWcsIDAsIDgsIDIwLCAtNCwgMTIpO1xuICB0aGlzLlVWTWFwKGxlZnRsZWcsIDEsIDE2LCAyMCwgLTQsIDEyKTtcbiAgdGhpcy5VVk1hcChsZWZ0bGVnLCAyLCA0LCAxNiwgNCwgNCwgMyk7XG4gIHRoaXMuVVZNYXAobGVmdGxlZywgMywgOCwgMjAsIDQsIC00LCAxKTtcbiAgdGhpcy5VVk1hcChsZWZ0bGVnLCA0LCAxMiwgMjAsIC00LCAxMik7XG4gIHRoaXMuVVZNYXAobGVmdGxlZywgNSwgNCwgMjAsIC00LCAxMik7XG5cbiAgLy8gUmlnaHQgbGVnXG4gIHZhciByaWdodGxlZ2dlbyA9IG5ldyBUSFJFRS5DdWJlR2VvbWV0cnkoNCwgMTIsIDQpO1xuICBmb3IodmFyIGk9MDsgaSA8IDg7IGkrPTEpIHtcbiAgICByaWdodGxlZ2dlby52ZXJ0aWNlc1tpXS55IC09IDY7XG4gIH1cbiAgdmFyIHJpZ2h0bGVnID0gdGhpcy5yaWdodExlZyA9bmV3IFRIUkVFLk1lc2gocmlnaHRsZWdnZW8sIHRoaXMuY2hhck1hdGVyaWFsKTtcbiAgcmlnaHRsZWcucG9zaXRpb24ueiA9IDI7XG4gIHJpZ2h0bGVnLnBvc2l0aW9uLnkgPSAtNjtcbiAgdGhpcy5VVk1hcChyaWdodGxlZywgMCwgNCwgMjAsIDQsIDEyKTtcbiAgdGhpcy5VVk1hcChyaWdodGxlZywgMSwgMTIsIDIwLCA0LCAxMik7XG4gIHRoaXMuVVZNYXAocmlnaHRsZWcsIDIsIDgsIDE2LCAtNCwgNCwgMyk7XG4gIHRoaXMuVVZNYXAocmlnaHRsZWcsIDMsIDEyLCAyMCwgLTQsIC00LCAxKTtcbiAgdGhpcy5VVk1hcChyaWdodGxlZywgNCwgMCwgMjAsIDQsIDEyKTtcbiAgdGhpcy5VVk1hcChyaWdodGxlZywgNSwgOCwgMjAsIDQsIDEyKTtcbiAgXG4gIC8vIEJvZHlcbiAgdmFyIGJvZHlnZW8gPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KDQsIDEyLCA4KTtcbiAgdmFyIGJvZHltZXNoID0gdGhpcy5ib2R5ID0gbmV3IFRIUkVFLk1lc2goYm9keWdlbywgdGhpcy5jaGFyTWF0ZXJpYWwpO1xuICB0aGlzLlVWTWFwKGJvZHltZXNoLCAwLCAyMCwgMjAsIDgsIDEyKTtcbiAgdGhpcy5VVk1hcChib2R5bWVzaCwgMSwgMzIsIDIwLCA4LCAxMik7XG4gIHRoaXMuVVZNYXAoYm9keW1lc2gsIDIsIDIwLCAxNiwgOCwgNCwgMSk7XG4gIHRoaXMuVVZNYXAoYm9keW1lc2gsIDMsIDI4LCAxNiwgOCwgNCwgMyk7XG4gIHRoaXMuVVZNYXAoYm9keW1lc2gsIDQsIDE2LCAyMCwgNCwgMTIpO1xuICB0aGlzLlVWTWFwKGJvZHltZXNoLCA1LCAyOCwgMjAsIDQsIDEyKTtcbiAgdXBwZXJib2R5LmFkZChib2R5bWVzaCk7XG4gIFxuICBcbiAgLy8gTGVmdCBhcm1cbiAgdmFyIGxlZnRhcm1nZW8gPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KDQsIDEyLCA0KTtcbiAgZm9yKHZhciBpPTA7IGkgPCA4OyBpKz0xKSB7XG4gICAgbGVmdGFybWdlby52ZXJ0aWNlc1tpXS55IC09IDQ7XG4gIH1cbiAgdmFyIGxlZnRhcm0gPSB0aGlzLmxlZnRBcm0gPSBuZXcgVEhSRUUuTWVzaChsZWZ0YXJtZ2VvLCB0aGlzLmNoYXJNYXRlcmlhbCk7XG4gIGxlZnRhcm0ucG9zaXRpb24ueiA9IC02O1xuICBsZWZ0YXJtLnBvc2l0aW9uLnkgPSA0O1xuICBsZWZ0YXJtLnJvdGF0aW9uLnggPSBNYXRoLlBJLzMyO1xuICB0aGlzLlVWTWFwKGxlZnRhcm0sIDAsIDQ4LCAyMCwgLTQsIDEyKTtcbiAgdGhpcy5VVk1hcChsZWZ0YXJtLCAxLCA1NiwgMjAsIC00LCAxMik7XG4gIHRoaXMuVVZNYXAobGVmdGFybSwgMiwgNDgsIDE2LCAtNCwgNCwgMSk7XG4gIHRoaXMuVVZNYXAobGVmdGFybSwgMywgNTIsIDE2LCAtNCwgNCwgMyk7XG4gIHRoaXMuVVZNYXAobGVmdGFybSwgNCwgNTIsIDIwLCAtNCwgMTIpO1xuICB0aGlzLlVWTWFwKGxlZnRhcm0sIDUsIDQ0LCAyMCwgLTQsIDEyKTtcbiAgdXBwZXJib2R5LmFkZChsZWZ0YXJtKTtcbiAgXG4gIC8vIFJpZ2h0IGFybVxuICB2YXIgcmlnaHRhcm1nZW8gPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KDQsIDEyLCA0KTtcbiAgZm9yKHZhciBpPTA7IGkgPCA4OyBpKz0xKSB7XG4gICAgcmlnaHRhcm1nZW8udmVydGljZXNbaV0ueSAtPSA0O1xuICB9XG4gIHZhciByaWdodGFybSA9dGhpcy5yaWdodEFybSA9IG5ldyBUSFJFRS5NZXNoKHJpZ2h0YXJtZ2VvLCB0aGlzLmNoYXJNYXRlcmlhbCk7XG4gIHJpZ2h0YXJtLnBvc2l0aW9uLnogPSA2O1xuICByaWdodGFybS5wb3NpdGlvbi55ID0gNDtcbiAgcmlnaHRhcm0ucm90YXRpb24ueCA9IC1NYXRoLlBJLzMyO1xuICB0aGlzLlVWTWFwKHJpZ2h0YXJtLCAwLCA0NCwgMjAsIDQsIDEyKTtcbiAgdGhpcy5VVk1hcChyaWdodGFybSwgMSwgNTIsIDIwLCA0LCAxMik7XG4gIHRoaXMuVVZNYXAocmlnaHRhcm0sIDIsIDQ0LCAxNiwgNCwgNCwgMSk7XG4gIHRoaXMuVVZNYXAocmlnaHRhcm0sIDMsIDQ4LCAxNiwgNCwgNCwgMyk7XG4gIHRoaXMuVVZNYXAocmlnaHRhcm0sIDQsIDQwLCAyMCwgNCwgMTIpO1xuICB0aGlzLlVWTWFwKHJpZ2h0YXJtLCA1LCA0OCwgMjAsIDQsIDEyKTtcbiAgdXBwZXJib2R5LmFkZChyaWdodGFybSk7XG4gIFxuICAvL0hlYWRcbiAgdmFyIGhlYWRnZW8gPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KDgsIDgsIDgpO1xuICB2YXIgaGVhZG1lc2ggPSB0aGlzLmhlYWQgPSBuZXcgVEhSRUUuTWVzaChoZWFkZ2VvLCB0aGlzLmNoYXJNYXRlcmlhbCk7XG4gIGhlYWRtZXNoLnBvc2l0aW9uLnkgPSAyO1xuICB0aGlzLlVWTWFwKGhlYWRtZXNoLCAwLCA4LCA4LCA4LCA4KTtcbiAgdGhpcy5VVk1hcChoZWFkbWVzaCwgMSwgMjQsIDgsIDgsIDgpO1xuICBcbiAgdGhpcy5VVk1hcChoZWFkbWVzaCwgMiwgOCwgMCwgOCwgOCwgMSk7XG4gIHRoaXMuVVZNYXAoaGVhZG1lc2gsIDMsIDE2LCAwLCA4LCA4LCAzKTtcbiAgXG4gIHRoaXMuVVZNYXAoaGVhZG1lc2gsIDQsIDAsIDgsIDgsIDgpO1xuICB0aGlzLlVWTWFwKGhlYWRtZXNoLCA1LCAxNiwgOCwgOCwgOCk7XG5cbiAgdmFyIHVucm90YXRlZEhlYWRNZXNoID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG4gIHVucm90YXRlZEhlYWRNZXNoLnJvdGF0aW9uLnkgPSBNYXRoLlBJIC8gMjtcbiAgdW5yb3RhdGVkSGVhZE1lc2guYWRkKGhlYWRtZXNoKTtcblxuICBoZWFkZ3JvdXAuYWRkKHVucm90YXRlZEhlYWRNZXNoKTtcblxuICB2YXIgaGVsbWV0ID0gdGhpcy5jdWJlRnJvbVBsYW5lcyg5LCB0aGlzLmNoYXJNYXRlcmlhbFRyYW5zKTtcbiAgaGVsbWV0LnBvc2l0aW9uLnkgPSAyO1xuICB0aGlzLlVWTWFwKGhlbG1ldC5jaGlsZHJlblswXSwgMCwgMzIrOCwgOCwgOCwgOCk7XG4gIHRoaXMuVVZNYXAoaGVsbWV0LmNoaWxkcmVuWzFdLCAwLCAzMisyNCwgOCwgOCwgOCk7XG4gIHRoaXMuVVZNYXAoaGVsbWV0LmNoaWxkcmVuWzJdLCAwLCAzMis4LCAwLCA4LCA4LCAxKTtcbiAgdGhpcy5VVk1hcChoZWxtZXQuY2hpbGRyZW5bM10sIDAsIDMyKzE2LCAwLCA4LCA4LCAzKTtcbiAgdGhpcy5VVk1hcChoZWxtZXQuY2hpbGRyZW5bNF0sIDAsIDMyKzAsIDgsIDgsIDgpO1xuICB0aGlzLlVWTWFwKGhlbG1ldC5jaGlsZHJlbls1XSwgMCwgMzIrMTYsIDgsIDgsIDgpO1xuICBcbiAgaGVhZGdyb3VwLmFkZChoZWxtZXQpO1xuICBcbiAgdmFyIGVhcnMgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgXG4gIHZhciBlYXJnZW8gPSBuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KDEsICg5LzgpKjYsICg5LzgpKjYpO1xuICB2YXIgbGVmdGVhciA9IG5ldyBUSFJFRS5NZXNoKGVhcmdlbywgdGhpcy5jaGFyTWF0ZXJpYWwpO1xuICB2YXIgcmlnaHRlYXIgPSBuZXcgVEhSRUUuTWVzaChlYXJnZW8sIHRoaXMuY2hhck1hdGVyaWFsKTtcbiAgXG4gIGxlZnRlYXIucG9zaXRpb24ueSA9IDIrKDkvOCkqNTtcbiAgcmlnaHRlYXIucG9zaXRpb24ueSA9IDIrKDkvOCkqNTtcbiAgbGVmdGVhci5wb3NpdGlvbi56ID0gLSg5LzgpKjU7XG4gIHJpZ2h0ZWFyLnBvc2l0aW9uLnogPSAoOS84KSo1O1xuICBcbiAgLy8gUmlnaHQgZWFyIHNoYXJlIHNhbWUgZ2VvbWV0cnksIHNhbWUgdXYtbWFwc1xuICBcbiAgdGhpcy5VVk1hcChsZWZ0ZWFyLCAwLCAyNSwgMSwgNiwgNik7IC8vIEZyb250IHNpZGVcbiAgdGhpcy5VVk1hcChsZWZ0ZWFyLCAxLCAzMiwgMSwgNiwgNik7IC8vIEJhY2sgc2lkZVxuICBcbiAgdGhpcy5VVk1hcChsZWZ0ZWFyLCAyLCAyNSwgMCwgNiwgMSwgMSk7IC8vIFRvcCBlZGdlXG4gIHRoaXMuVVZNYXAobGVmdGVhciwgMywgMzEsIDAsIDYsIDEsIDEpOyAvLyBCb3R0b20gZWRnZVxuICBcbiAgdGhpcy5VVk1hcChsZWZ0ZWFyLCA0LCAyNCwgMSwgMSwgNik7IC8vIExlZnQgZWRnZVxuICB0aGlzLlVWTWFwKGxlZnRlYXIsIDUsIDMxLCAxLCAxLCA2KTsgLy8gUmlnaHQgZWRnZVxuICBcbiAgZWFycy5hZGQobGVmdGVhcik7XG4gIGVhcnMuYWRkKHJpZ2h0ZWFyKTtcbiAgXG4gIGxlZnRlYXIudmlzaWJsZSA9IHJpZ2h0ZWFyLnZpc2libGUgPSBmYWxzZTtcbiAgXG4gIGhlYWRncm91cC5hZGQoZWFycyk7XG4gIGhlYWRncm91cC5wb3NpdGlvbi55ID0gODtcbiAgXG4gIHZhciBwbGF5ZXJNb2RlbCA9IHRoaXMucGxheWVyTW9kZWwgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgXG4gIHBsYXllck1vZGVsLmFkZChsZWZ0bGVnKTtcbiAgcGxheWVyTW9kZWwuYWRkKHJpZ2h0bGVnKTtcbiAgXG4gIHBsYXllck1vZGVsLmFkZCh1cHBlcmJvZHkpO1xuICBcbiAgdmFyIHBsYXllclJvdGF0aW9uID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG4gIHBsYXllclJvdGF0aW9uLnJvdGF0aW9uLnkgPSBNYXRoLlBJIC8gMlxuICBwbGF5ZXJSb3RhdGlvbi5wb3NpdGlvbi55ID0gMTJcbiAgcGxheWVyUm90YXRpb24uYWRkKHBsYXllck1vZGVsKVxuXG4gIHZhciByb3RhdGVkSGVhZCA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuICByb3RhdGVkSGVhZC5yb3RhdGlvbi55ID0gLU1hdGguUEkvMjtcbiAgcm90YXRlZEhlYWQuYWRkKGhlYWRncm91cCk7XG5cbiAgcGxheWVyTW9kZWwuYWRkKHJvdGF0ZWRIZWFkKTtcbiAgcGxheWVyTW9kZWwucG9zaXRpb24ueSA9IDY7XG4gIFxuICB2YXIgcGxheWVyR3JvdXAgPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgcGxheWVyR3JvdXAuY2FtZXJhSW5zaWRlID0gbmV3IFRIUkVFLk9iamVjdDNEKClcbiAgcGxheWVyR3JvdXAuY2FtZXJhT3V0c2lkZSA9IG5ldyBUSFJFRS5PYmplY3QzRCgpXG5cbiAgcGxheWVyR3JvdXAuY2FtZXJhSW5zaWRlLnBvc2l0aW9uLnggPSAwO1xuICBwbGF5ZXJHcm91cC5jYW1lcmFJbnNpZGUucG9zaXRpb24ueSA9IDI7XG4gIHBsYXllckdyb3VwLmNhbWVyYUluc2lkZS5wb3NpdGlvbi56ID0gMDsgXG5cbiAgcGxheWVyR3JvdXAuaGVhZCA9IGhlYWRncm91cFxuICBoZWFkZ3JvdXAuYWRkKHBsYXllckdyb3VwLmNhbWVyYUluc2lkZSlcbiAgcGxheWVyR3JvdXAuY2FtZXJhSW5zaWRlLmFkZChwbGF5ZXJHcm91cC5jYW1lcmFPdXRzaWRlKVxuXG4gIHBsYXllckdyb3VwLmNhbWVyYU91dHNpZGUucG9zaXRpb24ueiA9IDEwMFxuXG4gIFxuICBwbGF5ZXJHcm91cC5hZGQocGxheWVyUm90YXRpb24pO1xuICBwbGF5ZXJHcm91cC5zY2FsZSA9IHRoaXMuc2NhbGVcbiAgcmV0dXJuIHBsYXllckdyb3VwXG59IiwidmFyIHdhbGtTcGVlZCA9IDEuMFxudmFyIHN0YXJ0ZWRXYWxraW5nID0gMC4wXG52YXIgc3RvcHBlZFdhbGtpbmcgPSAwLjBcbnZhciB3YWxraW5nID0gZmFsc2VcbnZhciBhY2NlbGVyYXRpb24gPSAxLjBcblxuZXhwb3J0cy5yZW5kZXIgPSBmdW5jdGlvbihza2luKXtcbiAgdmFyIHRpbWUgPSBEYXRlLm5vdygpIC8gMTAwMFxuICBpZiAod2Fsa2luZyAmJiB0aW1lIDwgc3RhcnRlZFdhbGtpbmcgKyBhY2NlbGVyYXRpb24pe1xuICAgIHdhbGtTcGVlZCA9ICh0aW1lIC0gc3RhcnRlZFdhbGtpbmcpIC8gYWNjZWxlcmF0aW9uXG4gIH1cbiAgaWYgKCF3YWxraW5nICYmIHRpbWUgPCBzdG9wcGVkV2Fsa2luZyArIGFjY2VsZXJhdGlvbil7XG4gICAgd2Fsa1NwZWVkID0gLTEgLyBhY2NlbGVyYXRpb24gKiAodGltZSAtIHN0b3BwZWRXYWxraW5nKSArIDFcbiAgfVxuXG4gIHNraW4uaGVhZC5yb3RhdGlvbi55ID0gTWF0aC5zaW4odGltZSAqIDEuNSkgLyAzICogd2Fsa1NwZWVkXG4gIHNraW4uaGVhZC5yb3RhdGlvbi56ID0gTWF0aC5zaW4odGltZSkgLyAyICogd2Fsa1NwZWVkXG4gIFxuICBza2luLnJpZ2h0QXJtLnJvdGF0aW9uLnogPSAyICogTWF0aC5jb3MoMC42NjYyICogdGltZSAqIDEwICsgTWF0aC5QSSkgKiB3YWxrU3BlZWRcbiAgc2tpbi5yaWdodEFybS5yb3RhdGlvbi54ID0gMSAqIChNYXRoLmNvcygwLjI4MTIgKiB0aW1lICogMTApIC0gMSkgKiB3YWxrU3BlZWRcbiAgc2tpbi5sZWZ0QXJtLnJvdGF0aW9uLnogPSAyICogTWF0aC5jb3MoMC42NjYyICogdGltZSAqIDEwKSAqIHdhbGtTcGVlZFxuICBza2luLmxlZnRBcm0ucm90YXRpb24ueCA9IDEgKiAoTWF0aC5jb3MoMC4yMzEyICogdGltZSAqIDEwKSArIDEpICogd2Fsa1NwZWVkXG4gIFxuICBza2luLnJpZ2h0TGVnLnJvdGF0aW9uLnogPSAxLjQgKiBNYXRoLmNvcygwLjY2NjIgKiB0aW1lICogMTApICogd2Fsa1NwZWVkXG4gIHNraW4ubGVmdExlZy5yb3RhdGlvbi56ID0gMS40ICogTWF0aC5jb3MoMC42NjYyICogdGltZSAqIDEwICsgTWF0aC5QSSkgKiB3YWxrU3BlZWRcbn1cblxuZXhwb3J0cy5zdGFydFdhbGtpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDBcbiAgd2Fsa2luZyA9IHRydWVcbiAgaWYgKHN0b3BwZWRXYWxraW5nICsgYWNjZWxlcmF0aW9uPm5vdyl7XG4gICAgdmFyIHByb2dyZXNzID0gbm93IC0gc3RvcHBlZFdhbGtpbmc7XG4gICAgc3RhcnRlZFdhbGtpbmcgPSBub3cgLSAoc3RvcHBlZFdhbGtpbmcgKyBhY2NlbGVyYXRpb24gLSBub3cpXG4gIH0gZWxzZSB7XG4gICAgc3RhcnRlZFdhbGtpbmcgPSBEYXRlLm5vdygpIC8gMTAwMFxuICB9XG59XG5leHBvcnRzLnN0b3BXYWxraW5nID0gZnVuY3Rpb24oKSB7XG4gIHZhciBub3cgPSBEYXRlLm5vdygpIC8gMTAwMFxuICB3YWxraW5nID0gZmFsc2VcbiAgaWYgKHN0YXJ0ZWRXYWxraW5nICsgYWNjZWxlcmF0aW9uID4gbm93KXtcbiAgICBzdG9wcGVkV2Fsa2luZyA9IG5vdyAtIChzdGFydGVkV2Fsa2luZyArIGFjY2VsZXJhdGlvbiAtIG5vdylcbiAgfSBlbHNlIHtcbiAgICBzdG9wcGVkV2Fsa2luZyA9IERhdGUubm93KCkgLyAxMDAwXG4gIH1cbn1cbmV4cG9ydHMuaXNXYWxraW5nID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuIHdhbGtpbmdcbn1cblxuZXhwb3J0cy5zZXRBY2NlbGVyYXRpb24gPSBmdW5jdGlvbihuZXdBKXtcbiAgYWNjZWxlcmF0aW9uID0gbmV3QVxufSIsInZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBDaHVua2VyKG9wdHMpXG59XG5cbm1vZHVsZS5leHBvcnRzLkNodW5rZXIgPSBDaHVua2VyXG5cbmZ1bmN0aW9uIENodW5rZXIob3B0cykge1xuICB0aGlzLmRpc3RhbmNlID0gb3B0cy5jaHVua0Rpc3RhbmNlIHx8IDJcbiAgdGhpcy5jaHVua1NpemUgPSBvcHRzLmNodW5rU2l6ZSB8fCAzMlxuICB0aGlzLmN1YmVTaXplID0gb3B0cy5jdWJlU2l6ZSB8fCAyNVxuICB0aGlzLmdlbmVyYXRlVm94ZWxDaHVuayA9IG9wdHMuZ2VuZXJhdGVWb3hlbENodW5rXG4gIHRoaXMuY2h1bmtzID0ge31cbiAgdGhpcy5tZXNoZXMgPSB7fVxuXG4gIGlmICh0aGlzLmNodW5rU2l6ZSAmIHRoaXMuY2h1bmtTaXplLTEgIT09IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjaHVua1NpemUgbXVzdCBiZSBhIHBvd2VyIG9mIDInKVxuICB2YXIgYml0cyA9IDA7XG4gIGZvciAodmFyIHNpemUgPSB0aGlzLmNodW5rU2l6ZTsgc2l6ZSA+IDA7IHNpemUgPj49IDEpIGJpdHMrKztcbiAgdGhpcy5jaHVua0JpdHMgPSBiaXRzIC0gMTtcbn1cblxuaW5oZXJpdHMoQ2h1bmtlciwgZXZlbnRzLkV2ZW50RW1pdHRlcilcblxuQ2h1bmtlci5wcm90b3R5cGUubmVhcmJ5Q2h1bmtzID0gZnVuY3Rpb24ocG9zaXRpb24sIGRpc3RhbmNlKSB7XG4gIHZhciBjdXJyZW50ID0gdGhpcy5jaHVua0F0UG9zaXRpb24ocG9zaXRpb24pXG4gIHZhciB4ID0gY3VycmVudFswXVxuICB2YXIgeSA9IGN1cnJlbnRbMV1cbiAgdmFyIHogPSBjdXJyZW50WzJdXG4gIHZhciBkaXN0ID0gZGlzdGFuY2UgfHwgdGhpcy5kaXN0YW5jZVxuICB2YXIgbmVhcmJ5ID0gW11cbiAgZm9yICh2YXIgY3ggPSAoeCAtIGRpc3QpOyBjeCAhPT0gKHggKyBkaXN0KTsgKytjeCkge1xuICAgIGZvciAodmFyIGN5ID0gKHkgLSBkaXN0KTsgY3kgIT09ICh5ICsgZGlzdCk7ICsrY3kpIHtcbiAgICAgIGZvciAodmFyIGN6ID0gKHogLSBkaXN0KTsgY3ogIT09ICh6ICsgZGlzdCk7ICsrY3opIHtcbiAgICAgICAgbmVhcmJ5LnB1c2goW2N4LCBjeSwgY3pdKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbmVhcmJ5XG59XG5cbkNodW5rZXIucHJvdG90eXBlLnJlcXVlc3RNaXNzaW5nQ2h1bmtzID0gZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHRoaXMubmVhcmJ5Q2h1bmtzKHBvc2l0aW9uKS5tYXAoZnVuY3Rpb24oY2h1bmspIHtcbiAgICBpZiAoIXNlbGYuY2h1bmtzW2NodW5rLmpvaW4oJ3wnKV0pIHtcbiAgICAgIHNlbGYuZW1pdCgnbWlzc2luZ0NodW5rJywgY2h1bmspXG4gICAgfVxuICB9KVxufVxuXG5DaHVua2VyLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHZhciBiaXRzID0gdGhpcy5jaHVua0JpdHNcbiAgdmFyIGxvdyA9IFt4IDw8IGJpdHMsIHkgPDwgYml0cywgeiA8PCBiaXRzXVxuICB2YXIgaGlnaCA9IFsoeCsxKSA8PCBiaXRzLCAoeSsxKSA8PCBiaXRzLCAoeisxKSA8PCBiaXRzXVxuICByZXR1cm4gW2xvdywgaGlnaF1cbn1cblxuQ2h1bmtlci5wcm90b3R5cGUuZ2VuZXJhdGVDaHVuayA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcyh4LCB5LCB6KVxuICB2YXIgY2h1bmsgPSB0aGlzLmdlbmVyYXRlVm94ZWxDaHVuayhib3VuZHNbMF0sIGJvdW5kc1sxXSwgeCwgeSwgeilcbiAgdmFyIHBvc2l0aW9uID0gW3gsIHksIHpdXG4gIGNodW5rLnBvc2l0aW9uID0gcG9zaXRpb25cbiAgdGhpcy5jaHVua3NbcG9zaXRpb24uam9pbignfCcpXSA9IGNodW5rXG4gIHJldHVybiBjaHVua1xufVxuXG5DaHVua2VyLnByb3RvdHlwZS5jaHVua0F0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHZhciBiaXRzID0gdGhpcy5jaHVua0JpdHM7XG4gIHZhciBjeCA9IHggPj4gYml0cztcbiAgdmFyIGN5ID0geSA+PiBiaXRzO1xuICB2YXIgY3ogPSB6ID4+IGJpdHM7XG4gIHZhciBjaHVua1BvcyA9IFtjeCwgY3ksIGN6XTtcbiAgcmV0dXJuIGNodW5rUG9zO1xufVxuXG5DaHVua2VyLnByb3RvdHlwZS5jaHVua0F0UG9zaXRpb24gPSBmdW5jdGlvbihwb3NpdGlvbikge1xuICB2YXIgY3ViZVNpemUgPSB0aGlzLmN1YmVTaXplO1xuICB2YXIgeCA9IE1hdGguZmxvb3IocG9zaXRpb25bMF0gLyBjdWJlU2l6ZSlcbiAgdmFyIHkgPSBNYXRoLmZsb29yKHBvc2l0aW9uWzFdIC8gY3ViZVNpemUpXG4gIHZhciB6ID0gTWF0aC5mbG9vcihwb3NpdGlvblsyXSAvIGN1YmVTaXplKVxuICB2YXIgY2h1bmtQb3MgPSB0aGlzLmNodW5rQXRDb29yZGluYXRlcyh4LCB5LCB6KVxuICByZXR1cm4gY2h1bmtQb3Ncbn07XG5cbkNodW5rZXIucHJvdG90eXBlLnZveGVsSW5kZXhGcm9tQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHZhciBiaXRzID0gdGhpcy5jaHVua0JpdHNcbiAgdmFyIG1hc2sgPSAoMSA8PCBiaXRzKSAtIDFcbiAgdmFyIHZpZHggPSAoeCAmIG1hc2spICsgKCh5ICYgbWFzaykgPDwgYml0cykgKyAoKHogJiBtYXNrKSA8PCBiaXRzICogMilcbiAgcmV0dXJuIHZpZHhcbn1cblxuQ2h1bmtlci5wcm90b3R5cGUudm94ZWxJbmRleEZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xuICB2YXIgdiA9IHRoaXMudm94ZWxWZWN0b3IocG9zKVxuICByZXR1cm4gdGhpcy52b3hlbEluZGV4KHYpXG59XG5cbkNodW5rZXIucHJvdG90eXBlLnZveGVsQXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uKHgsIHksIHosIHZhbCkge1xuICB2YXIgY2tleSA9IHRoaXMuY2h1bmtBdENvb3JkaW5hdGVzKHgsIHksIHopLmpvaW4oJ3wnKVxuICB2YXIgY2h1bmsgPSB0aGlzLmNodW5rc1tja2V5XVxuICBpZiAoIWNodW5rKSByZXR1cm4gZmFsc2VcbiAgdmFyIHZpZHggPSB0aGlzLnZveGVsSW5kZXhGcm9tQ29vcmRpbmF0ZXMoeCwgeSwgeilcbiAgdmFyIHYgPSBjaHVuay52b3hlbHNbdmlkeF1cbiAgaWYgKHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgY2h1bmsudm94ZWxzW3ZpZHhdID0gdmFsXG4gIH1cbiAgcmV0dXJuIHZcbn1cblxuQ2h1bmtlci5wcm90b3R5cGUudm94ZWxBdFBvc2l0aW9uID0gZnVuY3Rpb24ocG9zLCB2YWwpIHtcbiAgdmFyIGN1YmVTaXplID0gdGhpcy5jdWJlU2l6ZTtcbiAgdmFyIHggPSBNYXRoLmZsb29yKHBvc1swXSAvIGN1YmVTaXplKVxuICB2YXIgeSA9IE1hdGguZmxvb3IocG9zWzFdIC8gY3ViZVNpemUpXG4gIHZhciB6ID0gTWF0aC5mbG9vcihwb3NbMl0gLyBjdWJlU2l6ZSlcbiAgdmFyIHYgPSB0aGlzLnZveGVsQXRDb29yZGluYXRlcyh4LCB5LCB6LCB2YWwpXG4gIHJldHVybiB2O1xufVxuXG4vLyBkZXByZWNhdGVkXG5DaHVua2VyLnByb3RvdHlwZS52b3hlbEluZGV4ID0gZnVuY3Rpb24odm94ZWxWZWN0b3IpIHtcbiAgdmFyIHZpZHggPSB0aGlzLnZveGVsSW5kZXhGcm9tQ29vcmRpbmF0ZXModm94ZWxWZWN0b3JbMF0sIHZveGVsVmVjdG9yWzFdLCB2b3hlbFZlY3RvclsyXSlcbiAgcmV0dXJuIHZpZHhcbn1cblxuLy8gZGVwcmVjYXRlZFxuQ2h1bmtlci5wcm90b3R5cGUudm94ZWxWZWN0b3IgPSBmdW5jdGlvbihwb3MpIHtcbiAgdmFyIGN1YmVTaXplID0gdGhpcy5jdWJlU2l6ZVxuICB2YXIgbWFzayA9ICgxIDw8IHRoaXMuY2h1bmtCaXRzKSAtIDFcbiAgdmFyIHZ4ID0gKE1hdGguZmxvb3IocG9zWzBdIC8gY3ViZVNpemUpKSAmIG1hc2tcbiAgdmFyIHZ5ID0gKE1hdGguZmxvb3IocG9zWzFdIC8gY3ViZVNpemUpKSAmIG1hc2tcbiAgdmFyIHZ6ID0gKE1hdGguZmxvb3IocG9zWzJdIC8gY3ViZVNpemUpKSAmIG1hc2tcbiAgcmV0dXJuIFt2eCwgdnksIHZ6XVxufTtcbiIsInZhciBjaHVua2VyID0gcmVxdWlyZSgnLi9jaHVua2VyJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIGlmICghb3B0cy5nZW5lcmF0ZVZveGVsQ2h1bmspIG9wdHMuZ2VuZXJhdGVWb3hlbENodW5rID0gZnVuY3Rpb24obG93LCBoaWdoKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRlKGxvdywgaGlnaCwgbW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yWydWYWxsZXknXSlcbiAgfVxuICByZXR1cm4gY2h1bmtlcihvcHRzKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5tZXNoZXJzID0ge1xuICBjdWxsZWQ6IHJlcXVpcmUoJy4vbWVzaGVycy9jdWxsZWQnKS5tZXNoZXIsXG4gIGdyZWVkeTogcmVxdWlyZSgnLi9tZXNoZXJzL2dyZWVkeScpLm1lc2hlcixcbiAgbW9ub3RvbmU6IHJlcXVpcmUoJy4vbWVzaGVycy9tb25vdG9uZScpLm1lc2hlcixcbiAgc3R1cGlkOiByZXF1aXJlKCcuL21lc2hlcnMvc3R1cGlkJykubWVzaGVyXG59XG5cbm1vZHVsZS5leHBvcnRzLkNodW5rZXIgPSBjaHVua2VyLkNodW5rZXJcbm1vZHVsZS5leHBvcnRzLmdlb21ldHJ5ID0ge31cbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRvciA9IHt9XG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlXG5cbi8vIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21pa29sYWx5c2Vua28vbWlrb2xhbHlzZW5rby5naXRodWIuY29tL2Jsb2IvbWFzdGVyL01pbmVjcmFmdE1lc2hlczIvanMvdGVzdGRhdGEuanMjTDRcbmZ1bmN0aW9uIGdlbmVyYXRlKGwsIGgsIGYsIGdhbWUpIHtcbiAgdmFyIGQgPSBbIGhbMF0tbFswXSwgaFsxXS1sWzFdLCBoWzJdLWxbMl0gXVxuICB2YXIgdiA9IG5ldyBJbnQ4QXJyYXkoZFswXSpkWzFdKmRbMl0pXG4gIHZhciBuID0gMFxuICBmb3IodmFyIGs9bFsyXTsgazxoWzJdOyArK2spXG4gIGZvcih2YXIgaj1sWzFdOyBqPGhbMV07ICsrailcbiAgZm9yKHZhciBpPWxbMF07IGk8aFswXTsgKytpLCArK24pIHtcbiAgICB2W25dID0gZihpLGosayxuLGdhbWUpXG4gIH1cbiAgcmV0dXJuIHt2b3hlbHM6diwgZGltczpkfVxufVxuXG4vLyBzaGFwZSBhbmQgdGVycmFpbiBnZW5lcmF0b3IgZnVuY3Rpb25zXG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0b3JbJ1NwaGVyZSddID0gZnVuY3Rpb24oaSxqLGspIHtcbiAgcmV0dXJuIGkqaStqKmorayprIDw9IDE2KjE2ID8gMSA6IDBcbn1cblxubW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yWydOb2lzZSddID0gZnVuY3Rpb24oaSxqLGspIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCAwLjEgPyBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgOiAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0b3JbJ0RlbnNlIE5vaXNlJ10gPSBmdW5jdGlvbihpLGosaykge1xuICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0b3JbJ0NoZWNrZXInXSA9IGZ1bmN0aW9uKGksaixrKSB7XG4gIHJldHVybiAhISgoaStqK2spJjEpID8gKCgoaV5qXmspJjIpID8gMSA6IDB4ZmZmZmZmKSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnSGlsbCddID0gZnVuY3Rpb24oaSxqLGspIHtcbiAgcmV0dXJuIGogPD0gMTYgKiBNYXRoLmV4cCgtKGkqaSArIGsqaykgLyA2NCkgPyAxIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yWydWYWxsZXknXSA9IGZ1bmN0aW9uKGksaixrKSB7XG4gIHJldHVybiBqIDw9IChpKmkgKyBrKmspICogMzEgLyAoMzIqMzIqMikgKyAxID8gMSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnSGlsbHkgVGVycmFpbiddID0gZnVuY3Rpb24oaSxqLGspIHtcbiAgdmFyIGgwID0gMy4wICogTWF0aC5zaW4oTWF0aC5QSSAqIGkgLyAxMi4wIC0gTWF0aC5QSSAqIGsgKiAwLjEpICsgMjc7ICAgIFxuICBpZihqID4gaDArMSkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGlmKGgwIDw9IGopIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICB2YXIgaDEgPSAyLjAgKiBNYXRoLnNpbihNYXRoLlBJICogaSAqIDAuMjUgLSBNYXRoLlBJICogayAqIDAuMykgKyAyMDtcbiAgaWYoaDEgPD0gaikge1xuICAgIHJldHVybiAyO1xuICB9XG4gIGlmKDIgPCBqKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCAwLjEgPyAweDIyMjIyMiA6IDB4YWFhYWFhO1xuICB9XG4gIHJldHVybiAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5zY2FsZSA9IGZ1bmN0aW9uICggeCwgZnJvbUxvdywgZnJvbUhpZ2gsIHRvTG93LCB0b0hpZ2ggKSB7XG4gIHJldHVybiAoIHggLSBmcm9tTG93ICkgKiAoIHRvSGlnaCAtIHRvTG93ICkgLyAoIGZyb21IaWdoIC0gZnJvbUxvdyApICsgdG9Mb3dcbn1cblxuLy8gY29udmVuaWVuY2UgZnVuY3Rpb24gdGhhdCB1c2VzIHRoZSBhYm92ZSBmdW5jdGlvbnMgdG8gcHJlYmFrZSBzb21lIHNpbXBsZSB2b3hlbCBnZW9tZXRyaWVzXG5tb2R1bGUuZXhwb3J0cy5nZW5lcmF0ZUV4YW1wbGVzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgJ1NwaGVyZSc6IGdlbmVyYXRlKFstMTYsLTE2LC0xNl0sIFsxNiwxNiwxNl0sIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnU3BoZXJlJ10pLFxuICAgICdOb2lzZSc6IGdlbmVyYXRlKFswLDAsMF0sIFsxNiwxNiwxNl0sIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnTm9pc2UnXSksXG4gICAgJ0RlbnNlIE5vaXNlJzogZ2VuZXJhdGUoWzAsMCwwXSwgWzE2LDE2LDE2XSwgbW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yWydEZW5zZSBOb2lzZSddKSxcbiAgICAnQ2hlY2tlcic6IGdlbmVyYXRlKFswLDAsMF0sIFs4LDgsOF0sIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnQ2hlY2tlciddKSxcbiAgICAnSGlsbCc6IGdlbmVyYXRlKFstMTYsIDAsIC0xNl0sIFsxNiwxNiwxNl0sIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnSGlsbCddKSxcbiAgICAnVmFsbGV5JzogZ2VuZXJhdGUoWzAsMCwwXSwgWzMyLDMyLDMyXSwgbW9kdWxlLmV4cG9ydHMuZ2VuZXJhdG9yWydWYWxsZXknXSksXG4gICAgJ0hpbGx5IFRlcnJhaW4nOiBnZW5lcmF0ZShbMCwgMCwgMF0sIFszMiwzMiwzMl0sIG1vZHVsZS5leHBvcnRzLmdlbmVyYXRvclsnSGlsbHkgVGVycmFpbiddKVxuICB9XG59XG5cbiIsIi8vTmFpdmUgbWVzaGluZyAod2l0aCBmYWNlIGN1bGxpbmcpXG5mdW5jdGlvbiBDdWxsZWRNZXNoKHZvbHVtZSwgZGltcykge1xuICAvL1ByZWNhbGN1bGF0ZSBkaXJlY3Rpb24gdmVjdG9ycyBmb3IgY29udmVuaWVuY2VcbiAgdmFyIGRpciA9IG5ldyBBcnJheSgzKTtcbiAgZm9yKHZhciBpPTA7IGk8MzsgKytpKSB7XG4gICAgZGlyW2ldID0gW1swLDAsMF0sIFswLDAsMF1dO1xuICAgIGRpcltpXVswXVsoaSsxKSUzXSA9IDE7XG4gICAgZGlyW2ldWzFdWyhpKzIpJTNdID0gMTtcbiAgfVxuICAvL01hcmNoIG92ZXIgdGhlIHZvbHVtZVxuICB2YXIgdmVydGljZXMgPSBbXVxuICAgICwgZmFjZXMgPSBbXVxuICAgICwgeCA9IFswLDAsMF1cbiAgICAsIEIgPSBbW2ZhbHNlLHRydWVdICAgIC8vSW5jcmVtZW50YWxseSB1cGRhdGUgYm91bmRzICh0aGlzIGlzIGEgYml0IHVnbHkpXG4gICAgICAgICAgLFtmYWxzZSx0cnVlXVxuICAgICAgICAgICxbZmFsc2UsdHJ1ZV1dXG4gICAgLCBuID0gLWRpbXNbMF0qZGltc1sxXTtcbiAgZm9yKCAgICAgICAgICAgQlsyXT1bZmFsc2UsdHJ1ZV0seFsyXT0tMTsgeFsyXTxkaW1zWzJdOyBCWzJdPVt0cnVlLCgrK3hbMl08ZGltc1syXS0xKV0pXG4gIGZvcihuLT1kaW1zWzBdLEJbMV09W2ZhbHNlLHRydWVdLHhbMV09LTE7IHhbMV08ZGltc1sxXTsgQlsxXT1bdHJ1ZSwoKyt4WzFdPGRpbXNbMV0tMSldKVxuICBmb3Iobi09MSwgICAgICBCWzBdPVtmYWxzZSx0cnVlXSx4WzBdPS0xOyB4WzBdPGRpbXNbMF07IEJbMF09W3RydWUsKCsreFswXTxkaW1zWzBdLTEpXSwgKytuKSB7XG4gICAgLy9SZWFkIGN1cnJlbnQgdm94ZWwgYW5kIDMgbmVpZ2hib3Jpbmcgdm94ZWxzIHVzaW5nIGJvdW5kcyBjaGVjayByZXN1bHRzXG4gICAgdmFyIHAgPSAgIChCWzBdWzBdICYmIEJbMV1bMF0gJiYgQlsyXVswXSkgPyB2b2x1bWVbbl0gICAgICAgICAgICAgICAgIDogMFxuICAgICAgLCBiID0gWyAoQlswXVsxXSAmJiBCWzFdWzBdICYmIEJbMl1bMF0pID8gdm9sdW1lW24rMV0gICAgICAgICAgICAgICA6IDBcbiAgICAgICAgICAgICwgKEJbMF1bMF0gJiYgQlsxXVsxXSAmJiBCWzJdWzBdKSA/IHZvbHVtZVtuK2RpbXNbMF1dICAgICAgICAgOiAwXG4gICAgICAgICAgICAsIChCWzBdWzBdICYmIEJbMV1bMF0gJiYgQlsyXVsxXSkgPyB2b2x1bWVbbitkaW1zWzBdKmRpbXNbMV1dIDogMFxuICAgICAgICAgIF07XG4gICAgLy9HZW5lcmF0ZSBmYWNlc1xuICAgIGZvcih2YXIgZD0wOyBkPDM7ICsrZClcbiAgICBpZigoISFwKSAhPT0gKCEhYltkXSkpIHtcbiAgICAgIHZhciBzID0gIXAgPyAxIDogMDtcbiAgICAgIHZhciB0ID0gW3hbMF0seFsxXSx4WzJdXVxuICAgICAgICAsIHUgPSBkaXJbZF1bc11cbiAgICAgICAgLCB2ID0gZGlyW2RdW3NeMV07XG4gICAgICArK3RbZF07XG4gICAgICBcbiAgICAgIHZhciB2ZXJ0ZXhfY291bnQgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdLCAgICAgICAgICAgdFsxXSwgICAgICAgICAgIHRbMl0gICAgICAgICAgXSk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdK3VbMF0sICAgICAgdFsxXSt1WzFdLCAgICAgIHRbMl0rdVsyXSAgICAgXSk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdK3VbMF0rdlswXSwgdFsxXSt1WzFdK3ZbMV0sIHRbMl0rdVsyXSt2WzJdXSk7XG4gICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdICAgICArdlswXSwgdFsxXSAgICAgK3ZbMV0sIHRbMl0gICAgICt2WzJdXSk7XG4gICAgICBmYWNlcy5wdXNoKFt2ZXJ0ZXhfY291bnQsIHZlcnRleF9jb3VudCsxLCB2ZXJ0ZXhfY291bnQrMiwgdmVydGV4X2NvdW50KzMsIHMgPyBiW2RdIDogcF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB2ZXJ0aWNlczp2ZXJ0aWNlcywgZmFjZXM6ZmFjZXMgfTtcbn1cblxuXG5pZihleHBvcnRzKSB7XG4gIGV4cG9ydHMubWVzaGVyID0gQ3VsbGVkTWVzaDtcbn1cbiIsInZhciBHcmVlZHlNZXNoID0gKGZ1bmN0aW9uKCkge1xuLy9DYWNoZSBidWZmZXIgaW50ZXJuYWxseVxudmFyIG1hc2sgPSBuZXcgSW50MzJBcnJheSg0MDk2KTtcblxucmV0dXJuIGZ1bmN0aW9uKHZvbHVtZSwgZGltcykge1xuICB2YXIgdmVydGljZXMgPSBbXSwgZmFjZXMgPSBbXVxuICAgICwgZGltc1ggPSBkaW1zWzBdXG4gICAgLCBkaW1zWSA9IGRpbXNbMV1cbiAgICAsIGRpbXNYWSA9IGRpbXNYICogZGltc1k7XG5cbiAgLy9Td2VlcCBvdmVyIDMtYXhlc1xuICBmb3IodmFyIGQ9MDsgZDwzOyArK2QpIHtcbiAgICB2YXIgaSwgaiwgaywgbCwgdywgVywgaCwgbiwgY1xuICAgICAgLCB1ID0gKGQrMSklM1xuICAgICAgLCB2ID0gKGQrMiklM1xuICAgICAgLCB4ID0gWzAsMCwwXVxuICAgICAgLCBxID0gWzAsMCwwXVxuICAgICAgLCBkdSA9IFswLDAsMF1cbiAgICAgICwgZHYgPSBbMCwwLDBdXG4gICAgICAsIGRpbXNEID0gZGltc1tkXVxuICAgICAgLCBkaW1zVSA9IGRpbXNbdV1cbiAgICAgICwgZGltc1YgPSBkaW1zW3ZdXG4gICAgICAsIHFkaW1zWCwgcWRpbXNYWVxuICAgICAgLCB4ZFxuXG4gICAgaWYgKG1hc2subGVuZ3RoIDwgZGltc1UgKiBkaW1zVikge1xuICAgICAgbWFzayA9IG5ldyBJbnQzMkFycmF5KGRpbXNVICogZGltc1YpO1xuICAgIH1cblxuICAgIHFbZF0gPSAgMTtcbiAgICB4W2RdID0gLTE7XG5cbiAgICBxZGltc1ggID0gZGltc1ggICogcVsxXVxuICAgIHFkaW1zWFkgPSBkaW1zWFkgKiBxWzJdXG5cbiAgICAvLyBDb21wdXRlIG1hc2tcbiAgICB3aGlsZSAoeFtkXSA8IGRpbXNEKSB7XG4gICAgICB4ZCA9IHhbZF1cbiAgICAgIG4gPSAwO1xuXG4gICAgICBmb3IoeFt2XSA9IDA7IHhbdl0gPCBkaW1zVjsgKyt4W3ZdKSB7XG4gICAgICAgIGZvcih4W3VdID0gMDsgeFt1XSA8IGRpbXNVOyArK3hbdV0sICsrbikge1xuICAgICAgICAgIHZhciBhID0geGQgPj0gMCAgICAgICYmIHZvbHVtZVt4WzBdICAgICAgKyBkaW1zWCAqIHhbMV0gICAgICAgICAgKyBkaW1zWFkgKiB4WzJdICAgICAgICAgIF1cbiAgICAgICAgICAgICwgYiA9IHhkIDwgZGltc0QtMSAmJiB2b2x1bWVbeFswXStxWzBdICsgZGltc1ggKiB4WzFdICsgcWRpbXNYICsgZGltc1hZICogeFsyXSArIHFkaW1zWFldXG4gICAgICAgICAgaWYgKGEgPyBiIDogIWIpIHtcbiAgICAgICAgICAgIG1hc2tbbl0gPSAwOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFza1tuXSA9IGEgPyBhIDogLWI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgKyt4W2RdO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBtZXNoIGZvciBtYXNrIHVzaW5nIGxleGljb2dyYXBoaWMgb3JkZXJpbmdcbiAgICAgIG4gPSAwO1xuICAgICAgZm9yIChqPTA7IGogPCBkaW1zVjsgKytqKSB7XG4gICAgICAgIGZvciAoaT0wOyBpIDwgZGltc1U7ICkge1xuICAgICAgICAgIGMgPSBtYXNrW25dO1xuICAgICAgICAgIGlmICghYykge1xuICAgICAgICAgICAgaSsrOyAgbisrOyBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvL0NvbXB1dGUgd2lkdGhcbiAgICAgICAgICB3ID0gMTtcbiAgICAgICAgICB3aGlsZSAoYyA9PT0gbWFza1tuK3ddICYmIGkrdyA8IGRpbXNVKSB3Kys7XG5cbiAgICAgICAgICAvL0NvbXB1dGUgaGVpZ2h0ICh0aGlzIGlzIHNsaWdodGx5IGF3a3dhcmQpXG4gICAgICAgICAgZm9yIChoPTE7IGoraCA8IGRpbXNWOyArK2gpIHtcbiAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGsgPCB3ICYmIGMgPT09IG1hc2tbbitrK2gqZGltc1VdKSBrKytcbiAgICAgICAgICAgIGlmIChrIDwgdykgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gQWRkIHF1YWRcbiAgICAgICAgICAvLyBUaGUgZHUvZHYgYXJyYXlzIGFyZSByZXVzZWQvcmVzZXRcbiAgICAgICAgICAvLyBmb3IgZWFjaCBpdGVyYXRpb24uXG4gICAgICAgICAgZHVbZF0gPSAwOyBkdltkXSA9IDA7XG4gICAgICAgICAgeFt1XSAgPSBpOyAgeFt2XSA9IGo7XG5cbiAgICAgICAgICBpZiAoYyA+IDApIHtcbiAgICAgICAgICAgIGR2W3ZdID0gaDsgZHZbdV0gPSAwO1xuICAgICAgICAgICAgZHVbdV0gPSB3OyBkdVt2XSA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGMgPSAtYztcbiAgICAgICAgICAgIGR1W3ZdID0gaDsgZHVbdV0gPSAwO1xuICAgICAgICAgICAgZHZbdV0gPSB3OyBkdlt2XSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB2ZXJ0ZXhfY291bnQgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgICAgdmVydGljZXMucHVzaChbeFswXSwgICAgICAgICAgICAgeFsxXSwgICAgICAgICAgICAgeFsyXSAgICAgICAgICAgIF0pO1xuICAgICAgICAgIHZlcnRpY2VzLnB1c2goW3hbMF0rZHVbMF0sICAgICAgIHhbMV0rZHVbMV0sICAgICAgIHhbMl0rZHVbMl0gICAgICBdKTtcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt4WzBdK2R1WzBdK2R2WzBdLCB4WzFdK2R1WzFdK2R2WzFdLCB4WzJdK2R1WzJdK2R2WzJdXSk7XG4gICAgICAgICAgdmVydGljZXMucHVzaChbeFswXSAgICAgICtkdlswXSwgeFsxXSAgICAgICtkdlsxXSwgeFsyXSAgICAgICtkdlsyXV0pO1xuICAgICAgICAgIGZhY2VzLnB1c2goW3ZlcnRleF9jb3VudCwgdmVydGV4X2NvdW50KzEsIHZlcnRleF9jb3VudCsyLCB2ZXJ0ZXhfY291bnQrMywgY10pO1xuXG4gICAgICAgICAgLy9aZXJvLW91dCBtYXNrXG4gICAgICAgICAgVyA9IG4gKyB3O1xuICAgICAgICAgIGZvcihsPTA7IGw8aDsgKytsKSB7XG4gICAgICAgICAgICBmb3Ioaz1uOyBrPFc7ICsraykge1xuICAgICAgICAgICAgICBtYXNrW2srbCpkaW1zVV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vSW5jcmVtZW50IGNvdW50ZXJzIGFuZCBjb250aW51ZVxuICAgICAgICAgIGkgKz0gdzsgbiArPSB3O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHZlcnRpY2VzOnZlcnRpY2VzLCBmYWNlczpmYWNlcyB9O1xufVxufSkoKTtcblxuaWYoZXhwb3J0cykge1xuICBleHBvcnRzLm1lc2hlciA9IEdyZWVkeU1lc2g7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIE1vbm90b25lTWVzaCA9IChmdW5jdGlvbigpe1xuXG5mdW5jdGlvbiBNb25vdG9uZVBvbHlnb24oYywgdiwgdWwsIHVyKSB7XG4gIHRoaXMuY29sb3IgID0gYztcbiAgdGhpcy5sZWZ0ICAgPSBbW3VsLCB2XV07XG4gIHRoaXMucmlnaHQgID0gW1t1ciwgdl1dO1xufTtcblxuTW9ub3RvbmVQb2x5Z29uLnByb3RvdHlwZS5jbG9zZV9vZmYgPSBmdW5jdGlvbih2KSB7XG4gIHRoaXMubGVmdC5wdXNoKFsgdGhpcy5sZWZ0W3RoaXMubGVmdC5sZW5ndGgtMV1bMF0sIHYgXSk7XG4gIHRoaXMucmlnaHQucHVzaChbIHRoaXMucmlnaHRbdGhpcy5yaWdodC5sZW5ndGgtMV1bMF0sIHYgXSk7XG59O1xuXG5Nb25vdG9uZVBvbHlnb24ucHJvdG90eXBlLm1lcmdlX3J1biA9IGZ1bmN0aW9uKHYsIHVfbCwgdV9yKSB7XG4gIHZhciBsID0gdGhpcy5sZWZ0W3RoaXMubGVmdC5sZW5ndGgtMV1bMF1cbiAgICAsIHIgPSB0aGlzLnJpZ2h0W3RoaXMucmlnaHQubGVuZ3RoLTFdWzBdOyBcbiAgaWYobCAhPT0gdV9sKSB7XG4gICAgdGhpcy5sZWZ0LnB1c2goWyBsLCB2IF0pO1xuICAgIHRoaXMubGVmdC5wdXNoKFsgdV9sLCB2IF0pO1xuICB9XG4gIGlmKHIgIT09IHVfcikge1xuICAgIHRoaXMucmlnaHQucHVzaChbIHIsIHYgXSk7XG4gICAgdGhpcy5yaWdodC5wdXNoKFsgdV9yLCB2IF0pO1xuICB9XG59O1xuXG5cbnJldHVybiBmdW5jdGlvbih2b2x1bWUsIGRpbXMpIHtcbiAgZnVuY3Rpb24gZihpLGosaykge1xuICAgIHJldHVybiB2b2x1bWVbaSArIGRpbXNbMF0gKiAoaiArIGRpbXNbMV0gKiBrKV07XG4gIH1cbiAgLy9Td2VlcCBvdmVyIDMtYXhlc1xuICB2YXIgdmVydGljZXMgPSBbXSwgZmFjZXMgPSBbXTtcbiAgZm9yKHZhciBkPTA7IGQ8MzsgKytkKSB7XG4gICAgdmFyIGksIGosIGtcbiAgICAgICwgdSA9IChkKzEpJTMgICAvL3UgYW5kIHYgYXJlIG9ydGhvZ29uYWwgZGlyZWN0aW9ucyB0byBkXG4gICAgICAsIHYgPSAoZCsyKSUzXG4gICAgICAsIHggPSBuZXcgSW50MzJBcnJheSgzKVxuICAgICAgLCBxID0gbmV3IEludDMyQXJyYXkoMylcbiAgICAgICwgcnVucyA9IG5ldyBJbnQzMkFycmF5KDIgKiAoZGltc1t1XSsxKSlcbiAgICAgICwgZnJvbnRpZXIgPSBuZXcgSW50MzJBcnJheShkaW1zW3VdKSAgLy9Gcm9udGllciBpcyBsaXN0IG9mIHBvaW50ZXJzIHRvIHBvbHlnb25zXG4gICAgICAsIG5leHRfZnJvbnRpZXIgPSBuZXcgSW50MzJBcnJheShkaW1zW3VdKVxuICAgICAgLCBsZWZ0X2luZGV4ID0gbmV3IEludDMyQXJyYXkoMiAqIGRpbXNbdl0pXG4gICAgICAsIHJpZ2h0X2luZGV4ID0gbmV3IEludDMyQXJyYXkoMiAqIGRpbXNbdl0pXG4gICAgICAsIHN0YWNrID0gbmV3IEludDMyQXJyYXkoMjQgKiBkaW1zW3ZdKVxuICAgICAgLCBkZWx0YSA9IFtbMCwwXSwgWzAsMF1dO1xuICAgIC8vcSBwb2ludHMgYWxvbmcgZC1kaXJlY3Rpb25cbiAgICBxW2RdID0gMTtcbiAgICAvL0luaXRpYWxpemUgc2VudGluZWxcbiAgICBmb3IoeFtkXT0tMTsgeFtkXTxkaW1zW2RdOyApIHtcbiAgICAgIC8vIC0tLSBQZXJmb3JtIG1vbm90b25lIHBvbHlnb24gc3ViZGl2aXNpb24gLS0tXG4gICAgICB2YXIgbiA9IDBcbiAgICAgICAgLCBwb2x5Z29ucyA9IFtdXG4gICAgICAgICwgbmYgPSAwO1xuICAgICAgZm9yKHhbdl09MDsgeFt2XTxkaW1zW3ZdOyArK3hbdl0pIHtcbiAgICAgICAgLy9NYWtlIG9uZSBwYXNzIG92ZXIgdGhlIHUtc2NhbiBsaW5lIG9mIHRoZSB2b2x1bWUgdG8gcnVuLWxlbmd0aCBlbmNvZGUgcG9seWdvblxuICAgICAgICB2YXIgbnIgPSAwLCBwID0gMCwgYyA9IDA7XG4gICAgICAgIGZvcih4W3VdPTA7IHhbdV08ZGltc1t1XTsgKyt4W3VdLCBwID0gYykge1xuICAgICAgICAgIC8vQ29tcHV0ZSB0aGUgdHlwZSBmb3IgdGhpcyBmYWNlXG4gICAgICAgICAgdmFyIGEgPSAoMCAgICA8PSB4W2RdICAgICAgPyBmKHhbMF0sICAgICAgeFsxXSwgICAgICB4WzJdKSAgICAgIDogMClcbiAgICAgICAgICAgICwgYiA9ICh4W2RdIDwgIGRpbXNbZF0tMSA/IGYoeFswXStxWzBdLCB4WzFdK3FbMV0sIHhbMl0rcVsyXSkgOiAwKTtcbiAgICAgICAgICBjID0gYTtcbiAgICAgICAgICBpZigoIWEpID09PSAoIWIpKSB7XG4gICAgICAgICAgICBjID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYoIWEpIHtcbiAgICAgICAgICAgIGMgPSAtYjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9JZiBjZWxsIHR5cGUgZG9lc24ndCBtYXRjaCwgc3RhcnQgYSBuZXcgcnVuXG4gICAgICAgICAgaWYocCAhPT0gYykge1xuICAgICAgICAgICAgcnVuc1tucisrXSA9IHhbdV07XG4gICAgICAgICAgICBydW5zW25yKytdID0gYztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9BZGQgc2VudGluZWwgcnVuXG4gICAgICAgIHJ1bnNbbnIrK10gPSBkaW1zW3VdO1xuICAgICAgICBydW5zW25yKytdID0gMDtcbiAgICAgICAgLy9VcGRhdGUgZnJvbnRpZXIgYnkgbWVyZ2luZyBydW5zXG4gICAgICAgIHZhciBmcCA9IDA7XG4gICAgICAgIGZvcih2YXIgaT0wLCBqPTA7IGk8bmYgJiYgajxuci0yOyApIHtcbiAgICAgICAgICB2YXIgcCAgICA9IHBvbHlnb25zW2Zyb250aWVyW2ldXVxuICAgICAgICAgICAgLCBwX2wgID0gcC5sZWZ0W3AubGVmdC5sZW5ndGgtMV1bMF1cbiAgICAgICAgICAgICwgcF9yICA9IHAucmlnaHRbcC5yaWdodC5sZW5ndGgtMV1bMF1cbiAgICAgICAgICAgICwgcF9jICA9IHAuY29sb3JcbiAgICAgICAgICAgICwgcl9sICA9IHJ1bnNbal0gICAgLy9TdGFydCBvZiBydW5cbiAgICAgICAgICAgICwgcl9yICA9IHJ1bnNbaisyXSAgLy9FbmQgb2YgcnVuXG4gICAgICAgICAgICAsIHJfYyAgPSBydW5zW2orMV07IC8vQ29sb3Igb2YgcnVuXG4gICAgICAgICAgLy9DaGVjayBpZiB3ZSBjYW4gbWVyZ2UgcnVuIHdpdGggcG9seWdvblxuICAgICAgICAgIGlmKHJfciA+IHBfbCAmJiBwX3IgPiByX2wgJiYgcl9jID09PSBwX2MpIHtcbiAgICAgICAgICAgIC8vTWVyZ2UgcnVuXG4gICAgICAgICAgICBwLm1lcmdlX3J1bih4W3ZdLCByX2wsIHJfcik7XG4gICAgICAgICAgICAvL0luc2VydCBwb2x5Z29uIGludG8gZnJvbnRpZXJcbiAgICAgICAgICAgIG5leHRfZnJvbnRpZXJbZnArK10gPSBmcm9udGllcltpXTtcbiAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIGogKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9DaGVjayBpZiB3ZSBuZWVkIHRvIGFkdmFuY2UgdGhlIHJ1biBwb2ludGVyXG4gICAgICAgICAgICBpZihyX3IgPD0gcF9yKSB7XG4gICAgICAgICAgICAgIGlmKCEhcl9jKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5fcG9seSA9IG5ldyBNb25vdG9uZVBvbHlnb24ocl9jLCB4W3ZdLCByX2wsIHJfcik7XG4gICAgICAgICAgICAgICAgbmV4dF9mcm9udGllcltmcCsrXSA9IHBvbHlnb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBwb2x5Z29ucy5wdXNoKG5fcG9seSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaiArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9DaGVjayBpZiB3ZSBuZWVkIHRvIGFkdmFuY2UgdGhlIGZyb250aWVyIHBvaW50ZXJcbiAgICAgICAgICAgIGlmKHBfciA8PSByX3IpIHtcbiAgICAgICAgICAgICAgcC5jbG9zZV9vZmYoeFt2XSk7XG4gICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9DbG9zZSBvZmYgYW55IHJlc2lkdWFsIHBvbHlnb25zXG4gICAgICAgIGZvcig7IGk8bmY7ICsraSkge1xuICAgICAgICAgIHBvbHlnb25zW2Zyb250aWVyW2ldXS5jbG9zZV9vZmYoeFt2XSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9BZGQgYW55IGV4dHJhIHJ1bnMgdG8gZnJvbnRpZXJcbiAgICAgICAgZm9yKDsgajxuci0yOyBqKz0yKSB7XG4gICAgICAgICAgdmFyIHJfbCAgPSBydW5zW2pdXG4gICAgICAgICAgICAsIHJfciAgPSBydW5zW2orMl1cbiAgICAgICAgICAgICwgcl9jICA9IHJ1bnNbaisxXTtcbiAgICAgICAgICBpZighIXJfYykge1xuICAgICAgICAgICAgdmFyIG5fcG9seSA9IG5ldyBNb25vdG9uZVBvbHlnb24ocl9jLCB4W3ZdLCByX2wsIHJfcik7XG4gICAgICAgICAgICBuZXh0X2Zyb250aWVyW2ZwKytdID0gcG9seWdvbnMubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbnMucHVzaChuX3BvbHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1N3YXAgZnJvbnRpZXJzXG4gICAgICAgIHZhciB0bXAgPSBuZXh0X2Zyb250aWVyO1xuICAgICAgICBuZXh0X2Zyb250aWVyID0gZnJvbnRpZXI7XG4gICAgICAgIGZyb250aWVyID0gdG1wO1xuICAgICAgICBuZiA9IGZwO1xuICAgICAgfVxuICAgICAgLy9DbG9zZSBvZmYgZnJvbnRpZXJcbiAgICAgIGZvcih2YXIgaT0wOyBpPG5mOyArK2kpIHtcbiAgICAgICAgdmFyIHAgPSBwb2x5Z29uc1tmcm9udGllcltpXV07XG4gICAgICAgIHAuY2xvc2Vfb2ZmKGRpbXNbdl0pO1xuICAgICAgfVxuICAgICAgLy8gLS0tIE1vbm90b25lIHN1YmRpdmlzaW9uIG9mIHBvbHlnb24gaXMgY29tcGxldGUgYXQgdGhpcyBwb2ludCAtLS1cbiAgICAgIFxuICAgICAgeFtkXSsrO1xuICAgICAgXG4gICAgICAvL05vdyB3ZSBqdXN0IG5lZWQgdG8gdHJpYW5ndWxhdGUgZWFjaCBtb25vdG9uZSBwb2x5Z29uXG4gICAgICBmb3IodmFyIGk9MDsgaTxwb2x5Z29ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcCA9IHBvbHlnb25zW2ldXG4gICAgICAgICAgLCBjID0gcC5jb2xvclxuICAgICAgICAgICwgZmxpcHBlZCA9IGZhbHNlO1xuICAgICAgICBpZihjIDwgMCkge1xuICAgICAgICAgIGZsaXBwZWQgPSB0cnVlO1xuICAgICAgICAgIGMgPSAtYztcbiAgICAgICAgfVxuICAgICAgICBmb3IodmFyIGo9MDsgajxwLmxlZnQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICBsZWZ0X2luZGV4W2pdID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgIHZhciB5ID0gWzAuMCwwLjAsMC4wXVxuICAgICAgICAgICAgLCB6ID0gcC5sZWZ0W2pdO1xuICAgICAgICAgIHlbZF0gPSB4W2RdO1xuICAgICAgICAgIHlbdV0gPSB6WzBdO1xuICAgICAgICAgIHlbdl0gPSB6WzFdO1xuICAgICAgICAgIHZlcnRpY2VzLnB1c2goeSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKHZhciBqPTA7IGo8cC5yaWdodC5sZW5ndGg7ICsraikge1xuICAgICAgICAgIHJpZ2h0X2luZGV4W2pdID0gdmVydGljZXMubGVuZ3RoO1xuICAgICAgICAgIHZhciB5ID0gWzAuMCwwLjAsMC4wXVxuICAgICAgICAgICAgLCB6ID0gcC5yaWdodFtqXTtcbiAgICAgICAgICB5W2RdID0geFtkXTtcbiAgICAgICAgICB5W3VdID0gelswXTtcbiAgICAgICAgICB5W3ZdID0gelsxXTtcbiAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJpYW5ndWxhdGUgdGhlIG1vbm90b25lIHBvbHlnb25cbiAgICAgICAgdmFyIGJvdHRvbSA9IDBcbiAgICAgICAgICAsIHRvcCA9IDBcbiAgICAgICAgICAsIGxfaSA9IDFcbiAgICAgICAgICAsIHJfaSA9IDFcbiAgICAgICAgICAsIHNpZGUgPSB0cnVlOyAgLy90cnVlID0gcmlnaHQsIGZhbHNlID0gbGVmdFxuICAgICAgICBcbiAgICAgICAgc3RhY2tbdG9wKytdID0gbGVmdF9pbmRleFswXTtcbiAgICAgICAgc3RhY2tbdG9wKytdID0gcC5sZWZ0WzBdWzBdO1xuICAgICAgICBzdGFja1t0b3ArK10gPSBwLmxlZnRbMF1bMV07XG4gICAgICAgIFxuICAgICAgICBzdGFja1t0b3ArK10gPSByaWdodF9pbmRleFswXTtcbiAgICAgICAgc3RhY2tbdG9wKytdID0gcC5yaWdodFswXVswXTtcbiAgICAgICAgc3RhY2tbdG9wKytdID0gcC5yaWdodFswXVsxXTtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlKGxfaSA8IHAubGVmdC5sZW5ndGggfHwgcl9pIDwgcC5yaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAvL0NvbXB1dGUgbmV4dCBzaWRlXG4gICAgICAgICAgdmFyIG5fc2lkZSA9IGZhbHNlO1xuICAgICAgICAgIGlmKGxfaSA9PT0gcC5sZWZ0Lmxlbmd0aCkge1xuICAgICAgICAgICAgbl9zaWRlID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYocl9pICE9PSBwLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGwgPSBwLmxlZnRbbF9pXVxuICAgICAgICAgICAgICAsIHIgPSBwLnJpZ2h0W3JfaV07XG4gICAgICAgICAgICBuX3NpZGUgPSBsWzFdID4gclsxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGlkeCA9IG5fc2lkZSA/IHJpZ2h0X2luZGV4W3JfaV0gOiBsZWZ0X2luZGV4W2xfaV1cbiAgICAgICAgICAgICwgdmVydCA9IG5fc2lkZSA/IHAucmlnaHRbcl9pXSA6IHAubGVmdFtsX2ldO1xuICAgICAgICAgIGlmKG5fc2lkZSAhPT0gc2lkZSkge1xuICAgICAgICAgICAgLy9PcHBvc2l0ZSBzaWRlXG4gICAgICAgICAgICB3aGlsZShib3R0b20rMyA8IHRvcCkge1xuICAgICAgICAgICAgICBpZihmbGlwcGVkID09PSBuX3NpZGUpIHtcbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKFsgc3RhY2tbYm90dG9tXSwgc3RhY2tbYm90dG9tKzNdLCBpZHgsIGNdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWNlcy5wdXNoKFsgc3RhY2tbYm90dG9tKzNdLCBzdGFja1tib3R0b21dLCBpZHgsIGNdKTsgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJvdHRvbSArPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL1NhbWUgc2lkZVxuICAgICAgICAgICAgd2hpbGUoYm90dG9tKzMgPCB0b3ApIHtcbiAgICAgICAgICAgICAgLy9Db21wdXRlIGNvbnZleGl0eVxuICAgICAgICAgICAgICBmb3IodmFyIGo9MDsgajwyOyArK2opXG4gICAgICAgICAgICAgIGZvcih2YXIgaz0wOyBrPDI7ICsraykge1xuICAgICAgICAgICAgICAgIGRlbHRhW2pdW2tdID0gc3RhY2tbdG9wLTMqKGorMSkraysxXSAtIHZlcnRba107XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGRldCA9IGRlbHRhWzBdWzBdICogZGVsdGFbMV1bMV0gLSBkZWx0YVsxXVswXSAqIGRlbHRhWzBdWzFdO1xuICAgICAgICAgICAgICBpZihuX3NpZGUgPT09IChkZXQgPiAwKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKGRldCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmKGZsaXBwZWQgPT09IG5fc2lkZSkge1xuICAgICAgICAgICAgICAgICAgZmFjZXMucHVzaChbIHN0YWNrW3RvcC0zXSwgc3RhY2tbdG9wLTZdLCBpZHgsIGMgXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZhY2VzLnB1c2goWyBzdGFja1t0b3AtNl0sIHN0YWNrW3RvcC0zXSwgaWR4LCBjIF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0b3AgLT0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy9QdXNoIHZlcnRleFxuICAgICAgICAgIHN0YWNrW3RvcCsrXSA9IGlkeDtcbiAgICAgICAgICBzdGFja1t0b3ArK10gPSB2ZXJ0WzBdO1xuICAgICAgICAgIHN0YWNrW3RvcCsrXSA9IHZlcnRbMV07XG4gICAgICAgICAgLy9VcGRhdGUgbG9vcCBpbmRleFxuICAgICAgICAgIGlmKG5fc2lkZSkge1xuICAgICAgICAgICAgKytyX2k7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICsrbF9pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzaWRlID0gbl9zaWRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHZlcnRpY2VzOnZlcnRpY2VzLCBmYWNlczpmYWNlcyB9O1xufVxufSkoKTtcblxuaWYoZXhwb3J0cykge1xuICBleHBvcnRzLm1lc2hlciA9IE1vbm90b25lTWVzaDtcbn1cbiIsIi8vVGhlIHN0dXBpZGVzdCBwb3NzaWJsZSB3YXkgdG8gZ2VuZXJhdGUgYSBNaW5lY3JhZnQgbWVzaCAoSSB0aGluaylcbmZ1bmN0aW9uIFN0dXBpZE1lc2godm9sdW1lLCBkaW1zKSB7XG4gIHZhciB2ZXJ0aWNlcyA9IFtdLCBmYWNlcyA9IFtdLCB4ID0gWzAsMCwwXSwgbiA9IDA7XG4gIGZvcih4WzJdPTA7IHhbMl08ZGltc1syXTsgKyt4WzJdKVxuICBmb3IoeFsxXT0wOyB4WzFdPGRpbXNbMV07ICsreFsxXSlcbiAgZm9yKHhbMF09MDsgeFswXTxkaW1zWzBdOyArK3hbMF0sICsrbilcbiAgaWYoISF2b2x1bWVbbl0pIHtcbiAgICBmb3IodmFyIGQ9MDsgZDwzOyArK2QpIHtcbiAgICAgIHZhciB0ID0gW3hbMF0sIHhbMV0sIHhbMl1dXG4gICAgICAgICwgdSA9IFswLDAsMF1cbiAgICAgICAgLCB2ID0gWzAsMCwwXTtcbiAgICAgIHVbKGQrMSklM10gPSAxO1xuICAgICAgdlsoZCsyKSUzXSA9IDE7XG4gICAgICBmb3IodmFyIHM9MDsgczwyOyArK3MpIHtcbiAgICAgICAgdFtkXSA9IHhbZF0gKyBzO1xuICAgICAgICB2YXIgdG1wID0gdTtcbiAgICAgICAgdSA9IHY7XG4gICAgICAgIHYgPSB0bXA7XG4gICAgICAgIHZhciB2ZXJ0ZXhfY291bnQgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgICAgIHZlcnRpY2VzLnB1c2goW3RbMF0sICAgICAgICAgICB0WzFdLCAgICAgICAgICAgdFsyXSAgICAgICAgICBdKTtcbiAgICAgICAgdmVydGljZXMucHVzaChbdFswXSt1WzBdLCAgICAgIHRbMV0rdVsxXSwgICAgICB0WzJdK3VbMl0gICAgIF0pO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFt0WzBdK3VbMF0rdlswXSwgdFsxXSt1WzFdK3ZbMV0sIHRbMl0rdVsyXSt2WzJdXSk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2goW3RbMF0gICAgICt2WzBdLCB0WzFdICAgICArdlsxXSwgdFsyXSAgICAgK3ZbMl1dKTtcbiAgICAgICAgZmFjZXMucHVzaChbdmVydGV4X2NvdW50LCB2ZXJ0ZXhfY291bnQrMSwgdmVydGV4X2NvdW50KzIsIHZlcnRleF9jb3VudCszLCB2b2x1bWVbbl1dKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdmVydGljZXM6dmVydGljZXMsIGZhY2VzOmZhY2VzIH07XG59XG5cblxuaWYoZXhwb3J0cykge1xuICBleHBvcnRzLm1lc2hlciA9IFN0dXBpZE1lc2g7XG59XG4iLCJ2YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpXG5cbm1vZHVsZS5leHBvcnRzID0gSGlnaGxpZ2h0ZXJcblxuZnVuY3Rpb24gSGlnaGxpZ2h0ZXIoZ2FtZSwgb3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSGlnaGxpZ2h0ZXIpKSByZXR1cm4gbmV3IEhpZ2hsaWdodGVyKGdhbWUsIG9wdHMpXG4gIHRoaXMuZ2FtZSA9IGdhbWVcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgdGhpcy5lbmFibGVkID0gb3B0cy5lbmFibGVkIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLmdlb21ldHJ5ID0gb3B0cy5nZW9tZXRyeSB8fCBuZXcgZ2FtZS5USFJFRS5DdWJlR2VvbWV0cnkoMSwgMSwgMSlcbiAgdmFyIG1hdGVyaWFsID0gb3B0cy5tYXRlcmlhbCB8fCBuZXcgZ2FtZS5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgY29sb3I6IG9wdHMuY29sb3IgfHwgMHgwMDAwMDAsXG4gICAgd2lyZWZyYW1lOiB0cnVlLFxuICAgIHdpcmVmcmFtZUxpbmV3aWR0aDogb3B0cy53aXJlZnJhbWVMaW5ld2lkdGggfHwgMyxcbiAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICBvcGFjaXR5OiBvcHRzLndpcmVmcmFtZU9wYWNpdHkgfHwgMC41XG4gIH0pXG4gIHRoaXMubWVzaCA9IG5ldyBnYW1lLlRIUkVFLk1lc2goZ2VvbWV0cnksIG1hdGVyaWFsKVxuICB0aGlzLmRpc3RhbmNlID0gb3B0cy5kaXN0YW5jZSB8fCAxMFxuICB0aGlzLmN1cnJWb3hlbFBvcyAvLyB1bmRlZmluZWQgd2hlbiBubyB2b3hlbCBzZWxlY3RlZCBmb3IgaGlnaGxpZ2h0XG4gIHRoaXMuY3VyclZveGVsQWRqIC8vIHVuZGVmaW5lZCB3aGVuIG5vIGFkamFjZW50IHZveGVsIHNlbGVjdGVkIGZvciBoaWdobGlnaHRcbiAgdGhpcy50YXJnZXRQb3NpdGlvbiAvLyBkZXNpcmVkIHBvc2l0aW9uIG9mIGhpZ2hsaWdodCBjdWJlIGNlbnRlclxuICBcbiAgLy8gdGhlIGFkamFjZW50IGhpZ2hsaWdodCB3aWxsIGJlIGFjdGl2ZSB3aGVuIHRoZSBmb2xsb3dpbmcgcmV0dXJucyB0cnVlXG4gIHRoaXMuYWRqYWNlbnRBY3RpdmUgPSBvcHRzLmFkamFjZW50QWN0aXZlIHx8IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdhbWUuY29udHJvbHMuc3RhdGUuYWx0IH1cbiAgXG4gIC8vIHRoZSBzZWxlY3Rpb24gaGlnaGxpZ2h0IHdpbGwgYmUgYWN0aXZlIHdoZW4gdGhlIGZvbGxvd2luZyByZXR1cm5zIHRydWVcbiAgdGhpcy5zZWxlY3RBY3RpdmUgPSBvcHRzLnNlbGVjdEFjdGl2ZSB8fCBmdW5jdGlvbiAoKSB7IHJldHVybiBnYW1lLmNvbnRyb2xzLnN0YXRlLnNlbGVjdCB9XG4gIFxuICAvLyBhbmltYXRlIGhpZ2hsaWdodCB0cmFuc2l0aW9ucz9cbiAgdGhpcy5hbmltYXRlID0gb3B0cy5hbmltYXRlXG4gIHRoaXMuYW5pbWF0ZUZ1bmN0aW9uID0gb3B0cy5hbmltYXRlRnVuY3Rpb24gfHwgZnVuY3Rpb24gKHBvc2l0aW9uLCB0YXJnZXRQb3NpdGlvbiwgZGVsdGFUaW1lKSB7XG4gICAgaWYgKCFwb3NpdGlvbiB8fCAhdGFyZ2V0UG9zaXRpb24gfHwgIWRlbHRhVGltZSkgcmV0dXJuO1xuICAgIHZhciByYXRlID0gMTBcbiAgICBpZiAoTWF0aC5hYnModGFyZ2V0UG9zaXRpb25bMF0gLSBwb3NpdGlvblswXSkgPCAwLjA1XG4gICAgICYmIE1hdGguYWJzKHRhcmdldFBvc2l0aW9uWzFdIC0gcG9zaXRpb25bMV0pIDwgMC4wNVxuICAgICAmJiBNYXRoLmFicyh0YXJnZXRQb3NpdGlvblsyXSAtIHBvc2l0aW9uWzJdKSA8IDAuMDUpIHtcbiAgICAgIHJldHVybiB0YXJnZXRQb3NpdGlvbiAvLyBjbG9zZSBlbm91Z2ggdG8gc25hcCBhbmQgYmUgZG9uZVxuICAgIH1cbiAgICBkZWx0YVRpbWUgPSBkZWx0YVRpbWUgLyAxMDAwIC8vIHVzdWFsbHkgYXJvdW5kIC4wMTYgc2Vjb25kcyAoNjAgRlBTKVxuICAgIHBvc2l0aW9uWzBdICs9IHJhdGUgKiBkZWx0YVRpbWUgKiAodGFyZ2V0UG9zaXRpb25bMF0gLSBwb3NpdGlvblswXSlcbiAgICBwb3NpdGlvblsxXSArPSByYXRlICogZGVsdGFUaW1lICogKHRhcmdldFBvc2l0aW9uWzFdIC0gcG9zaXRpb25bMV0pXG4gICAgcG9zaXRpb25bMl0gKz0gcmF0ZSAqIGRlbHRhVGltZSAqICh0YXJnZXRQb3NpdGlvblsyXSAtIHBvc2l0aW9uWzJdKVxuICAgIHJldHVybiBwb3NpdGlvblxuICB9XG5cbiAgLy8gaGlnaGxpZ2h0ICdlYXNpbmcnIGFuaW1hdGlvbiwgY2FsbGVkIGV2ZXJ5IHRpY2sgaWYgZW5hYmxlZFxuICB2YXIgc2VsZiA9IHRoaXNcbiAgaWYgKHRoaXMuYW5pbWF0ZSkgZ2FtZS5vbigndGljaycsIGZ1bmN0aW9uIChkdCkge1xuICAgIHZhciBwb3NpdGlvbiA9IFtzZWxmLm1lc2gucG9zaXRpb24ueCwgc2VsZi5tZXNoLnBvc2l0aW9uLnksIHNlbGYubWVzaC5wb3NpdGlvbi56XVxuICAgIHBvc2l0aW9uID0gc2VsZi5hbmltYXRlRnVuY3Rpb24ocG9zaXRpb24sIHNlbGYudGFyZ2V0UG9zaXRpb24sIGR0KVxuICAgIGlmIChwb3NpdGlvbikgc2VsZi5tZXNoLnBvc2l0aW9uLnNldChwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIHBvc2l0aW9uWzJdKVxuICB9KVxuXG4gIGdhbWUub24oJ3RpY2snLCBfLnRocm90dGxlKHRoaXMuaGlnaGxpZ2h0LmJpbmQodGhpcyksIG9wdHMuZnJlcXVlbmN5IHx8IDEwMCkpXG4gIFxuICAvLyBhbmNob3JzIGZvciBtdWx0aS12b3hlbCBzZWxlY3Rpb25cbiAgdGhpcy5zZWxlY3RTdGFydFxuICB0aGlzLnNlbGVjdEVuZFxufVxuXG5pbmhlcml0cyhIaWdobGlnaHRlciwgZXZlbnRzLkV2ZW50RW1pdHRlcilcblxuSGlnaGxpZ2h0ZXIucHJvdG90eXBlLmhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcblxuICBpZiAoIXRoaXMuZW5hYmxlZCgpKSB7XG4gICAgaWYgKHRoaXMubWVzaC5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuZ2FtZS5zY2VuZS5yZW1vdmUodGhpcy5tZXNoKVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY3AgPSB0aGlzLmdhbWUuY2FtZXJhUG9zaXRpb24oKVxuICB2YXIgY3YgPSB0aGlzLmdhbWUuY2FtZXJhVmVjdG9yKClcbiAgdmFyIGhpdCA9IHRoaXMuZ2FtZS5yYXljYXN0Vm94ZWxzKGNwLCBjdiwgdGhpcy5kaXN0YW5jZSlcbiAgdmFyIHRhcmdldFBvc2l0aW9uQ2FuZGlkYXRlXG5cbiAgdmFyIHJlbW92ZUFkamFjZW50ID0gZnVuY3Rpb24gKHNlbGYpIHsgLy8gcmVtb3ZlIGFkamFjZW50IGhpZ2hsaWdodCBpZiBhbnlcbiAgICBpZiAoIXNlbGYuY3VyclZveGVsQWRqKSByZXR1cm47XG4gICAgc2VsZi5lbWl0KCdyZW1vdmUtYWRqYWNlbnQnLCBzZWxmLmN1cnJWb3hlbEFkailcbiAgICBzZWxmLmN1cnJWb3hlbEFkaiA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gcmVtb3ZlIGV4aXN0aW5nIGhpZ2hsaWdodCBpZiBhbnlcbiAgaWYgKCFoaXQpIHtcbiAgICBpZiAoIXRoaXMuY3VyclZveGVsUG9zKSByZXR1cm47IC8vIGFscmVhZHkgcmVtb3ZlZFxuICAgIHRoaXMuZ2FtZS5zY2VuZS5yZW1vdmUodGhpcy5tZXNoKVxuICAgIHRoaXMuZW1pdCgncmVtb3ZlJywgdGhpcy5jdXJyVm94ZWxQb3Muc2xpY2UoKSlcbiAgICB0aGlzLmN1cnJWb3hlbFBvcyA9IHVuZGVmaW5lZFxuICAgIHJlbW92ZUFkamFjZW50KHRoaXMpXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5ld1ZveGVsUG9zID0gaGl0LnZveGVsXG4gIGlmICghdGhpcy5jdXJyVm94ZWxQb3NcbiAgICB8fCBuZXdWb3hlbFBvc1swXSAhPT0gdGhpcy5jdXJyVm94ZWxQb3NbMF1cbiAgICB8fCBuZXdWb3hlbFBvc1sxXSAhPT0gdGhpcy5jdXJyVm94ZWxQb3NbMV1cbiAgICB8fCBuZXdWb3hlbFBvc1syXSAhPT0gdGhpcy5jdXJyVm94ZWxQb3NbMl0pIHsgLy8gbm8gY3VycmVudCBoaWdobGlnaHQgb3IgaXQgbW92ZWRcblxuICAgIGlmICh0aGlzLmN1cnJWb3hlbFBvcykge1xuICAgICAgdGhpcy5lbWl0KCdyZW1vdmUnLCB0aGlzLmN1cnJWb3hlbFBvcy5zbGljZSgpKSAvLyBtb3ZlZCBoaWdobGlnaHRcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmdhbWUuc2NlbmUuYWRkKHRoaXMubWVzaCkgLy8gZnJlc2ggaGlnaGxpZ2h0XG4gICAgfVxuICAgIHRoaXMuZW1pdCgnaGlnaGxpZ2h0JywgbmV3Vm94ZWxQb3Muc2xpY2UoKSlcbiAgICB0aGlzLmN1cnJWb3hlbFBvcyA9IG5ld1ZveGVsUG9zLnNsaWNlKClcbiAgfVxuICAvLyB0cnkgdG8gc2V0IHRoZSBwb3NpdGlvbiBldmVyeSB0aW1lLCBpdCBtYXkgYmUgb3ZlcnJpZGRlbiBiZWxvd1xuICB0YXJnZXRQb3NpdGlvbkNhbmRpZGF0ZSA9IFt0aGlzLmN1cnJWb3hlbFBvc1swXSArIDAuNSwgdGhpcy5jdXJyVm94ZWxQb3NbMV0gKyAwLjUsIHRoaXMuY3VyclZveGVsUG9zWzJdICsgMC41XVxuXG4gIC8vIGlmIGluIFwiYWRqYWNlbnRcIiBtb2RlLCBoaWdobGlnaHQgYWRqYWNlbnQgdm94ZWwgaW5zdGVhZFxuICBpZiAodGhpcy5hZGphY2VudEFjdGl2ZSgpKSB7XG4gICAgLy8gc2luY2Ugd2UgZ290IGhlcmUsIHdlIGtub3cgd2UgaGF2ZSBhIHNlbGVjdGVkIG5vbi1lbXB0eSB2b3hlbFxuICAgIC8vIGFuZCB3aXRoIGFuIGVtcHR5IGFkamFjZW50IHZveGVsIHRoYXQgd2UgY2FuIHdvcmsgd2l0aFxuICAgIHZhciBuZXdWb3hlbEFkaiA9IGhpdC5hZGphY2VudFxuICAgIGlmICghdGhpcy5jdXJyVm94ZWxBZGpcbiAgICAgIHx8IG5ld1ZveGVsQWRqWzBdICE9PSB0aGlzLmN1cnJWb3hlbEFkalswXVxuICAgICAgfHwgbmV3Vm94ZWxBZGpbMV0gIT09IHRoaXMuY3VyclZveGVsQWRqWzFdXG4gICAgICB8fCBuZXdWb3hlbEFkalsyXSAhPT0gdGhpcy5jdXJyVm94ZWxBZGpbMl0pIHsgLy8gbm8gY3VycmVudCBhZGogaGlnaGxpZ2h0IG9yIGl0IGhhcyBtb3ZlZFxuICBcbiAgICAgIGlmICh0aGlzLmN1cnJWb3hlbEFkaikge1xuICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZS1hZGphY2VudCcsIHRoaXMuY3VyclZveGVsQWRqLnNsaWNlKCkpIC8vIG1vdmVkIGFkamFjZW50IGhpZ2hsaWdodFxuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KCdoaWdobGlnaHQtYWRqYWNlbnQnLCBuZXdWb3hlbEFkai5zbGljZSgpKVxuICAgICAgXG4gICAgICB0aGlzLmN1cnJWb3hlbEFkaiA9IG5ld1ZveGVsQWRqLnNsaWNlKClcbiAgICB9XG4gICAgdGFyZ2V0UG9zaXRpb25DYW5kaWRhdGUgPSBbdGhpcy5jdXJyVm94ZWxBZGpbMF0gKyAwLjUsIHRoaXMuY3VyclZveGVsQWRqWzFdICsgMC41LCB0aGlzLmN1cnJWb3hlbEFkalsyXSArIDAuNV1cbiAgfVxuICBlbHNlIHJlbW92ZUFkamFjZW50KHRoaXMpXG5cbiAgLy8gaWYgaW4gXCJzZWxlY3RcIiBtb2RlLCB0cmFjayBzdGFydCBhbmQgZW5kIHZveGVsIGJvdW5kc1xuICBpZiAodGhpcy5zZWxlY3RBY3RpdmUoKSkge1xuICAgIGlmICghdGhpcy5zZWxlY3RTdGFydCkgeyAvLyBzdGFydCBhIG5ldyBzZWxlY3Rpb25cbiAgICAgIHRoaXMuc2VsZWN0U3RhcnQgPSB0aGlzLnNlbGVjdEVuZCA9IHRoaXMuY3VyclZveGVsQWRqIHx8IHRoaXMuY3VyclZveGVsUG9zXG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGVuZENhbmRpZGF0ZSA9IHRoaXMuY3VyclZveGVsQWRqIHx8IHRoaXMuY3VyclZveGVsUG9zXG4gICAgICBpZiAoZW5kQ2FuZGlkYXRlWzBdICE9PSB0aGlzLnNlbGVjdEVuZFswXVxuICAgICAgIHx8IGVuZENhbmRpZGF0ZVsxXSAhPT0gdGhpcy5zZWxlY3RFbmRbMV1cbiAgICAgICB8fCBlbmRDYW5kaWRhdGVbMl0gIT09IHRoaXMuc2VsZWN0RW5kWzJdKSB7IFxuICAgICAgICAgXG4gICAgICAgIHRoaXMuc2VsZWN0RW5kID0gZW5kQ2FuZGlkYXRlIC8vIHNlbGVjdGlvbiBlbmQgaGFzIGNoYW5nZWRcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZW1pdCgnaGlnaGxpZ2h0LXNlbGVjdCcsIHsgc3RhcnQ6IHRoaXMuc2VsZWN0U3RhcnQuc2xpY2UoKSwgZW5kOiB0aGlzLnNlbGVjdEVuZC5zbGljZSgpIH0pXG4gICAgICAgIFxuICAgICAgICB2YXIgc2NhbGUgPSBbXVxuICAgICAgICBzY2FsZVswXSA9IE1hdGguYWJzKHRoaXMuc2VsZWN0RW5kWzBdIC0gdGhpcy5zZWxlY3RTdGFydFswXSkgKyAxXG4gICAgICAgIHNjYWxlWzFdID0gTWF0aC5hYnModGhpcy5zZWxlY3RFbmRbMV0gLSB0aGlzLnNlbGVjdFN0YXJ0WzFdKSArIDFcbiAgICAgICAgc2NhbGVbMl0gPSBNYXRoLmFicyh0aGlzLnNlbGVjdEVuZFsyXSAtIHRoaXMuc2VsZWN0U3RhcnRbMl0pICsgMVxuICAgICAgICB0aGlzLm1lc2guc2NhbGUuc2V0KHNjYWxlWzBdLCBzY2FsZVsxXSwgc2NhbGVbMl0pXG4gICAgICAgIFxuICAgICAgICB2YXIgcG9zID0gW11cbiAgICAgICAgcG9zWzBdID0gdGhpcy5zZWxlY3RTdGFydFswXSArIDAuNSArICh0aGlzLnNlbGVjdEVuZFswXSAtIHRoaXMuc2VsZWN0U3RhcnRbMF0pIC8gMlxuICAgICAgICBwb3NbMV0gPSB0aGlzLnNlbGVjdFN0YXJ0WzFdICsgMC41ICsgKHRoaXMuc2VsZWN0RW5kWzFdIC0gdGhpcy5zZWxlY3RTdGFydFsxXSkgLyAyXG4gICAgICAgIHBvc1syXSA9IHRoaXMuc2VsZWN0U3RhcnRbMl0gKyAwLjUgKyAodGhpcy5zZWxlY3RFbmRbMl0gLSB0aGlzLnNlbGVjdFN0YXJ0WzJdKSAvIDJcbiAgICAgICAgdGhpcy50YXJnZXRQb3NpdGlvbiA9IHBvc1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBpZiAodGhpcy5zZWxlY3RTdGFydCkge1xuICAgICAgdGhpcy5lbWl0KCdoaWdobGlnaHQtZGVzZWxlY3QnLCB7IHN0YXJ0OiB0aGlzLnNlbGVjdFN0YXJ0LnNsaWNlKCksIGVuZDogdGhpcy5zZWxlY3RFbmQuc2xpY2UoKSB9KVxuICAgICAgdGhpcy5zZWxlY3RTdGFydCA9IG51bGxcbiAgICAgIHRoaXMubWVzaC5zY2FsZS5zZXQoMSwgMSwgMSlcbiAgICB9XG4gICAgdGhpcy50YXJnZXRQb3NpdGlvbiA9IHRhcmdldFBvc2l0aW9uQ2FuZGlkYXRlIC8vIGhpZ2hsaWdodGVkIHZveGVsIG9yIGFkamFjZW50XG4gIH1cbiAgaWYgKCF0aGlzLmFuaW1hdGUpIHRoaXMubWVzaC5wb3NpdGlvbi5zZXQodGhpcy50YXJnZXRQb3NpdGlvblswXSwgdGhpcy50YXJnZXRQb3NpdGlvblsxXSwgdGhpcy50YXJnZXRQb3NpdGlvblsyXSlcbn1cbiIsInZhciBub2lzZSA9IHJlcXVpcmUoJ3BlcmxpbicpLm5vaXNlXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VlZCwgZmxvb3IsIGNlaWxpbmcsIGRpdmlzb3IpIHtcbiAgZmxvb3IgPSBmbG9vciB8fCAwXG4gIGNlaWxpbmcgPSBjZWlsaW5nIHx8IDIwIC8vIG1pbmVjcmFmdCdzIGxpbWl0XG4gIGRpdmlzb3IgPSBkaXZpc29yIHx8IDUwXG4gIG5vaXNlLnNlZWQoc2VlZClcbiAgcmV0dXJuIGZ1bmN0aW9uIGdlbmVyYXRlQ2h1bmsocG9zaXRpb24sIHdpZHRoKSB7XG4gICAgdmFyIHN0YXJ0WCA9IHBvc2l0aW9uWzBdICogd2lkdGhcbiAgICB2YXIgc3RhcnRZID0gcG9zaXRpb25bMV0gKiB3aWR0aFxuICAgIHZhciBzdGFydFogPSBwb3NpdGlvblsyXSAqIHdpZHRoXG4gICAgdmFyIGNodW5rID0gbmV3IEludDhBcnJheSh3aWR0aCAqIHdpZHRoICogd2lkdGgpXG4gICAgcG9pbnRzSW5zaWRlKHN0YXJ0WCwgc3RhcnRaLCB3aWR0aCwgZnVuY3Rpb24oeCwgeikge1xuICAgICAgdmFyIG4gPSBub2lzZS5zaW1wbGV4Mih4IC8gZGl2aXNvciAsIHogLyBkaXZpc29yKVxuICAgICAgdmFyIHkgPSB+fnNjYWxlKG4sIC0xLCAxLCBmbG9vciwgY2VpbGluZylcbiAgICAgIGlmICh5ID09PSBmbG9vciB8fCBzdGFydFkgPCB5ICYmIHkgPCBzdGFydFkgKyB3aWR0aCkge1xuICAgICAgICB2YXIgeGlkeCA9IE1hdGguYWJzKCh3aWR0aCArIHggJSB3aWR0aCkgJSB3aWR0aClcbiAgICAgICAgdmFyIHlpZHggPSBNYXRoLmFicygod2lkdGggKyB5ICUgd2lkdGgpICUgd2lkdGgpXG4gICAgICAgIHZhciB6aWR4ID0gTWF0aC5hYnMoKHdpZHRoICsgeiAlIHdpZHRoKSAlIHdpZHRoKVxuICAgICAgICB2YXIgaWR4ID0geGlkeCArIHlpZHggKiB3aWR0aCArIHppZHggKiB3aWR0aCAqIHdpZHRoXG4gICAgICAgIGNodW5rW2lkeF0gPSAxXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gY2h1bmtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb2ludHNJbnNpZGUoc3RhcnRYLCBzdGFydFksIHdpZHRoLCBmdW5jKSB7XG4gIGZvciAodmFyIHggPSBzdGFydFg7IHggPCBzdGFydFggKyB3aWR0aDsgeCsrKVxuICAgIGZvciAodmFyIHkgPSBzdGFydFk7IHkgPCBzdGFydFkgKyB3aWR0aDsgeSsrKVxuICAgICAgZnVuYyh4LCB5KVxufVxuXG5mdW5jdGlvbiBzY2FsZSggeCwgZnJvbUxvdywgZnJvbUhpZ2gsIHRvTG93LCB0b0hpZ2ggKSB7XG4gIHJldHVybiAoIHggLSBmcm9tTG93ICkgKiAoIHRvSGlnaCAtIHRvTG93ICkgLyAoIGZyb21IaWdoIC0gZnJvbUxvdyApICsgdG9Mb3dcbn1cbjsiLCIvKlxuICogQSBzcGVlZC1pbXByb3ZlZCBwZXJsaW4gYW5kIHNpbXBsZXggbm9pc2UgYWxnb3JpdGhtcyBmb3IgMkQuXG4gKlxuICogQmFzZWQgb24gZXhhbXBsZSBjb2RlIGJ5IFN0ZWZhbiBHdXN0YXZzb24gKHN0ZWd1QGl0bi5saXUuc2UpLlxuICogT3B0aW1pc2F0aW9ucyBieSBQZXRlciBFYXN0bWFuIChwZWFzdG1hbkBkcml6emxlLnN0YW5mb3JkLmVkdSkuXG4gKiBCZXR0ZXIgcmFuayBvcmRlcmluZyBtZXRob2QgYnkgU3RlZmFuIEd1c3RhdnNvbiBpbiAyMDEyLlxuICogQ29udmVydGVkIHRvIEphdmFzY3JpcHQgYnkgSm9zZXBoIEdlbnRsZS5cbiAqXG4gKiBWZXJzaW9uIDIwMTItMDMtMDlcbiAqXG4gKiBUaGlzIGNvZGUgd2FzIHBsYWNlZCBpbiB0aGUgcHVibGljIGRvbWFpbiBieSBpdHMgb3JpZ2luYWwgYXV0aG9yLFxuICogU3RlZmFuIEd1c3RhdnNvbi4gWW91IG1heSB1c2UgaXQgYXMgeW91IHNlZSBmaXQsIGJ1dFxuICogYXR0cmlidXRpb24gaXMgYXBwcmVjaWF0ZWQuXG4gKlxuICovXG5cbihmdW5jdGlvbihnbG9iYWwpe1xuICB2YXIgbW9kdWxlID0gZ2xvYmFsLm5vaXNlID0ge307XG5cbiAgZnVuY3Rpb24gR3JhZCh4LCB5LCB6KSB7XG4gICAgdGhpcy54ID0geDsgdGhpcy55ID0geTsgdGhpcy56ID0gejtcbiAgfVxuICBcbiAgR3JhZC5wcm90b3R5cGUuZG90MiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy54KnggKyB0aGlzLnkqeTtcbiAgfTtcblxuICBHcmFkLnByb3RvdHlwZS5kb3QzID0gZnVuY3Rpb24oeCwgeSwgeikge1xuICAgIHJldHVybiB0aGlzLngqeCArIHRoaXMueSp5ICsgdGhpcy56Kno7XG4gIH07XG5cbiAgdmFyIGdyYWQzID0gW25ldyBHcmFkKDEsMSwwKSxuZXcgR3JhZCgtMSwxLDApLG5ldyBHcmFkKDEsLTEsMCksbmV3IEdyYWQoLTEsLTEsMCksXG4gICAgICAgICAgICAgICBuZXcgR3JhZCgxLDAsMSksbmV3IEdyYWQoLTEsMCwxKSxuZXcgR3JhZCgxLDAsLTEpLG5ldyBHcmFkKC0xLDAsLTEpLFxuICAgICAgICAgICAgICAgbmV3IEdyYWQoMCwxLDEpLG5ldyBHcmFkKDAsLTEsMSksbmV3IEdyYWQoMCwxLC0xKSxuZXcgR3JhZCgwLC0xLC0xKV07XG5cbiAgdmFyIHAgPSBbMTUxLDE2MCwxMzcsOTEsOTAsMTUsXG4gIDEzMSwxMywyMDEsOTUsOTYsNTMsMTk0LDIzMyw3LDIyNSwxNDAsMzYsMTAzLDMwLDY5LDE0Miw4LDk5LDM3LDI0MCwyMSwxMCwyMyxcbiAgMTkwLCA2LDE0OCwyNDcsMTIwLDIzNCw3NSwwLDI2LDE5Nyw2Miw5NCwyNTIsMjE5LDIwMywxMTcsMzUsMTEsMzIsNTcsMTc3LDMzLFxuICA4OCwyMzcsMTQ5LDU2LDg3LDE3NCwyMCwxMjUsMTM2LDE3MSwxNjgsIDY4LDE3NSw3NCwxNjUsNzEsMTM0LDEzOSw0OCwyNywxNjYsXG4gIDc3LDE0NiwxNTgsMjMxLDgzLDExMSwyMjksMTIyLDYwLDIxMSwxMzMsMjMwLDIyMCwxMDUsOTIsNDEsNTUsNDYsMjQ1LDQwLDI0NCxcbiAgMTAyLDE0Myw1NCwgNjUsMjUsNjMsMTYxLCAxLDIxNiw4MCw3MywyMDksNzYsMTMyLDE4NywyMDgsIDg5LDE4LDE2OSwyMDAsMTk2LFxuICAxMzUsMTMwLDExNiwxODgsMTU5LDg2LDE2NCwxMDAsMTA5LDE5OCwxNzMsMTg2LCAzLDY0LDUyLDIxNywyMjYsMjUwLDEyNCwxMjMsXG4gIDUsMjAyLDM4LDE0NywxMTgsMTI2LDI1NSw4Miw4NSwyMTIsMjA3LDIwNiw1OSwyMjcsNDcsMTYsNTgsMTcsMTgyLDE4OSwyOCw0MixcbiAgMjIzLDE4MywxNzAsMjEzLDExOSwyNDgsMTUyLCAyLDQ0LDE1NCwxNjMsIDcwLDIyMSwxNTMsMTAxLDE1NSwxNjcsIDQzLDE3Miw5LFxuICAxMjksMjIsMzksMjUzLCAxOSw5OCwxMDgsMTEwLDc5LDExMywyMjQsMjMyLDE3OCwxODUsIDExMiwxMDQsMjE4LDI0Niw5NywyMjgsXG4gIDI1MSwzNCwyNDIsMTkzLDIzOCwyMTAsMTQ0LDEyLDE5MSwxNzksMTYyLDI0MSwgODEsNTEsMTQ1LDIzNSwyNDksMTQsMjM5LDEwNyxcbiAgNDksMTkyLDIxNCwgMzEsMTgxLDE5OSwxMDYsMTU3LDE4NCwgODQsMjA0LDE3NiwxMTUsMTIxLDUwLDQ1LDEyNywgNCwxNTAsMjU0LFxuICAxMzgsMjM2LDIwNSw5MywyMjIsMTE0LDY3LDI5LDI0LDcyLDI0MywxNDEsMTI4LDE5NSw3OCw2NiwyMTUsNjEsMTU2LDE4MF07XG4gIC8vIFRvIHJlbW92ZSB0aGUgbmVlZCBmb3IgaW5kZXggd3JhcHBpbmcsIGRvdWJsZSB0aGUgcGVybXV0YXRpb24gdGFibGUgbGVuZ3RoXG4gIHZhciBwZXJtID0gbmV3IEFycmF5KDUxMik7XG4gIHZhciBncmFkUCA9IG5ldyBBcnJheSg1MTIpO1xuXG4gIC8vIFRoaXMgaXNuJ3QgYSB2ZXJ5IGdvb2Qgc2VlZGluZyBmdW5jdGlvbiwgYnV0IGl0IHdvcmtzIG9rLiBJdCBzdXBwb3J0cyAyXjE2XG4gIC8vIGRpZmZlcmVudCBzZWVkIHZhbHVlcy4gV3JpdGUgc29tZXRoaW5nIGJldHRlciBpZiB5b3UgbmVlZCBtb3JlIHNlZWRzLlxuICBtb2R1bGUuc2VlZCA9IGZ1bmN0aW9uKHNlZWQpIHtcbiAgICBpZihzZWVkID4gMCAmJiBzZWVkIDwgMSkge1xuICAgICAgLy8gU2NhbGUgdGhlIHNlZWQgb3V0XG4gICAgICBzZWVkICo9IDY1NTM2O1xuICAgIH1cblxuICAgIHNlZWQgPSBNYXRoLmZsb29yKHNlZWQpO1xuICAgIGlmKHNlZWQgPCAyNTYpIHtcbiAgICAgIHNlZWQgfD0gc2VlZCA8PCA4O1xuICAgIH1cblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgdmFyIHY7XG4gICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgdiA9IHBbaV0gXiAoc2VlZCAmIDI1NSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gcFtpXSBeICgoc2VlZD4+OCkgJiAyNTUpO1xuICAgICAgfVxuXG4gICAgICBwZXJtW2ldID0gcGVybVtpICsgMjU2XSA9IHY7XG4gICAgICBncmFkUFtpXSA9IGdyYWRQW2kgKyAyNTZdID0gZ3JhZDNbdiAlIDEyXTtcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLnNlZWQoMCk7XG5cbiAgLypcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyBpKyspIHtcbiAgICBwZXJtW2ldID0gcGVybVtpICsgMjU2XSA9IHBbaV07XG4gICAgZ3JhZFBbaV0gPSBncmFkUFtpICsgMjU2XSA9IGdyYWQzW3Blcm1baV0gJSAxMl07XG4gIH0qL1xuXG4gIC8vIFNrZXdpbmcgYW5kIHVuc2tld2luZyBmYWN0b3JzIGZvciAyLCAzLCBhbmQgNCBkaW1lbnNpb25zXG4gIHZhciBGMiA9IDAuNSooTWF0aC5zcXJ0KDMpLTEpO1xuICB2YXIgRzIgPSAoMy1NYXRoLnNxcnQoMykpLzY7XG5cbiAgdmFyIEYzID0gMS8zO1xuICB2YXIgRzMgPSAxLzY7XG5cbiAgLy8gMkQgc2ltcGxleCBub2lzZVxuICBtb2R1bGUuc2ltcGxleDIgPSBmdW5jdGlvbih4aW4sIHlpbikge1xuICAgIHZhciBuMCwgbjEsIG4yOyAvLyBOb2lzZSBjb250cmlidXRpb25zIGZyb20gdGhlIHRocmVlIGNvcm5lcnNcbiAgICAvLyBTa2V3IHRoZSBpbnB1dCBzcGFjZSB0byBkZXRlcm1pbmUgd2hpY2ggc2ltcGxleCBjZWxsIHdlJ3JlIGluXG4gICAgdmFyIHMgPSAoeGluK3lpbikqRjI7IC8vIEhhaXJ5IGZhY3RvciBmb3IgMkRcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoeGluK3MpO1xuICAgIHZhciBqID0gTWF0aC5mbG9vcih5aW4rcyk7XG4gICAgdmFyIHQgPSAoaStqKSpHMjtcbiAgICB2YXIgeDAgPSB4aW4taSt0OyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpbiwgdW5za2V3ZWQuXG4gICAgdmFyIHkwID0geWluLWordDtcbiAgICAvLyBGb3IgdGhlIDJEIGNhc2UsIHRoZSBzaW1wbGV4IHNoYXBlIGlzIGFuIGVxdWlsYXRlcmFsIHRyaWFuZ2xlLlxuICAgIC8vIERldGVybWluZSB3aGljaCBzaW1wbGV4IHdlIGFyZSBpbi5cbiAgICB2YXIgaTEsIGoxOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgKG1pZGRsZSkgY29ybmVyIG9mIHNpbXBsZXggaW4gKGksaikgY29vcmRzXG4gICAgaWYoeDA+eTApIHsgLy8gbG93ZXIgdHJpYW5nbGUsIFhZIG9yZGVyOiAoMCwwKS0+KDEsMCktPigxLDEpXG4gICAgICBpMT0xOyBqMT0wO1xuICAgIH0gZWxzZSB7ICAgIC8vIHVwcGVyIHRyaWFuZ2xlLCBZWCBvcmRlcjogKDAsMCktPigwLDEpLT4oMSwxKVxuICAgICAgaTE9MDsgajE9MTtcbiAgICB9XG4gICAgLy8gQSBzdGVwIG9mICgxLDApIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoMS1jLC1jKSBpbiAoeCx5KSwgYW5kXG4gICAgLy8gYSBzdGVwIG9mICgwLDEpIGluIChpLGopIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jKSBpbiAoeCx5KSwgd2hlcmVcbiAgICAvLyBjID0gKDMtc3FydCgzKSkvNlxuICAgIHZhciB4MSA9IHgwIC0gaTEgKyBHMjsgLy8gT2Zmc2V0cyBmb3IgbWlkZGxlIGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcbiAgICB2YXIgeTEgPSB5MCAtIGoxICsgRzI7XG4gICAgdmFyIHgyID0geDAgLSAxICsgMiAqIEcyOyAvLyBPZmZzZXRzIGZvciBsYXN0IGNvcm5lciBpbiAoeCx5KSB1bnNrZXdlZCBjb29yZHNcbiAgICB2YXIgeTIgPSB5MCAtIDEgKyAyICogRzI7XG4gICAgLy8gV29yayBvdXQgdGhlIGhhc2hlZCBncmFkaWVudCBpbmRpY2VzIG9mIHRoZSB0aHJlZSBzaW1wbGV4IGNvcm5lcnNcbiAgICBpICY9IDI1NTtcbiAgICBqICY9IDI1NTtcbiAgICB2YXIgZ2kwID0gZ3JhZFBbaStwZXJtW2pdXTtcbiAgICB2YXIgZ2kxID0gZ3JhZFBbaStpMStwZXJtW2orajFdXTtcbiAgICB2YXIgZ2kyID0gZ3JhZFBbaSsxK3Blcm1baisxXV07XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBjb250cmlidXRpb24gZnJvbSB0aGUgdGhyZWUgY29ybmVyc1xuICAgIHZhciB0MCA9IDAuNSAtIHgwKngwLXkwKnkwO1xuICAgIGlmKHQwPDApIHtcbiAgICAgIG4wID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDAgKj0gdDA7XG4gICAgICBuMCA9IHQwICogdDAgKiBnaTAuZG90Mih4MCwgeTApOyAgLy8gKHgseSkgb2YgZ3JhZDMgdXNlZCBmb3IgMkQgZ3JhZGllbnRcbiAgICB9XG4gICAgdmFyIHQxID0gMC41IC0geDEqeDEteTEqeTE7XG4gICAgaWYodDE8MCkge1xuICAgICAgbjEgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0MSAqPSB0MTtcbiAgICAgIG4xID0gdDEgKiB0MSAqIGdpMS5kb3QyKHgxLCB5MSk7XG4gICAgfVxuICAgIHZhciB0MiA9IDAuNSAtIHgyKngyLXkyKnkyO1xuICAgIGlmKHQyPDApIHtcbiAgICAgIG4yID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDIgKj0gdDI7XG4gICAgICBuMiA9IHQyICogdDIgKiBnaTIuZG90Mih4MiwgeTIpO1xuICAgIH1cbiAgICAvLyBBZGQgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggY29ybmVyIHRvIGdldCB0aGUgZmluYWwgbm9pc2UgdmFsdWUuXG4gICAgLy8gVGhlIHJlc3VsdCBpcyBzY2FsZWQgdG8gcmV0dXJuIHZhbHVlcyBpbiB0aGUgaW50ZXJ2YWwgWy0xLDFdLlxuICAgIHJldHVybiA3MCAqIChuMCArIG4xICsgbjIpO1xuICB9O1xuXG4gIC8vIDNEIHNpbXBsZXggbm9pc2VcbiAgbW9kdWxlLnNpbXBsZXgzID0gZnVuY3Rpb24oeGluLCB5aW4sIHppbikge1xuICAgIHZhciBuMCwgbjEsIG4yLCBuMzsgLy8gTm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIHRoZSBmb3VyIGNvcm5lcnNcblxuICAgIC8vIFNrZXcgdGhlIGlucHV0IHNwYWNlIHRvIGRldGVybWluZSB3aGljaCBzaW1wbGV4IGNlbGwgd2UncmUgaW5cbiAgICB2YXIgcyA9ICh4aW4reWluK3ppbikqRjM7IC8vIEhhaXJ5IGZhY3RvciBmb3IgMkRcbiAgICB2YXIgaSA9IE1hdGguZmxvb3IoeGluK3MpO1xuICAgIHZhciBqID0gTWF0aC5mbG9vcih5aW4rcyk7XG4gICAgdmFyIGsgPSBNYXRoLmZsb29yKHppbitzKTtcblxuICAgIHZhciB0ID0gKGkraitrKSpHMztcbiAgICB2YXIgeDAgPSB4aW4taSt0OyAvLyBUaGUgeCx5IGRpc3RhbmNlcyBmcm9tIHRoZSBjZWxsIG9yaWdpbiwgdW5za2V3ZWQuXG4gICAgdmFyIHkwID0geWluLWordDtcbiAgICB2YXIgejAgPSB6aW4tayt0O1xuXG4gICAgLy8gRm9yIHRoZSAzRCBjYXNlLCB0aGUgc2ltcGxleCBzaGFwZSBpcyBhIHNsaWdodGx5IGlycmVndWxhciB0ZXRyYWhlZHJvbi5cbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggc2ltcGxleCB3ZSBhcmUgaW4uXG4gICAgdmFyIGkxLCBqMSwgazE7IC8vIE9mZnNldHMgZm9yIHNlY29uZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xuICAgIHZhciBpMiwgajIsIGsyOyAvLyBPZmZzZXRzIGZvciB0aGlyZCBjb3JuZXIgb2Ygc2ltcGxleCBpbiAoaSxqLGspIGNvb3Jkc1xuICAgIGlmKHgwID49IHkwKSB7XG4gICAgICBpZih5MCA+PSB6MCkgICAgICB7IGkxPTE7IGoxPTA7IGsxPTA7IGkyPTE7IGoyPTE7IGsyPTA7IH1cbiAgICAgIGVsc2UgaWYoeDAgPj0gejApIHsgaTE9MTsgajE9MDsgazE9MDsgaTI9MTsgajI9MDsgazI9MTsgfVxuICAgICAgZWxzZSAgICAgICAgICAgICAgeyBpMT0wOyBqMT0wOyBrMT0xOyBpMj0xOyBqMj0wOyBrMj0xOyB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKHkwIDwgejApICAgICAgeyBpMT0wOyBqMT0wOyBrMT0xOyBpMj0wOyBqMj0xOyBrMj0xOyB9XG4gICAgICBlbHNlIGlmKHgwIDwgejApIHsgaTE9MDsgajE9MTsgazE9MDsgaTI9MDsgajI9MTsgazI9MTsgfVxuICAgICAgZWxzZSAgICAgICAgICAgICB7IGkxPTA7IGoxPTE7IGsxPTA7IGkyPTE7IGoyPTE7IGsyPTA7IH1cbiAgICB9XG4gICAgLy8gQSBzdGVwIG9mICgxLDAsMCkgaW4gKGksaixrKSBtZWFucyBhIHN0ZXAgb2YgKDEtYywtYywtYykgaW4gKHgseSx6KSxcbiAgICAvLyBhIHN0ZXAgb2YgKDAsMSwwKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsMS1jLC1jKSBpbiAoeCx5LHopLCBhbmRcbiAgICAvLyBhIHN0ZXAgb2YgKDAsMCwxKSBpbiAoaSxqLGspIG1lYW5zIGEgc3RlcCBvZiAoLWMsLWMsMS1jKSBpbiAoeCx5LHopLCB3aGVyZVxuICAgIC8vIGMgPSAxLzYuXG4gICAgdmFyIHgxID0geDAgLSBpMSArIEczOyAvLyBPZmZzZXRzIGZvciBzZWNvbmQgY29ybmVyXG4gICAgdmFyIHkxID0geTAgLSBqMSArIEczO1xuICAgIHZhciB6MSA9IHowIC0gazEgKyBHMztcblxuICAgIHZhciB4MiA9IHgwIC0gaTIgKyAyICogRzM7IC8vIE9mZnNldHMgZm9yIHRoaXJkIGNvcm5lclxuICAgIHZhciB5MiA9IHkwIC0gajIgKyAyICogRzM7XG4gICAgdmFyIHoyID0gejAgLSBrMiArIDIgKiBHMztcblxuICAgIHZhciB4MyA9IHgwIC0gMSArIDMgKiBHMzsgLy8gT2Zmc2V0cyBmb3IgZm91cnRoIGNvcm5lclxuICAgIHZhciB5MyA9IHkwIC0gMSArIDMgKiBHMztcbiAgICB2YXIgejMgPSB6MCAtIDEgKyAzICogRzM7XG5cbiAgICAvLyBXb3JrIG91dCB0aGUgaGFzaGVkIGdyYWRpZW50IGluZGljZXMgb2YgdGhlIGZvdXIgc2ltcGxleCBjb3JuZXJzXG4gICAgaSAmPSAyNTU7XG4gICAgaiAmPSAyNTU7XG4gICAgayAmPSAyNTU7XG4gICAgdmFyIGdpMCA9IGdyYWRQW2krICAgcGVybVtqKyAgIHBlcm1bayAgIF1dXTtcbiAgICB2YXIgZ2kxID0gZ3JhZFBbaStpMStwZXJtW2orajErcGVybVtrK2sxXV1dO1xuICAgIHZhciBnaTIgPSBncmFkUFtpK2kyK3Blcm1baitqMitwZXJtW2srazJdXV07XG4gICAgdmFyIGdpMyA9IGdyYWRQW2krIDErcGVybVtqKyAxK3Blcm1baysgMV1dXTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgY29udHJpYnV0aW9uIGZyb20gdGhlIGZvdXIgY29ybmVyc1xuICAgIHZhciB0MCA9IDAuNSAtIHgwKngwLXkwKnkwLXowKnowO1xuICAgIGlmKHQwPDApIHtcbiAgICAgIG4wID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDAgKj0gdDA7XG4gICAgICBuMCA9IHQwICogdDAgKiBnaTAuZG90Myh4MCwgeTAsIHowKTsgIC8vICh4LHkpIG9mIGdyYWQzIHVzZWQgZm9yIDJEIGdyYWRpZW50XG4gICAgfVxuICAgIHZhciB0MSA9IDAuNSAtIHgxKngxLXkxKnkxLXoxKnoxO1xuICAgIGlmKHQxPDApIHtcbiAgICAgIG4xID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdDEgKj0gdDE7XG4gICAgICBuMSA9IHQxICogdDEgKiBnaTEuZG90Myh4MSwgeTEsIHoxKTtcbiAgICB9XG4gICAgdmFyIHQyID0gMC41IC0geDIqeDIteTIqeTItejIqejI7XG4gICAgaWYodDI8MCkge1xuICAgICAgbjIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0MiAqPSB0MjtcbiAgICAgIG4yID0gdDIgKiB0MiAqIGdpMi5kb3QzKHgyLCB5MiwgejIpO1xuICAgIH1cbiAgICB2YXIgdDMgPSAwLjUgLSB4Myp4My15Myp5My16Myp6MztcbiAgICBpZih0MzwwKSB7XG4gICAgICBuMyA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQzICo9IHQzO1xuICAgICAgbjMgPSB0MyAqIHQzICogZ2kzLmRvdDMoeDMsIHkzLCB6Myk7XG4gICAgfVxuICAgIC8vIEFkZCBjb250cmlidXRpb25zIGZyb20gZWFjaCBjb3JuZXIgdG8gZ2V0IHRoZSBmaW5hbCBub2lzZSB2YWx1ZS5cbiAgICAvLyBUaGUgcmVzdWx0IGlzIHNjYWxlZCB0byByZXR1cm4gdmFsdWVzIGluIHRoZSBpbnRlcnZhbCBbLTEsMV0uXG4gICAgcmV0dXJuIDMyICogKG4wICsgbjEgKyBuMiArIG4zKTtcblxuICB9O1xuXG4gIC8vICMjIyMjIFBlcmxpbiBub2lzZSBzdHVmZlxuXG4gIGZ1bmN0aW9uIGZhZGUodCkge1xuICAgIHJldHVybiB0KnQqdCoodCoodCo2LTE1KSsxMCk7XG4gIH1cblxuICBmdW5jdGlvbiBsZXJwKGEsIGIsIHQpIHtcbiAgICByZXR1cm4gKDEtdCkqYSArIHQqYjtcbiAgfVxuXG4gIC8vIDJEIFBlcmxpbiBOb2lzZVxuICBtb2R1bGUucGVybGluMiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAvLyBGaW5kIHVuaXQgZ3JpZCBjZWxsIGNvbnRhaW5pbmcgcG9pbnRcbiAgICB2YXIgWCA9IE1hdGguZmxvb3IoeCksIFkgPSBNYXRoLmZsb29yKHkpO1xuICAgIC8vIEdldCByZWxhdGl2ZSB4eSBjb29yZGluYXRlcyBvZiBwb2ludCB3aXRoaW4gdGhhdCBjZWxsXG4gICAgeCA9IHggLSBYOyB5ID0geSAtIFk7XG4gICAgLy8gV3JhcCB0aGUgaW50ZWdlciBjZWxscyBhdCAyNTUgKHNtYWxsZXIgaW50ZWdlciBwZXJpb2QgY2FuIGJlIGludHJvZHVjZWQgaGVyZSlcbiAgICBYID0gWCAmIDI1NTsgWSA9IFkgJiAyNTU7XG5cbiAgICAvLyBDYWxjdWxhdGUgbm9pc2UgY29udHJpYnV0aW9ucyBmcm9tIGVhY2ggb2YgdGhlIGZvdXIgY29ybmVyc1xuICAgIHZhciBuMDAgPSBncmFkUFtYK3Blcm1bWV1dLmRvdDIoeCwgeSk7XG4gICAgdmFyIG4wMSA9IGdyYWRQW1grcGVybVtZKzFdXS5kb3QyKHgsIHktMSk7XG4gICAgdmFyIG4xMCA9IGdyYWRQW1grMStwZXJtW1ldXS5kb3QyKHgtMSwgeSk7XG4gICAgdmFyIG4xMSA9IGdyYWRQW1grMStwZXJtW1krMV1dLmRvdDIoeC0xLCB5LTEpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgZmFkZSBjdXJ2ZSB2YWx1ZSBmb3IgeFxuICAgIHZhciB1ID0gZmFkZSh4KTtcblxuICAgIC8vIEludGVycG9sYXRlIHRoZSBmb3VyIHJlc3VsdHNcbiAgICByZXR1cm4gbGVycChcbiAgICAgICAgbGVycChuMDAsIG4xMCwgdSksXG4gICAgICAgIGxlcnAobjAxLCBuMTEsIHUpLFxuICAgICAgIGZhZGUoeSkpO1xuICB9O1xuXG4gIC8vIDNEIFBlcmxpbiBOb2lzZVxuICBtb2R1bGUucGVybGluMyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICAvLyBGaW5kIHVuaXQgZ3JpZCBjZWxsIGNvbnRhaW5pbmcgcG9pbnRcbiAgICB2YXIgWCA9IE1hdGguZmxvb3IoeCksIFkgPSBNYXRoLmZsb29yKHkpLCBaID0gTWF0aC5mbG9vcih6KTtcbiAgICAvLyBHZXQgcmVsYXRpdmUgeHl6IGNvb3JkaW5hdGVzIG9mIHBvaW50IHdpdGhpbiB0aGF0IGNlbGxcbiAgICB4ID0geCAtIFg7IHkgPSB5IC0gWTsgeiA9IHogLSBaO1xuICAgIC8vIFdyYXAgdGhlIGludGVnZXIgY2VsbHMgYXQgMjU1IChzbWFsbGVyIGludGVnZXIgcGVyaW9kIGNhbiBiZSBpbnRyb2R1Y2VkIGhlcmUpXG4gICAgWCA9IFggJiAyNTU7IFkgPSBZICYgMjU1OyBaID0gWiAmIDI1NTtcblxuICAgIC8vIENhbGN1bGF0ZSBub2lzZSBjb250cmlidXRpb25zIGZyb20gZWFjaCBvZiB0aGUgZWlnaHQgY29ybmVyc1xuICAgIHZhciBuMDAwID0gZ3JhZFBbWCsgIHBlcm1bWSsgIHBlcm1bWiAgXV1dLmRvdDMoeCwgICB5LCAgICAgeik7XG4gICAgdmFyIG4wMDEgPSBncmFkUFtYKyAgcGVybVtZKyAgcGVybVtaKzFdXV0uZG90Myh4LCAgIHksICAgei0xKTtcbiAgICB2YXIgbjAxMCA9IGdyYWRQW1grICBwZXJtW1krMStwZXJtW1ogIF1dXS5kb3QzKHgsICAgeS0xLCAgIHopO1xuICAgIHZhciBuMDExID0gZ3JhZFBbWCsgIHBlcm1bWSsxK3Blcm1bWisxXV1dLmRvdDMoeCwgICB5LTEsIHotMSk7XG4gICAgdmFyIG4xMDAgPSBncmFkUFtYKzErcGVybVtZKyAgcGVybVtaICBdXV0uZG90Myh4LTEsICAgeSwgICB6KTtcbiAgICB2YXIgbjEwMSA9IGdyYWRQW1grMStwZXJtW1krICBwZXJtW1orMV1dXS5kb3QzKHgtMSwgICB5LCB6LTEpO1xuICAgIHZhciBuMTEwID0gZ3JhZFBbWCsxK3Blcm1bWSsxK3Blcm1bWiAgXV1dLmRvdDMoeC0xLCB5LTEsICAgeik7XG4gICAgdmFyIG4xMTEgPSBncmFkUFtYKzErcGVybVtZKzErcGVybVtaKzFdXV0uZG90Myh4LTEsIHktMSwgei0xKTtcblxuICAgIC8vIENvbXB1dGUgdGhlIGZhZGUgY3VydmUgdmFsdWUgZm9yIHgsIHksIHpcbiAgICB2YXIgdSA9IGZhZGUoeCk7XG4gICAgdmFyIHYgPSBmYWRlKHkpO1xuICAgIHZhciB3ID0gZmFkZSh6KTtcblxuICAgIC8vIEludGVycG9sYXRlXG4gICAgcmV0dXJuIGxlcnAoXG4gICAgICAgIGxlcnAoXG4gICAgICAgICAgbGVycChuMDAwLCBuMTAwLCB1KSxcbiAgICAgICAgICBsZXJwKG4wMDEsIG4xMDEsIHUpLCB3KSxcbiAgICAgICAgbGVycChcbiAgICAgICAgICBsZXJwKG4wMTAsIG4xMTAsIHUpLFxuICAgICAgICAgIGxlcnAobjAxMSwgbjExMSwgdSksIHcpLFxuICAgICAgIHYpO1xuICB9O1xuXG59KSh0eXBlb2YgbW9kdWxlID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IG1vZHVsZS5leHBvcnRzKTsiLCJ2YXIgdHJhaiA9IHJlcXVpcmUoJ3ZveGVsLXRyYWplY3RvcnknKTtcbnZhciB0aWMgPSByZXF1aXJlKCd0aWMnKSgpO1xuXG5mdW5jdGlvbiBTa3kob3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmIChvcHRzLlRIUkVFKSBvcHRzID0ge2dhbWU6b3B0c307XG4gIHRoaXMuZ2FtZSAgID0gb3B0cy5nYW1lO1xuICB0aGlzLnRpbWUgICA9IG9wdHMudGltZSAgfHwgMDtcbiAgdGhpcy5zaXplICAgPSBvcHRzLnNpemUgIHx8IHRoaXMuZ2FtZS53b3JsZFdpZHRoKCkgKiAzO1xuICB0aGlzLl9jb2xvciA9IG9wdHMuY29sb3IgfHwgbmV3IHRoaXMuZ2FtZS5USFJFRS5Db2xvcigwLCAwLCAwKTtcbiAgdGhpcy5fc3BlZWQgPSBvcHRzLnNwZWVkIHx8IDAuMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciBza3kgPSBuZXcgU2t5KG9wdHMgfHwge30pO1xuICBza3kuY3JlYXRlQm94KCk7XG4gIHNreS5jcmVhdGVMaWdodHMoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZuKSB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykgc2t5LmZuID0gZm47XG4gICAgZWxzZSBpZiAodHlwZW9mIGZuID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gbW92ZSB0byB0aGUgc3BlY2lmaWMgdGltZSBvZiBkYXlcbiAgICAgIHNreS50aW1lID0gZm47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSAyNDAwOyBpICs9IHNreS5fc3BlZWQpIHNreS50aWNrLmNhbGwoc2t5KTtcbiAgICB9XG4gICAgcmV0dXJuIHNreS50aWNrLmJpbmQoc2t5KTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzLlNreSA9IFNreTtcblxuU2t5LnByb3RvdHlwZS50aWNrID0gZnVuY3Rpb24oZHQpIHtcbiAgdGljLnRpY2soZHQpO1xuICB0aGlzLmZuLmNhbGwodGhpcywgdGhpcy50aW1lKTtcbiAgdmFyIHBvcyA9IHRoaXMuZ2FtZS5jYW1lcmFQb3NpdGlvbigpO1xuICB2YXIgdmVjID0gbmV3IHRoaXMuZ2FtZS5USFJFRS5WZWN0b3IzKHBvc1swXSwgcG9zWzFdLCBwb3NbMl0pO1xuICB0aGlzLm91dGVyLnBvc2l0aW9uLmNvcHkodmVjKTtcbiAgdGhpcy5pbm5lci5wb3NpdGlvbi5jb3B5KHZlYyk7XG4gIHRoaXMuYW1iaWVudC5wb3NpdGlvbi5jb3B5KHZlYyk7XG4gIHRoaXMudGltZSArPSB0aGlzLl9zcGVlZDtcbiAgaWYgKHRoaXMudGltZSA+IDI0MDApIHRoaXMudGltZSA9IDA7XG4gIHJldHVybiB0aGlzO1xufTtcblxuU2t5LnByb3RvdHlwZS5jcmVhdGVCb3ggPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdhbWUgPSB0aGlzLmdhbWU7XG4gIHZhciBzaXplID0gdGhpcy5zaXplO1xuXG4gIHZhciBtYXQgPSBuZXcgZ2FtZS5USFJFRS5NZXNoQmFzaWNNYXRlcmlhbCh7XG4gICAgc2lkZTogZ2FtZS5USFJFRS5CYWNrU2lkZSxcbiAgICBmb2c6IGZhbHNlLFxuICB9KTtcbiAgdGhpcy5vdXRlciA9IG5ldyBnYW1lLlRIUkVFLk1lc2goXG4gICAgbmV3IGdhbWUuVEhSRUUuQ3ViZUdlb21ldHJ5KHNpemUsIHNpemUsIHNpemUpLFxuICAgIG5ldyBnYW1lLlRIUkVFLk1lc2hGYWNlTWF0ZXJpYWwoW1xuICAgICAgbWF0LCBtYXQsIG1hdCwgbWF0LCBtYXQsIG1hdFxuICAgIF0pXG4gICk7XG4gIGdhbWUuc2NlbmUuYWRkKHRoaXMub3V0ZXIpO1xuXG4gIHZhciBtYXRlcmlhbHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICBtYXRlcmlhbHMucHVzaCh0aGlzLmNyZWF0ZUNhbnZhcygpKTtcbiAgfVxuICB0aGlzLmlubmVyID0gbmV3IGdhbWUuVEhSRUUuTWVzaChcbiAgICBuZXcgZ2FtZS5USFJFRS5DdWJlR2VvbWV0cnkoc2l6ZS0xMCwgc2l6ZS0xMCwgc2l6ZS0xMCksXG4gICAgbmV3IGdhbWUuVEhSRUUuTWVzaEZhY2VNYXRlcmlhbChtYXRlcmlhbHMpXG4gICk7XG4gIGdhbWUuc2NlbmUuYWRkKHRoaXMuaW5uZXIpO1xufTtcblxuU2t5LnByb3RvdHlwZS5jcmVhdGVMaWdodHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdhbWUgPSB0aGlzLmdhbWU7XG4gIHRoaXMuYW1iaWVudCA9IG5ldyBnYW1lLlRIUkVFLkhlbWlzcGhlcmVMaWdodCgweDQwOENGRiwgMHhGRkM4ODAsIDAuNik7XG4gIGdhbWUuc2NlbmUuYWRkKHRoaXMuYW1iaWVudCk7XG4gIHRoaXMuc3VubGlnaHQgPSBuZXcgZ2FtZS5USFJFRS5EaXJlY3Rpb25hbExpZ2h0KDB4ZmZmZmZmLCAwLjUpO1xuICBnYW1lLnNjZW5lLmFkZCh0aGlzLnN1bmxpZ2h0KTtcbn07XG5cblNreS5wcm90b3R5cGUuY29sb3IgPSBmdW5jdGlvbihlbmQsIHRpbWUpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAoc2VsZi5fY29sb3JJbnRlcnZhbCkgc2VsZi5fY29sb3JJbnRlcnZhbCgpO1xuICB2YXIgaSA9IDA7XG4gIHZhciBzdGFydCA9IHNlbGYuX2NvbG9yLmNsb25lKCkuZ2V0SFNMKCk7XG4gIHZhciBjb2xvciA9IHNlbGYuX2NvbG9yLmNsb25lKCkuZ2V0SFNMKCk7XG4gIHNlbGYuX2NvbG9ySW50ZXJ2YWwgPSB0aWMuaW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGR0ID0gaSAvIHRpbWU7XG4gICAgZm9yICh2YXIgcCBpbiBjb2xvcikgY29sb3JbcF0gPSBzdGFydFtwXSArIChlbmRbcF0gLSBzdGFydFtwXSkgKiBkdDtcbiAgICBzZWxmLl9jb2xvci5zZXRIU0woY29sb3IuaCwgY29sb3IucywgY29sb3IubCk7XG4gICAgc2VsZi5vdXRlci5tYXRlcmlhbC5tYXRlcmlhbHMuZm9yRWFjaChmdW5jdGlvbihtYXQpIHtcbiAgICAgIG1hdC5jb2xvci5zZXRIU0woY29sb3IuaCwgY29sb3IucywgY29sb3IubCk7XG4gICAgfSk7XG4gICAgc2VsZi5hbWJpZW50LmNvbG9yLnNldEhTTChjb2xvci5oLCBjb2xvci5zLCBjb2xvci5sKTtcbiAgICBpZiAoc2VsZi5nYW1lLnNjZW5lLmZvZykgc2VsZi5nYW1lLnNjZW5lLmZvZy5jb2xvci5zZXRIU0woY29sb3IuaCwgY29sb3IucywgY29sb3IubCk7XG4gICAgaWYgKGR0ID09PSAxKSBzZWxmLl9jb2xvckludGVydmFsKCk7XG4gICAgaSArPSBzZWxmLl9zcGVlZDtcbiAgfSwgc2VsZi5fc3BlZWQpO1xufTtcblxuU2t5LnByb3RvdHlwZS5zcGVlZCA9IGZ1bmN0aW9uKHNwZWVkKSB7XG4gIGlmIChzcGVlZCAhPSBudWxsKSB0aGlzLl9zcGVlZCA9IHNwZWVkO1xuICByZXR1cm4gdGhpcy5fc3BlZWQ7XG59O1xuXG5Ta3kucHJvdG90eXBlLnBhaW50ID0gZnVuY3Rpb24oZmFjZXMsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICB2YXIgaW5kZXggPSBbJ2JhY2snLCAnZnJvbnQnLCAndG9wJywgJ2JvdHRvbScsICdsZWZ0JywgJ3JpZ2h0J107XG4gIGlmIChmYWNlcyA9PT0gJ2FsbCcpIGZhY2VzID0gaW5kZXg7XG4gIGlmIChmYWNlcyA9PT0gJ3NpZGVzJykgZmFjZXMgPSBbJ2JhY2snLCAnZnJvbnQnLCAnbGVmdCcsICdyaWdodCddO1xuICBpZiAoIWlzQXJyYXkoZmFjZXMpKSBmYWNlcyA9IFtmYWNlc107XG4gIGZhY2VzLmZvckVhY2goZnVuY3Rpb24oZmFjZSkge1xuICAgIGlmICh0eXBlb2YgZmFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZhY2UgPSBpbmRleC5pbmRleE9mKFN0cmluZyhmYWNlKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgIGlmIChmYWNlID09PSAtMSkgcmV0dXJuO1xuICAgIH1cbiAgICBzZWxmLm1hdGVyaWFsID0gc2VsZi5pbm5lci5tYXRlcmlhbC5tYXRlcmlhbHNbZmFjZV07XG4gICAgc2VsZi5jYW52YXMgPSBzZWxmLm1hdGVyaWFsLm1hcC5pbWFnZTtcbiAgICBzZWxmLmNvbnRleHQgPSBzZWxmLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIHNlbGYuaW5uZXIubWF0ZXJpYWwubWF0ZXJpYWxzW2ZhY2VdLm1hcC5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gIH0pO1xuICBzZWxmLm1hdGVyaWFsID0gc2VsZi5jYW52YXMgPSBzZWxmLmNvbnRleHQgPSBmYWxzZTtcbn07XG5cblNreS5wcm90b3R5cGUuc3VuICAgPSByZXF1aXJlKCcuL2xpYi9zdW4uanMnKTtcblNreS5wcm90b3R5cGUubW9vbiAgPSByZXF1aXJlKCcuL2xpYi9tb29uLmpzJyk7XG5Ta3kucHJvdG90eXBlLnN0YXJzID0gcmVxdWlyZSgnLi9saWIvc3RhcnMuanMnKTtcblxuU2t5LnByb3RvdHlwZS5jcmVhdGVDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGdhbWUgPSB0aGlzLmdhbWU7XG5cbiAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLndpZHRoID0gNTEyO1xuICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIHZhciBtYXRlcmlhbCA9IG5ldyBnYW1lLlRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICBzaWRlOiBnYW1lLlRIUkVFLkJhY2tTaWRlLFxuICAgIG1hcDogbmV3IGdhbWUuVEhSRUUuVGV4dHVyZShjYW52YXMpLFxuICAgIHRyYW5zcGFyZW50OiB0cnVlLFxuICAgIGZvZzogZmFsc2UsXG4gIH0pO1xuICBtYXRlcmlhbC5tYWdGaWx0ZXIgPSBnYW1lLlRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gIG1hdGVyaWFsLm1pbkZpbHRlciA9IGdhbWUuVEhSRUUuTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xuICBtYXRlcmlhbC53cmFwUyA9IG1hdGVyaWFsLndyYXBUID0gZ2FtZS5USFJFRS5SZXBlYXRXcmFwcGluZztcbiAgbWF0ZXJpYWwubWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICByZXR1cm4gbWF0ZXJpYWw7XG59O1xuXG5Ta3kucHJvdG90eXBlLnNwaW4gPSBmdW5jdGlvbihyLCBheGlzKSB7XG4gIGF4aXMgPSBheGlzIHx8ICd6JztcbiAgdGhpcy5pbm5lci5yb3RhdGlvbltheGlzXSA9IHRoaXMub3V0ZXIucm90YXRpb25bYXhpc10gPSByO1xuICB0aGlzLmFtYmllbnQucm90YXRpb25bYXhpc10gPSByICsgTWF0aC5QSTtcbiAgdmFyIHQgPSB0cmFqKHRoaXMuc2l6ZS8yLCB0aGlzLmFtYmllbnQucm90YXRpb24pO1xuICB0aGlzLnN1bmxpZ2h0LnBvc2l0aW9uLnNldCh0WzBdLCB0WzFdLCB0WzJdKTtcbiAgdGhpcy5zdW5saWdodC5sb29rQXQoMCwgMCwgMCk7XG59O1xuXG5Ta3kucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jYW52YXMpIHJldHVybiBmYWxzZTtcbiAgdGhpcy5jb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbn07XG5cbi8vIGRlZmF1bHQgc2t5XG5Ta3kucHJvdG90eXBlLl9kZWZhdWx0ID0ge1xuICBob3Vyczoge1xuICAgICAgIDA6IHtjb2xvcjoge2g6IDIzMC8zNjAsIHM6IDAuMywgbDogMH19LFxuICAgICAzMDA6IHtjb2xvcjoge2g6IDI2LzM2MCwgczogMC4zLCBsOiAwLjV9fSxcbiAgICAgNTAwOiB7Y29sb3I6IHtoOiAyMzAvMzYwLCBzOiAwLjMsIGw6IDAuN319LFxuICAgIDE0MDA6IHtjb2xvcjoge2g6IDI2LzM2MCwgczogMC4zLCBsOiAwLjV9fSxcbiAgICAxNjAwOiB7Y29sb3I6IHtoOiAyMzAvMzYwLCBzOiAwLjMsIGw6IDB9fVxuICB9LFxuICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBhZGQgYSBzdW4gb24gdGhlIGJvdHRvbVxuICAgIHRoaXMucGFpbnQoJ2JvdHRvbScsIHRoaXMuc3VuKTtcbiAgICAvLyBhZGQgc29tZSBzdGFyc1xuICAgIHRoaXMucGFpbnQoWyd0b3AnLCAnbGVmdCcsICdyaWdodCcsICdmcm9udCcsICdiYWNrJ10sIHRoaXMuc3RhcnMsIDUwMCk7XG4gICAgLy8gYWRkIGZ1bGwgbW9vbiB0byB0aGUgdG9wXG4gICAgdGhpcy5wYWludCgndG9wJywgdGhpcy5tb29uLCAwKTtcbiAgICAvLyBubyBzdW5saWdodCBhdCBzdGFydHVwXG4gICAgdGhpcy5zdW5saWdodC5pbnRlbnNpdHkgPSAwO1xuICB9LFxuICBkYXk6IDAsXG4gIG1vb25DeWNsZTogMjkuNTMwNTg4MixcbiAgdW50aWw6IGZhbHNlLFxuICBsYXN0OiAwXG59O1xuXG4vLyBkZWZhdWx0IHNreSBmblxuU2t5LnByb3RvdHlwZS5mbiA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgdmFyIG15ID0gdGhpcy5fZGVmYXVsdDtcbiAgdmFyIGhvdXIgPSBNYXRoLnJvdW5kKHRpbWUgLyAxMDApICogMTAwO1xuICB2YXIgc3BlZWQgPSBNYXRoLmFicyhteS5sYXN0IC0gdGltZSk7XG4gIG15Lmxhc3QgPSB0aW1lO1xuXG4gIC8vIHJ1biBpbml0aWFsaXphdGlvbiBvbmNlXG4gIGlmIChteS5pbml0KSB7IG15LmluaXQuY2FsbCh0aGlzKTsgZGVsZXRlIG15LmluaXQ7IH1cblxuICAvLyBzd2l0Y2ggY29sb3IgYmFzZWQgb24gdGltZSBvZiBkYXlcbiAgLy8gbWF5YmUgbWFrZSB0aGlzIG5leHQgcGFydCBpbnRvIGEgaGVscGVyIGZ1bmN0aW9uXG4gIGlmIChteS5ob3Vyc1tob3VyXSkge1xuICAgIGlmICghbXkudW50aWwpIHtcbiAgICAgIHRoaXMuY29sb3IobXkuaG91cnNbaG91cl0uY29sb3IsIHNwZWVkID4gOSA/IDEwMCA6IDEwMDApO1xuICAgICAgbXkudW50aWwgPSBob3VyICsgMTAwO1xuICAgIH1cbiAgfVxuICBpZiAobXkudW50aWwgPT09IGhvdXIpIG15LnVudGlsID0gZmFsc2U7XG5cbiAgLy8gY2hhbmdlIG1vb24gcGhhc2VcbiAgaWYgKHRpbWUgPT09IDEyMDApIHtcbiAgICB0aGlzLnBhaW50KCd0b3AnLCB0aGlzLmNsZWFyKTtcbiAgICB0aGlzLnBhaW50KCd0b3AnLCB0aGlzLm1vb24sIE1hdGguZmxvb3IobXkuZGF5ICUgbXkubW9vbkN5Y2xlKSAvIG15Lm1vb25DeWNsZSk7XG4gICAgdGhpcy5wYWludCgndG9wJywgdGhpcy5zdGFycywgNTAwKTtcbiAgfVxuXG4gIC8vIGZhZGUgc3RhcnMgaW4gYW5kIG91dFxuICBpZiAodGltZSA9PT0gNTAwKSB7XG4gICAgdGhpcy5wYWludChbJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2Zyb250JywgJ2JhY2snXSwgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgIHZhciBpID0gdGljLmludGVydmFsKGZ1bmN0aW9uKG1hdCkge1xuICAgICAgICBtYXQub3BhY2l0eSAtPSAwLjE7XG4gICAgICAgIGlmIChtYXQub3BhY2l0eSA8PSAwKSBpKCk7XG4gICAgICB9LCAxMDAsIHRoaXMubWF0ZXJpYWwpO1xuICAgIH0pO1xuICB9XG4gIGlmICh0aW1lID09PSAxODAwKSB7XG4gICAgdGhpcy5wYWludChbJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2Zyb250JywgJ2JhY2snXSwgZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcbiAgICAgIHZhciBpID0gdGljLmludGVydmFsKGZ1bmN0aW9uKG1hdCkge1xuICAgICAgICBtYXQub3BhY2l0eSArPSAwLjE7XG4gICAgICAgIGlmIChtYXQub3BhY2l0eSA+PSAxKSBpKCk7XG4gICAgICB9LCAxMDAsIHRoaXMubWF0ZXJpYWwpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdHVybiBvbiBzdW5saWdodFxuICBpZiAodGltZSA9PT0gNDAwKSB7XG4gICAgKGZ1bmN0aW9uKHN1bmxpZ2h0KSB7XG4gICAgICB2YXIgaSA9IHRpYy5pbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgc3VubGlnaHQuaW50ZW5zaXR5ICs9IDAuMTtcbiAgICAgICAgaWYgKHN1bmxpZ2h0LmludGVuc2l0eSA8PSAxKSBpKCk7XG4gICAgICB9LCAxMDApO1xuICAgIH0odGhpcy5zdW5saWdodCkpO1xuICB9XG5cbiAgLy8gdHVybiBvZmYgc3VubGlnaHRcbiAgaWYgKHRpbWUgPT09IDE4MDApIHtcbiAgICAoZnVuY3Rpb24oc3VubGlnaHQpIHtcbiAgICAgIHZhciBpID0gdGljLmludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICBzdW5saWdodC5pbnRlbnNpdHkgLT0gMC4xO1xuICAgICAgICBpZiAoc3VubGlnaHQuaW50ZW5zaXR5IDw9IDApIGkoKTtcbiAgICAgIH0sIDEwMCk7XG4gICAgfSh0aGlzLnN1bmxpZ2h0KSk7XG4gIH1cblxuICAvLyBzcGluIHRoZSBza3kgMSByZXZvbHV0aW9uIHBlciBkYXlcbiAgdGhpcy5zcGluKE1hdGguUEkgKiAyICogKHRpbWUgLyAyNDAwKSk7XG5cbiAgLy8ga2VlcCB0cmFjayBvZiBkYXlzXG4gIGlmICh0aW1lID09PSAyNDAwKSBteS5kYXkrKztcbn07XG5cblNreS5wcm90b3R5cGUucmdiYSA9IGZ1bmN0aW9uKGMsIG8pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICBjID0ge3I6IGFyZ3VtZW50c1swXSwgZzogYXJndW1lbnRzWzFdLCBiOiBhcmd1bWVudHNbMl19O1xuICAgIG8gPSBhcmd1bWVudHNbM107XG4gIH1cbiAgcmV0dXJuICdyZ2JhKCcgKyAoYy5yKjI1NSkgKyAnLCAnICsgKGMuZyoyNTUpICsgJywgJyArIChjLmIqMjU1KSArICcsICcgKyBvICsgJyknO1xufTtcblxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcilcbiAgICB8fCAodHlwZW9mIGFyID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXIpID09PSAnW29iamVjdCBBcnJheV0nKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGhhc2UsIHIsIGNvbG9yKSB7XG4gIGlmICghdGhpcy5jYW52YXMpIHJldHVybiBmYWxzZTtcbiAgciA9IHIgfHwgMjA7XG4gIGNvbG9yID0gY29sb3IgfHwgbmV3IHRoaXMuZ2FtZS5USFJFRS5Db2xvcigweEU2RTJEMSk7XG4gIHZhciB4ID0gdGhpcy5jYW52YXMud2lkdGggLyAyO1xuICB2YXIgeSA9IHRoaXMuY2FudmFzLmhlaWdodCAvIDI7XG5cbiAgLy8gYmcgZ2xvd1xuICB0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHZhciBncmQgPSB0aGlzLmNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoeCtyLzIsIHkrci8yLCAxLCB4K3IvMiwgeStyLzIsIHIgKiAyKTtcbiAgZ3JkLmFkZENvbG9yU3RvcCgwLCB0aGlzLnJnYmEoMSwgMSwgMSwgMC4zKSk7XG4gIGdyZC5hZGRDb2xvclN0b3AoMSwgdGhpcy5yZ2JhKDEsIDEsIDEsIDApKTtcbiAgdGhpcy5jb250ZXh0LmFyYyh4K3IvMiwgeStyLzIsIHIgKiAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gZ3JkO1xuICB0aGlzLmNvbnRleHQuZmlsbCgpO1xuICB0aGlzLmNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgLy8gY2xpcHBpbmcgcmVnaW9uXG4gIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgdGhpcy5jb250ZXh0LnJlY3QoeCwgeSwgciwgcik7XG4gIHRoaXMuY29udGV4dC5jbGlwKCk7XG4gIFxuICAvLyBtb29uIGJnXG4gIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgdGhpcy5jb250ZXh0LnJlY3QoeCwgeSwgciwgcik7XG4gIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLnJnYmEoY29sb3IsIDEpO1xuICB0aGlzLmNvbnRleHQuZmlsbCgpO1xuXG4gIHRoaXMuY29udGV4dC50cmFuc2xhdGUoeCwgeSk7XG5cbiAgLy8gbGlnaHRlciBpbnNpZGVcbiAgdGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICB0aGlzLmNvbnRleHQucmVjdCg0LCA0LCByLTgsIHItOCk7XG4gIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLnJnYmEoMSwgMSwgMSwgMC44KTtcbiAgdGhpcy5jb250ZXh0LmZpbGwoKTtcblxuICAvLyBtb29uIHBoYXNlXG4gIHZhciBweCA9IChwaGFzZSAqIHIgKiAyKSAtIHI7XG4gIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgdGhpcy5jb250ZXh0LnJlY3QocHgsIDAsIHIsIHIpO1xuICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5yZ2JhKDAsIDAsIDAsIDAuOCk7XG4gIHRoaXMuY29udGV4dC5maWxsKCk7XG4gIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgdGhpcy5jb250ZXh0LnJlY3QoMiArIHB4LCAyLCByLTQsIHItNCk7XG4gIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLnJnYmEoMCwgMCwgMCwgMC45KTtcbiAgdGhpcy5jb250ZXh0LmZpbGwoKTtcblxuICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYW10KSB7XG4gIGlmICghdGhpcy5jYW52YXMpIHJldHVybiBmYWxzZTtcbiAgdmFyIGNvbG9ycyA9IFtcbiAgICAnI0ZGRkZGRicsICcjRkZGRkZGJywgJyNGRkZGRkYnLCAnI0ZGRkZGRicsICcjRkZGRkZGJyxcbiAgICAnI0ZGRkZGRicsICcjRkZGRkZGJywgJyNGRkZGRkYnLCAnI0ZGRkZGRicsICcjRkZGRkZGJyxcbiAgICAnIzg1ODlGRicsICcjRkY4NTg1J1xuICBdO1xuICB2YXIgYWxwaGEgPSB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYW10OyBpKyspIHtcbiAgICB0aGlzLmNvbnRleHQuZ2xvYmFsQWxwaGEgPSBNYXRoLnJhbmRvbSgpICogMSArIDAuNTtcbiAgICB0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5jb250ZXh0LmFyYyhcbiAgICAgIE1hdGgucmFuZG9tKCkgKiB0aGlzLmNhbnZhcy53aWR0aCxcbiAgICAgIE1hdGgucmFuZG9tKCkgKiB0aGlzLmNhbnZhcy5oZWlnaHQsXG4gICAgICBNYXRoLnJhbmRvbSgpICogMC41LFxuICAgICAgMCwgMiAqIE1hdGguUEksIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gY29sb3JzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvbG9ycy5sZW5ndGgpXTtcbiAgICB0aGlzLmNvbnRleHQuZmlsbCgpO1xuICB9XG4gIHRoaXMuY29udGV4dC5nbG9iYWxBbHBoYSA9IGFscGhhO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHIsIGNvbG9yKSB7XG4gIGlmICghdGhpcy5jYW52YXMpIHJldHVybiBmYWxzZTtcbiAgciA9IHIgfHwgNTA7XG4gIGNvbG9yID0gY29sb3IgfHwgbmV3IHRoaXMuZ2FtZS5USFJFRS5Db2xvcigweEY4RkZCNSk7XG5cbiAgdGhpcy5jb250ZXh0LnNhdmUoKTtcblxuICAvLyBiZyBnbG93XG4gIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgeCA9ICh0aGlzLmNhbnZhcy53aWR0aC8yKTtcbiAgeSA9ICh0aGlzLmNhbnZhcy5oZWlnaHQvMik7XG4gIHZhciBncmQgPSB0aGlzLmNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQoeCwgeSwgMSwgeCwgeSwgciAqIDIpO1xuICBncmQuYWRkQ29sb3JTdG9wKDAsIHRoaXMucmdiYSgxLCAxLCAxLCAwLjMpKTtcbiAgZ3JkLmFkZENvbG9yU3RvcCgxLCB0aGlzLnJnYmEoMSwgMSwgMSwgMCkpO1xuICB0aGlzLmNvbnRleHQuYXJjKHgsIHksIHIgKiAyLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gZ3JkO1xuICB0aGlzLmNvbnRleHQuZmlsbCgpO1xuICB0aGlzLmNvbnRleHQuY2xvc2VQYXRoKCk7XG5cbiAgLy8gb3V0ZXIgc3VuXG4gIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgeCA9ICh0aGlzLmNhbnZhcy53aWR0aCAvIDIpIC0gKHIgLyAyKTtcbiAgeSA9ICh0aGlzLmNhbnZhcy5oZWlnaHQgLyAyKSAtIChyIC8gMik7XG4gIHRoaXMuY29udGV4dC5yZWN0KHgsIHksIHIsIHIpO1xuICB0aGlzLmNvbnRleHQuZmlsbFN0eWxlID0gdGhpcy5yZ2JhKGNvbG9yLCAxKTtcbiAgdGhpcy5jb250ZXh0LmZpbGwoKTtcbiAgdGhpcy5jb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gIC8vIGlubmVyIHN1blxuICB0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gIHIgLz0gMS42O1xuICB4ID0gKHRoaXMuY2FudmFzLndpZHRoIC8gMikgLSAociAvIDIpO1xuICB5ID0gKHRoaXMuY2FudmFzLmhlaWdodCAvIDIpIC0gKHIgLyAyKTtcbiAgdGhpcy5jb250ZXh0LnJlY3QoeCwgeSwgciwgcik7XG4gIHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLnJnYmEoMSwgMSwgMSwgMC41KTtcbiAgdGhpcy5jb250ZXh0LmZpbGwoKTtcbiAgdGhpcy5jb250ZXh0LmNsb3NlUGF0aCgpO1xuXG4gIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmVsb2NpdHksIHJvdGF0aW9uLCBvcmlnaW4pIHtcbiAgaWYgKHR5cGVvZiB2ZWxvY2l0eSA9PT0gJ29iamVjdCcpIHtcbiAgICBvcmlnaW4gICA9IHZlbG9jaXR5Lm9yaWdpbjtcbiAgICByb3RhdGlvbiA9IHZlbG9jaXR5LnJvdGF0aW9uO1xuICAgIHZlbG9jaXR5ID0gdmVsb2NpdHkudmVsb2NpdHk7XG4gIH1cbiAgdmVsb2NpdHkgICA9IHZlbG9jaXR5IHx8IDE7XG4gIHJvdGF0aW9uICAgPSByb3RhdGlvbiB8fCBbMCwgMCwgMF07XG4gIG9yaWdpbiAgICAgPSBvcmlnaW4gICB8fCBbMCwgMCwgMF07XG4gIGlmICghQXJyYXkuaXNBcnJheShyb3RhdGlvbikpIHJvdGF0aW9uID0gW3JvdGF0aW9uLngsIHJvdGF0aW9uLnksIHJvdGF0aW9uLnpdO1xuICBpZiAoIUFycmF5LmlzQXJyYXkob3JpZ2luKSkgb3JpZ2luID0gW29yaWdpbi54LCBvcmlnaW4ueSwgb3JpZ2luLnpdO1xuICByZXR1cm4gW1xuICAgICh2ZWxvY2l0eSAqIE1hdGguc2luKHJvdGF0aW9uWzBdKSAqIE1hdGguc2luKHJvdGF0aW9uWzFdKSkgKyBvcmlnaW5bMF0sXG4gICAgKHZlbG9jaXR5ICogTWF0aC5jb3Mocm90YXRpb25bMF0pKSArIG9yaWdpblsxXSxcbiAgICAodmVsb2NpdHkgKiBNYXRoLnNpbihyb3RhdGlvblswXSkgKiBNYXRoLmNvcyhyb3RhdGlvblsxXSkpICsgb3JpZ2luWzJdXG4gIF07XG59O1xuIiwiLy8vIENvcHlyaWdodCAyMDE0LTIwMTUgUmVkIEhhdCwgSW5jLiBhbmQvb3IgaXRzIGFmZmlsaWF0ZXNcbi8vLyBhbmQgb3RoZXIgY29udHJpYnV0b3JzIGFzIGluZGljYXRlZCBieSB0aGUgQGF1dGhvciB0YWdzLlxuLy8vXG4vLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vLy9cbi8vLyAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy8vXG4vLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi9saWJzL2hhd3Rpby11dGlsaXRpZXMvZGVmcy5kLnRzXCIvPlxuLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4uL2xpYnMvaGF3dGlvLWt1YmVybmV0ZXMvZGVmcy5kLnRzXCIvPlxuXG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vaW5jbHVkZXMudHNcIi8+XG5tb2R1bGUgS3ViZTNkIHtcblxuICBleHBvcnQgdmFyIFcgPSAxO1xuICBleHBvcnQgdmFyIFMgPSAwO1xuICBleHBvcnQgdmFyIFdBTEwgPSBXO1xuICBleHBvcnQgdmFyIFNQQUNFID0gUztcblxuICBleHBvcnQgdmFyIENFTExfU0laRSA9IDEwMDtcbiAgZXhwb3J0IHZhciBGTE9PUl9MRVZFTCA9IC1DRUxMX1NJWkU7XG5cbiAgZXhwb3J0IGludGVyZmFjZSBSZW5kZXJhYmxlIHtcbiAgICByZW5kZXIoKTp2b2lkO1xuICAgIGRlc3Ryb3koKTp2b2lkO1xuICB9XG5cbiAgZXhwb3J0IGludGVyZmFjZSBTY2VuZU9iamVjdCBleHRlbmRzIFJlbmRlcmFibGV7XG4gICAgZ2V0UG9zaXRpb24oKTphbnk7XG4gICAgc2V0UG9zaXRpb24oeCwgeSwgeik7XG4gICAgc2V0Um90YXRpb24ocngsIHJ5LCByeik7XG4gIH07XG59XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vaW5jbHVkZXMudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwia3ViZTNkSW50ZXJmYWNlcy50c1wiLz5cblxuZGVjbGFyZSB2YXIgVEhSRUU7IC8vID0gcmVxdWlyZSgndGhyZWVqcy1idWlsZCcpO1xudmFyIGNyZWF0ZUdhbWUgPSByZXF1aXJlKCd2b3hlbC1oZWxsby13b3JsZCcpO1xudmFyIHRlcnJhaW4gPSByZXF1aXJlKCd2b3hlbC1wZXJsaW4tdGVycmFpbicpO1xudmFyIGZseSA9IHJlcXVpcmUoJ3ZveGVsLWZseScpO1xudmFyIHdhbGsgPSByZXF1aXJlKCd2b3hlbC13YWxrJyk7XG52YXIgaGlnaGxpZ2h0ID0gcmVxdWlyZSgndm94ZWwtaGlnaGxpZ2h0Jyk7XG52YXIgcGxheWVyID0gcmVxdWlyZSgndm94ZWwtcGxheWVyJyk7XG52YXIgY3JlYXRlU2t5ID0gcmVxdWlyZSgndm94ZWwtc2t5Jyk7XG5cbm1vZHVsZSBLdWJlM2Qge1xuICBleHBvcnQgdmFyIHBsdWdpbk5hbWUgPSAnS3ViZTNkJztcbiAgZXhwb3J0IHZhciBsb2c6TG9nZ2luZy5Mb2dnZXIgPSBMb2dnZXIuZ2V0KHBsdWdpbk5hbWUpO1xuICBleHBvcnQgdmFyIHRlbXBsYXRlUGF0aCA9ICdwbHVnaW5zL2t1YmUzZC9odG1sJztcbiAgZXhwb3J0IHZhciBoYXZlUG9pbnRlckxvY2sgPSAncG9pbnRlckxvY2tFbGVtZW50JyBpbiBkb2N1bWVudCB8fCAnbW96UG9pbnRlckxvY2tFbGVtZW50JyBpbiBkb2N1bWVudCB8fCAnd2Via2l0UG9pbnRlckxvY2tFbGVtZW50JyBpbiBkb2N1bWVudDtcblxuXG4gIGV4cG9ydCB2YXIgSGFsZlBJID0gTWF0aC5QSSAvIDI7XG5cbiAgZXhwb3J0IGZ1bmN0aW9uIHJnYlRvSGV4KHIsIGcsIGIpIHtcbiAgICByZXR1cm4gXCIjXCIgKyAoKDEgPDwgMjQpICsgKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcmFuZG9tR3JleSgpIHtcbiAgICB2YXIgcmdiVmFsID0gTWF0aC5yYW5kb20oKSAqIDEyOCArIDEyODtcbiAgICByZXR1cm4gcmdiVG9IZXgocmdiVmFsLCByZ2JWYWwsIHJnYlZhbCk7XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gd2ViZ2xBdmFpbGFibGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnY2FudmFzJyApO1xuICAgICAgcmV0dXJuICEhKCAoPGFueT53aW5kb3cpLldlYkdMUmVuZGVyaW5nQ29udGV4dCAmJiAoXG4gICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApIHx8XG4gICAgICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCggJ2V4cGVyaW1lbnRhbC13ZWJnbCcgKSApXG4gICAgICAgICAgKTtcbiAgICB9IGNhdGNoICggZSApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBleHBvcnQgZnVuY3Rpb24gcGxhY2VPYmplY3QoY2VsbFgsIGNlbGxZLCBpc0Zsb29yID0gZmFsc2UpIHtcbiAgICB2YXIgeCA9IGNlbGxYICogQ0VMTF9TSVpFO1xuICAgIHZhciB6ID0gY2VsbFkgKiBDRUxMX1NJWkU7XG4gICAgdmFyIHkgPSBpc0Zsb29yID8gRkxPT1JfTEVWRUwgOiAwO1xuICAgIHJldHVybiBbeCwgeSwgel07XG4gIH1cblxuXG5cbn1cbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJrdWJlM2RIZWxwZXJzLnRzXCIvPlxuXG5tb2R1bGUgS3ViZTNkIHtcblxuICBleHBvcnQgdmFyIF9tb2R1bGUgPSBhbmd1bGFyLm1vZHVsZShwbHVnaW5OYW1lLCBbXSk7XG4gIGV4cG9ydCB2YXIgY29udHJvbGxlciA9IFBsdWdpbkhlbHBlcnMuY3JlYXRlQ29udHJvbGxlckZ1bmN0aW9uKF9tb2R1bGUsIHBsdWdpbk5hbWUpO1xuXG4gIHZhciB0YWIgPSB1bmRlZmluZWQ7XG5cbiAgX21vZHVsZS5jb25maWcoWyckcm91dGVQcm92aWRlcicsIFwiSGF3dGlvTmF2QnVpbGRlclByb3ZpZGVyXCIsICgkcm91dGVQcm92aWRlcjogbmcucm91dGUuSVJvdXRlUHJvdmlkZXIsIGJ1aWxkZXI6IEhhd3Rpb01haW5OYXYuQnVpbGRlckZhY3RvcnkpID0+IHtcbiAgICB0YWIgPSBidWlsZGVyLmNyZWF0ZSgpXG4gICAgICAuaWQocGx1Z2luTmFtZSlcbiAgICAgIC50aXRsZSgoKSA9PiAnM0QgVmlldycpXG4gICAgICAuaHJlZigoKSA9PiAnL2t1YmVybmV0ZXMvM2QnKVxuICAgICAgLnBhZ2UoKCkgPT4gYnVpbGRlci5qb2luKHRlbXBsYXRlUGF0aCwgJ3ZpZXcuaHRtbCcpKVxuICAgICAgLmJ1aWxkKCk7XG4gICAgYnVpbGRlci5jb25maWd1cmVSb3V0aW5nKCRyb3V0ZVByb3ZpZGVyLCB0YWIpO1xuXG4gIH1dKTtcblxuICBfbW9kdWxlLnJ1bihbJ0hhd3Rpb05hdicsIChuYXYpID0+IHtcbiAgICBuYXYub24oSGF3dGlvTWFpbk5hdi5BY3Rpb25zLkFERCwgcGx1Z2luTmFtZSwgKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLmlkICE9PSAna3ViZXJuZXRlcycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFfLmFueShpdGVtLnRhYnMsICh0YWI6YW55KSA9PiB0YWIuaWQgPT09IHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGl0ZW0udGFicy5wdXNoKHRhYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1dKTtcblxuXG4gIGhhd3Rpb1BsdWdpbkxvYWRlci5hZGRNb2R1bGUocGx1Z2luTmFtZSk7XG5cbn1cbiIsIi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJrdWJlM2RQbHVnaW4udHNcIi8+XG5cbm1vZHVsZSBLdWJlM2Qge1xuXG4gIF9tb2R1bGUuZGlyZWN0aXZlKCdyZXF1ZXN0TG9jaycsIFsnJGRvY3VtZW50JywgKCRkb2N1bWVudCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgc2NvcGU6IHtcbiAgICAgICAgJ29uTG9jayc6ICcmcmVxdWVzdExvY2snXG4gICAgICB9LFxuICAgICAgbGluazogKHNjb3BlLCBlbGVtZW50LCBhdHRyKSA9PiB7XG4gICAgICAgIHZhciBlbCA9IGVsZW1lbnRbMF0gfHwgZWxlbWVudDtcbiAgICAgICAgaWYgKGhhdmVQb2ludGVyTG9jaykge1xuICAgICAgICAgIGxvZy5kZWJ1ZyhcImhlcmUhXCIpO1xuICAgICAgICAgIHZhciBkb2MgPSAkZG9jdW1lbnRbMF07XG4gICAgICAgICAgdmFyIGJvZHkgPSBkb2MuYm9keTtcblxuICAgICAgICAgIHZhciBwb2ludGVybG9ja2NoYW5nZSA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCBkb2MucG9pbnRlckxvY2tFbGVtZW50ID09PSBib2R5IHx8IFxuICAgICAgICAgICAgICAgICBkb2MubW96UG9pbnRlckxvY2tFbGVtZW50ID09PSBib2R5IHx8IFxuICAgICAgICAgICAgICAgICBkb2Mud2Via2l0UG9pbnRlckxvY2tFbGVtZW50ID09PSBib2R5ICkge1xuICAgICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICBzY29wZS5vbkxvY2soeyBsb2NrOiB0cnVlIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgICAgICAgICAgICBzY29wZS5vbkxvY2soeyBsb2NrOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIENvcmUuJGFwcGx5KHNjb3BlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgdmFyIHBvaW50ZXJsb2NrZXJyb3IgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoICdwb2ludGVybG9ja2NoYW5nZScsIHBvaW50ZXJsb2NrY2hhbmdlLCBmYWxzZSApO1xuICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCAnbW96cG9pbnRlcmxvY2tjaGFuZ2UnLCBwb2ludGVybG9ja2NoYW5nZSwgZmFsc2UgKTtcbiAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmtpdHBvaW50ZXJsb2NrY2hhbmdlJywgcG9pbnRlcmxvY2tjaGFuZ2UsIGZhbHNlICk7XG5cbiAgICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lciggJ3BvaW50ZXJsb2NrZXJyb3InLCBwb2ludGVybG9ja2Vycm9yLCBmYWxzZSApO1xuICAgICAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCAnbW96cG9pbnRlcmxvY2tlcnJvcicsIHBvaW50ZXJsb2NrZXJyb3IsIGZhbHNlICk7XG4gICAgICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoICd3ZWJraXRwb2ludGVybG9ja2Vycm9yJywgcG9pbnRlcmxvY2tlcnJvciwgZmFsc2UgKTtcblxuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgYm9keS5yZXF1ZXN0UG9pbnRlckxvY2sgPSBib2R5LnJlcXVlc3RQb2ludGVyTG9jayB8fCBib2R5Lm1velJlcXVlc3RQb2ludGVyTG9jayB8fCBib2R5LndlYmtpdFJlcXVlc3RQb2ludGVyTG9jaztcbiAgICAgICAgICAgIGJvZHkucmVxdWVzdFBvaW50ZXJMb2NrKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxufVxuIiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cImt1YmUzZEludGVyZmFjZXMudHNcIi8+XG5tb2R1bGUgS3ViZTNkIHtcblxuICB2YXIgbG9nOkxvZ2dpbmcuTG9nZ2VyID0gTG9nZ2VyLmdldCgnS3ViZTNkJyk7XG5cbiAgZXhwb3J0IGNsYXNzIFNjZW5lT2JqZWN0QmFzZSBpbXBsZW1lbnRzIFNjZW5lT2JqZWN0IHtcblxuICAgIHByaXZhdGUgYm91bmRpbmdCb3g6YW55ID0gbnVsbDtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBzY2VuZTphbnksIHB1YmxpYyBnZW9tZXRyeTphbnkpIHtcbiAgICAgIHRoaXMuc2NlbmUuYWRkKGdlb21ldHJ5KTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBuZXcgVEhSRUUuQm91bmRpbmdCb3hIZWxwZXIodGhpcy5nZW9tZXRyeSwgMHgwMGZmMDApO1xuICAgICAgdGhpcy5zY2VuZS5hZGQodGhpcy5ib3VuZGluZ0JveCk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLnNjZW5lLnJlbW92ZSh0aGlzLmdlb21ldHJ5KTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZ2VvbWV0cnk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlYnVnKGVuYWJsZSkge1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC52aXNpYmxlID0gZW5hYmxlO1xuICAgIH1cblxuICAgIHB1YmxpYyBtb3ZlKHgsIHksIHopIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkucG9zaXRpb24ueCArPSB4O1xuICAgICAgdGhpcy5nZW9tZXRyeS5wb3NpdGlvbi55ICs9IHk7XG4gICAgICB0aGlzLmdlb21ldHJ5LnBvc2l0aW9uLnogKz0gejtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucG9zaXRpb24ueCArPSB4O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5wb3NpdGlvbi55ICs9IHk7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnBvc2l0aW9uLnogKz0gejtcbiAgICB9XG5cbiAgICBwdWJsaWMgcm90YXRlKHJ4LCByeSwgcnopIHtcbiAgICAgIHRoaXMuZ2VvbWV0cnkucm90YXRpb24ueCArPSByeDtcbiAgICAgIHRoaXMuZ2VvbWV0cnkucm90YXRpb24ueSArPSByeTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkucm90YXRpb24ueiArPSByejtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucm90YXRpb24ueCArPSByeDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucm90YXRpb24ueSArPSByeTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucm90YXRpb24ueiArPSByejtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0UG9zaXRpb24oKSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnVwZGF0ZSgpO1xuICAgICAgcmV0dXJuIHRoaXMuYm91bmRpbmdCb3gub2JqZWN0LnBvc2l0aW9uO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXRQb3NpdGlvbih4LCB5LCB6KSB7XG4gICAgICB0aGlzLmdlb21ldHJ5LnBvc2l0aW9uLnggPSB4O1xuICAgICAgdGhpcy5nZW9tZXRyeS5wb3NpdGlvbi55ID0geTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkucG9zaXRpb24ueiA9IHo7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnBvc2l0aW9uLnggPSB4O1xuICAgICAgdGhpcy5ib3VuZGluZ0JveC5wb3NpdGlvbi55ID0geTtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3gucG9zaXRpb24ueiA9IHo7XG5cbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0Um90YXRpb24ocngsIHJ5LCByeikge1xuICAgICAgdGhpcy5nZW9tZXRyeS5yb3RhdGlvbi54ID0gcng7XG4gICAgICB0aGlzLmdlb21ldHJ5LnJvdGF0aW9uLnkgPSByeTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkucm90YXRpb24ueiA9IHJ6O1xuICAgICAgdGhpcy5nZW9tZXRyeS5yb3RhdGlvbi54ID0gcng7XG4gICAgICB0aGlzLmdlb21ldHJ5LnJvdGF0aW9uLnkgPSByeTtcbiAgICAgIHRoaXMuZ2VvbWV0cnkucm90YXRpb24ueiA9IHJ6O1xuICAgIH1cblxuICAgIHB1YmxpYyByZW5kZXIoKSB7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94LnVwZGF0ZSgpO1xuICAgIH1cblxuICB9XG5cbiAgZXhwb3J0IGNsYXNzIFBvZE9iamVjdCBleHRlbmRzIFNjZW5lT2JqZWN0QmFzZSB7XG4gICAgcHJpdmF0ZSBhbmdsZTpudW1iZXIgPSB1bmRlZmluZWQ7XG4gICAgcHJpdmF0ZSBjaXJjbGU6YW55ID0gdW5kZWZpbmVkO1xuICAgIHByaXZhdGUgcm90YXRpb24gPSB7XG4gICAgICB4OiBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAvIDEwMDAsXG4gICAgICB5OiBNYXRoLnJhbmRvbSgpICogTWF0aC5QSSAvIDEwMCxcbiAgICAgIHo6IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJIC8gMTAwMFxuICAgIH07XG4gICAgY29uc3RydWN0b3IocHVibGljIHNjZW5lOiBhbnksIHB1YmxpYyBob3N0T2JqZWN0Okhvc3RPYmplY3QsIHB1YmxpYyBpZDpzdHJpbmcsIHB1YmxpYyBvYmo6YW55KSB7XG4gICAgICBzdXBlcihzY2VuZSwgbmV3IFRIUkVFLk9iamVjdDNEKCkpO1xuICAgICAgdmFyIHRleHR1cmUgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKG9iai4kaWNvblVybCk7XG4gICAgICB0ZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gICAgICB0aGlzLmdlb21ldHJ5LmFkZChcbiAgICAgICAgICBuZXcgVEhSRUUuTWVzaChcbiAgICAgICAgICAgIG5ldyBUSFJFRS5Cb3hHZW9tZXRyeSg1MCwgNTAsIDUwKSwgXG4gICAgICAgICAgICBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe1xuICAgICAgICAgICAgICBjb2xvcjogMHhmZmZmZmYsIFxuICAgICAgICAgICAgICBtYXA6IHRleHR1cmUsXG4gICAgICAgICAgICAgIGJ1bXBNYXA6IHRleHR1cmUsXG4gICAgICAgICAgICAgIGNhc3RTaGFkb3c6IHRydWUsIFxuICAgICAgICAgICAgICByZWNlaXZlU2hhZG93OiB0cnVlLCBcbiAgICAgICAgICAgICAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICkpO1xuICAgICAgbG9nLmRlYnVnKFwiQ3JlYXRlZCBwb2Qgb2JqZWN0IFwiLCBpZCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZShtb2RlbCwgcG9kKSB7XG4gICAgICB0aGlzLm9iaiA9IHBvZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuaG9zdE9iamVjdC5nZW9tZXRyeS5yZW1vdmUodGhpcy5jaXJjbGUpO1xuICAgICAgbG9nLmRlYnVnKFwiRGVzdHJveWVkIHBvZCBvYmplY3QgXCIsIHRoaXMuaWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgZGlzdGFuY2UoKSB7XG4gICAgICB2YXIgaG9zdFBvc2l0aW9uID0gdGhpcy5ob3N0T2JqZWN0LmdldFBvc2l0aW9uKCk7XG4gICAgICB2YXIgbXlQb3NpdGlvbiA9IHRoaXMuZ2V0UG9zaXRpb24oKTtcbiAgICAgIHZhciBkaXN0WCA9IE1hdGguYWJzKGhvc3RQb3NpdGlvbi54IC0gbXlQb3NpdGlvbi54KTtcbiAgICAgIHZhciBkaXN0WSA9IE1hdGguYWJzKGhvc3RQb3NpdGlvbi55IC0gbXlQb3NpdGlvbi55KTtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoZGlzdFggKiBkaXN0WCArIGRpc3RZICogZGlzdFkpO1xuICAgIH1cblxuICAgIHByaXZhdGUgYW5nbGVPZlZlbG9jaXR5KCkge1xuICAgICAgaWYgKCF0aGlzLmFuZ2xlKSB7XG4gICAgICAgIHZhciBkaXN0ID0gdGhpcy5kaXN0YW5jZSgpO1xuICAgICAgICBsb2cuZGVidWcoXCJwb2QgaWQ6IFwiLCB0aGlzLmlkLCBcIiBkaXN0YW5jZTogXCIsIGRpc3QpO1xuICAgICAgICB0aGlzLmFuZ2xlID0gKDEgLyBkaXN0KSAqIDEwO1xuICAgICAgICBsb2cuZGVidWcoXCJwb2QgaWQ6IFwiLCB0aGlzLmlkLCBcIiBhbmdsZTogXCIsIHRoaXMuYW5nbGUpO1xuICAgICAgICB2YXIgbWF0ZXJpYWxBcnJheSA9IFtdO1xuICAgICAgICB2YXIgZmFjZSA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7IFxuICAgICAgICAgIGNvbG9yOiAweDU1NTU1NSxcbiAgICAgICAgICBjYXN0U2hhZG93OiB0cnVlLFxuICAgICAgICAgIHJlY2VpdmVTaGFkb3c6IHRydWUsXG4gICAgICAgICAgd2lyZWZyYW1lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBtYXRlcmlhbEFycmF5LnB1c2goZmFjZS5jbG9uZSgpKTtcbiAgICAgICAgbWF0ZXJpYWxBcnJheS5wdXNoKGZhY2UuY2xvbmUoKSk7XG4gICAgICAgIHRoaXMuY2lyY2xlID0gbmV3IFRIUkVFLk1lc2gobmV3IFRIUkVFLlJpbmdHZW9tZXRyeShkaXN0IC0gMSwgZGlzdCArIDEsIDEyOCksIG5ldyBUSFJFRS5NZXNoRmFjZU1hdGVyaWFsKG1hdGVyaWFsQXJyYXkpKTtcbiAgICAgICAgdGhpcy5ob3N0T2JqZWN0Lmdlb21ldHJ5LmFkZCh0aGlzLmNpcmNsZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hbmdsZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVuZGVyKCkge1xuICAgICAgdmFyIG15UG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uKCk7XG4gICAgICB2YXIgaG9zdFBvc2l0aW9uID0gdGhpcy5ob3N0T2JqZWN0LmdldFBvc2l0aW9uKCk7XG4gICAgICB2YXIgeCA9IG15UG9zaXRpb24ueDtcbiAgICAgIHZhciB5ID0gbXlQb3NpdGlvbi55O1xuICAgICAgdmFyIGNlbnRlclggPSBob3N0UG9zaXRpb24ueDtcbiAgICAgIHZhciBjZW50ZXJZID0gaG9zdFBvc2l0aW9uLnk7XG4gICAgICB2YXIgb2Zmc2V0WCA9IHggLSBjZW50ZXJYO1xuICAgICAgdmFyIG9mZnNldFkgPSB5IC0gY2VudGVyWTtcbiAgICAgIHZhciBhbmdsZSA9IHRoaXMuYW5nbGVPZlZlbG9jaXR5KCk7XG4gICAgICB2YXIgbmV3WCA9IGNlbnRlclggKyBvZmZzZXRYICogTWF0aC5jb3MoYW5nbGUpIC0gb2Zmc2V0WSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHZhciBuZXdZID0gY2VudGVyWSArIG9mZnNldFggKiBNYXRoLnNpbihhbmdsZSkgKyBvZmZzZXRZICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgdGhpcy5zZXRQb3NpdGlvbihuZXdYLCBuZXdZLCAwKTtcbiAgICAgIHRoaXMucm90YXRlKHRoaXMucm90YXRpb24ueCwgdGhpcy5yb3RhdGlvbi55LCB0aGlzLnJvdGF0aW9uLnopO1xuICAgICAgc3VwZXIucmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgZXhwb3J0IGNsYXNzIEhvc3RPYmplY3QgZXh0ZW5kcyBTY2VuZU9iamVjdEJhc2Uge1xuICAgIHByaXZhdGUgb2Zmc2V0WCA9IDIwMDtcbiAgICBwcml2YXRlIG9mZnNldFkgPSAyMDA7XG4gICAgcHVibGljIHBvZHMgPSB7fTtcbiAgICBwdWJsaWMgcm90YXRpb24gPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHo6IE1hdGgucmFuZG9tKCkgKiBNYXRoLlBJIC8gMTAwMFxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHNjZW5lOiBhbnksIHB1YmxpYyBpZDpzdHJpbmcsIHB1YmxpYyBvYmo6YW55KSB7XG4gICAgICBzdXBlcihzY2VuZSwgbmV3IFRIUkVFLk9iamVjdDNEKCkpXG4gICAgICB2YXIgdGV4dHVyZSA9IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoJ2ltZy9zdW4tdGV4dHVyZS5qcGcnKTtcbiAgICAgIHRleHR1cmUubWluRmlsdGVyID0gVEhSRUUuTmVhcmVzdEZpbHRlcjtcbiAgICAgIHRoaXMuZ2VvbWV0cnkuYWRkKCBcbiAgICAgICAgICBuZXcgVEhSRUUuUG9pbnRMaWdodCgweGZmZDcwMCwgMSwgNTAwMCksXG4gICAgICAgICAgbmV3IFRIUkVFLk1lc2goXG4gICAgICAgICAgICBuZXcgVEhSRUUuU3BoZXJlR2VvbWV0cnkoMTAwLCAzMiwgMTYpLCBcbiAgICAgICAgICAgIG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7XG4gICAgICAgICAgICAgIGNvbG9yOiAweGZmZDcwMCwgXG4gICAgICAgICAgICAgIG1hcDogdGV4dHVyZSxcbiAgICAgICAgICAgICAgYnVtcE1hcDogdGV4dHVyZSxcbiAgICAgICAgICAgICAgc3BlY3VsYXI6IDB4MDBmZjAwLCBcbiAgICAgICAgICAgICAgc2hhZGluZzogVEhSRUUuU21vb3RoU2hhZGluZ1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICBsb2cuZGVidWcoXCJDcmVhdGVkIGhvc3Qgb2JqZWN0IFwiLCBpZCk7XG4gICAgfVxuXG4gICAgcHVibGljIHVwZGF0ZShtb2RlbCwgaG9zdCkge1xuICAgICAgdGhpcy5vYmogPSBob3N0O1xuICAgICAgdmFyIHBvZHNUb1JlbW92ZSA9IFtdO1xuICAgICAgXy5mb3JJbih0aGlzLnBvZHMsIChwb2QsIGtleSkgPT4ge1xuICAgICAgICBpZiAoIShrZXkgaW4gbW9kZWwucG9kc0J5S2V5KSkge1xuICAgICAgICAgIHBvZHNUb1JlbW92ZS5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgXy5mb3JFYWNoKHBvZHNUb1JlbW92ZSwgKGlkKSA9PiB0aGlzLnJlbW92ZVBvZChpZCkpO1xuICAgICAgXy5mb3JFYWNoKHRoaXMub2JqLnBvZHMsIChwb2Q6YW55KSA9PiB7XG4gICAgICAgIHZhciBuYW1lID0gcG9kLl9rZXk7XG4gICAgICAgIGlmICghdGhpcy5oYXNQb2QobmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmFkZFBvZChuYW1lLCBwb2QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwb2RPYmogPSB0aGlzLnBvZHNbbmFtZV07XG4gICAgICAgICAgcG9kT2JqLnVwZGF0ZShtb2RlbCwgcG9kKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIGRlYnVnKGVuYWJsZSkge1xuICAgICAgdmFyIGlkcyA9IF8ua2V5cyh0aGlzLnBvZHMpXG4gICAgICBfLmZvckVhY2goaWRzLCAoaWQpID0+IHRoaXMucG9kc1tpZF0uZGVidWcoZW5hYmxlKSk7XG4gICAgICBzdXBlci5kZWJ1ZyhlbmFibGUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBkZXN0cm95KCkge1xuICAgICAgaWYgKHRoaXMucG9kcykge1xuICAgICAgICB2YXIgcG9kSWRzID0gXy5rZXlzKHRoaXMucG9kcyk7XG4gICAgICAgIF8uZm9yRWFjaChwb2RJZHMsIChpZCkgPT4gdGhpcy5yZW1vdmVQb2QoaWQpKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICAgIGxvZy5kZWJ1ZyhcIkRlc3Ryb3lpbmcgaG9zdCBvYmplY3QgXCIsIHRoaXMuaWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyByZW1vdmVQb2QoaWQpIHtcbiAgICAgIHZhciBwb2QgPSB0aGlzLnBvZHNbaWRdO1xuICAgICAgaWYgKHBvZCkge1xuICAgICAgICBwb2QuZGVzdHJveSgpO1xuICAgICAgICBkZWxldGUgdGhpcy5wb2RzW2lkXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgYWRkUG9kKGtleSwgcDphbnkpIHtcbiAgICAgIGlmICh0aGlzLmhhc1BvZChrZXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBteVBvc2l0aW9uID0gdGhpcy5nZXRQb3NpdGlvbigpO1xuICAgICAgdmFyIHBvZE9mZnNldFggPSB0aGlzLm9mZnNldFggLSBteVBvc2l0aW9uLng7XG4gICAgICB2YXIgcG9kT2Zmc2V0WSA9IG15UG9zaXRpb24ueTtcbiAgICAgIC8qXG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLnJhbmRvbSgpICogMzYwO1xuICAgICAgdmFyIHBvZFggPSBteVBvc2l0aW9uLnggKyBwb2RPZmZzZXRYICogTWF0aC5jb3MoYW5nbGUpIC0gcG9kT2Zmc2V0WSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIHZhciBwb2RZID0gbXlQb3NpdGlvbi55ICsgcG9kT2Zmc2V0WCAqIE1hdGguc2luKGFuZ2xlKSAtIHBvZE9mZnNldFkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAqL1xuICAgICAgdmFyIHBvZCA9IG5ldyBQb2RPYmplY3QodGhpcy5zY2VuZSwgdGhpcywga2V5LCBwKTtcbiAgICAgIHBvZC5zZXRQb3NpdGlvbihteVBvc2l0aW9uLngsIG15UG9zaXRpb24ueSwgbXlQb3NpdGlvbi56KTtcbiAgICAgIHBvZC5tb3ZlKHRoaXMub2Zmc2V0WCwgMCwgMCk7XG4gICAgICB0aGlzLm9mZnNldFggPSB0aGlzLm9mZnNldFggKyBNYXRoLnJhbmRvbSgpICogNTAgKyAxMDA7XG4gICAgICB0aGlzLm9mZnNldFkgPSB0aGlzLm9mZnNldFkgKyBNYXRoLnJhbmRvbSgpICogNTAgKyAxMDA7XG4gICAgICB0aGlzLnBvZHNba2V5XSA9IHBvZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgaGFzUG9kKGlkKSB7XG4gICAgICByZXR1cm4gKGlkIGluIHRoaXMucG9kcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzdGVwID0gMDtcbiAgICBcbiAgICBwdWJsaWMgcmVuZGVyKCkge1xuICAgICAgdGhpcy5yb3RhdGUodGhpcy5yb3RhdGlvbi54LCB0aGlzLnJvdGF0aW9uLnksIHRoaXMucm90YXRpb24ueik7XG4gICAgICBfLmZvckluKHRoaXMucG9kcywgKHBvZE9iamVjdCwgaWQpID0+IHtcbiAgICAgICAgcG9kT2JqZWN0LnJlbmRlcigpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnN0ZXAgPSB0aGlzLnN0ZXAgKyAxO1xuICAgICAgc3VwZXIucmVuZGVyKCk7XG4gICAgfVxuXG5cbiAgfVxuXG59XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwia3ViZTNkSGVscGVycy50c1wiLz5cblxubW9kdWxlIEt1YmUzZCB7XG5cbiAgdmFyIGxldmVsRGF0YSA9IFxuICAgIFtcbiAgICAgIFsgVywgVywgVywgVywgVywgVywgVywgVyBdLFxuICAgICAgWyBXLCBTLCBTLCBTLCBTLCBTLCBTLCBXIF0sXG4gICAgICBbIFcsIFMsIFMsIFMsIFMsIFMsIFMsIFcgXSxcbiAgICAgIFsgVywgUywgUywgUywgUywgUywgUywgVyBdLFxuICAgICAgWyBXLCBTLCBTLCBTLCBTLCBTLCBTLCBXIF0sXG4gICAgICBbIFcsIFMsIFMsIFMsIFMsIFMsIFMsIFcgXSxcbiAgICAgIFsgVywgUywgUywgUywgUywgUywgUywgVyBdLFxuICAgICAgWyBXLCBXLCBXLCBXLCBXLCBXLCBXLCBXIF1cbiAgICBdO1xuXG4gIHZhciBsZXZlbFdpZHRoID0gbGV2ZWxEYXRhWzBdLmxlbmd0aDtcbiAgdmFyIGxldmVsSGVpZ2h0ID0gbGV2ZWxEYXRhLmxlbmd0aDtcbiAgLypcblxuICB2YXIgd2FsbFRleHR1cmUgPSBUSFJFRS5JbWFnZVV0aWxzLmxvYWRUZXh0dXJlKCdpbWcvSU1HUDE0NTAuanBnJyk7XG4gIHdhbGxUZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gIHZhciB3YWxsTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoe1xuICAgIGNvbG9yOiAweDAwZmYwMCwgXG4gICAgbWFwOiB3YWxsVGV4dHVyZSxcbiAgICBjYXN0U2hhZG93OiB0cnVlLFxuICAgIHJlY2VpdmVTaGFkb3c6IHRydWUsXG4gICAgd2lyZWZyYW1lOiBmYWxzZVxuICB9KTtcbiAgdmFyIHdhbGwgPSBuZXcgVEhSRUUuTWVzaChuZXcgVEhSRUUuQm94R2VvbWV0cnkoQ0VMTF9TSVpFLCBDRUxMX1NJWkUsIENFTExfU0laRSksIHdhbGxNYXRlcmlhbCk7XG5cbiAgdmFyIGZsb29yVGV4dHVyZSA9IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoJ2ltZy9JTUdQMTQ1MC5qcGcnKTtcbiAgZmxvb3JUZXh0dXJlLm1pbkZpbHRlciA9IFRIUkVFLk5lYXJlc3RGaWx0ZXI7XG4gIHZhciBmbG9vck1hdGVyaWFsID0gbmV3IFRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtcbiAgICBjb2xvcjogMHhmZjAwMDAsIFxuICAgIG1hcDogZmxvb3JUZXh0dXJlLFxuICAgIGNhc3RTaGFkb3c6IHRydWUsXG4gICAgcmVjZWl2ZVNoYWRvdzogdHJ1ZSxcbiAgICB3aXJlZnJhbWU6IGZhbHNlXG4gIH0pO1xuICB2YXIgZmxvb3IgPSBuZXcgVEhSRUUuTWVzaChuZXcgVEhSRUUuQm94R2VvbWV0cnkoQ0VMTF9TSVpFLCBDRUxMX1NJWkUsIENFTExfU0laRSksIGZsb29yTWF0ZXJpYWwpO1xuICAqL1xuXG4gIGZ1bmN0aW9uIG1ha2VCb3goY2VsbFgsIGNlbGxZLCBpc0Zsb29yID0gZmFsc2UpIHtcbiAgICAvKlxuICAgIHZhciBib3ggPSBpc0Zsb29yID8gZmxvb3IuY2xvbmUoKSA6IHdhbGwuY2xvbmUoKTtcbiAgICBib3gucG9zaXRpb24uZnJvbUFycmF5KHBsYWNlT2JqZWN0KGNlbGxYLCBjZWxsWSwgaXNGbG9vcikpO1xuICAgIHJldHVybiBib3g7XG4gICAgKi9cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgZXhwb3J0IGNsYXNzIFdvcmxkIGltcGxlbWVudHMgUmVuZGVyYWJsZSB7XG4gICAgcHJpdmF0ZSBhbWJpZW50ID0gbmV3IFRIUkVFLkFtYmllbnRMaWdodCggMHhmZmZmZmYgKTtcbiAgICBwcml2YXRlIGxpZ2h0ID0gbmV3IFRIUkVFLkRpcmVjdGlvbmFsTGlnaHQoIDB4ODg4ODg4ICk7XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBzY2VuZSkge1xuICAgICAgdGhpcy5hbWJpZW50LmNvbG9yLnNldEhTTCggMC4xLCAwLjMsIDAuMiApO1xuICAgICAgdGhpcy5saWdodC5wb3NpdGlvbi5zZXQoIDEsIDEsIDApO1xuICAgICAgLy9zY2VuZS5mb2cgPSBuZXcgVEhSRUUuRm9nKDB4ZmZmZmZmLCA1MDAsIDEwMDAwKVxuICAgICAgc2NlbmUuYWRkKHRoaXMuYW1iaWVudCk7XG4gICAgICBzY2VuZS5hZGQodGhpcy5saWdodCk7XG5cbiAgICAgIC8vIHNreWJveFxuICAgICAgdmFyIG1hdGVyaWFsQXJyYXkgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKVxuICAgICAgICBtYXRlcmlhbEFycmF5LnB1c2gobmV3IFRIUkVFLk1lc2hCYXNpY01hdGVyaWFsKHtcbiAgICAgICAgICBtYXA6IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoJ2ltZy9zcGFjZS1zZWFtbGVzcy5wbmcnKSxcbiAgICAgICAgICBzaWRlOiBUSFJFRS5CYWNrU2lkZVxuICAgICAgICB9KSk7XG4gICAgICB2YXIgc2t5TWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaEZhY2VNYXRlcmlhbChtYXRlcmlhbEFycmF5KTtcbiAgICAgIHNjZW5lLmFkZChuZXcgVEhSRUUuTWVzaChuZXcgVEhSRUUuQm94R2VvbWV0cnkoMTAwMDAsIDEwMDAwLCAxMDAwMCksIHNreU1hdGVyaWFsKSk7XG5cbiAgICAgIC8vIHdhbGxzL2Zsb29yXG4gICAgICBfLmZvckVhY2gobGV2ZWxEYXRhLCAocm93LCB5KSA9PiB7XG4gICAgICAgIF8uZm9yRWFjaChyb3csIChjZWxsLCB4KSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChjZWxsKSB7XG4gICAgICAgICAgICBjYXNlIFdBTEw6XG4gICAgICAgICAgICAgIHNjZW5lLmFkZChtYWtlQm94KHgsIHksIGZhbHNlKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzY2VuZS5hZGQobWFrZUJveCh4LCB5LCB0cnVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8qXG4gICAgICAvLyBwYXJ0aWNsZSBjbG91ZFxuICAgICAgdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEwMDAwOyBpKyspIHtcbiAgICAgICAgdmFyIHZlcnRleCA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgICAgIHZlcnRleC54ID0gVEhSRUUuTWF0aC5yYW5kRmxvYXRTcHJlYWQoIDEwMDAwICk7XG4gICAgICAgIHZlcnRleC55ID0gVEhSRUUuTWF0aC5yYW5kRmxvYXRTcHJlYWQoIDEwMDAwICk7XG4gICAgICAgIHZlcnRleC56ID0gVEhSRUUuTWF0aC5yYW5kRmxvYXRTcHJlYWQoIDEwMDAwICk7XG4gICAgICAgIGdlb21ldHJ5LnZlcnRpY2VzLnB1c2godmVydGV4KTtcbiAgICAgIH1cbiAgICAgIHZhciBwYXJ0aWNsZXMgPSBuZXcgVEhSRUUuUG9pbnRDbG91ZCggZ2VvbWV0cnksIG5ldyBUSFJFRS5Qb2ludENsb3VkTWF0ZXJpYWwoe2NvbG9yOiAweDg4ODg4OCwgZm9nOiB0cnVlfSkpO1xuICAgICAgc2NlbmUuYWRkKHBhcnRpY2xlcyk7XG4gICAgICAqL1xuICAgIH1cblxuICAgIHB1YmxpYyBwbGFjZVBsYXllcihvYmplY3QpIHtcbiAgICAgIHRoaXMucGxhY2VPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcGxhY2VPYmplY3Qob2JqZWN0KSB7XG4gICAgICBpZiAoIW9iamVjdCB8fCAhb2JqZWN0LnBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciB4LCB5O1xuICAgICAgZG8ge1xuICAgICAgICB4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGxldmVsV2lkdGggLSAyKSArIDEpO1xuICAgICAgICB5ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKGxldmVsSGVpZ2h0IC0yKSArIDEpO1xuICAgICAgICBsb2cuZGVidWcoXCJ4OlwiLHgsXCJ5OlwiLHksXCJ2YWw6XCIsbGV2ZWxEYXRhW3ldW3hdKTtcbiAgICAgIH0gd2hpbGUgKGxldmVsRGF0YVt5XVt4XSAhPT0gU1BBQ0UpXG4gICAgICBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KHBsYWNlT2JqZWN0KHgsIHkpKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgcmVuZGVyKCkge1xuXG4gICAgfVxuXG4gICAgcHVibGljIGRlc3Ryb3koKSB7XG5cbiAgICB9XG5cbiAgfVxuXG59XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwia3ViZTNkSGVscGVycy50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJ3b3JsZC50c1wiLz5cblxubW9kdWxlIEt1YmUzZCB7XG5cbiAgZXhwb3J0IGNsYXNzIFBsYXllciBpbXBsZW1lbnRzIFJlbmRlcmFibGUge1xuICAgIHByaXZhdGUgbG9nOkxvZ2dpbmcuTG9nZ2VyID0gTG9nZ2VyLmdldCgna3ViZTNkLXBsYXllcicpO1xuICAgIHByaXZhdGUgZG9tRWxlbWVudDphbnkgPSBudWxsO1xuICAgIHByaXZhdGUgX2xvb2tBdDphbnkgPSBudWxsO1xuICAgIHByaXZhdGUgcGl0Y2ggPSBuZXcgVEhSRUUuT2JqZWN0M0QoKTtcbiAgICBwcml2YXRlIHlhdyA9IG5ldyBUSFJFRS5PYmplY3QzRCgpO1xuXG4gICAgcHJpdmF0ZSBfZW5hYmxlZCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX2RvY3VtZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgcHJpdmF0ZSBnZXRXb3JsZE9iamVjdHM6YW55ID0gKCkgPT4gW107XG5cbiAgICBwcml2YXRlIHJheWNhc3RlciA9IG5ldyBUSFJFRS5SYXljYXN0ZXIobmV3IFRIUkVFLlZlY3RvcjMoKSwgbmV3IFRIUkVFLlZlY3RvcjMoMCwgLTEsIDApLCAwLCAxMCk7XG5cbiAgICAvLyBtb3ZlbWVudCBib29sZWFuc1xuICAgIHByaXZhdGUgZm9yd2FyZCA9IGZhbHNlO1xuICAgIHByaXZhdGUgYmFja3dhcmQgPSBmYWxzZTtcbiAgICBwcml2YXRlIGxlZnQgPSBmYWxzZTtcbiAgICBwcml2YXRlIHJpZ2h0ID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBjYW5KdW1wID0gdHJ1ZTtcbiAgICBwcml2YXRlIHJ1bm5pbmcgPSBmYWxzZTtcblxuICAgIC8vIG1vdmVtZW50IHZlbG9jaXR5XG4gICAgcHJpdmF0ZSB2ZWxvY2l0eSA9IG5ldyBUSFJFRS5WZWN0b3IzKCk7XG4gICAgcHJpdmF0ZSBwcmV2VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgLy8ga2V5L21vdXNlIGhhbmRsZXJzXG4gICAgcHJpdmF0ZSBoYW5kbGVyczphbnkgPSBudWxsO1xuXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHByaXZhdGUgc2NlbmUsIHByaXZhdGUgY2FtZXJhLCBwcml2YXRlIGQsIHByaXZhdGUgd29ybGQ6V29ybGQpIHtcblxuICAgICAgY2FtZXJhLnJvdGF0aW9uLnNldCgwLCAwLCAwKTtcbiAgICAgIGNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgICB0aGlzLnBpdGNoLmFkZChjYW1lcmEpO1xuICAgICAgdGhpcy55YXcuYWRkKHRoaXMucGl0Y2gpO1xuICAgICAgc2NlbmUuYWRkKHRoaXMueWF3KTtcblxuICAgICAgdGhpcy55YXcucG9zaXRpb24uc2V0KDAsIDAsIC01KTtcblxuICAgICAgdmFyIGRvbUVsZW1lbnQgPSB0aGlzLmRvbUVsZW1lbnQgPSAkKGQpO1xuXG4gICAgICBpZiAoIWhhdmVQb2ludGVyTG9jaykge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHNlbGYuaGFuZGxlcnMgPSB7XG4gICAgICAgICdrZXlkb3duJzogKGV2ZW50OmFueSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG4gICAgICAgICAgICBjYXNlIDM4OiAvLyB1cFxuICAgICAgICAgICAgY2FzZSA4NzogLy8gd1xuICAgICAgICAgICAgICBzZWxmLmZvcndhcmQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzc6IC8vIGxlZnRcbiAgICAgICAgICAgIGNhc2UgNjU6IC8vIGFcbiAgICAgICAgICAgICAgc2VsZi5sZWZ0ID0gdHJ1ZTsgXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0MDogLy8gZG93blxuICAgICAgICAgICAgY2FzZSA4MzogLy8gc1xuICAgICAgICAgICAgICBzZWxmLmJhY2t3YXJkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OiAvLyByaWdodFxuICAgICAgICAgICAgY2FzZSA2ODogLy8gZFxuICAgICAgICAgICAgICBzZWxmLnJpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2OiAvLyBzaGlmdFxuICAgICAgICAgICAgICBzZWxmLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzI6IC8vIHNwYWNlXG4gICAgICAgICAgICAgIGlmIChzZWxmLmNhbkp1bXAgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnZlbG9jaXR5LnkgKz0gMzUwO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FuSnVtcCA9IGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ2tleXVwJzogKGV2ZW50OmFueSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoIGV2ZW50LmtleUNvZGUgKSB7XG4gICAgICAgICAgICBjYXNlIDM4OiAvLyB1cFxuICAgICAgICAgICAgY2FzZSA4NzogLy8gd1xuICAgICAgICAgICAgICBzZWxmLmZvcndhcmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM3OiAvLyBsZWZ0XG4gICAgICAgICAgICBjYXNlIDY1OiAvLyBhXG4gICAgICAgICAgICAgIHNlbGYubGVmdCA9IGZhbHNlOyBcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQwOiAvLyBkb3duXG4gICAgICAgICAgICBjYXNlIDgzOiAvLyBzXG4gICAgICAgICAgICAgIHNlbGYuYmFja3dhcmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM5OiAvLyByaWdodFxuICAgICAgICAgICAgY2FzZSA2ODogLy8gZFxuICAgICAgICAgICAgICBzZWxmLnJpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxNjogLy8gc2hpZnRcbiAgICAgICAgICAgICAgc2VsZi5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgJ21vdXNlbW92ZSc6IChldmVudDphbnkpID0+IHtcbiAgICAgICAgICBpZiAoIXNlbGYuX2VuYWJsZWQgfHwgIWhhdmVQb2ludGVyTG9jaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgeWF3ID0gc2VsZi55YXc7XG4gICAgICAgICAgdmFyIHBpdGNoID0gc2VsZi5waXRjaDtcbiAgICAgICAgICB2YXIgZGVsdGFYID0gZXZlbnQubW92ZW1lbnRYIHx8IGV2ZW50Lm1vek1vdmVtZW50WCB8fCBldmVudC53ZWJraXRNb3ZlbWVudFggfHwgMDtcbiAgICAgICAgICB2YXIgZGVsdGFZID0gZXZlbnQubW92ZW1lbnRZIHx8IGV2ZW50Lm1vek1vdmVtZW50WCB8fCBldmVudC53ZWJraXRNb3ZlbWVudFggfHwgMDtcbiAgICAgICAgICB5YXcucm90YXRpb24ueSAtPSBkZWx0YVggKiAwLjAwMjtcbiAgICAgICAgICBwaXRjaC5yb3RhdGlvbi54IC09IGRlbHRhWSAqIDAuMDAyO1xuICAgICAgICAgIHBpdGNoLnJvdGF0aW9uLnggPSBNYXRoLm1heCgtSGFsZlBJLCBNYXRoLm1pbihIYWxmUEksIHBpdGNoLnJvdGF0aW9uLngpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF8uZm9ySW4odGhpcy5oYW5kbGVycywgKGhhbmRsZXIsIGV2dCkgPT4gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGZhbHNlKSk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBlbmFibGVkKGVuYWJsZWQpIHtcbiAgICAgIHRoaXMuX2VuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5jYW1lcmEucG9zaXRpb24uc2V0KDAsIDAsIDApO1xuICAgICAgICB0aGlzLmNhbWVyYS5yb3RhdGlvbi5zZXQoMCwgMCwgMCk7XG4gICAgICAgIHRoaXMub2JqZWN0LnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICAgICAgdmFyIGFuZ2xlID0gVEhSRUUuTWF0aC5kZWdUb1JhZChUSFJFRS5NYXRoLnJhbmRvbTE2KCkgKiAzNjApO1xuICAgICAgICB0aGlzLnlhdy5yb3RhdGlvbi5zZXQoMCwgYW5nbGUsIDApO1xuICAgICAgICB0aGlzLndvcmxkLnBsYWNlUGxheWVyKHRoaXMub2JqZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueWF3LnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICAgICAgdGhpcy55YXcucm90YXRpb24uc2V0KDAsIDAsIDApO1xuICAgICAgICB0aGlzLnBpdGNoLnJvdGF0aW9uLnNldCgwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHB1YmxpYyBzZXRXb3JsZE9iamVjdHNDYWxsYmFjayhmdW5jKSB7XG4gICAgICB0aGlzLmdldFdvcmxkT2JqZWN0cyA9IGZ1bmM7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBlbmFibGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBvYmplY3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy55YXc7XG4gICAgfVxuXG4gICAgcHVibGljIGxvb2tBdChib3gpIHtcbiAgICAgIHRoaXMuX2xvb2tBdCA9IGJveDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMueWF3KTtcbiAgICAgIHRoaXMueWF3LmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMucGl0Y2guZGlzcG9zZSgpO1xuICAgICAgXy5mb3JJbih0aGlzLmhhbmRsZXJzLCAoaGFuZGxlciwgZXZ0KSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcikpO1xuICAgIH1cblxuICAgIHByaXZhdGUgd2Fsa2luZ01vZGlmaWVyID0gNTAwO1xuICAgIHByaXZhdGUgcnVubmluZ01vZGlmaWVyID0gMjAwO1xuXG4gICAgcHVibGljIHJlbmRlcigpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICFoYXZlUG9pbnRlckxvY2spIHtcbiAgICAgICAgaWYgKHRoaXMuX2xvb2tBdCkge1xuICAgICAgICAgIHZhciBhbmdsZSA9IERhdGUubm93KCkgKiAwLjAwMDE7XG4gICAgICAgICAgdGhpcy5jYW1lcmEuZm9jdXModGhpcy5fbG9va0F0LCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHJheWNhc3RlciA9IHRoaXMucmF5Y2FzdGVyO1xuICAgICAgdmFyIHZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eTtcbiAgICAgIHZhciBtZSA9IHRoaXMub2JqZWN0O1xuICAgICAgcmF5Y2FzdGVyLnJheS5vcmlnaW4uY29weSggdGhpcy55YXcucG9zaXRpb24gKTtcbiAgICAgIHJheWNhc3Rlci5yYXkub3JpZ2luLnkgLT0gMTA7XG4gICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuZ2V0V29ybGRPYmplY3RzKCk7XG4gICAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IHJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzKG9iamVjdHMpO1xuICAgICAgdmFyIGlzT25PYmplY3QgPSBpbnRlcnNlY3Rpb25zLmxlbmd0aCA+IDA7XG4gICAgICB2YXIgdGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgdmFyIGludGVydmFsID0gdGltZSAtIHRoaXMucHJldlRpbWU7XG4gICAgICB2YXIgbW9kaWZpZXIgPSB0aGlzLnJ1bm5pbmcgPyB0aGlzLnJ1bm5pbmdNb2RpZmllciA6IHRoaXMud2Fsa2luZ01vZGlmaWVyO1xuICAgICAgdmFyIGRlbHRhID0gaW50ZXJ2YWwgLyBtb2RpZmllcjtcbiAgICAgIHZhciBkZWx0YVkgPSBpbnRlcnZhbCAvIHRoaXMud2Fsa2luZ01vZGlmaWVyO1xuXG4gICAgICB2ZWxvY2l0eS54IC09IHZlbG9jaXR5LnggKiAxMC4wICogZGVsdGE7XG4gICAgICB2ZWxvY2l0eS56IC09IHZlbG9jaXR5LnogKiAxMC4wICogZGVsdGE7XG4gICAgICB2ZWxvY2l0eS55IC09IDkuOCAqIDEwMC4wICogZGVsdGFZOyAvLyAxMDAuMCA9IG1hc3NcblxuICAgICAgaWYgKHRoaXMuZm9yd2FyZCkgdmVsb2NpdHkueiAtPSA0MDAuMCAqIGRlbHRhO1xuICAgICAgaWYgKHRoaXMuYmFja3dhcmQpIHZlbG9jaXR5LnogKz0gNDAwLjAgKiBkZWx0YTtcbiAgICAgIGlmICh0aGlzLmxlZnQpIHZlbG9jaXR5LnggLT0gNDAwLjAgKiBkZWx0YTtcbiAgICAgIGlmICh0aGlzLnJpZ2h0KSB2ZWxvY2l0eS54ICs9IDQwMC4wICogZGVsdGE7XG5cbiAgICAgIGlmICggaXNPbk9iamVjdCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgdmVsb2NpdHkueSA9IE1hdGgubWF4KCAwLCB2ZWxvY2l0eS55ICk7XG4gICAgICAgIHRoaXMuY2FuSnVtcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIG1lLnRyYW5zbGF0ZVgodmVsb2NpdHkueCAqIGRlbHRhKTtcbiAgICAgIG1lLnRyYW5zbGF0ZVkodmVsb2NpdHkueSAqIGRlbHRhWSk7XG4gICAgICBtZS50cmFuc2xhdGVaKHZlbG9jaXR5LnogKiBkZWx0YSk7XG5cbiAgICAgIGlmICggbWUucG9zaXRpb24ueSA8IDEwICkge1xuXG4gICAgICAgIHZlbG9jaXR5LnkgPSAwO1xuICAgICAgICBtZS5wb3NpdGlvbi55ID0gMTA7XG4gICAgICAgIHRoaXMuY2FuSnVtcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJldlRpbWUgPSB0aW1lO1xuICAgIH1cbiAgfVxufVxuIiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cImt1YmUzZFBsdWdpbi50c1wiLz5cblxubW9kdWxlIEt1YmUzZCB7XG5cbiAgdmFyIGRpcmVjdGl2ZU5hbWUgPSAndGhyZWVqcyc7XG5cbiAgX21vZHVsZS5kaXJlY3RpdmUoZGlyZWN0aXZlTmFtZSwgWygpID0+IHtcbiAgICBUSFJFRS5JbWFnZVV0aWxzLmNyb3NzT3JpZ2luID0gJyc7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgc2NvcGU6IHtcbiAgICAgICAgY29uZmlnOiAnPT8nICsgZGlyZWN0aXZlTmFtZVxuICAgICAgfSxcbiAgICAgIGxpbms6IChzY29wZSwgZWxlbWVudCwgYXR0cnMpID0+IHtcblxuICAgICAgICB2YXIgc2NlbmU6YW55ID0gbnVsbDtcbiAgICAgICAgdmFyIGNhbWVyYTphbnkgPSBudWxsO1xuICAgICAgICB2YXIgcmVuZGVyZXI6YW55ID0gbnVsbDtcbiAgICAgICAgdmFyIGtlZXBSZW5kZXJpbmcgPSB0cnVlO1xuICAgICAgICB2YXIgcmVzaXplSGFuZGxlOmFueSA9IG51bGw7XG5cbiAgICAgICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICBrZWVwUmVuZGVyaW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgICAgICQod2luZG93KS5vZmYoJ3Jlc2l6ZScsIHJlc2l6ZUZ1bmMpO1xuICAgICAgICAgIGRlbGV0ZSByZW5kZXJlcjtcbiAgICAgICAgICBkZWxldGUgY2FtZXJhO1xuICAgICAgICAgIGRlbGV0ZSBzY2VuZTtcbiAgICAgICAgICBlbGVtZW50LmVtcHR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzaXplRnVuYyA9ICgpID0+IHtcbiAgICAgICAgICAgIGxvZy5kZWJ1ZyhcInJlc2l6aW5nXCIpO1xuICAgICAgICAgICAgZWxlbWVudC5maW5kKCdjYW52YXMnKS53aWR0aChlbGVtZW50LndpZHRoKCkpLmhlaWdodChlbGVtZW50LmhlaWdodCgpKTtcbiAgICAgICAgICAgIGNhbWVyYS5hc3BlY3QgPSBlbGVtZW50LndpZHRoKCkgLyBlbGVtZW50LmhlaWdodCgpO1xuICAgICAgICAgICAgY2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFNpemUoZWxlbWVudC53aWR0aCgpLCBlbGVtZW50LmhlaWdodCgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQub24oJyRkZXN0cm95JywgKCkgPT4ge1xuICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICBsb2cuZGVidWcoXCJzY2VuZSBkZXN0cm95ZWRcIik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNjb3BlLiR3YXRjaCgnY29uZmlnJywgXy5kZWJvdW5jZSgoY29uZmlnKSA9PiB7XG4gICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgIGlmICghY29uZmlnIHx8ICFjb25maWcuaW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwibm8gY29uZmlnLCByZXR1cm5pbmdcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZy5kZWJ1ZyhcImNyZWF0aW5nIHNjZW5lXCIpO1xuICAgICAgICAgIC8vc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICAgICAgICBzY2VuZSA9IG5ldyBUSFJFRS5TY2VuZSgpO1xuICAgICAgICAgIGNhbWVyYSA9IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg2MCwgZWxlbWVudC53aWR0aCgpIC8gZWxlbWVudC5oZWlnaHQoKSwgMC4xLCAyMDAwMCk7XG5cbiAgICAgICAgICBjYW1lcmEuZm9jdXMgPSAoYm94MzphbnksIGFuZ2xlLCBjOmFueSA9IGNhbWVyYSkgPT4ge1xuICAgICAgICAgICAgLy8gYWRqdXN0IHRoZSBjIHBvc2l0aW9uIHRvIGtlZXAgZXZlcnl0aGluZyBpbiB2aWV3LCB3ZSdsbCBkb1xuICAgICAgICAgICAgLy8gZ3JhZHVhbCBhZGp1c3RtZW50cyB0aG91Z2hcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBib3gzLnNpemUoKS55O1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gYm94My5zaXplKCkueCAvIChjYW1lcmEuYXNwZWN0IC8gMik7XG4gICAgICAgICAgICAvL2xvZy5kZWJ1ZyhcIndpZHRoOlwiLCB3aWR0aCwgXCIgaGVpZ2h0OlwiLCBoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKHdpZHRoIDwgMCB8fCBoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaXN0WSA9IE1hdGgucm91bmQoaGVpZ2h0ICogTWF0aC50YW4oIChjYW1lcmEuZm92IC8gMiApICogKCBNYXRoLlBJIC8gMTgwICkpKTtcbiAgICAgICAgICAgIHZhciBkaXN0WCA9IE1hdGgucm91bmQod2lkdGggKiBNYXRoLnRhbiggKGNhbWVyYS5mb3YgLyAyICkgKiAoIE1hdGguUEkgLyAxODAgKSkpO1xuICAgICAgICAgICAgdmFyIGRpc3RaID0gKGRpc3RZICsgZGlzdFgpO1xuICAgICAgICAgICAgLy8gbG9nLmRlYnVnKFwiZGlzdFk6XCIsIGRpc3RZLCBcIiBkaXN0WDpcIiwgZGlzdFgsIFwiZGlzdFo6XCIsIGRpc3RaKTtcbiAgICAgICAgICAgIHZhciB6ID0gTWF0aC5yb3VuZChjLnBvc2l0aW9uLnopO1xuICAgICAgICAgICAgdmFyIHBlcmlvZCA9IDUuMDtcbiAgICAgICAgICAgIGMucG9zaXRpb24ueCA9IGRpc3RYICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgYy5wb3NpdGlvbi55ID0gZGlzdFkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICBpZiAoeiAhPT0gZGlzdFopIHtcbiAgICAgICAgICAgICAgaWYgKHogPiBkaXN0Wikge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gKHogLSBkaXN0WikgLyBwZXJpb2Q7XG4gICAgICAgICAgICAgICAgYy5wb3NpdGlvbi56ID0geiAtIHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHogPCBkaXN0Wikge1xuICAgICAgICAgICAgICAgIHZhciB2ID0gKGRpc3RaIC0geikgLyBwZXJpb2Q7XG4gICAgICAgICAgICAgICAgYy5wb3NpdGlvbi56ID0geiArIHY7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGMubG9va0F0KGJveDMuY2VudGVyKCkpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAoIHdlYmdsQXZhaWxhYmxlKCkgKSB7XG4gICAgICAgICAgICByZW5kZXJlciA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmVyID0gbmV3IFRIUkVFLkNhbnZhc1JlbmRlcmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vcmVuZGVyZXIuc2V0Q2xlYXJDb2xvcigweGZmZmZmZik7XG4gICAgICAgICAgcmVuZGVyZXIuc2V0UGl4ZWxSYXRpbyh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XG4gICAgICAgICAgcmVuZGVyZXIuc2V0U2l6ZShlbGVtZW50LndpZHRoKCksIGVsZW1lbnQuaGVpZ2h0KCkpO1xuICAgICAgICAgIHZhciBkb21FbGVtZW50ID0gcmVuZGVyZXIuZG9tRWxlbWVudDtcbiAgICAgICAgICBjb25maWcuaW5pdGlhbGl6ZShyZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZG9tRWxlbWVudCk7XG5cbiAgICAgICAgICBlbGVtZW50LmFwcGVuZChkb21FbGVtZW50KTtcbiAgICAgICAgICAkKHdpbmRvdykub24oJ3Jlc2l6ZScsIHJlc2l6ZUZ1bmMpO1xuXG4gICAgICAgICAgdmFyIHJlbmRlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICgha2VlcFJlbmRlcmluZykge1xuICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcucmVuZGVyKSB7XG4gICAgICAgICAgICAgIGNvbmZpZy5yZW5kZXIocmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLCBjYW1lcmEpO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlbmRlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtlZXBSZW5kZXJpbmcgPSB0cnVlO1xuICAgICAgICAgIHJlbmRlcigpO1xuICAgICAgICB9LCA1MDAsIHsgdHJhaWxpbmc6IHRydWUgfSkpO1xuICAgICAgfVxuICAgIH07XG4gIH1dKTtcblxufVxuIiwiLy8vIDxyZWZlcmVuY2UgcGF0aD1cImt1YmUzZFBsdWdpbi50c1wiLz5cbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCJwbGF5ZXIudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwid29ybGQudHNcIi8+XG4vLy8gPHJlZmVyZW5jZSBwYXRoPVwib2JqZWN0cy50c1wiLz5cblxubW9kdWxlIEt1YmUzZCB7XG5cbiAgZXhwb3J0IHZhciBWaWV3Q29udHJvbGxlciA9IGNvbnRyb2xsZXIoJ1ZpZXdDb250cm9sbGVyJywgWyckc2NvcGUnLCAnS3ViZXJuZXRlc01vZGVsJywgJ0t1YmVybmV0ZXNTdGF0ZScsICckZWxlbWVudCcsICgkc2NvcGUsIG1vZGVsOkt1YmVybmV0ZXMuS3ViZXJuZXRlc01vZGVsU2VydmljZSwgc3RhdGUsICRlbGVtZW50KSA9PiB7XG5cbiAgICB2YXIgZGVidWdTY2VuZSA9IGZhbHNlO1xuXG4gICAgdmFyIHJlbmRlcmVyOmFueSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgc2NlbmU6YW55ID0gdW5kZWZpbmVkO1xuICAgIHZhciBjYW1lcmE6YW55ID0gdW5kZWZpbmVkO1xuICAgIHZhciBkb21FbGVtZW50OmFueSA9IHVuZGVmaW5lZDtcblxuICAgIHZhciBzY2VuZUdlb21ldHJ5ID0gbmV3IFRIUkVFLk9iamVjdDNEKCk7XG4gICAgdmFyIHNjZW5lQm91bmRzID0gbmV3IFRIUkVFLkJvdW5kaW5nQm94SGVscGVyKHNjZW5lR2VvbWV0cnksIDB4ZmYwMDAwKTtcblxuICAgIHZhciBob3N0T2JqZWN0cyA9IHt9O1xuXG4gICAgdmFyIHVwZGF0aW5nID0gZmFsc2U7XG4gICAgdmFyIGhhc01vdXNlID0gZmFsc2U7XG5cbiAgICB2YXIgcGxheWVyOlBsYXllciA9IG51bGw7XG4gICAgdmFyIHdvcmxkOldvcmxkID0gbnVsbDtcblxuICAgICRzY29wZS5vbkxvY2sgPSAobG9jaykgPT4ge1xuICAgICAgaWYgKCFwbGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGxheWVyLmVuYWJsZWQgPSBsb2NrO1xuICAgIH1cblxuICAgICRzY29wZS5jb25maWcgPSB7XG4gICAgICBpbml0aWFsaXplOiAociwgcywgYywgZCkgPT4ge1xuICAgICAgICBsb2cuZGVidWcoXCJpbml0IGNhbGxlZFwiKTtcbiAgICAgICAgcmVuZGVyZXIgPSByO1xuICAgICAgICBzY2VuZSA9IHM7XG4gICAgICAgIGNhbWVyYSA9IGM7XG4gICAgICAgIGRvbUVsZW1lbnQgPSBkO1xuXG4gICAgICAgIHdvcmxkID0gbmV3IFdvcmxkKHNjZW5lKTtcbiAgICAgICAgcGxheWVyID0gbmV3IFBsYXllcihzY2VuZSwgY2FtZXJhLCBkLCB3b3JsZCk7XG5cbiAgICAgICAgc2NlbmUuYWRkKHNjZW5lR2VvbWV0cnkpO1xuXG4gICAgICAgIGlmIChkZWJ1Z1NjZW5lKSB7XG4gICAgICAgICAgLy8gZGVidWcgc3R1ZmZcbiAgICAgICAgICAvLyBwdXRzIGEgYm91bmRpbmcgYm94IGFyb3VuZCB0aGUgc2NlbmUgd2Ugd2FudCB0byB2aWV3XG4gICAgICAgICAgc2NlbmUuYWRkKHNjZW5lQm91bmRzKTtcblxuICAgICAgICB9XG4gICAgICAgIC8vIGFkZHMgbGluZXMgZm9yIHRoZSB4L3kveiBheGlzXG4gICAgICAgIC8vIFRoZSBYIGF4aXMgaXMgcmVkLiBUaGUgWSBheGlzIGlzIGdyZWVuLiBUaGUgWiBheGlzIGlzIGJsdWVcbiAgICAgICAgdmFyIGF4aXMgPSBuZXcgVEhSRUUuQXhpc0hlbHBlcigxMDAwKTtcbiAgICAgICAgc2NlbmUuYWRkKGF4aXMpO1xuXG4gICAgICAgIHNjZW5lR2VvbWV0cnkucm90YXRpb24ueCA9IDkwO1xuICAgICAgICBzY2VuZUdlb21ldHJ5LnJvdGF0aW9uLnogPSA5MDtcbiAgICAgICAgc2NlbmVHZW9tZXRyeS5wb3NpdGlvbi54ID0gMDtcbiAgICAgICAgc2NlbmVHZW9tZXRyeS5wb3NpdGlvbi55ID0gMDtcbiAgICAgICAgc2NlbmVHZW9tZXRyeS5wb3NpdGlvbi56ID0gMDtcbiAgICAgICAgYnVpbGRTY2VuZSgpO1xuICAgICAgfSxcbiAgICAgIHJlbmRlcjogKHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhKSA9PiB7XG4gICAgICAgIC8vIE5PVEUgLSB0aGlzIGZ1bmN0aW9uIHJ1bnMgYXQgfiA2MGZwcyFcbiAgICAgICAgaWYgKHVwZGF0aW5nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdvcmxkLnJlbmRlcigpO1xuICAgICAgICB2YXIgYW5nbGUgPSBEYXRlLm5vdygpICogMC4wMDAxO1xuICAgICAgICBzY2VuZUdlb21ldHJ5LnBvc2l0aW9uLnggPSAxMDAwICogTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBzY2VuZUdlb21ldHJ5LnBvc2l0aW9uLnogPSAxMDAwICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAvLyBzY2VuZUdlb21ldHJ5LnJvdGF0aW9uLnggKz0gMC4wMDE7XG4gICAgICAgIC8vIHNjZW5lR2VvbWV0cnkucm90YXRpb24ueSArPSAwLjAwMTtcbiAgICAgICAgLy8gc2NlbmVHZW9tZXRyeS5yb3RhdGlvbi56ICs9IDAuMDAxO1xuICAgICAgICBfLmZvckluKGhvc3RPYmplY3RzLCAoaG9zdE9iamVjdCwga2V5KSA9PiB7XG4gICAgICAgICAgaG9zdE9iamVjdC5yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNjZW5lQm91bmRzLnVwZGF0ZSgpO1xuICAgICAgICBwbGF5ZXIubG9va0F0KHNjZW5lQm91bmRzLmJveCk7XG4gICAgICAgIHBsYXllci5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZFNjZW5lKCkge1xuICAgICAgaWYgKCFzY2VuZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB1cGRhdGluZyA9IHRydWU7XG4gICAgICB2YXIgb3JpZ2luWCA9IDA7XG4gICAgICB2YXIgb3JpZ2luWSA9IDA7XG5cbiAgICAgIHZhciBob3N0c1RvUmVtb3ZlID0gW107XG5cbiAgICAgIF8uZm9ySW4oaG9zdE9iamVjdHMsIChob3N0T2JqZWN0LCBrZXkpID0+IHtcbiAgICAgICAgaWYgKF8uYW55KG1vZGVsLmhvc3RzLCAoaG9zdCkgPT4gaG9zdC5lbGVtZW50SWQgPT09IGtleSkpIHtcbiAgICAgICAgICBsb2cuZGVidWcoXCJLZWVwaW5nIGhvc3Q6IFwiLCBrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGhvc3RzVG9SZW1vdmUucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgXy5mb3JFYWNoKGhvc3RzVG9SZW1vdmUsIChrZXkpID0+IHtcbiAgICAgICAgdmFyIGhvc3RPYmplY3QgPSBob3N0T2JqZWN0c1trZXldO1xuICAgICAgICBpZiAoaG9zdE9iamVjdCkge1xuICAgICAgICAgIGhvc3RPYmplY3QuZGVzdHJveSgpO1xuICAgICAgICAgIGRlbGV0ZSBob3N0T2JqZWN0c1trZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgXy5mb3JFYWNoKG1vZGVsLmhvc3RzLCAoaG9zdCkgPT4ge1xuICAgICAgICB2YXIgaWQgPSBob3N0LmVsZW1lbnRJZDtcbiAgICAgICAgbG9nLmRlYnVnKFwiaG9zdDogXCIsIGhvc3QpO1xuICAgICAgICB2YXIgaG9zdE9iamVjdCA9IGhvc3RPYmplY3RzW2lkXSB8fCBuZXcgSG9zdE9iamVjdChzY2VuZUdlb21ldHJ5LCBpZCwgaG9zdCk7XG4gICAgICAgIGlmICghKGlkIGluIGhvc3RPYmplY3RzKSkge1xuICAgICAgICAgIGhvc3RPYmplY3Quc2V0UG9zaXRpb24ob3JpZ2luWCwgb3JpZ2luWSwgMCk7XG4gICAgICAgICAgb3JpZ2luWCA9IG9yaWdpblggKyA1MDA7XG4gICAgICAgICAgb3JpZ2luWSA9IG9yaWdpblkgKyA1MDA7XG4gICAgICAgICAgaG9zdE9iamVjdHNbaWRdID0gaG9zdE9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBob3N0T2JqZWN0LnVwZGF0ZShtb2RlbCwgaG9zdCk7XG4gICAgICAgIGhvc3RPYmplY3QuZGVidWcoZGVidWdTY2VuZSk7XG4gICAgICB9KTtcblxuICAgICAgbG9nLmRlYnVnKFwibW9kZWwgdXBkYXRlZFwiKTtcbiAgICAgIHVwZGF0aW5nID0gZmFsc2U7XG4gICAgfVxuICAgICRzY29wZS4kb24oJ2t1YmVybmV0ZXNNb2RlbFVwZGF0ZWQnLCBidWlsZFNjZW5lKTtcbiAgfV0pO1xuXG59XG4iLCIvLy8gPHJlZmVyZW5jZSBwYXRoPVwia3ViZTNkUGx1Z2luLnRzXCIvPlxuXG5tb2R1bGUgS3ViZTNkIHtcblxuICB2YXIgY2h1bmtTaXplID0gMzI7XG4gIHZhciBnZW5lcmF0ZUNodW5rID0gdGVycmFpbignaGF3dGlvJywgMCwgMjAsIDUwKTtcblxuICBleHBvcnQgdmFyIFZveGVsQ29udHJvbGxlciA9IGNvbnRyb2xsZXIoJ1ZveGVsQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJ0t1YmVybmV0ZXNNb2RlbCcsICgkc2NvcGUsICRlbGVtZW50LCBtb2RlbDpLdWJlcm5ldGVzLkt1YmVybmV0ZXNNb2RlbFNlcnZpY2UpID0+IHtcblxuICAgIHZhciBjcmVhdHVyZXMgPSB7fTtcbiAgICB2YXIgYnVsbGV0cyA9IFtdO1xuXG4gICAgdmFyIGVsID0gJGVsZW1lbnQuZmluZCgnLmt1YmUzZC1jb250cm9sJylbMF07XG4gICAgdmFyIGdhbWUgPSBjcmVhdGVHYW1lKHtcbiAgICAgICAgbGlnaHRzRGlzYWJsZWQ6IHRydWUsXG4gICAgICAgIGZvZ0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgZ2VuZXJhdGVDaHVua3M6IGZhbHNlLFxuICAgICAgICB0ZXh0dXJlUGF0aDogJy4vaW1nL3RleHR1cmVzLycsXG4gICAgICAgIG1hdGVyaWFsczogW1snZ3Jhc3MnLCAnZGlydCcsICdncmFzc19kaXJ0J10sICdicmljaycsICdkaXJ0J10sXG4gICAgICAgIG1hdGVyaWFsRmxhdENvbG9yOiBmYWxzZSxcbiAgICAgICAgY29udGFpbmVyOiBlbFxuICAgICAgfSwgKGdhbWUsIGF2YXRhcikgPT4ge1xuXG4gICAgICAgIHZhciBidWxsZXQgPSBuZXcgZ2FtZS5USFJFRS5NZXNoKG5ldyBnYW1lLlRIUkVFLlNwaGVyZUdlb21ldHJ5KDAuMjUsIDMyLCAzMiksIG5ldyBnYW1lLlRIUkVFLk1lc2hQaG9uZ01hdGVyaWFsKHtcbiAgICAgICAgICBjb2xvcjogMHg4ODg4ODgsXG4gICAgICAgIH0pKTtcblxuICAgICAgICBmdW5jdGlvbiBuZXdDcmVhdHVyZSh0ZXh0dXJlKSB7XG4gICAgICAgICAgdmFyIFRIUkVFID0gZ2FtZS5USFJFRTtcbiAgICAgICAgICB2YXIgYm94VGV4dHVyZSA9IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUodGV4dHVyZSk7XG4gICAgICAgICAgYm94VGV4dHVyZS5taW5GaWx0ZXIgPSBUSFJFRS5OZWFyZXN0RmlsdGVyO1xuICAgICAgICAgIHZhciBib3hNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbCh7XG4gICAgICAgICAgICBtYXA6IGJveFRleHR1cmUsXG4gICAgICAgICAgICBhbHBoYU1hcDogYm94VGV4dHVyZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBib3ggPSBuZXcgVEhSRUUuTWVzaChuZXcgVEhSRUUuQ3ViZUdlb21ldHJ5KGdhbWUuY3ViZVNpemUsIGdhbWUuY3ViZVNpemUsIGdhbWUuY3ViZVNpemUpLCBib3hNYXRlcmlhbCk7XG4gICAgICAgICAgcmV0dXJuIGJveDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYWtlRmx5ID0gZmx5KGdhbWUpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZ2FtZS5jb250cm9scy50YXJnZXQoKTtcbiAgICAgICAgZ2FtZS5mbHllciA9IG1ha2VGbHkodGFyZ2V0KTtcblxuICAgICAgICB2YXIgc2t5ID0gY3JlYXRlU2t5KHtcbiAgICAgICAgICBnYW1lOiBnYW1lLFxuICAgICAgICAgIHRpbWU6IDgwMCxcbiAgICAgICAgICBzcGVlZDogMC4xLFxuICAgICAgICAgIGNvbG9yOiBuZXcgZ2FtZS5USFJFRS5Db2xvcihnYW1lLnNreUNvbG9yKVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBoaWdobGlnaHQgYmxvY2tzIHdoZW4geW91IGxvb2sgYXQgdGhlbSwgaG9sZCA8Q3RybD4gZm9yIGJsb2NrIHBsYWNlbWVudFxuICAgICAgICAvKlxuICAgICAgICB2YXIgYmxvY2tQb3NQbGFjZSwgYmxvY2tQb3NFcmFzZTtcbiAgICAgICAgdmFyIGhsID0gZ2FtZS5oaWdobGlnaHRlciA9IGhpZ2hsaWdodChnYW1lLCB7IGNvbG9yOiAweGZmMDAwMCB9KTtcbiAgICAgICAgaGwub24oJ2hpZ2hsaWdodCcsIGZ1bmN0aW9uICh2b3hlbFBvcykgeyBibG9ja1Bvc0VyYXNlID0gdm94ZWxQb3MgfSk7XG4gICAgICAgIGhsLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAodm94ZWxQb3MpIHsgYmxvY2tQb3NFcmFzZSA9IG51bGwgfSk7XG4gICAgICAgIGhsLm9uKCdoaWdobGlnaHQtYWRqYWNlbnQnLCBmdW5jdGlvbiAodm94ZWxQb3MpIHsgYmxvY2tQb3NQbGFjZSA9IHZveGVsUG9zIH0pO1xuICAgICAgICBobC5vbigncmVtb3ZlLWFkamFjZW50JywgZnVuY3Rpb24gKHZveGVsUG9zKSB7IGJsb2NrUG9zUGxhY2UgPSBudWxsIH0pO1xuICAgICAgICAqL1xuXG4gICAgICAgIC8vIHRvZ2dsZSBiZXR3ZWVuIGZpcnN0IGFuZCB0aGlyZCBwZXJzb24gbW9kZXNcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICBpZiAoZXYua2V5Q29kZSA9PT0gJ1InLmNoYXJDb2RlQXQoMCkpIGF2YXRhci50b2dnbGUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYmxvY2sgaW50ZXJhY3Rpb24gc3R1ZmYsIHVzZXMgaGlnaGxpZ2h0IGRhdGFcbiAgICAgICAgdmFyIGN1cnJlbnRNYXRlcmlhbCA9IDE7XG5cbiAgICAgICAgZ2FtZS5vbignZmlyZScsIGZ1bmN0aW9uICh0YXJnZXQsIHN0YXRlKSB7XG4gICAgICAgICAgbG9nLmRlYnVnKFwiZmlyZSwgdGFyZ2V0OiBcIiwgdGFyZ2V0LCBcIiBzdGF0ZTogXCIsIHN0YXRlKTtcbiAgICAgICAgICBpZiAoYnVsbGV0cy5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYiA9IGJ1bGxldC5jbG9uZSgpO1xuICAgICAgICAgIGIucG9zaXRpb24uc2V0KHRhcmdldC5wb3NpdGlvbi54LCB0YXJnZXQucG9zaXRpb24ueSArIDEsIHRhcmdldC5wb3NpdGlvbi56KTtcbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gZ2FtZS5jYW1lcmFWZWN0b3IoKTtcbiAgICAgICAgICB2YXIgdmVsb2NpdHkgPSBuZXcgZ2FtZS5USFJFRS5WZWN0b3IzKGRpcmVjdGlvblswXSwgZGlyZWN0aW9uWzFdLCBkaXJlY3Rpb25bMl0pO1xuICAgICAgICAgIHZlbG9jaXR5Lm11bHRpcGx5U2NhbGFyKDAuMDUpO1xuICAgICAgICAgIHZhciBpdGVtOmFueSA9IHtcbiAgICAgICAgICAgIG1lc2g6IGIsXG4gICAgICAgICAgICBzaXplOiAwLjgsXG4gICAgICAgICAgICB2ZWxvY2l0eTogdmVsb2NpdHlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGl0ZW0gPSBnYW1lLmFkZEl0ZW0oaXRlbSk7XG4gICAgICAgICAgbG9nLmRlYnVnKFwiaXRlbTogXCIsIGl0ZW0pO1xuICAgICAgICAgIGJ1bGxldHMucHVzaChpdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ2FtZS5vbigndGljaycsIGZ1bmN0aW9uKGRlbHRhKSB7XG5cbiAgICAgICAgICAvLyBwbGF5ZXJcbiAgICAgICAgICB3YWxrLnJlbmRlcih0YXJnZXQucGxheWVyU2tpbik7XG4gICAgICAgICAgdmFyIHZ4ID0gTWF0aC5hYnModGFyZ2V0LnZlbG9jaXR5LngpO1xuICAgICAgICAgIHZhciB2eiA9IE1hdGguYWJzKHRhcmdldC52ZWxvY2l0eS56KTtcbiAgICAgICAgICBpZiAodnggPiAwLjAwMSB8fCB2eiA+IDAuMDAxKSB7XG4gICAgICAgICAgICB3YWxrLnN0b3BXYWxraW5nKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhbGsuc3RhcnRXYWxraW5nKClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBwcm9qZWN0aWxlc1xuICAgICAgICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgICAgICAgIF8uZm9yRWFjaChidWxsZXRzLCAoYnVsbGV0KSA9PiB7XG4gICAgICAgICAgICBpZiAoYnVsbGV0Lmxhc3RQb3NpdGlvbikge1xuICAgICAgICAgICAgICB2YXIgcG9zID0gYnVsbGV0Lm1lc2gucG9zaXRpb247XG4gICAgICAgICAgICAgIHZhciBsYXN0ID0gYnVsbGV0Lmxhc3RQb3NpdGlvbjtcbiAgICAgICAgICAgICAgaWYgKHBvcy54ID09PSBsYXN0LnggJiYgcG9zLnkgPT09IGxhc3QueSAmJiBwb3MueiA9PT0gbGFzdC56KSB7XG4gICAgICAgICAgICAgICAgZ2FtZS5yZW1vdmVJdGVtKGJ1bGxldCk7XG4gICAgICAgICAgICAgICAgdG9SZW1vdmUucHVzaChidWxsZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWxsZXQubGFzdFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICB4OiBidWxsZXQubWVzaC5wb3NpdGlvbi54LFxuICAgICAgICAgICAgICB5OiBidWxsZXQubWVzaC5wb3NpdGlvbi55LFxuICAgICAgICAgICAgICB6OiBidWxsZXQubWVzaC5wb3NpdGlvbi56XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYnVsbGV0QUFCQiA9IGJ1bGxldC5hYWJiKCk7XG4gICAgICAgICAgICB2YXIgaGl0ID0gZmFsc2U7XG4gICAgICAgICAgICBfLmZvckluKGNyZWF0dXJlcywgKGNyZWF0dXJlLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgaWYgKCFjcmVhdHVyZS5lbnRpdHkgfHwgaGl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChidWxsZXRBQUJCLmludGVyc2VjdHMoY3JlYXR1cmUuZW50aXR5LmFhYmIoKSkpIHtcbiAgICAgICAgICAgICAgICBoaXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGdhbWUucmVtb3ZlSXRlbShidWxsZXQpO1xuICAgICAgICAgICAgICAgIHRvUmVtb3ZlLnB1c2goYnVsbGV0KTtcbiAgICAgICAgICAgICAgICBjcmVhdHVyZS5oaXQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfLmZvckVhY2godG9SZW1vdmUsIChidWxsZXQpID0+IHtcbiAgICAgICAgICAgIF8ucmVtb3ZlKGJ1bGxldHMsIGJ1bGxldCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBza3koKShkZWx0YSk7XG5cbiAgICAgICAgICBpZiAoZ2FtZS5wZW5kaW5nQ2h1bmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiUGVuZGluZyBjaHVua3MsIHNraXBwaW5nIGVudGl0eSBjcmVhdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBjcmVhdHVyZXNcbiAgICAgICAgICB2YXIgY3JlYXR1cmVzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgICBfLmZvckluKGNyZWF0dXJlcywgKGNyZWF0dXJlLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChjcmVhdHVyZS5oaXQgJiYgIWNyZWF0dXJlLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgbW9kZWxbJ3BvZHNSZXNvdXJjZSddLmRlbGV0ZSh7IGlkOiBLdWJlcm5ldGVzLmdldE5hbWUoY3JlYXR1cmUucG9kKSB9KTtcbiAgICAgICAgICAgICAgY3JlYXR1cmUuZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGlmIChjcmVhdHVyZS5jbGVhckludGVydmFsKSB7XG4gICAgICAgICAgICAgICAgY3JlYXR1cmUuY2xlYXJJbnRlcnZhbCgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjcmVhdHVyZS5jbGVhckludGVydmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNyZWF0dXJlLmVudGl0eS52ZWxvY2l0eS55ID0gMjtcbiAgICAgICAgICAgICAgY3JlYXR1cmUuZW50aXR5LnJlc3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgbG9nLmRlYnVnKFwiQ3JlYXR1cmUgaGl0OiBcIiwgY3JlYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNyZWF0dXJlLmhpdCAmJiBjcmVhdHVyZS5lbnRpdHkpIHtcbiAgICAgICAgICAgICAgY3JlYXR1cmUuZW50aXR5Lm1lc2guc2NhbGUueCA9IGNyZWF0dXJlLmVudGl0eS5tZXNoLnNjYWxlLnggKyAwLjA1O1xuICAgICAgICAgICAgICBjcmVhdHVyZS5lbnRpdHkubWVzaC5zY2FsZS56ID0gY3JlYXR1cmUuZW50aXR5Lm1lc2guc2NhbGUueiArIDAuMDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gbW9kZWwucG9kc0J5S2V5KSkge1xuICAgICAgICAgICAgICBsb2cuZGVidWcoXCJuZWVkIHRvIGRlbGV0ZSBjcmVhdHVyZSBcIiwga2V5KTtcbiAgICAgICAgICAgICAgY3JlYXR1cmVzVG9SZW1vdmUucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoJ2VudGl0eScgaW4gY3JlYXR1cmUpKSB7XG4gICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcIm5lZWQgdG8gY3JlYXRlIGNyZWF0dXJlIFwiLCBrZXkpO1xuICAgICAgICAgICAgICB2YXIgbWVzaCA9IG5ld0NyZWF0dXJlKGNyZWF0dXJlLnBvZC4kaWNvblVybCk7XG4gICAgICAgICAgICAgIG1lc2gubmFtZSA9IGtleTtcbiAgICAgICAgICAgICAgbWVzaC5wb3NpdGlvbi5zZXQoTWF0aC5yYW5kb20oKSAqIDIwIC0gMTAsIDMwLCBNYXRoLnJhbmRvbSgpICogMjAgLSAxMCk7XG4gICAgICAgICAgICAgIHZhciBpdGVtOmFueSA9IHtcbiAgICAgICAgICAgICAgICBtZXNoOiBtZXNoLFxuICAgICAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICAgICAgdmVsb2NpdHk6IHsgeDogMCwgeTogMCwgejogMCB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGNyZWF0dXJlLmVudGl0eSA9IGdhbWUuYWRkSXRlbShpdGVtKTtcbiAgICAgICAgICAgICAgY3JlYXR1cmUuY2xlYXJJbnRlcnZhbCA9IGdhbWUuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjcmVhdHVyZS5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNyZWF0dXJlLmVudGl0eS52ZWxvY2l0eS54ID0gKE1hdGgucmFuZG9tKCkgKiAxMCAtIDUpICogMC4wMDU7XG4gICAgICAgICAgICAgICAgY3JlYXR1cmUuZW50aXR5LnZlbG9jaXR5LnogPSAoTWF0aC5yYW5kb20oKSAqIDEwIC0gNSkgKiAwLjAwNTtcbiAgICAgICAgICAgICAgICBjcmVhdHVyZS5lbnRpdHkudmVsb2NpdHkueSA9IChNYXRoLnJhbmRvbSgpICogMTAgLSA1KSAqIDAuMDA1O1xuICAgICAgICAgICAgICAgIGNyZWF0dXJlLmVudGl0eS5yZXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgIH0sIE1hdGgucmFuZG9tKCkgKiA1MDAwICsgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBfLmZvckVhY2goY3JlYXR1cmVzVG9SZW1vdmUsIChrZXkpID0+IHtcbiAgICAgICAgICAgIHZhciBjcmVhdHVyZSA9IGNyZWF0dXJlc1trZXldO1xuICAgICAgICAgICAgaWYgKCFjcmVhdHVyZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3JlYXR1cmUuZW50aXR5KSB7XG4gICAgICAgICAgICAgIGdhbWUucmVtb3ZlSXRlbShjcmVhdHVyZS5lbnRpdHkpO1xuICAgICAgICAgICAgICBpZiAoY3JlYXR1cmUuY2xlYXJJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIGNyZWF0dXJlLmNsZWFySW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIGNyZWF0dXJlc1trZXldO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgLy8gZ2VuZXJhdGUgdGVycmFpbiBvbi1kZW1hbmRcbiAgICBnYW1lLnZveGVscy5vbignbWlzc2luZ0NodW5rJywgKHApID0+IHtcbiAgICAgIHZhciB2b3hlbHMgPSBnZW5lcmF0ZUNodW5rKHAsIGNodW5rU2l6ZSk7XG4gICAgICB2YXIgY2h1bmsgPSB7XG4gICAgICAgIHBvc2l0aW9uOiBwLFxuICAgICAgICBkaW1zOiBbY2h1bmtTaXplLCBjaHVua1NpemUsIGNodW5rU2l6ZV0sXG4gICAgICAgIHZveGVsczogdm94ZWxzXG4gICAgICB9O1xuICAgICAgZ2FtZS5zaG93Q2h1bmsoY2h1bmspO1xuICAgIH0pO1xuXG4gICAgJHNjb3BlLiRvbigna3ViZXJuZXRlc01vZGVsVXBkYXRlZCcsIChlLCBtb2RlbCkgPT4ge1xuICAgICAgbG9nLmRlYnVnKFwibW9kZWwgdXBkYXRlZDogXCIsIG1vZGVsKTtcbiAgICAgIF8uZm9ySW4obW9kZWwucG9kc0J5S2V5LCAocG9kLCBrZXkpID0+IHtcbiAgICAgICAgdmFyIGNyZWF0dXJlOmFueSA9IGNyZWF0dXJlc1trZXldO1xuICAgICAgICBpZiAoIWNyZWF0dXJlKSB7XG4gICAgICAgICAgY3JlYXR1cmUgPSBjcmVhdHVyZXNba2V5XSA9IDxhbnk+IHtcbiAgICAgICAgICAgIG5hbWU6IGtleSxcbiAgICAgICAgICAgIHBvZDogcG9kXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsb2cuZGVidWcoXCJDcmVhdHVyZXM6XCIsIGNyZWF0dXJlcyk7XG4gICAgfSk7XG5cbiAgfV0pO1xuICBcbn1cbiJdfQ==
